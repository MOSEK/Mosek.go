package mosek

// Generated for MOSEK [10, 1, 8]

// #include <stdlib.h>
// #include <mosek.h>
// #cgo LDFLAGS: -lmosek64
//
// extern void streamfunc_log(void *, char *);
// extern void streamfunc_wrn(void *, char *);
// extern void streamfunc_msg(void *, char *);
// extern void streamfunc_err(void *, char *);
// extern int callbackfunc(void *, void *, int, MSKrealt *, MSKint32t*, MSKint64t *);
import "C"

import (
    "unsafe"
    "fmt"
    "golang.org/x/exp/constraints"
)
// Constants
type Basindtype int32
const (
    MSK_BI_NEVER Basindtype = 0
    MSK_BI_ALWAYS Basindtype = 1
    MSK_BI_NO_ERROR Basindtype = 2
    MSK_BI_IF_FEASIBLE Basindtype = 3
    MSK_BI_RESERVERED Basindtype = 4
    MSK_BI_END Basindtype = 4
)
type Boundkey int32
const (
    MSK_BK_LO Boundkey = 0
    MSK_BK_UP Boundkey = 1
    MSK_BK_FX Boundkey = 2
    MSK_BK_FR Boundkey = 3
    MSK_BK_RA Boundkey = 4
    MSK_BK_END Boundkey = 4
)
type Mark int32
const (
    MSK_MARK_LO Mark = 0
    MSK_MARK_UP Mark = 1
    MSK_MARK_END Mark = 1
)
type Simdegen int32
const (
    MSK_SIM_DEGEN_NONE Simdegen = 0
    MSK_SIM_DEGEN_FREE Simdegen = 1
    MSK_SIM_DEGEN_AGGRESSIVE Simdegen = 2
    MSK_SIM_DEGEN_MODERATE Simdegen = 3
    MSK_SIM_DEGEN_MINIMUM Simdegen = 4
    MSK_SIM_DEGEN_END Simdegen = 4
)
type Transpose int32
const (
    MSK_TRANSPOSE_NO Transpose = 0
    MSK_TRANSPOSE_YES Transpose = 1
    MSK_TRANSPOSE_END Transpose = 1
)
type Uplo int32
const (
    MSK_UPLO_LO Uplo = 0
    MSK_UPLO_UP Uplo = 1
    MSK_UPLO_END Uplo = 1
)
type Simreform int32
const (
    MSK_SIM_REFORMULATION_OFF Simreform = 0
    MSK_SIM_REFORMULATION_ON Simreform = 1
    MSK_SIM_REFORMULATION_FREE Simreform = 2
    MSK_SIM_REFORMULATION_AGGRESSIVE Simreform = 3
    MSK_SIM_REFORMULATION_END Simreform = 3
)
type Simdupvec int32
const (
    MSK_SIM_EXPLOIT_DUPVEC_OFF Simdupvec = 0
    MSK_SIM_EXPLOIT_DUPVEC_ON Simdupvec = 1
    MSK_SIM_EXPLOIT_DUPVEC_FREE Simdupvec = 2
    MSK_SIM_EXPLOIT_DUPVEC_END Simdupvec = 2
)
type Simhotstart int32
const (
    MSK_SIM_HOTSTART_NONE Simhotstart = 0
    MSK_SIM_HOTSTART_FREE Simhotstart = 1
    MSK_SIM_HOTSTART_STATUS_KEYS Simhotstart = 2
    MSK_SIM_HOTSTART_END Simhotstart = 2
)
type Intpnthotstart int32
const (
    MSK_INTPNT_HOTSTART_NONE Intpnthotstart = 0
    MSK_INTPNT_HOTSTART_PRIMAL Intpnthotstart = 1
    MSK_INTPNT_HOTSTART_DUAL Intpnthotstart = 2
    MSK_INTPNT_HOTSTART_PRIMAL_DUAL Intpnthotstart = 3
    MSK_INTPNT_HOTSTART_END Intpnthotstart = 3
)
type Purify int32
const (
    MSK_PURIFY_NONE Purify = 0
    MSK_PURIFY_PRIMAL Purify = 1
    MSK_PURIFY_DUAL Purify = 2
    MSK_PURIFY_PRIMAL_DUAL Purify = 3
    MSK_PURIFY_AUTO Purify = 4
    MSK_PURIFY_END Purify = 4
)
type Callbackcode int32
const (
    MSK_CALLBACK_BEGIN_BI Callbackcode = 0
    MSK_CALLBACK_BEGIN_CONIC Callbackcode = 1
    MSK_CALLBACK_BEGIN_DUAL_BI Callbackcode = 2
    MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY Callbackcode = 3
    MSK_CALLBACK_BEGIN_DUAL_SETUP_BI Callbackcode = 4
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX Callbackcode = 5
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI Callbackcode = 6
    MSK_CALLBACK_BEGIN_INFEAS_ANA Callbackcode = 7
    MSK_CALLBACK_BEGIN_INTPNT Callbackcode = 8
    MSK_CALLBACK_BEGIN_LICENSE_WAIT Callbackcode = 9
    MSK_CALLBACK_BEGIN_MIO Callbackcode = 10
    MSK_CALLBACK_BEGIN_OPTIMIZER Callbackcode = 11
    MSK_CALLBACK_BEGIN_PRESOLVE Callbackcode = 12
    MSK_CALLBACK_BEGIN_PRIMAL_BI Callbackcode = 13
    MSK_CALLBACK_BEGIN_PRIMAL_REPAIR Callbackcode = 14
    MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY Callbackcode = 15
    MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI Callbackcode = 16
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX Callbackcode = 17
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI Callbackcode = 18
    MSK_CALLBACK_BEGIN_QCQO_REFORMULATE Callbackcode = 19
    MSK_CALLBACK_BEGIN_READ Callbackcode = 20
    MSK_CALLBACK_BEGIN_ROOT_CUTGEN Callbackcode = 21
    MSK_CALLBACK_BEGIN_SIMPLEX Callbackcode = 22
    MSK_CALLBACK_BEGIN_SIMPLEX_BI Callbackcode = 23
    MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX Callbackcode = 24
    MSK_CALLBACK_BEGIN_TO_CONIC Callbackcode = 25
    MSK_CALLBACK_BEGIN_WRITE Callbackcode = 26
    MSK_CALLBACK_CONIC Callbackcode = 27
    MSK_CALLBACK_DUAL_SIMPLEX Callbackcode = 28
    MSK_CALLBACK_END_BI Callbackcode = 29
    MSK_CALLBACK_END_CONIC Callbackcode = 30
    MSK_CALLBACK_END_DUAL_BI Callbackcode = 31
    MSK_CALLBACK_END_DUAL_SENSITIVITY Callbackcode = 32
    MSK_CALLBACK_END_DUAL_SETUP_BI Callbackcode = 33
    MSK_CALLBACK_END_DUAL_SIMPLEX Callbackcode = 34
    MSK_CALLBACK_END_DUAL_SIMPLEX_BI Callbackcode = 35
    MSK_CALLBACK_END_INFEAS_ANA Callbackcode = 36
    MSK_CALLBACK_END_INTPNT Callbackcode = 37
    MSK_CALLBACK_END_LICENSE_WAIT Callbackcode = 38
    MSK_CALLBACK_END_MIO Callbackcode = 39
    MSK_CALLBACK_END_OPTIMIZER Callbackcode = 40
    MSK_CALLBACK_END_PRESOLVE Callbackcode = 41
    MSK_CALLBACK_END_PRIMAL_BI Callbackcode = 42
    MSK_CALLBACK_END_PRIMAL_REPAIR Callbackcode = 43
    MSK_CALLBACK_END_PRIMAL_SENSITIVITY Callbackcode = 44
    MSK_CALLBACK_END_PRIMAL_SETUP_BI Callbackcode = 45
    MSK_CALLBACK_END_PRIMAL_SIMPLEX Callbackcode = 46
    MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI Callbackcode = 47
    MSK_CALLBACK_END_QCQO_REFORMULATE Callbackcode = 48
    MSK_CALLBACK_END_READ Callbackcode = 49
    MSK_CALLBACK_END_ROOT_CUTGEN Callbackcode = 50
    MSK_CALLBACK_END_SIMPLEX Callbackcode = 51
    MSK_CALLBACK_END_SIMPLEX_BI Callbackcode = 52
    MSK_CALLBACK_END_SOLVE_ROOT_RELAX Callbackcode = 53
    MSK_CALLBACK_END_TO_CONIC Callbackcode = 54
    MSK_CALLBACK_END_WRITE Callbackcode = 55
    MSK_CALLBACK_IM_BI Callbackcode = 56
    MSK_CALLBACK_IM_CONIC Callbackcode = 57
    MSK_CALLBACK_IM_DUAL_BI Callbackcode = 58
    MSK_CALLBACK_IM_DUAL_SENSIVITY Callbackcode = 59
    MSK_CALLBACK_IM_DUAL_SIMPLEX Callbackcode = 60
    MSK_CALLBACK_IM_INTPNT Callbackcode = 61
    MSK_CALLBACK_IM_LICENSE_WAIT Callbackcode = 62
    MSK_CALLBACK_IM_LU Callbackcode = 63
    MSK_CALLBACK_IM_MIO Callbackcode = 64
    MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX Callbackcode = 65
    MSK_CALLBACK_IM_MIO_INTPNT Callbackcode = 66
    MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX Callbackcode = 67
    MSK_CALLBACK_IM_ORDER Callbackcode = 68
    MSK_CALLBACK_IM_PRESOLVE Callbackcode = 69
    MSK_CALLBACK_IM_PRIMAL_BI Callbackcode = 70
    MSK_CALLBACK_IM_PRIMAL_SENSIVITY Callbackcode = 71
    MSK_CALLBACK_IM_PRIMAL_SIMPLEX Callbackcode = 72
    MSK_CALLBACK_IM_QO_REFORMULATE Callbackcode = 73
    MSK_CALLBACK_IM_READ Callbackcode = 74
    MSK_CALLBACK_IM_ROOT_CUTGEN Callbackcode = 75
    MSK_CALLBACK_IM_SIMPLEX Callbackcode = 76
    MSK_CALLBACK_IM_SIMPLEX_BI Callbackcode = 77
    MSK_CALLBACK_INTPNT Callbackcode = 78
    MSK_CALLBACK_NEW_INT_MIO Callbackcode = 79
    MSK_CALLBACK_PRIMAL_SIMPLEX Callbackcode = 80
    MSK_CALLBACK_READ_OPF Callbackcode = 81
    MSK_CALLBACK_READ_OPF_SECTION Callbackcode = 82
    MSK_CALLBACK_RESTART_MIO Callbackcode = 83
    MSK_CALLBACK_SOLVING_REMOTE Callbackcode = 84
    MSK_CALLBACK_UPDATE_DUAL_BI Callbackcode = 85
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX Callbackcode = 86
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI Callbackcode = 87
    MSK_CALLBACK_UPDATE_PRESOLVE Callbackcode = 88
    MSK_CALLBACK_UPDATE_PRIMAL_BI Callbackcode = 89
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX Callbackcode = 90
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI Callbackcode = 91
    MSK_CALLBACK_UPDATE_SIMPLEX Callbackcode = 92
    MSK_CALLBACK_WRITE_OPF Callbackcode = 93
    MSK_CALLBACK_END Callbackcode = 93
)
type Compresstype int32
const (
    MSK_COMPRESS_NONE Compresstype = 0
    MSK_COMPRESS_FREE Compresstype = 1
    MSK_COMPRESS_GZIP Compresstype = 2
    MSK_COMPRESS_ZSTD Compresstype = 3
    MSK_COMPRESS_END Compresstype = 3
)
type Conetype int32
const (
    MSK_CT_QUAD Conetype = 0
    MSK_CT_RQUAD Conetype = 1
    MSK_CT_PEXP Conetype = 2
    MSK_CT_DEXP Conetype = 3
    MSK_CT_PPOW Conetype = 4
    MSK_CT_DPOW Conetype = 5
    MSK_CT_ZERO Conetype = 6
    MSK_CT_END Conetype = 6
)
type Domaintype int32
const (
    MSK_DOMAIN_R Domaintype = 0
    MSK_DOMAIN_RZERO Domaintype = 1
    MSK_DOMAIN_RPLUS Domaintype = 2
    MSK_DOMAIN_RMINUS Domaintype = 3
    MSK_DOMAIN_QUADRATIC_CONE Domaintype = 4
    MSK_DOMAIN_RQUADRATIC_CONE Domaintype = 5
    MSK_DOMAIN_PRIMAL_EXP_CONE Domaintype = 6
    MSK_DOMAIN_DUAL_EXP_CONE Domaintype = 7
    MSK_DOMAIN_PRIMAL_POWER_CONE Domaintype = 8
    MSK_DOMAIN_DUAL_POWER_CONE Domaintype = 9
    MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE Domaintype = 10
    MSK_DOMAIN_DUAL_GEO_MEAN_CONE Domaintype = 11
    MSK_DOMAIN_SVEC_PSD_CONE Domaintype = 12
    MSK_DOMAIN_END Domaintype = 12
)
type Nametype int32
const (
    MSK_NAME_TYPE_GEN Nametype = 0
    MSK_NAME_TYPE_MPS Nametype = 1
    MSK_NAME_TYPE_LP Nametype = 2
    MSK_NAME_TYPE_END Nametype = 2
)
type Symmattype int32
const (
    MSK_SYMMAT_TYPE_SPARSE Symmattype = 0
    MSK_SYMMAT_TYPE_END Symmattype = 0
)
type Dataformat int32
const (
    MSK_DATA_FORMAT_EXTENSION Dataformat = 0
    MSK_DATA_FORMAT_MPS Dataformat = 1
    MSK_DATA_FORMAT_LP Dataformat = 2
    MSK_DATA_FORMAT_OP Dataformat = 3
    MSK_DATA_FORMAT_FREE_MPS Dataformat = 4
    MSK_DATA_FORMAT_TASK Dataformat = 5
    MSK_DATA_FORMAT_PTF Dataformat = 6
    MSK_DATA_FORMAT_CB Dataformat = 7
    MSK_DATA_FORMAT_JSON_TASK Dataformat = 8
    MSK_DATA_FORMAT_END Dataformat = 8
)
type Solformat int32
const (
    MSK_SOL_FORMAT_EXTENSION Solformat = 0
    MSK_SOL_FORMAT_B Solformat = 1
    MSK_SOL_FORMAT_TASK Solformat = 2
    MSK_SOL_FORMAT_JSON_TASK Solformat = 3
    MSK_SOL_FORMAT_END Solformat = 3
)
type Dinfitem int32
const (
    MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY Dinfitem = 0
    MSK_DINF_BI_CLEAN_DUAL_TIME Dinfitem = 1
    MSK_DINF_BI_CLEAN_PRIMAL_TIME Dinfitem = 2
    MSK_DINF_BI_CLEAN_TIME Dinfitem = 3
    MSK_DINF_BI_DUAL_TIME Dinfitem = 4
    MSK_DINF_BI_PRIMAL_TIME Dinfitem = 5
    MSK_DINF_BI_TIME Dinfitem = 6
    MSK_DINF_INTPNT_DUAL_FEAS Dinfitem = 7
    MSK_DINF_INTPNT_DUAL_OBJ Dinfitem = 8
    MSK_DINF_INTPNT_FACTOR_NUM_FLOPS Dinfitem = 9
    MSK_DINF_INTPNT_OPT_STATUS Dinfitem = 10
    MSK_DINF_INTPNT_ORDER_TIME Dinfitem = 11
    MSK_DINF_INTPNT_PRIMAL_FEAS Dinfitem = 12
    MSK_DINF_INTPNT_PRIMAL_OBJ Dinfitem = 13
    MSK_DINF_INTPNT_TIME Dinfitem = 14
    MSK_DINF_MIO_CLIQUE_SELECTION_TIME Dinfitem = 15
    MSK_DINF_MIO_CLIQUE_SEPARATION_TIME Dinfitem = 16
    MSK_DINF_MIO_CMIR_SELECTION_TIME Dinfitem = 17
    MSK_DINF_MIO_CMIR_SEPARATION_TIME Dinfitem = 18
    MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ Dinfitem = 19
    MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE Dinfitem = 20
    MSK_DINF_MIO_GMI_SELECTION_TIME Dinfitem = 21
    MSK_DINF_MIO_GMI_SEPARATION_TIME Dinfitem = 22
    MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME Dinfitem = 23
    MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME Dinfitem = 24
    MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ Dinfitem = 25
    MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME Dinfitem = 26
    MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME Dinfitem = 27
    MSK_DINF_MIO_LIPRO_SELECTION_TIME Dinfitem = 28
    MSK_DINF_MIO_LIPRO_SEPARATION_TIME Dinfitem = 29
    MSK_DINF_MIO_OBJ_ABS_GAP Dinfitem = 30
    MSK_DINF_MIO_OBJ_BOUND Dinfitem = 31
    MSK_DINF_MIO_OBJ_INT Dinfitem = 32
    MSK_DINF_MIO_OBJ_REL_GAP Dinfitem = 33
    MSK_DINF_MIO_PROBING_TIME Dinfitem = 34
    MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME Dinfitem = 35
    MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME Dinfitem = 36
    MSK_DINF_MIO_ROOT_OPTIMIZER_TIME Dinfitem = 37
    MSK_DINF_MIO_ROOT_PRESOLVE_TIME Dinfitem = 38
    MSK_DINF_MIO_ROOT_TIME Dinfitem = 39
    MSK_DINF_MIO_SYMMETRY_DETECTION_TIME Dinfitem = 40
    MSK_DINF_MIO_SYMMETRY_FACTOR Dinfitem = 41
    MSK_DINF_MIO_TIME Dinfitem = 42
    MSK_DINF_MIO_USER_OBJ_CUT Dinfitem = 43
    MSK_DINF_OPTIMIZER_TICKS Dinfitem = 44
    MSK_DINF_OPTIMIZER_TIME Dinfitem = 45
    MSK_DINF_PRESOLVE_ELI_TIME Dinfitem = 46
    MSK_DINF_PRESOLVE_LINDEP_TIME Dinfitem = 47
    MSK_DINF_PRESOLVE_TIME Dinfitem = 48
    MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION Dinfitem = 49
    MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ Dinfitem = 50
    MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION Dinfitem = 51
    MSK_DINF_QCQO_REFORMULATE_TIME Dinfitem = 52
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING Dinfitem = 53
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING Dinfitem = 54
    MSK_DINF_READ_DATA_TIME Dinfitem = 55
    MSK_DINF_REMOTE_TIME Dinfitem = 56
    MSK_DINF_SIM_DUAL_TIME Dinfitem = 57
    MSK_DINF_SIM_FEAS Dinfitem = 58
    MSK_DINF_SIM_OBJ Dinfitem = 59
    MSK_DINF_SIM_PRIMAL_TIME Dinfitem = 60
    MSK_DINF_SIM_TIME Dinfitem = 61
    MSK_DINF_SOL_BAS_DUAL_OBJ Dinfitem = 62
    MSK_DINF_SOL_BAS_DVIOLCON Dinfitem = 63
    MSK_DINF_SOL_BAS_DVIOLVAR Dinfitem = 64
    MSK_DINF_SOL_BAS_NRM_BARX Dinfitem = 65
    MSK_DINF_SOL_BAS_NRM_SLC Dinfitem = 66
    MSK_DINF_SOL_BAS_NRM_SLX Dinfitem = 67
    MSK_DINF_SOL_BAS_NRM_SUC Dinfitem = 68
    MSK_DINF_SOL_BAS_NRM_SUX Dinfitem = 69
    MSK_DINF_SOL_BAS_NRM_XC Dinfitem = 70
    MSK_DINF_SOL_BAS_NRM_XX Dinfitem = 71
    MSK_DINF_SOL_BAS_NRM_Y Dinfitem = 72
    MSK_DINF_SOL_BAS_PRIMAL_OBJ Dinfitem = 73
    MSK_DINF_SOL_BAS_PVIOLCON Dinfitem = 74
    MSK_DINF_SOL_BAS_PVIOLVAR Dinfitem = 75
    MSK_DINF_SOL_ITG_NRM_BARX Dinfitem = 76
    MSK_DINF_SOL_ITG_NRM_XC Dinfitem = 77
    MSK_DINF_SOL_ITG_NRM_XX Dinfitem = 78
    MSK_DINF_SOL_ITG_PRIMAL_OBJ Dinfitem = 79
    MSK_DINF_SOL_ITG_PVIOLACC Dinfitem = 80
    MSK_DINF_SOL_ITG_PVIOLBARVAR Dinfitem = 81
    MSK_DINF_SOL_ITG_PVIOLCON Dinfitem = 82
    MSK_DINF_SOL_ITG_PVIOLCONES Dinfitem = 83
    MSK_DINF_SOL_ITG_PVIOLDJC Dinfitem = 84
    MSK_DINF_SOL_ITG_PVIOLITG Dinfitem = 85
    MSK_DINF_SOL_ITG_PVIOLVAR Dinfitem = 86
    MSK_DINF_SOL_ITR_DUAL_OBJ Dinfitem = 87
    MSK_DINF_SOL_ITR_DVIOLACC Dinfitem = 88
    MSK_DINF_SOL_ITR_DVIOLBARVAR Dinfitem = 89
    MSK_DINF_SOL_ITR_DVIOLCON Dinfitem = 90
    MSK_DINF_SOL_ITR_DVIOLCONES Dinfitem = 91
    MSK_DINF_SOL_ITR_DVIOLVAR Dinfitem = 92
    MSK_DINF_SOL_ITR_NRM_BARS Dinfitem = 93
    MSK_DINF_SOL_ITR_NRM_BARX Dinfitem = 94
    MSK_DINF_SOL_ITR_NRM_SLC Dinfitem = 95
    MSK_DINF_SOL_ITR_NRM_SLX Dinfitem = 96
    MSK_DINF_SOL_ITR_NRM_SNX Dinfitem = 97
    MSK_DINF_SOL_ITR_NRM_SUC Dinfitem = 98
    MSK_DINF_SOL_ITR_NRM_SUX Dinfitem = 99
    MSK_DINF_SOL_ITR_NRM_XC Dinfitem = 100
    MSK_DINF_SOL_ITR_NRM_XX Dinfitem = 101
    MSK_DINF_SOL_ITR_NRM_Y Dinfitem = 102
    MSK_DINF_SOL_ITR_PRIMAL_OBJ Dinfitem = 103
    MSK_DINF_SOL_ITR_PVIOLACC Dinfitem = 104
    MSK_DINF_SOL_ITR_PVIOLBARVAR Dinfitem = 105
    MSK_DINF_SOL_ITR_PVIOLCON Dinfitem = 106
    MSK_DINF_SOL_ITR_PVIOLCONES Dinfitem = 107
    MSK_DINF_SOL_ITR_PVIOLVAR Dinfitem = 108
    MSK_DINF_TO_CONIC_TIME Dinfitem = 109
    MSK_DINF_WRITE_DATA_TIME Dinfitem = 110
    MSK_DINF_END Dinfitem = 110
)
type Feature int32
const (
    MSK_FEATURE_PTS Feature = 0
    MSK_FEATURE_PTON Feature = 1
    MSK_FEATURE_END Feature = 1
)
type Dparam int32
const (
    MSK_DPAR_ANA_SOL_INFEAS_TOL Dparam = 0
    MSK_DPAR_BASIS_REL_TOL_S Dparam = 1
    MSK_DPAR_BASIS_TOL_S Dparam = 2
    MSK_DPAR_BASIS_TOL_X Dparam = 3
    MSK_DPAR_CHECK_CONVEXITY_REL_TOL Dparam = 4
    MSK_DPAR_DATA_SYM_MAT_TOL Dparam = 5
    MSK_DPAR_DATA_SYM_MAT_TOL_HUGE Dparam = 6
    MSK_DPAR_DATA_SYM_MAT_TOL_LARGE Dparam = 7
    MSK_DPAR_DATA_TOL_AIJ_HUGE Dparam = 8
    MSK_DPAR_DATA_TOL_AIJ_LARGE Dparam = 9
    MSK_DPAR_DATA_TOL_BOUND_INF Dparam = 10
    MSK_DPAR_DATA_TOL_BOUND_WRN Dparam = 11
    MSK_DPAR_DATA_TOL_C_HUGE Dparam = 12
    MSK_DPAR_DATA_TOL_CJ_LARGE Dparam = 13
    MSK_DPAR_DATA_TOL_QIJ Dparam = 14
    MSK_DPAR_DATA_TOL_X Dparam = 15
    MSK_DPAR_INTPNT_CO_TOL_DFEAS Dparam = 16
    MSK_DPAR_INTPNT_CO_TOL_INFEAS Dparam = 17
    MSK_DPAR_INTPNT_CO_TOL_MU_RED Dparam = 18
    MSK_DPAR_INTPNT_CO_TOL_NEAR_REL Dparam = 19
    MSK_DPAR_INTPNT_CO_TOL_PFEAS Dparam = 20
    MSK_DPAR_INTPNT_CO_TOL_REL_GAP Dparam = 21
    MSK_DPAR_INTPNT_QO_TOL_DFEAS Dparam = 22
    MSK_DPAR_INTPNT_QO_TOL_INFEAS Dparam = 23
    MSK_DPAR_INTPNT_QO_TOL_MU_RED Dparam = 24
    MSK_DPAR_INTPNT_QO_TOL_NEAR_REL Dparam = 25
    MSK_DPAR_INTPNT_QO_TOL_PFEAS Dparam = 26
    MSK_DPAR_INTPNT_QO_TOL_REL_GAP Dparam = 27
    MSK_DPAR_INTPNT_TOL_DFEAS Dparam = 28
    MSK_DPAR_INTPNT_TOL_DSAFE Dparam = 29
    MSK_DPAR_INTPNT_TOL_INFEAS Dparam = 30
    MSK_DPAR_INTPNT_TOL_MU_RED Dparam = 31
    MSK_DPAR_INTPNT_TOL_PATH Dparam = 32
    MSK_DPAR_INTPNT_TOL_PFEAS Dparam = 33
    MSK_DPAR_INTPNT_TOL_PSAFE Dparam = 34
    MSK_DPAR_INTPNT_TOL_REL_GAP Dparam = 35
    MSK_DPAR_INTPNT_TOL_REL_STEP Dparam = 36
    MSK_DPAR_INTPNT_TOL_STEP_SIZE Dparam = 37
    MSK_DPAR_LOWER_OBJ_CUT Dparam = 38
    MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH Dparam = 39
    MSK_DPAR_MIO_DJC_MAX_BIGM Dparam = 40
    MSK_DPAR_MIO_MAX_TIME Dparam = 41
    MSK_DPAR_MIO_REL_GAP_CONST Dparam = 42
    MSK_DPAR_MIO_TOL_ABS_GAP Dparam = 43
    MSK_DPAR_MIO_TOL_ABS_RELAX_INT Dparam = 44
    MSK_DPAR_MIO_TOL_FEAS Dparam = 45
    MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT Dparam = 46
    MSK_DPAR_MIO_TOL_REL_GAP Dparam = 47
    MSK_DPAR_OPTIMIZER_MAX_TICKS Dparam = 48
    MSK_DPAR_OPTIMIZER_MAX_TIME Dparam = 49
    MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP Dparam = 50
    MSK_DPAR_PRESOLVE_TOL_AIJ Dparam = 51
    MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION Dparam = 52
    MSK_DPAR_PRESOLVE_TOL_REL_LINDEP Dparam = 53
    MSK_DPAR_PRESOLVE_TOL_S Dparam = 54
    MSK_DPAR_PRESOLVE_TOL_X Dparam = 55
    MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL Dparam = 56
    MSK_DPAR_SEMIDEFINITE_TOL_APPROX Dparam = 57
    MSK_DPAR_SIM_LU_TOL_REL_PIV Dparam = 58
    MSK_DPAR_SIMPLEX_ABS_TOL_PIV Dparam = 59
    MSK_DPAR_UPPER_OBJ_CUT Dparam = 60
    MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH Dparam = 61
    MSK_DPAR_END Dparam = 61
)
type Liinfitem int32
const (
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS Liinfitem = 0
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ Liinfitem = 1
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS Liinfitem = 2
    MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER Liinfitem = 3
    MSK_LIINF_BI_CLEAN_DUAL_ITER Liinfitem = 4
    MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER Liinfitem = 5
    MSK_LIINF_BI_CLEAN_PRIMAL_ITER Liinfitem = 6
    MSK_LIINF_BI_DUAL_ITER Liinfitem = 7
    MSK_LIINF_BI_PRIMAL_ITER Liinfitem = 8
    MSK_LIINF_INTPNT_FACTOR_NUM_NZ Liinfitem = 9
    MSK_LIINF_MIO_ANZ Liinfitem = 10
    MSK_LIINF_MIO_INTPNT_ITER Liinfitem = 11
    MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER Liinfitem = 12
    MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER Liinfitem = 13
    MSK_LIINF_MIO_PRESOLVED_ANZ Liinfitem = 14
    MSK_LIINF_MIO_SIMPLEX_ITER Liinfitem = 15
    MSK_LIINF_RD_NUMACC Liinfitem = 16
    MSK_LIINF_RD_NUMANZ Liinfitem = 17
    MSK_LIINF_RD_NUMDJC Liinfitem = 18
    MSK_LIINF_RD_NUMQNZ Liinfitem = 19
    MSK_LIINF_SIMPLEX_ITER Liinfitem = 20
    MSK_LIINF_END Liinfitem = 20
)
type Iinfitem int32
const (
    MSK_IINF_ANA_PRO_NUM_CON Iinfitem = 0
    MSK_IINF_ANA_PRO_NUM_CON_EQ Iinfitem = 1
    MSK_IINF_ANA_PRO_NUM_CON_FR Iinfitem = 2
    MSK_IINF_ANA_PRO_NUM_CON_LO Iinfitem = 3
    MSK_IINF_ANA_PRO_NUM_CON_RA Iinfitem = 4
    MSK_IINF_ANA_PRO_NUM_CON_UP Iinfitem = 5
    MSK_IINF_ANA_PRO_NUM_VAR Iinfitem = 6
    MSK_IINF_ANA_PRO_NUM_VAR_BIN Iinfitem = 7
    MSK_IINF_ANA_PRO_NUM_VAR_CONT Iinfitem = 8
    MSK_IINF_ANA_PRO_NUM_VAR_EQ Iinfitem = 9
    MSK_IINF_ANA_PRO_NUM_VAR_FR Iinfitem = 10
    MSK_IINF_ANA_PRO_NUM_VAR_INT Iinfitem = 11
    MSK_IINF_ANA_PRO_NUM_VAR_LO Iinfitem = 12
    MSK_IINF_ANA_PRO_NUM_VAR_RA Iinfitem = 13
    MSK_IINF_ANA_PRO_NUM_VAR_UP Iinfitem = 14
    MSK_IINF_INTPNT_FACTOR_DIM_DENSE Iinfitem = 15
    MSK_IINF_INTPNT_ITER Iinfitem = 16
    MSK_IINF_INTPNT_NUM_THREADS Iinfitem = 17
    MSK_IINF_INTPNT_SOLVE_DUAL Iinfitem = 18
    MSK_IINF_MIO_ABSGAP_SATISFIED Iinfitem = 19
    MSK_IINF_MIO_CLIQUE_TABLE_SIZE Iinfitem = 20
    MSK_IINF_MIO_CONSTRUCT_SOLUTION Iinfitem = 21
    MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION Iinfitem = 22
    MSK_IINF_MIO_NODE_DEPTH Iinfitem = 23
    MSK_IINF_MIO_NUM_ACTIVE_NODES Iinfitem = 24
    MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS Iinfitem = 25
    MSK_IINF_MIO_NUM_BRANCH Iinfitem = 26
    MSK_IINF_MIO_NUM_INT_SOLUTIONS Iinfitem = 27
    MSK_IINF_MIO_NUM_RELAX Iinfitem = 28
    MSK_IINF_MIO_NUM_REPEATED_PRESOLVE Iinfitem = 29
    MSK_IINF_MIO_NUM_RESTARTS Iinfitem = 30
    MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS Iinfitem = 31
    MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS Iinfitem = 32
    MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS Iinfitem = 33
    MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS Iinfitem = 34
    MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS Iinfitem = 35
    MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS Iinfitem = 36
    MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS Iinfitem = 37
    MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS Iinfitem = 38
    MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS Iinfitem = 39
    MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS Iinfitem = 40
    MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS Iinfitem = 41
    MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS Iinfitem = 42
    MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS Iinfitem = 43
    MSK_IINF_MIO_NUM_SOLVED_NODES Iinfitem = 44
    MSK_IINF_MIO_NUMBIN Iinfitem = 45
    MSK_IINF_MIO_NUMBINCONEVAR Iinfitem = 46
    MSK_IINF_MIO_NUMCON Iinfitem = 47
    MSK_IINF_MIO_NUMCONE Iinfitem = 48
    MSK_IINF_MIO_NUMCONEVAR Iinfitem = 49
    MSK_IINF_MIO_NUMCONT Iinfitem = 50
    MSK_IINF_MIO_NUMCONTCONEVAR Iinfitem = 51
    MSK_IINF_MIO_NUMDEXPCONES Iinfitem = 52
    MSK_IINF_MIO_NUMDJC Iinfitem = 53
    MSK_IINF_MIO_NUMDPOWCONES Iinfitem = 54
    MSK_IINF_MIO_NUMINT Iinfitem = 55
    MSK_IINF_MIO_NUMINTCONEVAR Iinfitem = 56
    MSK_IINF_MIO_NUMPEXPCONES Iinfitem = 57
    MSK_IINF_MIO_NUMPPOWCONES Iinfitem = 58
    MSK_IINF_MIO_NUMQCONES Iinfitem = 59
    MSK_IINF_MIO_NUMRQCONES Iinfitem = 60
    MSK_IINF_MIO_NUMVAR Iinfitem = 61
    MSK_IINF_MIO_OBJ_BOUND_DEFINED Iinfitem = 62
    MSK_IINF_MIO_PRESOLVED_NUMBIN Iinfitem = 63
    MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR Iinfitem = 64
    MSK_IINF_MIO_PRESOLVED_NUMCON Iinfitem = 65
    MSK_IINF_MIO_PRESOLVED_NUMCONE Iinfitem = 66
    MSK_IINF_MIO_PRESOLVED_NUMCONEVAR Iinfitem = 67
    MSK_IINF_MIO_PRESOLVED_NUMCONT Iinfitem = 68
    MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR Iinfitem = 69
    MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES Iinfitem = 70
    MSK_IINF_MIO_PRESOLVED_NUMDJC Iinfitem = 71
    MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES Iinfitem = 72
    MSK_IINF_MIO_PRESOLVED_NUMINT Iinfitem = 73
    MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR Iinfitem = 74
    MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES Iinfitem = 75
    MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES Iinfitem = 76
    MSK_IINF_MIO_PRESOLVED_NUMQCONES Iinfitem = 77
    MSK_IINF_MIO_PRESOLVED_NUMRQCONES Iinfitem = 78
    MSK_IINF_MIO_PRESOLVED_NUMVAR Iinfitem = 79
    MSK_IINF_MIO_RELGAP_SATISFIED Iinfitem = 80
    MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS Iinfitem = 81
    MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS Iinfitem = 82
    MSK_IINF_MIO_USER_OBJ_CUT Iinfitem = 83
    MSK_IINF_OPT_NUMCON Iinfitem = 84
    MSK_IINF_OPT_NUMVAR Iinfitem = 85
    MSK_IINF_OPTIMIZE_RESPONSE Iinfitem = 86
    MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS Iinfitem = 87
    MSK_IINF_PURIFY_DUAL_SUCCESS Iinfitem = 88
    MSK_IINF_PURIFY_PRIMAL_SUCCESS Iinfitem = 89
    MSK_IINF_RD_NUMBARVAR Iinfitem = 90
    MSK_IINF_RD_NUMCON Iinfitem = 91
    MSK_IINF_RD_NUMCONE Iinfitem = 92
    MSK_IINF_RD_NUMINTVAR Iinfitem = 93
    MSK_IINF_RD_NUMQ Iinfitem = 94
    MSK_IINF_RD_NUMVAR Iinfitem = 95
    MSK_IINF_RD_PROTYPE Iinfitem = 96
    MSK_IINF_SIM_DUAL_DEG_ITER Iinfitem = 97
    MSK_IINF_SIM_DUAL_HOTSTART Iinfitem = 98
    MSK_IINF_SIM_DUAL_HOTSTART_LU Iinfitem = 99
    MSK_IINF_SIM_DUAL_INF_ITER Iinfitem = 100
    MSK_IINF_SIM_DUAL_ITER Iinfitem = 101
    MSK_IINF_SIM_NUMCON Iinfitem = 102
    MSK_IINF_SIM_NUMVAR Iinfitem = 103
    MSK_IINF_SIM_PRIMAL_DEG_ITER Iinfitem = 104
    MSK_IINF_SIM_PRIMAL_HOTSTART Iinfitem = 105
    MSK_IINF_SIM_PRIMAL_HOTSTART_LU Iinfitem = 106
    MSK_IINF_SIM_PRIMAL_INF_ITER Iinfitem = 107
    MSK_IINF_SIM_PRIMAL_ITER Iinfitem = 108
    MSK_IINF_SIM_SOLVE_DUAL Iinfitem = 109
    MSK_IINF_SOL_BAS_PROSTA Iinfitem = 110
    MSK_IINF_SOL_BAS_SOLSTA Iinfitem = 111
    MSK_IINF_SOL_ITG_PROSTA Iinfitem = 112
    MSK_IINF_SOL_ITG_SOLSTA Iinfitem = 113
    MSK_IINF_SOL_ITR_PROSTA Iinfitem = 114
    MSK_IINF_SOL_ITR_SOLSTA Iinfitem = 115
    MSK_IINF_STO_NUM_A_REALLOC Iinfitem = 116
    MSK_IINF_END Iinfitem = 116
)
type Inftype int32
const (
    MSK_INF_DOU_TYPE Inftype = 0
    MSK_INF_INT_TYPE Inftype = 1
    MSK_INF_LINT_TYPE Inftype = 2
    MSK_INF_END Inftype = 2
)
type Iomode int32
const (
    MSK_IOMODE_READ Iomode = 0
    MSK_IOMODE_WRITE Iomode = 1
    MSK_IOMODE_READWRITE Iomode = 2
    MSK_IOMODE_END Iomode = 2
)
type Iparam int32
const (
    MSK_IPAR_ANA_SOL_BASIS Iparam = 0
    MSK_IPAR_ANA_SOL_PRINT_VIOLATED Iparam = 1
    MSK_IPAR_AUTO_SORT_A_BEFORE_OPT Iparam = 2
    MSK_IPAR_AUTO_UPDATE_SOL_INFO Iparam = 3
    MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE Iparam = 4
    MSK_IPAR_BI_CLEAN_OPTIMIZER Iparam = 5
    MSK_IPAR_BI_IGNORE_MAX_ITER Iparam = 6
    MSK_IPAR_BI_IGNORE_NUM_ERROR Iparam = 7
    MSK_IPAR_BI_MAX_ITERATIONS Iparam = 8
    MSK_IPAR_CACHE_LICENSE Iparam = 9
    MSK_IPAR_COMPRESS_STATFILE Iparam = 10
    MSK_IPAR_INFEAS_GENERIC_NAMES Iparam = 11
    MSK_IPAR_INFEAS_PREFER_PRIMAL Iparam = 12
    MSK_IPAR_INFEAS_REPORT_AUTO Iparam = 13
    MSK_IPAR_INFEAS_REPORT_LEVEL Iparam = 14
    MSK_IPAR_INTPNT_BASIS Iparam = 15
    MSK_IPAR_INTPNT_DIFF_STEP Iparam = 16
    MSK_IPAR_INTPNT_HOTSTART Iparam = 17
    MSK_IPAR_INTPNT_MAX_ITERATIONS Iparam = 18
    MSK_IPAR_INTPNT_MAX_NUM_COR Iparam = 19
    MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS Iparam = 20
    MSK_IPAR_INTPNT_OFF_COL_TRH Iparam = 21
    MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS Iparam = 22
    MSK_IPAR_INTPNT_ORDER_METHOD Iparam = 23
    MSK_IPAR_INTPNT_PURIFY Iparam = 24
    MSK_IPAR_INTPNT_REGULARIZATION_USE Iparam = 25
    MSK_IPAR_INTPNT_SCALING Iparam = 26
    MSK_IPAR_INTPNT_SOLVE_FORM Iparam = 27
    MSK_IPAR_INTPNT_STARTING_POINT Iparam = 28
    MSK_IPAR_LICENSE_DEBUG Iparam = 29
    MSK_IPAR_LICENSE_PAUSE_TIME Iparam = 30
    MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS Iparam = 31
    MSK_IPAR_LICENSE_TRH_EXPIRY_WRN Iparam = 32
    MSK_IPAR_LICENSE_WAIT Iparam = 33
    MSK_IPAR_LOG Iparam = 34
    MSK_IPAR_LOG_ANA_PRO Iparam = 35
    MSK_IPAR_LOG_BI Iparam = 36
    MSK_IPAR_LOG_BI_FREQ Iparam = 37
    MSK_IPAR_LOG_CUT_SECOND_OPT Iparam = 38
    MSK_IPAR_LOG_EXPAND Iparam = 39
    MSK_IPAR_LOG_FEAS_REPAIR Iparam = 40
    MSK_IPAR_LOG_FILE Iparam = 41
    MSK_IPAR_LOG_INCLUDE_SUMMARY Iparam = 42
    MSK_IPAR_LOG_INFEAS_ANA Iparam = 43
    MSK_IPAR_LOG_INTPNT Iparam = 44
    MSK_IPAR_LOG_LOCAL_INFO Iparam = 45
    MSK_IPAR_LOG_MIO Iparam = 46
    MSK_IPAR_LOG_MIO_FREQ Iparam = 47
    MSK_IPAR_LOG_ORDER Iparam = 48
    MSK_IPAR_LOG_PRESOLVE Iparam = 49
    MSK_IPAR_LOG_RESPONSE Iparam = 50
    MSK_IPAR_LOG_SENSITIVITY Iparam = 51
    MSK_IPAR_LOG_SENSITIVITY_OPT Iparam = 52
    MSK_IPAR_LOG_SIM Iparam = 53
    MSK_IPAR_LOG_SIM_FREQ Iparam = 54
    MSK_IPAR_LOG_SIM_MINOR Iparam = 55
    MSK_IPAR_LOG_STORAGE Iparam = 56
    MSK_IPAR_MAX_NUM_WARNINGS Iparam = 57
    MSK_IPAR_MIO_BRANCH_DIR Iparam = 58
    MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION Iparam = 59
    MSK_IPAR_MIO_CONSTRUCT_SOL Iparam = 60
    MSK_IPAR_MIO_CUT_CLIQUE Iparam = 61
    MSK_IPAR_MIO_CUT_CMIR Iparam = 62
    MSK_IPAR_MIO_CUT_GMI Iparam = 63
    MSK_IPAR_MIO_CUT_IMPLIED_BOUND Iparam = 64
    MSK_IPAR_MIO_CUT_KNAPSACK_COVER Iparam = 65
    MSK_IPAR_MIO_CUT_LIPRO Iparam = 66
    MSK_IPAR_MIO_CUT_SELECTION_LEVEL Iparam = 67
    MSK_IPAR_MIO_DATA_PERMUTATION_METHOD Iparam = 68
    MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL Iparam = 69
    MSK_IPAR_MIO_FEASPUMP_LEVEL Iparam = 70
    MSK_IPAR_MIO_HEURISTIC_LEVEL Iparam = 71
    MSK_IPAR_MIO_MAX_NUM_BRANCHES Iparam = 72
    MSK_IPAR_MIO_MAX_NUM_RELAXS Iparam = 73
    MSK_IPAR_MIO_MAX_NUM_RESTARTS Iparam = 74
    MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS Iparam = 75
    MSK_IPAR_MIO_MAX_NUM_SOLUTIONS Iparam = 76
    MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL Iparam = 77
    MSK_IPAR_MIO_MIN_REL Iparam = 78
    MSK_IPAR_MIO_MODE Iparam = 79
    MSK_IPAR_MIO_NODE_OPTIMIZER Iparam = 80
    MSK_IPAR_MIO_NODE_SELECTION Iparam = 81
    MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL Iparam = 82
    MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE Iparam = 83
    MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE Iparam = 84
    MSK_IPAR_MIO_PROBING_LEVEL Iparam = 85
    MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT Iparam = 86
    MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD Iparam = 87
    MSK_IPAR_MIO_RINS_MAX_NODES Iparam = 88
    MSK_IPAR_MIO_ROOT_OPTIMIZER Iparam = 89
    MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL Iparam = 90
    MSK_IPAR_MIO_SEED Iparam = 91
    MSK_IPAR_MIO_SYMMETRY_LEVEL Iparam = 92
    MSK_IPAR_MIO_VAR_SELECTION Iparam = 93
    MSK_IPAR_MIO_VB_DETECTION_LEVEL Iparam = 94
    MSK_IPAR_MT_SPINCOUNT Iparam = 95
    MSK_IPAR_NG Iparam = 96
    MSK_IPAR_NUM_THREADS Iparam = 97
    MSK_IPAR_OPF_WRITE_HEADER Iparam = 98
    MSK_IPAR_OPF_WRITE_HINTS Iparam = 99
    MSK_IPAR_OPF_WRITE_LINE_LENGTH Iparam = 100
    MSK_IPAR_OPF_WRITE_PARAMETERS Iparam = 101
    MSK_IPAR_OPF_WRITE_PROBLEM Iparam = 102
    MSK_IPAR_OPF_WRITE_SOL_BAS Iparam = 103
    MSK_IPAR_OPF_WRITE_SOL_ITG Iparam = 104
    MSK_IPAR_OPF_WRITE_SOL_ITR Iparam = 105
    MSK_IPAR_OPF_WRITE_SOLUTIONS Iparam = 106
    MSK_IPAR_OPTIMIZER Iparam = 107
    MSK_IPAR_PARAM_READ_CASE_NAME Iparam = 108
    MSK_IPAR_PARAM_READ_IGN_ERROR Iparam = 109
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL Iparam = 110
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES Iparam = 111
    MSK_IPAR_PRESOLVE_LEVEL Iparam = 112
    MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH Iparam = 113
    MSK_IPAR_PRESOLVE_LINDEP_NEW Iparam = 114
    MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH Iparam = 115
    MSK_IPAR_PRESOLVE_LINDEP_USE Iparam = 116
    MSK_IPAR_PRESOLVE_MAX_NUM_PASS Iparam = 117
    MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS Iparam = 118
    MSK_IPAR_PRESOLVE_USE Iparam = 119
    MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER Iparam = 120
    MSK_IPAR_PTF_WRITE_PARAMETERS Iparam = 121
    MSK_IPAR_PTF_WRITE_SOLUTIONS Iparam = 122
    MSK_IPAR_PTF_WRITE_TRANSFORM Iparam = 123
    MSK_IPAR_READ_DEBUG Iparam = 124
    MSK_IPAR_READ_KEEP_FREE_CON Iparam = 125
    MSK_IPAR_READ_MPS_FORMAT Iparam = 126
    MSK_IPAR_READ_MPS_WIDTH Iparam = 127
    MSK_IPAR_READ_TASK_IGNORE_PARAM Iparam = 128
    MSK_IPAR_REMOTE_USE_COMPRESSION Iparam = 129
    MSK_IPAR_REMOVE_UNUSED_SOLUTIONS Iparam = 130
    MSK_IPAR_SENSITIVITY_ALL Iparam = 131
    MSK_IPAR_SENSITIVITY_OPTIMIZER Iparam = 132
    MSK_IPAR_SENSITIVITY_TYPE Iparam = 133
    MSK_IPAR_SIM_BASIS_FACTOR_USE Iparam = 134
    MSK_IPAR_SIM_DEGEN Iparam = 135
    MSK_IPAR_SIM_DETECT_PWL Iparam = 136
    MSK_IPAR_SIM_DUAL_CRASH Iparam = 137
    MSK_IPAR_SIM_DUAL_PHASEONE_METHOD Iparam = 138
    MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION Iparam = 139
    MSK_IPAR_SIM_DUAL_SELECTION Iparam = 140
    MSK_IPAR_SIM_EXPLOIT_DUPVEC Iparam = 141
    MSK_IPAR_SIM_HOTSTART Iparam = 142
    MSK_IPAR_SIM_HOTSTART_LU Iparam = 143
    MSK_IPAR_SIM_MAX_ITERATIONS Iparam = 144
    MSK_IPAR_SIM_MAX_NUM_SETBACKS Iparam = 145
    MSK_IPAR_SIM_NON_SINGULAR Iparam = 146
    MSK_IPAR_SIM_PRIMAL_CRASH Iparam = 147
    MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD Iparam = 148
    MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION Iparam = 149
    MSK_IPAR_SIM_PRIMAL_SELECTION Iparam = 150
    MSK_IPAR_SIM_REFACTOR_FREQ Iparam = 151
    MSK_IPAR_SIM_REFORMULATION Iparam = 152
    MSK_IPAR_SIM_SAVE_LU Iparam = 153
    MSK_IPAR_SIM_SCALING Iparam = 154
    MSK_IPAR_SIM_SCALING_METHOD Iparam = 155
    MSK_IPAR_SIM_SEED Iparam = 156
    MSK_IPAR_SIM_SOLVE_FORM Iparam = 157
    MSK_IPAR_SIM_STABILITY_PRIORITY Iparam = 158
    MSK_IPAR_SIM_SWITCH_OPTIMIZER Iparam = 159
    MSK_IPAR_SOL_FILTER_KEEP_BASIC Iparam = 160
    MSK_IPAR_SOL_FILTER_KEEP_RANGED Iparam = 161
    MSK_IPAR_SOL_READ_NAME_WIDTH Iparam = 162
    MSK_IPAR_SOL_READ_WIDTH Iparam = 163
    MSK_IPAR_SOLUTION_CALLBACK Iparam = 164
    MSK_IPAR_TIMING_LEVEL Iparam = 165
    MSK_IPAR_WRITE_BAS_CONSTRAINTS Iparam = 166
    MSK_IPAR_WRITE_BAS_HEAD Iparam = 167
    MSK_IPAR_WRITE_BAS_VARIABLES Iparam = 168
    MSK_IPAR_WRITE_COMPRESSION Iparam = 169
    MSK_IPAR_WRITE_DATA_PARAM Iparam = 170
    MSK_IPAR_WRITE_FREE_CON Iparam = 171
    MSK_IPAR_WRITE_GENERIC_NAMES Iparam = 172
    MSK_IPAR_WRITE_GENERIC_NAMES_IO Iparam = 173
    MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS Iparam = 174
    MSK_IPAR_WRITE_INT_CONSTRAINTS Iparam = 175
    MSK_IPAR_WRITE_INT_HEAD Iparam = 176
    MSK_IPAR_WRITE_INT_VARIABLES Iparam = 177
    MSK_IPAR_WRITE_JSON_INDENTATION Iparam = 178
    MSK_IPAR_WRITE_LP_FULL_OBJ Iparam = 179
    MSK_IPAR_WRITE_LP_LINE_WIDTH Iparam = 180
    MSK_IPAR_WRITE_MPS_FORMAT Iparam = 181
    MSK_IPAR_WRITE_MPS_INT Iparam = 182
    MSK_IPAR_WRITE_SOL_BARVARIABLES Iparam = 183
    MSK_IPAR_WRITE_SOL_CONSTRAINTS Iparam = 184
    MSK_IPAR_WRITE_SOL_HEAD Iparam = 185
    MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES Iparam = 186
    MSK_IPAR_WRITE_SOL_VARIABLES Iparam = 187
    MSK_IPAR_WRITE_TASK_INC_SOL Iparam = 188
    MSK_IPAR_WRITE_XML_MODE Iparam = 189
    MSK_IPAR_END Iparam = 189
)
type Branchdir int32
const (
    MSK_BRANCH_DIR_FREE Branchdir = 0
    MSK_BRANCH_DIR_UP Branchdir = 1
    MSK_BRANCH_DIR_DOWN Branchdir = 2
    MSK_BRANCH_DIR_NEAR Branchdir = 3
    MSK_BRANCH_DIR_FAR Branchdir = 4
    MSK_BRANCH_DIR_ROOT_LP Branchdir = 5
    MSK_BRANCH_DIR_GUIDED Branchdir = 6
    MSK_BRANCH_DIR_PSEUDOCOST Branchdir = 7
    MSK_BRANCH_DIR_END Branchdir = 7
)
type Miqcqoreformmethod int32
const (
    MSK_MIO_QCQO_REFORMULATION_METHOD_FREE Miqcqoreformmethod = 0
    MSK_MIO_QCQO_REFORMULATION_METHOD_NONE Miqcqoreformmethod = 1
    MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION Miqcqoreformmethod = 2
    MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD Miqcqoreformmethod = 3
    MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP Miqcqoreformmethod = 4
    MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP Miqcqoreformmethod = 5
    MSK_MIO_QCQO_REFORMULATION_METHOD_END Miqcqoreformmethod = 5
)
type Miodatapermmethod int32
const (
    MSK_MIO_DATA_PERMUTATION_METHOD_NONE Miodatapermmethod = 0
    MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT Miodatapermmethod = 1
    MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM Miodatapermmethod = 2
    MSK_MIO_DATA_PERMUTATION_METHOD_END Miodatapermmethod = 2
)
type Miocontsoltype int32
const (
    MSK_MIO_CONT_SOL_NONE Miocontsoltype = 0
    MSK_MIO_CONT_SOL_ROOT Miocontsoltype = 1
    MSK_MIO_CONT_SOL_ITG Miocontsoltype = 2
    MSK_MIO_CONT_SOL_ITG_REL Miocontsoltype = 3
    MSK_MIO_CONT_SOL_END Miocontsoltype = 3
)
type Miomode int32
const (
    MSK_MIO_MODE_IGNORED Miomode = 0
    MSK_MIO_MODE_SATISFIED Miomode = 1
    MSK_MIO_MODE_END Miomode = 1
)
type Mionodeseltype int32
const (
    MSK_MIO_NODE_SELECTION_FREE Mionodeseltype = 0
    MSK_MIO_NODE_SELECTION_FIRST Mionodeseltype = 1
    MSK_MIO_NODE_SELECTION_BEST Mionodeseltype = 2
    MSK_MIO_NODE_SELECTION_PSEUDO Mionodeseltype = 3
    MSK_MIO_NODE_SELECTION_END Mionodeseltype = 3
)
type Miovarseltype int32
const (
    MSK_MIO_VAR_SELECTION_FREE Miovarseltype = 0
    MSK_MIO_VAR_SELECTION_PSEUDOCOST Miovarseltype = 1
    MSK_MIO_VAR_SELECTION_STRONG Miovarseltype = 2
    MSK_MIO_VAR_SELECTION_END Miovarseltype = 2
)
type Mpsformat int32
const (
    MSK_MPS_FORMAT_STRICT Mpsformat = 0
    MSK_MPS_FORMAT_RELAXED Mpsformat = 1
    MSK_MPS_FORMAT_FREE Mpsformat = 2
    MSK_MPS_FORMAT_CPLEX Mpsformat = 3
    MSK_MPS_FORMAT_END Mpsformat = 3
)
type Objsense int32
const (
    MSK_OBJECTIVE_SENSE_MINIMIZE Objsense = 0
    MSK_OBJECTIVE_SENSE_MAXIMIZE Objsense = 1
    MSK_OBJECTIVE_SENSE_END Objsense = 1
)
type Onoffkey int32
const (
    MSK_OFF Onoffkey = 0
    MSK_ON Onoffkey = 1
)
type Optimizertype int32
const (
    MSK_OPTIMIZER_CONIC Optimizertype = 0
    MSK_OPTIMIZER_DUAL_SIMPLEX Optimizertype = 1
    MSK_OPTIMIZER_FREE Optimizertype = 2
    MSK_OPTIMIZER_FREE_SIMPLEX Optimizertype = 3
    MSK_OPTIMIZER_INTPNT Optimizertype = 4
    MSK_OPTIMIZER_MIXED_INT Optimizertype = 5
    MSK_OPTIMIZER_PRIMAL_SIMPLEX Optimizertype = 6
    MSK_OPTIMIZER_END Optimizertype = 6
)
type Orderingtype int32
const (
    MSK_ORDER_METHOD_FREE Orderingtype = 0
    MSK_ORDER_METHOD_APPMINLOC Orderingtype = 1
    MSK_ORDER_METHOD_EXPERIMENTAL Orderingtype = 2
    MSK_ORDER_METHOD_TRY_GRAPHPAR Orderingtype = 3
    MSK_ORDER_METHOD_FORCE_GRAPHPAR Orderingtype = 4
    MSK_ORDER_METHOD_NONE Orderingtype = 5
    MSK_ORDER_METHOD_END Orderingtype = 5
)
type Presolvemode int32
const (
    MSK_PRESOLVE_MODE_OFF Presolvemode = 0
    MSK_PRESOLVE_MODE_ON Presolvemode = 1
    MSK_PRESOLVE_MODE_FREE Presolvemode = 2
    MSK_PRESOLVE_MODE_END Presolvemode = 2
)
type Parametertype int32
const (
    MSK_PAR_INVALID_TYPE Parametertype = 0
    MSK_PAR_DOU_TYPE Parametertype = 1
    MSK_PAR_INT_TYPE Parametertype = 2
    MSK_PAR_STR_TYPE Parametertype = 3
    MSK_PAR_END Parametertype = 3
)
type Problemitem int32
const (
    MSK_PI_VAR Problemitem = 0
    MSK_PI_CON Problemitem = 1
    MSK_PI_CONE Problemitem = 2
    MSK_PI_END Problemitem = 2
)
type Problemtype int32
const (
    MSK_PROBTYPE_LO Problemtype = 0
    MSK_PROBTYPE_QO Problemtype = 1
    MSK_PROBTYPE_QCQO Problemtype = 2
    MSK_PROBTYPE_CONIC Problemtype = 3
    MSK_PROBTYPE_MIXED Problemtype = 4
    MSK_PROBTYPE_END Problemtype = 4
)
type Prosta int32
const (
    MSK_PRO_STA_UNKNOWN Prosta = 0
    MSK_PRO_STA_PRIM_AND_DUAL_FEAS Prosta = 1
    MSK_PRO_STA_PRIM_FEAS Prosta = 2
    MSK_PRO_STA_DUAL_FEAS Prosta = 3
    MSK_PRO_STA_PRIM_INFEAS Prosta = 4
    MSK_PRO_STA_DUAL_INFEAS Prosta = 5
    MSK_PRO_STA_PRIM_AND_DUAL_INFEAS Prosta = 6
    MSK_PRO_STA_ILL_POSED Prosta = 7
    MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED Prosta = 8
    MSK_PRO_STA_END Prosta = 8
)
type Xmlwriteroutputtype int32
const (
    MSK_WRITE_XML_MODE_ROW Xmlwriteroutputtype = 0
    MSK_WRITE_XML_MODE_COL Xmlwriteroutputtype = 1
    MSK_WRITE_XML_MODE_END Xmlwriteroutputtype = 1
)
type Rescode int32
const (
    MSK_RES_OK Rescode = 0
    MSK_RES_WRN_OPEN_PARAM_FILE Rescode = 50
    MSK_RES_WRN_LARGE_BOUND Rescode = 51
    MSK_RES_WRN_LARGE_LO_BOUND Rescode = 52
    MSK_RES_WRN_LARGE_UP_BOUND Rescode = 53
    MSK_RES_WRN_LARGE_CON_FX Rescode = 54
    MSK_RES_WRN_LARGE_CJ Rescode = 57
    MSK_RES_WRN_LARGE_AIJ Rescode = 62
    MSK_RES_WRN_ZERO_AIJ Rescode = 63
    MSK_RES_WRN_NAME_MAX_LEN Rescode = 65
    MSK_RES_WRN_SPAR_MAX_LEN Rescode = 66
    MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR Rescode = 70
    MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR Rescode = 71
    MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR Rescode = 72
    MSK_RES_WRN_LP_OLD_QUAD_FORMAT Rescode = 80
    MSK_RES_WRN_LP_DROP_VARIABLE Rescode = 85
    MSK_RES_WRN_NZ_IN_UPR_TRI Rescode = 200
    MSK_RES_WRN_DROPPED_NZ_QOBJ Rescode = 201
    MSK_RES_WRN_IGNORE_INTEGER Rescode = 250
    MSK_RES_WRN_NO_GLOBAL_OPTIMIZER Rescode = 251
    MSK_RES_WRN_MIO_INFEASIBLE_FINAL Rescode = 270
    MSK_RES_WRN_SOL_FILTER Rescode = 300
    MSK_RES_WRN_UNDEF_SOL_FILE_NAME Rescode = 350
    MSK_RES_WRN_SOL_FILE_IGNORED_CON Rescode = 351
    MSK_RES_WRN_SOL_FILE_IGNORED_VAR Rescode = 352
    MSK_RES_WRN_TOO_FEW_BASIS_VARS Rescode = 400
    MSK_RES_WRN_TOO_MANY_BASIS_VARS Rescode = 405
    MSK_RES_WRN_LICENSE_EXPIRE Rescode = 500
    MSK_RES_WRN_LICENSE_SERVER Rescode = 501
    MSK_RES_WRN_EMPTY_NAME Rescode = 502
    MSK_RES_WRN_USING_GENERIC_NAMES Rescode = 503
    MSK_RES_WRN_INVALID_MPS_NAME Rescode = 504
    MSK_RES_WRN_INVALID_MPS_OBJ_NAME Rescode = 505
    MSK_RES_WRN_LICENSE_FEATURE_EXPIRE Rescode = 509
    MSK_RES_WRN_PARAM_NAME_DOU Rescode = 510
    MSK_RES_WRN_PARAM_NAME_INT Rescode = 511
    MSK_RES_WRN_PARAM_NAME_STR Rescode = 512
    MSK_RES_WRN_PARAM_STR_VALUE Rescode = 515
    MSK_RES_WRN_PARAM_IGNORED_CMIO Rescode = 516
    MSK_RES_WRN_ZEROS_IN_SPARSE_ROW Rescode = 705
    MSK_RES_WRN_ZEROS_IN_SPARSE_COL Rescode = 710
    MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK Rescode = 800
    MSK_RES_WRN_ELIMINATOR_SPACE Rescode = 801
    MSK_RES_WRN_PRESOLVE_OUTOFSPACE Rescode = 802
    MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS Rescode = 803
    MSK_RES_WRN_WRITE_CHANGED_NAMES Rescode = 830
    MSK_RES_WRN_WRITE_DISCARDED_CFIX Rescode = 831
    MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES Rescode = 850
    MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES Rescode = 851
    MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES Rescode = 852
    MSK_RES_WRN_DUPLICATE_CONE_NAMES Rescode = 853
    MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES Rescode = 854
    MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES Rescode = 855
    MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES Rescode = 856
    MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES Rescode = 857
    MSK_RES_WRN_ANA_LARGE_BOUNDS Rescode = 900
    MSK_RES_WRN_ANA_C_ZERO Rescode = 901
    MSK_RES_WRN_ANA_EMPTY_COLS Rescode = 902
    MSK_RES_WRN_ANA_CLOSE_BOUNDS Rescode = 903
    MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS Rescode = 904
    MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES Rescode = 930
    MSK_RES_WRN_NO_DUALIZER Rescode = 950
    MSK_RES_WRN_SYM_MAT_LARGE Rescode = 960
    MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER Rescode = 970
    MSK_RES_WRN_LARGE_FIJ Rescode = 980
    MSK_RES_ERR_LICENSE Rescode = 1000
    MSK_RES_ERR_LICENSE_EXPIRED Rescode = 1001
    MSK_RES_ERR_LICENSE_VERSION Rescode = 1002
    MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION Rescode = 1003
    MSK_RES_ERR_SIZE_LICENSE Rescode = 1005
    MSK_RES_ERR_PROB_LICENSE Rescode = 1006
    MSK_RES_ERR_FILE_LICENSE Rescode = 1007
    MSK_RES_ERR_MISSING_LICENSE_FILE Rescode = 1008
    MSK_RES_ERR_SIZE_LICENSE_CON Rescode = 1010
    MSK_RES_ERR_SIZE_LICENSE_VAR Rescode = 1011
    MSK_RES_ERR_SIZE_LICENSE_INTVAR Rescode = 1012
    MSK_RES_ERR_OPTIMIZER_LICENSE Rescode = 1013
    MSK_RES_ERR_FLEXLM Rescode = 1014
    MSK_RES_ERR_LICENSE_SERVER Rescode = 1015
    MSK_RES_ERR_LICENSE_MAX Rescode = 1016
    MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON Rescode = 1017
    MSK_RES_ERR_LICENSE_FEATURE Rescode = 1018
    MSK_RES_ERR_PLATFORM_NOT_LICENSED Rescode = 1019
    MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE Rescode = 1020
    MSK_RES_ERR_LICENSE_CANNOT_CONNECT Rescode = 1021
    MSK_RES_ERR_LICENSE_INVALID_HOSTID Rescode = 1025
    MSK_RES_ERR_LICENSE_SERVER_VERSION Rescode = 1026
    MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT Rescode = 1027
    MSK_RES_ERR_LICENSE_NO_SERVER_LINE Rescode = 1028
    MSK_RES_ERR_OLDER_DLL Rescode = 1035
    MSK_RES_ERR_NEWER_DLL Rescode = 1036
    MSK_RES_ERR_LINK_FILE_DLL Rescode = 1040
    MSK_RES_ERR_THREAD_MUTEX_INIT Rescode = 1045
    MSK_RES_ERR_THREAD_MUTEX_LOCK Rescode = 1046
    MSK_RES_ERR_THREAD_MUTEX_UNLOCK Rescode = 1047
    MSK_RES_ERR_THREAD_CREATE Rescode = 1048
    MSK_RES_ERR_THREAD_COND_INIT Rescode = 1049
    MSK_RES_ERR_UNKNOWN Rescode = 1050
    MSK_RES_ERR_SPACE Rescode = 1051
    MSK_RES_ERR_FILE_OPEN Rescode = 1052
    MSK_RES_ERR_FILE_READ Rescode = 1053
    MSK_RES_ERR_FILE_WRITE Rescode = 1054
    MSK_RES_ERR_DATA_FILE_EXT Rescode = 1055
    MSK_RES_ERR_INVALID_FILE_NAME Rescode = 1056
    MSK_RES_ERR_INVALID_SOL_FILE_NAME Rescode = 1057
    MSK_RES_ERR_END_OF_FILE Rescode = 1059
    MSK_RES_ERR_NULL_ENV Rescode = 1060
    MSK_RES_ERR_NULL_TASK Rescode = 1061
    MSK_RES_ERR_INVALID_STREAM Rescode = 1062
    MSK_RES_ERR_NO_INIT_ENV Rescode = 1063
    MSK_RES_ERR_INVALID_TASK Rescode = 1064
    MSK_RES_ERR_NULL_POINTER Rescode = 1065
    MSK_RES_ERR_LIVING_TASKS Rescode = 1066
    MSK_RES_ERR_READ_GZIP Rescode = 1067
    MSK_RES_ERR_READ_ZSTD Rescode = 1068
    MSK_RES_ERR_BLANK_NAME Rescode = 1070
    MSK_RES_ERR_DUP_NAME Rescode = 1071
    MSK_RES_ERR_FORMAT_STRING Rescode = 1072
    MSK_RES_ERR_SPARSITY_SPECIFICATION Rescode = 1073
    MSK_RES_ERR_MISMATCHING_DIMENSION Rescode = 1074
    MSK_RES_ERR_INVALID_OBJ_NAME Rescode = 1075
    MSK_RES_ERR_INVALID_CON_NAME Rescode = 1076
    MSK_RES_ERR_INVALID_VAR_NAME Rescode = 1077
    MSK_RES_ERR_INVALID_CONE_NAME Rescode = 1078
    MSK_RES_ERR_INVALID_BARVAR_NAME Rescode = 1079
    MSK_RES_ERR_SPACE_LEAKING Rescode = 1080
    MSK_RES_ERR_SPACE_NO_INFO Rescode = 1081
    MSK_RES_ERR_DIMENSION_SPECIFICATION Rescode = 1082
    MSK_RES_ERR_AXIS_NAME_SPECIFICATION Rescode = 1083
    MSK_RES_ERR_READ_FORMAT Rescode = 1090
    MSK_RES_ERR_MPS_FILE Rescode = 1100
    MSK_RES_ERR_MPS_INV_FIELD Rescode = 1101
    MSK_RES_ERR_MPS_INV_MARKER Rescode = 1102
    MSK_RES_ERR_MPS_NULL_CON_NAME Rescode = 1103
    MSK_RES_ERR_MPS_NULL_VAR_NAME Rescode = 1104
    MSK_RES_ERR_MPS_UNDEF_CON_NAME Rescode = 1105
    MSK_RES_ERR_MPS_UNDEF_VAR_NAME Rescode = 1106
    MSK_RES_ERR_MPS_INVALID_CON_KEY Rescode = 1107
    MSK_RES_ERR_MPS_INVALID_BOUND_KEY Rescode = 1108
    MSK_RES_ERR_MPS_INVALID_SEC_NAME Rescode = 1109
    MSK_RES_ERR_MPS_NO_OBJECTIVE Rescode = 1110
    MSK_RES_ERR_MPS_SPLITTED_VAR Rescode = 1111
    MSK_RES_ERR_MPS_MUL_CON_NAME Rescode = 1112
    MSK_RES_ERR_MPS_MUL_QSEC Rescode = 1113
    MSK_RES_ERR_MPS_MUL_QOBJ Rescode = 1114
    MSK_RES_ERR_MPS_INV_SEC_ORDER Rescode = 1115
    MSK_RES_ERR_MPS_MUL_CSEC Rescode = 1116
    MSK_RES_ERR_MPS_CONE_TYPE Rescode = 1117
    MSK_RES_ERR_MPS_CONE_OVERLAP Rescode = 1118
    MSK_RES_ERR_MPS_CONE_REPEAT Rescode = 1119
    MSK_RES_ERR_MPS_NON_SYMMETRIC_Q Rescode = 1120
    MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT Rescode = 1121
    MSK_RES_ERR_MPS_INVALID_OBJSENSE Rescode = 1122
    MSK_RES_ERR_MPS_TAB_IN_FIELD2 Rescode = 1125
    MSK_RES_ERR_MPS_TAB_IN_FIELD3 Rescode = 1126
    MSK_RES_ERR_MPS_TAB_IN_FIELD5 Rescode = 1127
    MSK_RES_ERR_MPS_INVALID_OBJ_NAME Rescode = 1128
    MSK_RES_ERR_MPS_INVALID_KEY Rescode = 1129
    MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT Rescode = 1130
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE Rescode = 1131
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE Rescode = 1132
    MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT Rescode = 1133
    MSK_RES_ERR_OPF_SYNTAX Rescode = 1134
    MSK_RES_ERR_OPF_PREMATURE_EOF Rescode = 1136
    MSK_RES_ERR_OPF_MISMATCHED_TAG Rescode = 1137
    MSK_RES_ERR_OPF_DUPLICATE_BOUND Rescode = 1138
    MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME Rescode = 1139
    MSK_RES_ERR_OPF_INVALID_CONE_TYPE Rescode = 1140
    MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM Rescode = 1141
    MSK_RES_ERR_OPF_INVALID_TAG Rescode = 1142
    MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY Rescode = 1143
    MSK_RES_ERR_OPF_TOO_LARGE Rescode = 1144
    MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION Rescode = 1146
    MSK_RES_ERR_LP_EMPTY Rescode = 1151
    MSK_RES_ERR_WRITE_MPS_INVALID_NAME Rescode = 1153
    MSK_RES_ERR_LP_INVALID_VAR_NAME Rescode = 1154
    MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME Rescode = 1156
    MSK_RES_ERR_LP_FILE_FORMAT Rescode = 1157
    MSK_RES_ERR_LP_EXPECTED_NUMBER Rescode = 1158
    MSK_RES_ERR_READ_LP_MISSING_END_TAG Rescode = 1159
    MSK_RES_ERR_LP_INDICATOR_VAR Rescode = 1160
    MSK_RES_ERR_LP_EXPECTED_OBJECTIVE Rescode = 1161
    MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION Rescode = 1162
    MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND Rescode = 1163
    MSK_RES_ERR_LP_DUPLICATE_SECTION Rescode = 1164
    MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED Rescode = 1165
    MSK_RES_ERR_WRITING_FILE Rescode = 1166
    MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE Rescode = 1170
    MSK_RES_ERR_JSON_SYNTAX Rescode = 1175
    MSK_RES_ERR_JSON_STRING Rescode = 1176
    MSK_RES_ERR_JSON_NUMBER_OVERFLOW Rescode = 1177
    MSK_RES_ERR_JSON_FORMAT Rescode = 1178
    MSK_RES_ERR_JSON_DATA Rescode = 1179
    MSK_RES_ERR_JSON_MISSING_DATA Rescode = 1180
    MSK_RES_ERR_PTF_INCOMPATIBILITY Rescode = 1181
    MSK_RES_ERR_PTF_UNDEFINED_ITEM Rescode = 1182
    MSK_RES_ERR_PTF_INCONSISTENCY Rescode = 1183
    MSK_RES_ERR_PTF_FORMAT Rescode = 1184
    MSK_RES_ERR_ARGUMENT_LENNEQ Rescode = 1197
    MSK_RES_ERR_ARGUMENT_TYPE Rescode = 1198
    MSK_RES_ERR_NUM_ARGUMENTS Rescode = 1199
    MSK_RES_ERR_IN_ARGUMENT Rescode = 1200
    MSK_RES_ERR_ARGUMENT_DIMENSION Rescode = 1201
    MSK_RES_ERR_SHAPE_IS_TOO_LARGE Rescode = 1202
    MSK_RES_ERR_INDEX_IS_TOO_SMALL Rescode = 1203
    MSK_RES_ERR_INDEX_IS_TOO_LARGE Rescode = 1204
    MSK_RES_ERR_INDEX_IS_NOT_UNIQUE Rescode = 1205
    MSK_RES_ERR_PARAM_NAME Rescode = 1206
    MSK_RES_ERR_PARAM_NAME_DOU Rescode = 1207
    MSK_RES_ERR_PARAM_NAME_INT Rescode = 1208
    MSK_RES_ERR_PARAM_NAME_STR Rescode = 1209
    MSK_RES_ERR_PARAM_INDEX Rescode = 1210
    MSK_RES_ERR_PARAM_IS_TOO_LARGE Rescode = 1215
    MSK_RES_ERR_PARAM_IS_TOO_SMALL Rescode = 1216
    MSK_RES_ERR_PARAM_VALUE_STR Rescode = 1217
    MSK_RES_ERR_PARAM_TYPE Rescode = 1218
    MSK_RES_ERR_INF_DOU_INDEX Rescode = 1219
    MSK_RES_ERR_INF_INT_INDEX Rescode = 1220
    MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL Rescode = 1221
    MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE Rescode = 1222
    MSK_RES_ERR_INF_LINT_INDEX Rescode = 1225
    MSK_RES_ERR_ARG_IS_TOO_SMALL Rescode = 1226
    MSK_RES_ERR_ARG_IS_TOO_LARGE Rescode = 1227
    MSK_RES_ERR_INVALID_WHICHSOL Rescode = 1228
    MSK_RES_ERR_INF_DOU_NAME Rescode = 1230
    MSK_RES_ERR_INF_INT_NAME Rescode = 1231
    MSK_RES_ERR_INF_TYPE Rescode = 1232
    MSK_RES_ERR_INF_LINT_NAME Rescode = 1234
    MSK_RES_ERR_INDEX Rescode = 1235
    MSK_RES_ERR_WHICHSOL Rescode = 1236
    MSK_RES_ERR_SOLITEM Rescode = 1237
    MSK_RES_ERR_WHICHITEM_NOT_ALLOWED Rescode = 1238
    MSK_RES_ERR_MAXNUMCON Rescode = 1240
    MSK_RES_ERR_MAXNUMVAR Rescode = 1241
    MSK_RES_ERR_MAXNUMBARVAR Rescode = 1242
    MSK_RES_ERR_MAXNUMQNZ Rescode = 1243
    MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ Rescode = 1245
    MSK_RES_ERR_INVALID_IDX Rescode = 1246
    MSK_RES_ERR_INVALID_MAX_NUM Rescode = 1247
    MSK_RES_ERR_UNALLOWED_WHICHSOL Rescode = 1248
    MSK_RES_ERR_NUMCONLIM Rescode = 1250
    MSK_RES_ERR_NUMVARLIM Rescode = 1251
    MSK_RES_ERR_TOO_SMALL_MAXNUMANZ Rescode = 1252
    MSK_RES_ERR_INV_APTRE Rescode = 1253
    MSK_RES_ERR_MUL_A_ELEMENT Rescode = 1254
    MSK_RES_ERR_INV_BK Rescode = 1255
    MSK_RES_ERR_INV_BKC Rescode = 1256
    MSK_RES_ERR_INV_BKX Rescode = 1257
    MSK_RES_ERR_INV_VAR_TYPE Rescode = 1258
    MSK_RES_ERR_SOLVER_PROBTYPE Rescode = 1259
    MSK_RES_ERR_OBJECTIVE_RANGE Rescode = 1260
    MSK_RES_ERR_INV_RESCODE Rescode = 1261
    MSK_RES_ERR_INV_IINF Rescode = 1262
    MSK_RES_ERR_INV_LIINF Rescode = 1263
    MSK_RES_ERR_INV_DINF Rescode = 1264
    MSK_RES_ERR_BASIS Rescode = 1266
    MSK_RES_ERR_INV_SKC Rescode = 1267
    MSK_RES_ERR_INV_SKX Rescode = 1268
    MSK_RES_ERR_INV_SK_STR Rescode = 1269
    MSK_RES_ERR_INV_SK Rescode = 1270
    MSK_RES_ERR_INV_CONE_TYPE_STR Rescode = 1271
    MSK_RES_ERR_INV_CONE_TYPE Rescode = 1272
    MSK_RES_ERR_INV_SKN Rescode = 1274
    MSK_RES_ERR_INVALID_SURPLUS Rescode = 1275
    MSK_RES_ERR_INV_NAME_ITEM Rescode = 1280
    MSK_RES_ERR_PRO_ITEM Rescode = 1281
    MSK_RES_ERR_INVALID_FORMAT_TYPE Rescode = 1283
    MSK_RES_ERR_FIRSTI Rescode = 1285
    MSK_RES_ERR_LASTI Rescode = 1286
    MSK_RES_ERR_FIRSTJ Rescode = 1287
    MSK_RES_ERR_LASTJ Rescode = 1288
    MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL Rescode = 1289
    MSK_RES_ERR_NONLINEAR_EQUALITY Rescode = 1290
    MSK_RES_ERR_NONCONVEX Rescode = 1291
    MSK_RES_ERR_NONLINEAR_RANGED Rescode = 1292
    MSK_RES_ERR_CON_Q_NOT_PSD Rescode = 1293
    MSK_RES_ERR_CON_Q_NOT_NSD Rescode = 1294
    MSK_RES_ERR_OBJ_Q_NOT_PSD Rescode = 1295
    MSK_RES_ERR_OBJ_Q_NOT_NSD Rescode = 1296
    MSK_RES_ERR_ARGUMENT_PERM_ARRAY Rescode = 1299
    MSK_RES_ERR_CONE_INDEX Rescode = 1300
    MSK_RES_ERR_CONE_SIZE Rescode = 1301
    MSK_RES_ERR_CONE_OVERLAP Rescode = 1302
    MSK_RES_ERR_CONE_REP_VAR Rescode = 1303
    MSK_RES_ERR_MAXNUMCONE Rescode = 1304
    MSK_RES_ERR_CONE_TYPE Rescode = 1305
    MSK_RES_ERR_CONE_TYPE_STR Rescode = 1306
    MSK_RES_ERR_CONE_OVERLAP_APPEND Rescode = 1307
    MSK_RES_ERR_REMOVE_CONE_VARIABLE Rescode = 1310
    MSK_RES_ERR_APPENDING_TOO_BIG_CONE Rescode = 1311
    MSK_RES_ERR_CONE_PARAMETER Rescode = 1320
    MSK_RES_ERR_SOL_FILE_INVALID_NUMBER Rescode = 1350
    MSK_RES_ERR_HUGE_C Rescode = 1375
    MSK_RES_ERR_HUGE_AIJ Rescode = 1380
    MSK_RES_ERR_DUPLICATE_AIJ Rescode = 1385
    MSK_RES_ERR_LOWER_BOUND_IS_A_NAN Rescode = 1390
    MSK_RES_ERR_UPPER_BOUND_IS_A_NAN Rescode = 1391
    MSK_RES_ERR_INFINITE_BOUND Rescode = 1400
    MSK_RES_ERR_INV_QOBJ_SUBI Rescode = 1401
    MSK_RES_ERR_INV_QOBJ_SUBJ Rescode = 1402
    MSK_RES_ERR_INV_QOBJ_VAL Rescode = 1403
    MSK_RES_ERR_INV_QCON_SUBK Rescode = 1404
    MSK_RES_ERR_INV_QCON_SUBI Rescode = 1405
    MSK_RES_ERR_INV_QCON_SUBJ Rescode = 1406
    MSK_RES_ERR_INV_QCON_VAL Rescode = 1407
    MSK_RES_ERR_QCON_SUBI_TOO_SMALL Rescode = 1408
    MSK_RES_ERR_QCON_SUBI_TOO_LARGE Rescode = 1409
    MSK_RES_ERR_QOBJ_UPPER_TRIANGLE Rescode = 1415
    MSK_RES_ERR_QCON_UPPER_TRIANGLE Rescode = 1417
    MSK_RES_ERR_FIXED_BOUND_VALUES Rescode = 1420
    MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE Rescode = 1421
    MSK_RES_ERR_INVALID_OBJECTIVE_SENSE Rescode = 1445
    MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE Rescode = 1446
    MSK_RES_ERR_Y_IS_UNDEFINED Rescode = 1449
    MSK_RES_ERR_NAN_IN_DOUBLE_DATA Rescode = 1450
    MSK_RES_ERR_INF_IN_DOUBLE_DATA Rescode = 1451
    MSK_RES_ERR_NAN_IN_BLC Rescode = 1461
    MSK_RES_ERR_NAN_IN_BUC Rescode = 1462
    MSK_RES_ERR_INVALID_CFIX Rescode = 1469
    MSK_RES_ERR_NAN_IN_C Rescode = 1470
    MSK_RES_ERR_NAN_IN_BLX Rescode = 1471
    MSK_RES_ERR_NAN_IN_BUX Rescode = 1472
    MSK_RES_ERR_INVALID_AIJ Rescode = 1473
    MSK_RES_ERR_INVALID_CJ Rescode = 1474
    MSK_RES_ERR_SYM_MAT_INVALID Rescode = 1480
    MSK_RES_ERR_SYM_MAT_HUGE Rescode = 1482
    MSK_RES_ERR_INV_PROBLEM Rescode = 1500
    MSK_RES_ERR_MIXED_CONIC_AND_NL Rescode = 1501
    MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM Rescode = 1503
    MSK_RES_ERR_INV_OPTIMIZER Rescode = 1550
    MSK_RES_ERR_MIO_NO_OPTIMIZER Rescode = 1551
    MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE Rescode = 1552
    MSK_RES_ERR_FINAL_SOLUTION Rescode = 1560
    MSK_RES_ERR_FIRST Rescode = 1570
    MSK_RES_ERR_LAST Rescode = 1571
    MSK_RES_ERR_SLICE_SIZE Rescode = 1572
    MSK_RES_ERR_NEGATIVE_SURPLUS Rescode = 1573
    MSK_RES_ERR_NEGATIVE_APPEND Rescode = 1578
    MSK_RES_ERR_POSTSOLVE Rescode = 1580
    MSK_RES_ERR_OVERFLOW Rescode = 1590
    MSK_RES_ERR_NO_BASIS_SOL Rescode = 1600
    MSK_RES_ERR_BASIS_FACTOR Rescode = 1610
    MSK_RES_ERR_BASIS_SINGULAR Rescode = 1615
    MSK_RES_ERR_FACTOR Rescode = 1650
    MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX Rescode = 1700
    MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED Rescode = 1701
    MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND Rescode = 1702
    MSK_RES_ERR_REPAIR_INVALID_PROBLEM Rescode = 1710
    MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED Rescode = 1711
    MSK_RES_ERR_NAME_MAX_LEN Rescode = 1750
    MSK_RES_ERR_NAME_IS_NULL Rescode = 1760
    MSK_RES_ERR_INVALID_COMPRESSION Rescode = 1800
    MSK_RES_ERR_INVALID_IOMODE Rescode = 1801
    MSK_RES_ERR_NO_PRIMAL_INFEAS_CER Rescode = 2000
    MSK_RES_ERR_NO_DUAL_INFEAS_CER Rescode = 2001
    MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK Rescode = 2500
    MSK_RES_ERR_INV_MARKI Rescode = 2501
    MSK_RES_ERR_INV_MARKJ Rescode = 2502
    MSK_RES_ERR_INV_NUMI Rescode = 2503
    MSK_RES_ERR_INV_NUMJ Rescode = 2504
    MSK_RES_ERR_TASK_INCOMPATIBLE Rescode = 2560
    MSK_RES_ERR_TASK_INVALID Rescode = 2561
    MSK_RES_ERR_TASK_WRITE Rescode = 2562
    MSK_RES_ERR_LU_MAX_NUM_TRIES Rescode = 2800
    MSK_RES_ERR_INVALID_UTF8 Rescode = 2900
    MSK_RES_ERR_INVALID_WCHAR Rescode = 2901
    MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL Rescode = 2950
    MSK_RES_ERR_NO_SNX_FOR_BAS_SOL Rescode = 2953
    MSK_RES_ERR_INTERNAL Rescode = 3000
    MSK_RES_ERR_API_ARRAY_TOO_SMALL Rescode = 3001
    MSK_RES_ERR_API_CB_CONNECT Rescode = 3002
    MSK_RES_ERR_API_FATAL_ERROR Rescode = 3005
    MSK_RES_ERR_SEN_FORMAT Rescode = 3050
    MSK_RES_ERR_SEN_UNDEF_NAME Rescode = 3051
    MSK_RES_ERR_SEN_INDEX_RANGE Rescode = 3052
    MSK_RES_ERR_SEN_BOUND_INVALID_UP Rescode = 3053
    MSK_RES_ERR_SEN_BOUND_INVALID_LO Rescode = 3054
    MSK_RES_ERR_SEN_INDEX_INVALID Rescode = 3055
    MSK_RES_ERR_SEN_INVALID_REGEXP Rescode = 3056
    MSK_RES_ERR_SEN_SOLUTION_STATUS Rescode = 3057
    MSK_RES_ERR_SEN_NUMERICAL Rescode = 3058
    MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE Rescode = 3080
    MSK_RES_ERR_UNB_STEP_SIZE Rescode = 3100
    MSK_RES_ERR_IDENTICAL_TASKS Rescode = 3101
    MSK_RES_ERR_AD_INVALID_CODELIST Rescode = 3102
    MSK_RES_ERR_INTERNAL_TEST_FAILED Rescode = 3500
    MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE Rescode = 3600
    MSK_RES_ERR_INVALID_AMPL_STUB Rescode = 3700
    MSK_RES_ERR_INT64_TO_INT32_CAST Rescode = 3800
    MSK_RES_ERR_SIZE_LICENSE_NUMCORES Rescode = 3900
    MSK_RES_ERR_INFEAS_UNDEFINED Rescode = 3910
    MSK_RES_ERR_NO_BARX_FOR_SOLUTION Rescode = 3915
    MSK_RES_ERR_NO_BARS_FOR_SOLUTION Rescode = 3916
    MSK_RES_ERR_BAR_VAR_DIM Rescode = 3920
    MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX Rescode = 3940
    MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX Rescode = 3941
    MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR Rescode = 3942
    MSK_RES_ERR_SYM_MAT_INVALID_VALUE Rescode = 3943
    MSK_RES_ERR_SYM_MAT_DUPLICATE Rescode = 3944
    MSK_RES_ERR_INVALID_SYM_MAT_DIM Rescode = 3950
    MSK_RES_ERR_API_INTERNAL Rescode = 3999
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT Rescode = 4000
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX Rescode = 4001
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS Rescode = 4002
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS Rescode = 4003
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES Rescode = 4005
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS Rescode = 4006
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR Rescode = 4010
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS Rescode = 4011
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS Rescode = 4012
    MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES Rescode = 4500
    MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES Rescode = 4501
    MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES Rescode = 4502
    MSK_RES_ERR_DUPLICATE_CONE_NAMES Rescode = 4503
    MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES Rescode = 4504
    MSK_RES_ERR_DUPLICATE_DJC_NAMES Rescode = 4505
    MSK_RES_ERR_NON_UNIQUE_ARRAY Rescode = 5000
    MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL Rescode = 5004
    MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE Rescode = 5005
    MSK_RES_ERR_MIO_INTERNAL Rescode = 5010
    MSK_RES_ERR_INVALID_PROBLEM_TYPE Rescode = 6000
    MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS Rescode = 6010
    MSK_RES_ERR_UPPER_TRIANGLE Rescode = 6020
    MSK_RES_ERR_LAU_SINGULAR_MATRIX Rescode = 7000
    MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE Rescode = 7001
    MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX Rescode = 7002
    MSK_RES_ERR_LAU_UNKNOWN Rescode = 7005
    MSK_RES_ERR_LAU_ARG_M Rescode = 7010
    MSK_RES_ERR_LAU_ARG_N Rescode = 7011
    MSK_RES_ERR_LAU_ARG_K Rescode = 7012
    MSK_RES_ERR_LAU_ARG_TRANSA Rescode = 7015
    MSK_RES_ERR_LAU_ARG_TRANSB Rescode = 7016
    MSK_RES_ERR_LAU_ARG_UPLO Rescode = 7017
    MSK_RES_ERR_LAU_ARG_TRANS Rescode = 7018
    MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX Rescode = 7019
    MSK_RES_ERR_CBF_PARSE Rescode = 7100
    MSK_RES_ERR_CBF_OBJ_SENSE Rescode = 7101
    MSK_RES_ERR_CBF_NO_VARIABLES Rescode = 7102
    MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS Rescode = 7103
    MSK_RES_ERR_CBF_TOO_MANY_VARIABLES Rescode = 7104
    MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED Rescode = 7105
    MSK_RES_ERR_CBF_SYNTAX Rescode = 7106
    MSK_RES_ERR_CBF_DUPLICATE_OBJ Rescode = 7107
    MSK_RES_ERR_CBF_DUPLICATE_CON Rescode = 7108
    MSK_RES_ERR_CBF_DUPLICATE_VAR Rescode = 7110
    MSK_RES_ERR_CBF_DUPLICATE_INT Rescode = 7111
    MSK_RES_ERR_CBF_INVALID_VAR_TYPE Rescode = 7112
    MSK_RES_ERR_CBF_INVALID_CON_TYPE Rescode = 7113
    MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION Rescode = 7114
    MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD Rescode = 7115
    MSK_RES_ERR_CBF_DUPLICATE_BCOORD Rescode = 7116
    MSK_RES_ERR_CBF_DUPLICATE_ACOORD Rescode = 7117
    MSK_RES_ERR_CBF_TOO_FEW_VARIABLES Rescode = 7118
    MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS Rescode = 7119
    MSK_RES_ERR_CBF_TOO_FEW_INTS Rescode = 7120
    MSK_RES_ERR_CBF_TOO_MANY_INTS Rescode = 7121
    MSK_RES_ERR_CBF_INVALID_INT_INDEX Rescode = 7122
    MSK_RES_ERR_CBF_UNSUPPORTED Rescode = 7123
    MSK_RES_ERR_CBF_DUPLICATE_PSDVAR Rescode = 7124
    MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION Rescode = 7125
    MSK_RES_ERR_CBF_TOO_FEW_PSDVAR Rescode = 7126
    MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION Rescode = 7127
    MSK_RES_ERR_CBF_DUPLICATE_POW_CONES Rescode = 7130
    MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES Rescode = 7131
    MSK_RES_ERR_CBF_INVALID_POWER Rescode = 7132
    MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG Rescode = 7133
    MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX Rescode = 7134
    MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX Rescode = 7135
    MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE Rescode = 7136
    MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE Rescode = 7137
    MSK_RES_ERR_CBF_POWER_CONE_MISMATCH Rescode = 7138
    MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH Rescode = 7139
    MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES Rescode = 7140
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES Rescode = 7141
    MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD Rescode = 7150
    MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD Rescode = 7151
    MSK_RES_ERR_CBF_INVALID_NUM_ACOORD Rescode = 7152
    MSK_RES_ERR_CBF_INVALID_NUM_BCOORD Rescode = 7153
    MSK_RES_ERR_CBF_INVALID_NUM_FCOORD Rescode = 7155
    MSK_RES_ERR_CBF_INVALID_NUM_HCOORD Rescode = 7156
    MSK_RES_ERR_CBF_INVALID_NUM_DCOORD Rescode = 7157
    MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD Rescode = 7158
    MSK_RES_ERR_CBF_INVALID_NUM_PSDCON Rescode = 7200
    MSK_RES_ERR_CBF_DUPLICATE_PSDCON Rescode = 7201
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON Rescode = 7202
    MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX Rescode = 7203
    MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX Rescode = 7204
    MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX Rescode = 7205
    MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE Rescode = 7210
    MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER Rescode = 7700
    MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER Rescode = 7701
    MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE Rescode = 7750
    MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD Rescode = 7800
    MSK_RES_ERR_TOCONIC_CONSTRAINT_FX Rescode = 7801
    MSK_RES_ERR_TOCONIC_CONSTRAINT_RA Rescode = 7802
    MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC Rescode = 7803
    MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD Rescode = 7804
    MSK_RES_ERR_SERVER_CONNECT Rescode = 8000
    MSK_RES_ERR_SERVER_PROTOCOL Rescode = 8001
    MSK_RES_ERR_SERVER_STATUS Rescode = 8002
    MSK_RES_ERR_SERVER_TOKEN Rescode = 8003
    MSK_RES_ERR_SERVER_ADDRESS Rescode = 8004
    MSK_RES_ERR_SERVER_CERTIFICATE Rescode = 8005
    MSK_RES_ERR_SERVER_TLS_CLIENT Rescode = 8006
    MSK_RES_ERR_SERVER_ACCESS_TOKEN Rescode = 8007
    MSK_RES_ERR_SERVER_PROBLEM_SIZE Rescode = 8008
    MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX Rescode = 20050
    MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST Rescode = 20060
    MSK_RES_ERR_DUPLICATE_FIJ Rescode = 20100
    MSK_RES_ERR_INVALID_FIJ Rescode = 20101
    MSK_RES_ERR_HUGE_FIJ Rescode = 20102
    MSK_RES_ERR_INVALID_G Rescode = 20103
    MSK_RES_ERR_INVALID_B Rescode = 20150
    MSK_RES_ERR_DOMAIN_INVALID_INDEX Rescode = 20400
    MSK_RES_ERR_DOMAIN_DIMENSION Rescode = 20401
    MSK_RES_ERR_DOMAIN_DIMENSION_PSD Rescode = 20402
    MSK_RES_ERR_NOT_POWER_DOMAIN Rescode = 20403
    MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA Rescode = 20404
    MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA Rescode = 20405
    MSK_RES_ERR_DOMAIN_POWER_NLEFT Rescode = 20406
    MSK_RES_ERR_AFE_INVALID_INDEX Rescode = 20500
    MSK_RES_ERR_ACC_INVALID_INDEX Rescode = 20600
    MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX Rescode = 20601
    MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH Rescode = 20602
    MSK_RES_ERR_DJC_INVALID_INDEX Rescode = 20700
    MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE Rescode = 20701
    MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH Rescode = 20702
    MSK_RES_ERR_DJC_INVALID_TERM_SIZE Rescode = 20703
    MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH Rescode = 20704
    MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH Rescode = 20705
    MSK_RES_ERR_UNDEF_SOLUTION Rescode = 22000
    MSK_RES_ERR_NO_DOTY Rescode = 22010
    MSK_RES_TRM_MAX_ITERATIONS Rescode = 100000
    MSK_RES_TRM_MAX_TIME Rescode = 100001
    MSK_RES_TRM_OBJECTIVE_RANGE Rescode = 100002
    MSK_RES_TRM_STALL Rescode = 100006
    MSK_RES_TRM_USER_CALLBACK Rescode = 100007
    MSK_RES_TRM_MIO_NUM_RELAXS Rescode = 100008
    MSK_RES_TRM_MIO_NUM_BRANCHES Rescode = 100009
    MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS Rescode = 100015
    MSK_RES_TRM_MAX_NUM_SETBACKS Rescode = 100020
    MSK_RES_TRM_NUMERICAL_PROBLEM Rescode = 100025
    MSK_RES_TRM_LOST_RACE Rescode = 100027
    MSK_RES_TRM_INTERNAL Rescode = 100030
    MSK_RES_TRM_INTERNAL_STOP Rescode = 100031
    MSK_RES_END Rescode = 100031
)
type Rescodetype int32
const (
    MSK_RESPONSE_OK Rescodetype = 0
    MSK_RESPONSE_WRN Rescodetype = 1
    MSK_RESPONSE_TRM Rescodetype = 2
    MSK_RESPONSE_ERR Rescodetype = 3
    MSK_RESPONSE_UNK Rescodetype = 4
    MSK_RESPONSE_END Rescodetype = 4
)
type Scalingtype int32
const (
    MSK_SCALING_FREE Scalingtype = 0
    MSK_SCALING_NONE Scalingtype = 1
    MSK_SCALING_END Scalingtype = 1
)
type Scalingmethod int32
const (
    MSK_SCALING_METHOD_POW2 Scalingmethod = 0
    MSK_SCALING_METHOD_FREE Scalingmethod = 1
    MSK_SCALING_METHOD_END Scalingmethod = 1
)
type Sensitivitytype int32
const (
    MSK_SENSITIVITY_TYPE_BASIS Sensitivitytype = 0
    MSK_SENSITIVITY_TYPE_END Sensitivitytype = 0
)
type Simseltype int32
const (
    MSK_SIM_SELECTION_FREE Simseltype = 0
    MSK_SIM_SELECTION_FULL Simseltype = 1
    MSK_SIM_SELECTION_ASE Simseltype = 2
    MSK_SIM_SELECTION_DEVEX Simseltype = 3
    MSK_SIM_SELECTION_SE Simseltype = 4
    MSK_SIM_SELECTION_PARTIAL Simseltype = 5
    MSK_SIM_SELECTION_END Simseltype = 5
)
type Solitem int32
const (
    MSK_SOL_ITEM_XC Solitem = 0
    MSK_SOL_ITEM_XX Solitem = 1
    MSK_SOL_ITEM_Y Solitem = 2
    MSK_SOL_ITEM_SLC Solitem = 3
    MSK_SOL_ITEM_SUC Solitem = 4
    MSK_SOL_ITEM_SLX Solitem = 5
    MSK_SOL_ITEM_SUX Solitem = 6
    MSK_SOL_ITEM_SNX Solitem = 7
    MSK_SOL_ITEM_END Solitem = 7
)
type Solsta int32
const (
    MSK_SOL_STA_UNKNOWN Solsta = 0
    MSK_SOL_STA_OPTIMAL Solsta = 1
    MSK_SOL_STA_PRIM_FEAS Solsta = 2
    MSK_SOL_STA_DUAL_FEAS Solsta = 3
    MSK_SOL_STA_PRIM_AND_DUAL_FEAS Solsta = 4
    MSK_SOL_STA_PRIM_INFEAS_CER Solsta = 5
    MSK_SOL_STA_DUAL_INFEAS_CER Solsta = 6
    MSK_SOL_STA_PRIM_ILLPOSED_CER Solsta = 7
    MSK_SOL_STA_DUAL_ILLPOSED_CER Solsta = 8
    MSK_SOL_STA_INTEGER_OPTIMAL Solsta = 9
    MSK_SOL_STA_END Solsta = 9
)
type Soltype int32
const (
    MSK_SOL_ITR Soltype = 0
    MSK_SOL_BAS Soltype = 1
    MSK_SOL_ITG Soltype = 2
    MSK_SOL_END Soltype = 2
)
type Solveform int32
const (
    MSK_SOLVE_FREE Solveform = 0
    MSK_SOLVE_PRIMAL Solveform = 1
    MSK_SOLVE_DUAL Solveform = 2
    MSK_SOLVE_END Solveform = 2
)
type Sparam int32
const (
    MSK_SPAR_BAS_SOL_FILE_NAME Sparam = 0
    MSK_SPAR_DATA_FILE_NAME Sparam = 1
    MSK_SPAR_DEBUG_FILE_NAME Sparam = 2
    MSK_SPAR_INT_SOL_FILE_NAME Sparam = 3
    MSK_SPAR_ITR_SOL_FILE_NAME Sparam = 4
    MSK_SPAR_MIO_DEBUG_STRING Sparam = 5
    MSK_SPAR_PARAM_COMMENT_SIGN Sparam = 6
    MSK_SPAR_PARAM_READ_FILE_NAME Sparam = 7
    MSK_SPAR_PARAM_WRITE_FILE_NAME Sparam = 8
    MSK_SPAR_READ_MPS_BOU_NAME Sparam = 9
    MSK_SPAR_READ_MPS_OBJ_NAME Sparam = 10
    MSK_SPAR_READ_MPS_RAN_NAME Sparam = 11
    MSK_SPAR_READ_MPS_RHS_NAME Sparam = 12
    MSK_SPAR_REMOTE_OPTSERVER_HOST Sparam = 13
    MSK_SPAR_REMOTE_TLS_CERT Sparam = 14
    MSK_SPAR_REMOTE_TLS_CERT_PATH Sparam = 15
    MSK_SPAR_SENSITIVITY_FILE_NAME Sparam = 16
    MSK_SPAR_SENSITIVITY_RES_FILE_NAME Sparam = 17
    MSK_SPAR_SOL_FILTER_XC_LOW Sparam = 18
    MSK_SPAR_SOL_FILTER_XC_UPR Sparam = 19
    MSK_SPAR_SOL_FILTER_XX_LOW Sparam = 20
    MSK_SPAR_SOL_FILTER_XX_UPR Sparam = 21
    MSK_SPAR_STAT_KEY Sparam = 22
    MSK_SPAR_STAT_NAME Sparam = 23
    MSK_SPAR_WRITE_LP_GEN_VAR_NAME Sparam = 24
    MSK_SPAR_END Sparam = 24
)
type Stakey int32
const (
    MSK_SK_UNK Stakey = 0
    MSK_SK_BAS Stakey = 1
    MSK_SK_SUPBAS Stakey = 2
    MSK_SK_LOW Stakey = 3
    MSK_SK_UPR Stakey = 4
    MSK_SK_FIX Stakey = 5
    MSK_SK_INF Stakey = 6
    MSK_SK_END Stakey = 6
)
type Startpointtype int32
const (
    MSK_STARTING_POINT_FREE Startpointtype = 0
    MSK_STARTING_POINT_GUESS Startpointtype = 1
    MSK_STARTING_POINT_CONSTANT Startpointtype = 2
    MSK_STARTING_POINT_END Startpointtype = 2
)
type Streamtype int32
const (
    MSK_STREAM_LOG Streamtype = 0
    MSK_STREAM_MSG Streamtype = 1
    MSK_STREAM_ERR Streamtype = 2
    MSK_STREAM_WRN Streamtype = 3
    MSK_STREAM_END Streamtype = 3
)
type Value int32
const (
    MSK_LICENSE_BUFFER_LENGTH Value = 21
    MSK_MAX_STR_LEN Value = 1024
)
type Variabletype int32
const (
    MSK_VAR_TYPE_CONT Variabletype = 0
    MSK_VAR_TYPE_INT Variabletype = 1
    MSK_VAR_END Variabletype = 1
)



type MosekError struct {
    code int32
    msg string
}
func (self*MosekError) Error() string {
    return fmt.Sprintf("%d: %s",self.code,self.msg)
}


type ArrayLengthError struct {
    fun string
    arg string
}
func (self*ArrayLengthError) Error() string {
    return fmt.Sprintf("%s: Argument %s is too short",self.fun,self.arg)   
}


type Env struct {
        r    Rescode
        cptr unsafe.Pointer
}

type Task struct {
        r               Rescode
        cptr            unsafe.Pointer
	streamfunc      [4]func(string)
	callbackfunc    func(int32)int
	infcallbackfunc func(int32,[]float64,[]int32,[]int64)int
}

func (t * Task) ptr() C.MSKtask_t { return C.MSKtask_t(t.cptr) }
func (e * Env)  ptr() C.MSKenv_t  { return C.MSKenv_t(e.cptr) }

func (self * Env) getlasterror(res C.MSKrescodee) (Rescode,string) {
    return Rescode(res),""
}
func (self * Task) getlasterror(res C.MSKrescodee) (Rescode,string) {
    var lastcode C.MSKrescodee = res
    var lastmsglen C.long
    if 0 != C.MSK_getlasterror64(self.ptr(),&lastcode,0, &lastmsglen, nil) {
        return Rescode(lastcode),""
    } else {
        lastmsgbytes := make([]C.char,lastmsglen+1)
        if 0 != C.MSK_getlasterror64(self.ptr(),&lastcode,lastmsglen,&lastmsglen,(*C.char)(&lastmsgbytes[0])) {
            return Rescode(lastcode),""
        } else {
            return Rescode(lastcode),C.GoString(&lastmsgbytes[0])
        }
    }
}


//export streamfunc_log
func streamfunc_log(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[MSK_STREAM_LOG] != nil { task.streamfunc[MSK_STREAM_LOG](C.GoString(msg)) }
}

//export streamfunc_msg
func streamfunc_msg(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[MSK_STREAM_MSG] != nil { task.streamfunc[MSK_STREAM_MSG](C.GoString(msg)) }
}

//export streamfunc_wrn
func streamfunc_wrn(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[MSK_STREAM_WRN] != nil { task.streamfunc[MSK_STREAM_WRN](C.GoString(msg)) }
}

//export streamfunc_err
func streamfunc_err(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[MSK_STREAM_ERR] != nil { task.streamfunc[MSK_STREAM_ERR](C.GoString(msg)) }
}

//export callbackfunc
func callbackfunc(
	nativetask unsafe.Pointer,
	handle  unsafe.Pointer,
	code    C.int,
	dinf  * C.MSKrealt,
	iinf  * C.MSKint32t,
	liinf * C.MSKint64t) (C.int) {

	task := (*Task)(handle)

	var r int = 0

	if task.infcallbackfunc != nil {
		_dinf  := (*[int(MSK_DINF_END)]float64)(unsafe.Pointer(dinf))[0:MSK_DINF_END]
		_iinf  := (*[int(MSK_IINF_END)]int32)  (unsafe.Pointer(iinf))[0:MSK_IINF_END]
		_liinf := (*[int(MSK_LIINF_END)]int64) (unsafe.Pointer(liinf))[0:MSK_LIINF_END]

		r = task.infcallbackfunc(int32(code),_dinf,_iinf,_liinf)
	} else if task.callbackfunc != nil {
		r = task.callbackfunc(int32(code))
	}
	return C.int(r)
}


func MakeEnv() (env Env, res int32) {
        var envptr C.MSKenv_t
        res = int32(C.MSK_makeenv(&envptr,nil))
        if res == 0 {
                env.cptr = unsafe.Pointer(envptr)
        }
        return
}

func (env *Env) MakeTask() (task Task, res int32) {
        var taskptr C.MSKtask_t
        res = int32(C.MSK_makeemptytask(env.ptr(), &taskptr))
        if res != 0 { return }
	task.cptr            = unsafe.Pointer(taskptr)
	task.streamfunc[0]   = nil
	task.streamfunc[1]   = nil
	task.streamfunc[2]   = nil
	task.streamfunc[3]   = nil
	task.callbackfunc    = nil
	task.infcallbackfunc = nil

        return
}

func (e *Env) Delete() {
        envptr := e.ptr()
        _ = C.MSK_deleteenv(&envptr)
        e.cptr = nil
}

func (t *Task) Delete() {
        taskptr := t.ptr()
        _ = C.MSK_deletetask(&taskptr)
        t.cptr = nil
}

func (t *Task) PutStreamFunc(whichstream Streamtype, fun func(string)) {
	t.streamfunc[whichstream] = fun

	if fun == nil {
		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			nil,
			nil)
	} else {
		var strmfun (*[0]byte)
		switch whichstream {
		case MSK_STREAM_MSG: strmfun = (*[0]byte)(C.streamfunc_msg)
		case MSK_STREAM_LOG: strmfun = (*[0]byte)(C.streamfunc_log)
		case MSK_STREAM_ERR: strmfun = (*[0]byte)(C.streamfunc_err)
		case MSK_STREAM_WRN: strmfun = (*[0]byte)(C.streamfunc_wrn)
		}

		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			C.MSKuserhandle_t(unsafe.Pointer(t)),
			strmfun) // ?!?
	}
}

func (t *Task) PutCallbackFunc(fun func(int32) int) {
	t.callbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (t *Task) PutInfoCallbackFunc(fun func(int32,[]float64,[]int32,[]int64) int) {
	t.infcallbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (e * Env)  ClearError() { e.r = MSK_RES_OK }
func (t * Task) ClearError() { t.r = MSK_RES_OK }

//func (e * Env)  GetRes() int32 { return e.r }
//func (t * Task) GetRes() int32 { return t.r }

func minint(a []int) (r int) {
        if len(a) == 0 { panic("Minimum of empty array") }
        r = a[0]
        for i := 1; i < len(a); i++ {
                if a[i] < r { r = a[i] }
        }
        return
}

func sum[T int32|int64|float64](data []T) T {
    var r T
    for _,v := range data { r += v }
    return r
}


// Methods
func (self *Task) AnalyzeNames(whichstream Streamtype,nametype Nametype) (err error) {
  if _tmt0 := C.MSK_analyzenames(self.ptr(),whichstream,nametype); _tmt0 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt0)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AnalyzeProblem(whichstream Streamtype) (err error) {
  if _tmt1 := C.MSK_analyzeproblem(self.ptr(),whichstream); _tmt1 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AnalyzeSolution(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt2 := C.MSK_analyzesolution(self.ptr(),whichstream,whichsol); _tmt2 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt2)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAcc(domidx int64,afeidxlist []int64,b []float64) (err error) {
  _tmt3 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt3)
  var _tmt4 *int64
  if afeidxlist != nil { _tmt4 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt5 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAcc",arg:"b"}
    return
  }
  if b != nil { _tmt5 = (*C.MSKint32t)(&b[0]) }
  if _tmt6 := C.MSK_appendacc(self.ptr(),domidx,numafeidx,_tmt4,_tmt5); _tmt6 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt6)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccs(domidxs []int64,afeidxlist []int64,b []float64) (err error) {
  _tmt7 := len(domidxs)
  var numaccs int64 = int32(_tmt7)
  var _tmt8 *int64
  if domidxs != nil { _tmt8 = (*C.MSKint32t)(&domidxs[0]) }
  _tmt9 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt9)
  var _tmt10 *int64
  if afeidxlist != nil { _tmt10 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt11 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccs",arg:"b"}
    return
  }
  if b != nil { _tmt11 = (*C.MSKint32t)(&b[0]) }
  if _tmt12 := C.MSK_appendaccs(self.ptr(),numaccs,_tmt8,numafeidx,_tmt10,_tmt11); _tmt12 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt12)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccSeq(domidx int64,afeidxfirst int64,b []float64) (err error) {
  var _tmt13 int64
  if _tmt14 := C.MSK_getdomainn(task.nativep,domidx,addr(_tmt13)); _tmt14 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt14)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var numafeidx int64 = _tmt13
  var _tmt15 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccSeq",arg:"b"}
    return
  }
  if b != nil { _tmt15 = (*C.MSKint32t)(&b[0]) }
  if _tmt16 := C.MSK_appendaccseq(self.ptr(),domidx,numafeidx,afeidxfirst,_tmt15); _tmt16 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt16)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccsSeq(domidxs []int64,numafeidx int64,afeidxfirst int64,b []float64) (err error) {
  _tmt17 := len(domidxs)
  var numaccs int64 = int32(_tmt17)
  var _tmt18 *int64
  if domidxs != nil { _tmt18 = (*C.MSKint32t)(&domidxs[0]) }
  var _tmt19 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccsSeq",arg:"b"}
    return
  }
  if b != nil { _tmt19 = (*C.MSKint32t)(&b[0]) }
  if _tmt20 := C.MSK_appendaccsseq(self.ptr(),numaccs,_tmt18,numafeidx,afeidxfirst,_tmt19); _tmt20 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt20)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAfes(num int64) (err error) {
  if _tmt21 := C.MSK_appendafes(self.ptr(),num); _tmt21 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt21)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendBarvars(dim []int32) (err error) {
  _tmt22 := len(dim)
  var num int32 = int32(_tmt22)
  var _tmt23 *int32
  if dim != nil { _tmt23 = (*C.MSKint32t)(&dim[0]) }
  if _tmt24 := C.MSK_appendbarvars(self.ptr(),num,_tmt23); _tmt24 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt24)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendCone(ct Conetype,conepar float64,submem []int32) (err error) {
  _tmt25 := len(submem)
  var nummem int32 = int32(_tmt25)
  var _tmt26 *int32
  if submem != nil { _tmt26 = (*C.MSKint32t)(&submem[0]) }
  if _tmt27 := C.MSK_appendcone(self.ptr(),ct,conepar,nummem,_tmt26); _tmt27 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt27)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendConeSeq(ct Conetype,conepar float64,nummem int32,j int32) (err error) {
  if _tmt28 := C.MSK_appendconeseq(self.ptr(),ct,conepar,nummem,j); _tmt28 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt28)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendConesSeq(ct []Conetype,conepar []float64,nummem []int32,j int32) (err error) {
  _tmt29 := len(conepar)
  if _tmt29 < ct { _tmt29 = lof["name"] }
  if _tmt29 < nummem { _tmt29 = lof["name"] }
  var num int32 = int32(_tmt29)
  var _tmt30 *Conetype
  if ct != nil { _tmt30 = (*C.MSKint32t)(&ct[0]) }
  var _tmt31 *float64
  if conepar != nil { _tmt31 = (*C.MSKint32t)(&conepar[0]) }
  var _tmt32 *int32
  if nummem != nil { _tmt32 = (*C.MSKint32t)(&nummem[0]) }
  if _tmt33 := C.MSK_appendconesseq(self.ptr(),num,_tmt30,_tmt31,_tmt32,j); _tmt33 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt33)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendCons(num int32) (err error) {
  if _tmt34 := C.MSK_appendcons(self.ptr(),num); _tmt34 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt34)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDjcs(num int64) (err error) {
  if _tmt35 := C.MSK_appenddjcs(self.ptr(),num); _tmt35 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt35)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualExpConeDomain() (domidx int64,err error) {
  if _tmt36 := C.MSK_appenddualexpconedomain(self.ptr(),&domidx); _tmt36 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt36)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualGeoMeanConeDomain(n int64) (domidx int64,err error) {
  if _tmt37 := C.MSK_appenddualgeomeanconedomain(self.ptr(),n,&domidx); _tmt37 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt37)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualPowerConeDomain(n int64,alpha []float64) (domidx int64,err error) {
  _tmt38 := len(alpha)
  var nleft int64 = int32(_tmt38)
  var _tmt39 *float64
  if alpha != nil { _tmt39 = (*C.MSKint32t)(&alpha[0]) }
  if _tmt40 := C.MSK_appenddualpowerconedomain(self.ptr(),n,nleft,_tmt39,&domidx); _tmt40 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt40)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalExpConeDomain() (domidx int64,err error) {
  if _tmt41 := C.MSK_appendprimalexpconedomain(self.ptr(),&domidx); _tmt41 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt41)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalGeoMeanConeDomain(n int64) (domidx int64,err error) {
  if _tmt42 := C.MSK_appendprimalgeomeanconedomain(self.ptr(),n,&domidx); _tmt42 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt42)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalPowerConeDomain(n int64,alpha []float64) (domidx int64,err error) {
  _tmt43 := len(alpha)
  var nleft int64 = int32(_tmt43)
  var _tmt44 *float64
  if alpha != nil { _tmt44 = (*C.MSKint32t)(&alpha[0]) }
  if _tmt45 := C.MSK_appendprimalpowerconedomain(self.ptr(),n,nleft,_tmt44,&domidx); _tmt45 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt45)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendQuadraticConeDomain(n int64) (domidx int64,err error) {
  if _tmt46 := C.MSK_appendquadraticconedomain(self.ptr(),n,&domidx); _tmt46 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt46)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRDomain(n int64) (domidx int64,err error) {
  if _tmt47 := C.MSK_appendrdomain(self.ptr(),n,&domidx); _tmt47 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt47)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRminusDomain(n int64) (domidx int64,err error) {
  if _tmt48 := C.MSK_appendrminusdomain(self.ptr(),n,&domidx); _tmt48 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt48)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRplusDomain(n int64) (domidx int64,err error) {
  if _tmt49 := C.MSK_appendrplusdomain(self.ptr(),n,&domidx); _tmt49 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt49)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRQuadraticConeDomain(n int64) (domidx int64,err error) {
  if _tmt50 := C.MSK_appendrquadraticconedomain(self.ptr(),n,&domidx); _tmt50 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt50)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRzeroDomain(n int64) (domidx int64,err error) {
  if _tmt51 := C.MSK_appendrzerodomain(self.ptr(),n,&domidx); _tmt51 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt51)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSparseSymMat(dim int32,subi []int32,subj []int32,valij []float64) (idx int64,err error) {
  _tmt52 := len(subi)
  if _tmt52 < valij { _tmt52 = lof["name"] }
  if _tmt52 < subj { _tmt52 = lof["name"] }
  var nz int64 = int32(_tmt52)
  var _tmt53 *int32
  if subi != nil { _tmt53 = (*C.MSKint32t)(&subi[0]) }
  var _tmt54 *int32
  if subj != nil { _tmt54 = (*C.MSKint32t)(&subj[0]) }
  var _tmt55 *float64
  if valij != nil { _tmt55 = (*C.MSKint32t)(&valij[0]) }
  if _tmt56 := C.MSK_appendsparsesymmat(self.ptr(),dim,nz,_tmt53,_tmt54,_tmt55,&idx); _tmt56 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt56)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSparseSymMatList(dims []int32,nz []int64,subi []int32,subj []int32,valij []float64) (idx []int64,err error) {
  _tmt57 := len(dims)
  if _tmt57 < nz { _tmt57 = lof["name"] }
  var num int32 = int32(_tmt57)
  var _tmt58 *int32
  if dims != nil { _tmt58 = (*C.MSKint32t)(&dims[0]) }
  var _tmt59 *int64
  if nz != nil { _tmt59 = (*C.MSKint32t)(&nz[0]) }
  var _tmt60 *int32
  if len(subi) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"subi"}
    return
  }
  if subi != nil { _tmt60 = (*C.MSKint32t)(&subi[0]) }
  var _tmt61 *int32
  if len(subj) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"subj"}
    return
  }
  if subj != nil { _tmt61 = (*C.MSKint32t)(&subj[0]) }
  var _tmt62 *float64
  if len(valij) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"valij"}
    return
  }
  if valij != nil { _tmt62 = (*C.MSKint32t)(&valij[0]) }
  var _tmt63 *int64
  idx := make([]int64,num)
  if len(idx) > 0 { _tmt63 = (*int64)(&n[0]) }
  if _tmt64 := C.MSK_appendsparsesymmatlist(self.ptr(),num,_tmt58,_tmt59,_tmt60,_tmt61,_tmt62,_tmt63); _tmt64 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt64)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSvecPsdConeDomain(n int64) (domidx int64,err error) {
  if _tmt65 := C.MSK_appendsvecpsdconedomain(self.ptr(),n,&domidx); _tmt65 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt65)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendVars(num int32) (err error) {
  if _tmt66 := C.MSK_appendvars(self.ptr(),num); _tmt66 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt66)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) BasisCond() (nrmbasis float64,nrminvbasis float64,err error) {
  if _tmt67 := C.MSK_basiscond(self.ptr(),&nrmbasis,&nrminvbasis); _tmt67 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt67)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) CheckMem(file string,line int32) (err error) {
  _tmt68 := C.CString(file)
  if _tmt69 := C.MSK_checkmemtask(self.ptr(),_tmt68,line); _tmt69 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt69)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ChgConBound(i int32,lower int32,finite int32,value float64) (err error) {
  if _tmt70 := C.MSK_chgconbound(self.ptr(),i,lower,finite,value); _tmt70 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt70)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ChgVarBound(j int32,lower int32,finite int32,value float64) (err error) {
  if _tmt71 := C.MSK_chgvarbound(self.ptr(),j,lower,finite,value); _tmt71 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt71)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) CommitChanges() (err error) {
  if _tmt72 := C.MSK_commitchanges(self.ptr()); _tmt72 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt72)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) DeleteSolution(whichsol Soltype) (err error) {
  if _tmt73 := C.MSK_deletesolution(self.ptr(),whichsol); _tmt73 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt73)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) DualSensitivity(subj []int32) (leftpricej []float64,rightpricej []float64,leftrangej []float64,rightrangej []float64,err error) {
  _tmt74 := len(subj)
  var numj int32 = int32(_tmt74)
  var _tmt75 *int32
  if subj != nil { _tmt75 = (*C.MSKint32t)(&subj[0]) }
  var _tmt76 *float64
  leftpricej := make([]float64,numj)
  if len(leftpricej) > 0 { _tmt76 = (*float64)(&n[0]) }
  var _tmt77 *float64
  rightpricej := make([]float64,numj)
  if len(rightpricej) > 0 { _tmt77 = (*float64)(&n[0]) }
  var _tmt78 *float64
  leftrangej := make([]float64,numj)
  if len(leftrangej) > 0 { _tmt78 = (*float64)(&n[0]) }
  var _tmt79 *float64
  rightrangej := make([]float64,numj)
  if len(rightrangej) > 0 { _tmt79 = (*float64)(&n[0]) }
  if _tmt80 := C.MSK_dualsensitivity(self.ptr(),numj,_tmt75,_tmt76,_tmt77,_tmt78,_tmt79); _tmt80 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt80)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeBarfRow(afeidx int64) (err error) {
  if _tmt81 := C.MSK_emptyafebarfrow(self.ptr(),afeidx); _tmt81 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt81)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeBarfRowList(afeidxlist []int64) (err error) {
  _tmt82 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt82)
  var _tmt83 *int64
  if afeidxlist != nil { _tmt83 = (*C.MSKint32t)(&afeidxlist[0]) }
  if _tmt84 := C.MSK_emptyafebarfrowlist(self.ptr(),numafeidx,_tmt83); _tmt84 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt84)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFCol(varidx int32) (err error) {
  if _tmt85 := C.MSK_emptyafefcol(self.ptr(),varidx); _tmt85 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt85)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFColList(varidx []int32) (err error) {
  _tmt86 := len(varidx)
  var numvaridx int64 = int32(_tmt86)
  var _tmt87 *int32
  if varidx != nil { _tmt87 = (*C.MSKint32t)(&varidx[0]) }
  if _tmt88 := C.MSK_emptyafefcollist(self.ptr(),numvaridx,_tmt87); _tmt88 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt88)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFRow(afeidx int64) (err error) {
  if _tmt89 := C.MSK_emptyafefrow(self.ptr(),afeidx); _tmt89 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt89)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFRowList(afeidx []int64) (err error) {
  _tmt90 := len(afeidx)
  var numafeidx int64 = int32(_tmt90)
  var _tmt91 *int64
  if afeidx != nil { _tmt91 = (*C.MSKint32t)(&afeidx[0]) }
  if _tmt92 := C.MSK_emptyafefrowlist(self.ptr(),numafeidx,_tmt91); _tmt92 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt92)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EvaluateAcc(whichsol Soltype,accidx int64) (activity []float64,err error) {
  var _tmt95 *float64
  var _tmt93 int64
  if _tmt94 := C.MSK_getaccn(task.nativep,accidx,addr(_tmt93)); _tmt94 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt94)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  activity := make([]float64,_tmt93)
  if len(activity) > 0 { _tmt95 = (*float64)(&n[0]) }
  if _tmt96 := C.MSK_evaluateacc(self.ptr(),whichsol,accidx,_tmt95); _tmt96 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt96)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EvaluateAccs(whichsol Soltype) (activity []float64,err error) {
  var _tmt99 *float64
  var _tmt97 int64
  if _tmt98 := C.MSK_getaccntot(task.nativep,addr(_tmt97)); _tmt98 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt98)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  activity := make([]float64,_tmt97)
  if len(activity) > 0 { _tmt99 = (*float64)(&n[0]) }
  if _tmt100 := C.MSK_evaluateaccs(self.ptr(),whichsol,_tmt99); _tmt100 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt100)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateAccNames(sub []int64,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt101 := len(sub)
  var num int64 = int32(_tmt101)
  var _tmt102 *int64
  if sub != nil { _tmt102 = (*C.MSKint32t)(&sub[0]) }
  _tmt103 := C.CString(fmt)
  _tmt104 := len(dims)
  var ndims int32 = int32(_tmt104)
  var _tmt105 *int32
  if dims != nil { _tmt105 = (*C.MSKint32t)(&dims[0]) }
  var _tmt106 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateAccNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt106 = (*C.MSKint32t)(&sp[0]) }
  _tmt107 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt107)
  var _tmt108 *int32
  if namedaxisidxs != nil { _tmt108 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt109 := len(names)
  var numnames int64 = int32(_tmt109)
  var _tmt110 *string
  if names != nil { _tmt110 = (*C.MSKint32t)(&names[0]) }
  if _tmt111 := C.MSK_generateaccnames(self.ptr(),num,_tmt102,_tmt103,ndims,_tmt105,_tmt106,numnamedaxis,_tmt108,numnames,_tmt110); _tmt111 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt111)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateBarvarNames(subj []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt112 := len(subj)
  var num int32 = int32(_tmt112)
  var _tmt113 *int32
  if subj != nil { _tmt113 = (*C.MSKint32t)(&subj[0]) }
  _tmt114 := C.CString(fmt)
  _tmt115 := len(dims)
  var ndims int32 = int32(_tmt115)
  var _tmt116 *int32
  if dims != nil { _tmt116 = (*C.MSKint32t)(&dims[0]) }
  var _tmt117 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateBarvarNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt117 = (*C.MSKint32t)(&sp[0]) }
  _tmt118 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt118)
  var _tmt119 *int32
  if namedaxisidxs != nil { _tmt119 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt120 := len(names)
  var numnames int64 = int32(_tmt120)
  var _tmt121 *string
  if names != nil { _tmt121 = (*C.MSKint32t)(&names[0]) }
  if _tmt122 := C.MSK_generatebarvarnames(self.ptr(),num,_tmt113,_tmt114,ndims,_tmt116,_tmt117,numnamedaxis,_tmt119,numnames,_tmt121); _tmt122 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt122)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateConeNames(subk []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt123 := len(subk)
  var num int32 = int32(_tmt123)
  var _tmt124 *int32
  if subk != nil { _tmt124 = (*C.MSKint32t)(&subk[0]) }
  _tmt125 := C.CString(fmt)
  _tmt126 := len(dims)
  var ndims int32 = int32(_tmt126)
  var _tmt127 *int32
  if dims != nil { _tmt127 = (*C.MSKint32t)(&dims[0]) }
  var _tmt128 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateConeNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt128 = (*C.MSKint32t)(&sp[0]) }
  _tmt129 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt129)
  var _tmt130 *int32
  if namedaxisidxs != nil { _tmt130 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt131 := len(names)
  var numnames int64 = int32(_tmt131)
  var _tmt132 *string
  if names != nil { _tmt132 = (*C.MSKint32t)(&names[0]) }
  if _tmt133 := C.MSK_generateconenames(self.ptr(),num,_tmt124,_tmt125,ndims,_tmt127,_tmt128,numnamedaxis,_tmt130,numnames,_tmt132); _tmt133 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt133)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateConNames(subi []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt134 := len(subi)
  var num int32 = int32(_tmt134)
  var _tmt135 *int32
  if subi != nil { _tmt135 = (*C.MSKint32t)(&subi[0]) }
  _tmt136 := C.CString(fmt)
  _tmt137 := len(dims)
  var ndims int32 = int32(_tmt137)
  var _tmt138 *int32
  if dims != nil { _tmt138 = (*C.MSKint32t)(&dims[0]) }
  var _tmt139 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateConNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt139 = (*C.MSKint32t)(&sp[0]) }
  _tmt140 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt140)
  var _tmt141 *int32
  if namedaxisidxs != nil { _tmt141 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt142 := len(names)
  var numnames int64 = int32(_tmt142)
  var _tmt143 *string
  if names != nil { _tmt143 = (*C.MSKint32t)(&names[0]) }
  if _tmt144 := C.MSK_generateconnames(self.ptr(),num,_tmt135,_tmt136,ndims,_tmt138,_tmt139,numnamedaxis,_tmt141,numnames,_tmt143); _tmt144 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt144)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateDjcNames(sub []int64,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt145 := len(sub)
  var num int64 = int32(_tmt145)
  var _tmt146 *int64
  if sub != nil { _tmt146 = (*C.MSKint32t)(&sub[0]) }
  _tmt147 := C.CString(fmt)
  _tmt148 := len(dims)
  var ndims int32 = int32(_tmt148)
  var _tmt149 *int32
  if dims != nil { _tmt149 = (*C.MSKint32t)(&dims[0]) }
  var _tmt150 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateDjcNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt150 = (*C.MSKint32t)(&sp[0]) }
  _tmt151 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt151)
  var _tmt152 *int32
  if namedaxisidxs != nil { _tmt152 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt153 := len(names)
  var numnames int64 = int32(_tmt153)
  var _tmt154 *string
  if names != nil { _tmt154 = (*C.MSKint32t)(&names[0]) }
  if _tmt155 := C.MSK_generatedjcnames(self.ptr(),num,_tmt146,_tmt147,ndims,_tmt149,_tmt150,numnamedaxis,_tmt152,numnames,_tmt154); _tmt155 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt155)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateVarNames(subj []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt156 := len(subj)
  var num int32 = int32(_tmt156)
  var _tmt157 *int32
  if subj != nil { _tmt157 = (*C.MSKint32t)(&subj[0]) }
  _tmt158 := C.CString(fmt)
  _tmt159 := len(dims)
  var ndims int32 = int32(_tmt159)
  var _tmt160 *int32
  if dims != nil { _tmt160 = (*C.MSKint32t)(&dims[0]) }
  var _tmt161 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateVarNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt161 = (*C.MSKint32t)(&sp[0]) }
  _tmt162 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt162)
  var _tmt163 *int32
  if namedaxisidxs != nil { _tmt163 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt164 := len(names)
  var numnames int64 = int32(_tmt164)
  var _tmt165 *string
  if names != nil { _tmt165 = (*C.MSKint32t)(&names[0]) }
  if _tmt166 := C.MSK_generatevarnames(self.ptr(),num,_tmt157,_tmt158,ndims,_tmt160,_tmt161,numnamedaxis,_tmt163,numnames,_tmt165); _tmt166 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt166)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccAfeIdxList(accidx int64) (afeidxlist []int64,err error) {
  var _tmt169 *int64
  var _tmt167 int64
  if _tmt168 := C.MSK_getaccn(task.nativep,accidx,addr(_tmt167)); _tmt168 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt168)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt167)
  if len(afeidxlist) > 0 { _tmt169 = (*int64)(&n[0]) }
  if _tmt170 := C.MSK_getaccafeidxlist(self.ptr(),accidx,_tmt169); _tmt170 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt170)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccB(accidx int64) (b []float64,err error) {
  var _tmt173 *float64
  var _tmt171 int64
  if _tmt172 := C.MSK_getaccn(task.nativep,accidx,addr(_tmt171)); _tmt172 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt172)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt171)
  if len(b) > 0 { _tmt173 = (*float64)(&n[0]) }
  if _tmt174 := C.MSK_getaccb(self.ptr(),accidx,_tmt173); _tmt174 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt174)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccBarfBlockTriplet() (numtrip int64,acc_afe []int64,bar_var []int32,blk_row []int32,blk_col []int32,blk_val []float64,err error) {
  var _tmt175 int64
  if _tmt176 := C.MSK_getaccbarfnumblocktriplets(task.nativep,addr(_tmt175)); _tmt176 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt176)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumtrip int64 = _tmt175
  var _tmt177 *int64
  acc_afe := make([]int64,maxnumtrip)
  if len(acc_afe) > 0 { _tmt177 = (*int64)(&n[0]) }
  var _tmt178 *int32
  bar_var := make([]int32,maxnumtrip)
  if len(bar_var) > 0 { _tmt178 = (*int32)(&n[0]) }
  var _tmt179 *int32
  blk_row := make([]int32,maxnumtrip)
  if len(blk_row) > 0 { _tmt179 = (*int32)(&n[0]) }
  var _tmt180 *int32
  blk_col := make([]int32,maxnumtrip)
  if len(blk_col) > 0 { _tmt180 = (*int32)(&n[0]) }
  var _tmt181 *float64
  blk_val := make([]float64,maxnumtrip)
  if len(blk_val) > 0 { _tmt181 = (*float64)(&n[0]) }
  if _tmt182 := C.MSK_getaccbarfblocktriplet(self.ptr(),maxnumtrip,&numtrip,_tmt177,_tmt178,_tmt179,_tmt180,_tmt181); _tmt182 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt182)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccBarfNumBlockTriplets() (numtrip int64,err error) {
  if _tmt183 := C.MSK_getaccbarfnumblocktriplets(self.ptr(),&numtrip); _tmt183 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt183)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDomain(accidx int64) (domidx int64,err error) {
  if _tmt184 := C.MSK_getaccdomain(self.ptr(),accidx,&domidx); _tmt184 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt184)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDotY(whichsol Soltype,accidx int64) (doty []float64,err error) {
  var _tmt187 *float64
  var _tmt185 int64
  if _tmt186 := C.MSK_getaccn(task.nativep,accidx,addr(_tmt185)); _tmt186 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt186)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt185)
  if len(doty) > 0 { _tmt187 = (*float64)(&n[0]) }
  if _tmt188 := C.MSK_getaccdoty(self.ptr(),whichsol,accidx,_tmt187); _tmt188 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt188)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDotYS(whichsol Soltype) (doty []float64,err error) {
  var _tmt191 *float64
  var _tmt189 int64
  if _tmt190 := C.MSK_getaccntot(task.nativep,addr(_tmt189)); _tmt190 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt190)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt189)
  if len(doty) > 0 { _tmt191 = (*float64)(&n[0]) }
  if _tmt192 := C.MSK_getaccdotys(self.ptr(),whichsol,_tmt191); _tmt192 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt192)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccFNumnz() (accfnnz int64,err error) {
  if _tmt193 := C.MSK_getaccfnumnz(self.ptr(),&accfnnz); _tmt193 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt193)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccFTrip() (frow []int64,fcol []int32,fval []float64,err error) {
  var _tmt196 *int64
  var _tmt194 int64
  if _tmt195 := C.MSK_getaccfnumnz(task.nativep,addr(_tmt194)); _tmt195 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt195)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  frow := make([]int64,_tmt194)
  if len(frow) > 0 { _tmt196 = (*int64)(&n[0]) }
  var _tmt199 *int32
  var _tmt197 int64
  if _tmt198 := C.MSK_getaccfnumnz(task.nativep,addr(_tmt197)); _tmt198 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt198)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  fcol := make([]int32,_tmt197)
  if len(fcol) > 0 { _tmt199 = (*int32)(&n[0]) }
  var _tmt202 *float64
  var _tmt200 int64
  if _tmt201 := C.MSK_getaccfnumnz(task.nativep,addr(_tmt200)); _tmt201 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt201)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  fval := make([]float64,_tmt200)
  if len(fval) > 0 { _tmt202 = (*float64)(&n[0]) }
  if _tmt203 := C.MSK_getaccftrip(self.ptr(),_tmt196,_tmt199,_tmt202); _tmt203 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt203)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccGVector() (g []float64,err error) {
  var _tmt206 *float64
  var _tmt204 int64
  if _tmt205 := C.MSK_getaccntot(task.nativep,addr(_tmt204)); _tmt205 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt205)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  g := make([]float64,_tmt204)
  if len(g) > 0 { _tmt206 = (*float64)(&n[0]) }
  if _tmt207 := C.MSK_getaccgvector(self.ptr(),_tmt206); _tmt207 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt207)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccN(accidx int64) (n int64,err error) {
  if _tmt208 := C.MSK_getaccn(self.ptr(),accidx,&n); _tmt208 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt208)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccName(accidx int64) (name string,err error) {
  var _tmt209 int32
  if _tmt210 := C.MSK_getaccnamelen(task.nativep,accidx,addr(_tmt209)); _tmt210 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt210)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt209)
  _tmt211 := make([]byte,sizename)
  if _tmt212 := C.MSK_getaccname(self.ptr(),accidx,sizename,C.CString(&tmpvar1[0])); _tmt212 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt212)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt211,byte(0)); p < 0 {
    name = string(_tmt211)
  } else {
    name = string(_tmt211[:p])
  }
  return
}
func (self *Task) GetAccNameLen(accidx int64) (len int32,err error) {
  if _tmt213 := C.MSK_getaccnamelen(self.ptr(),accidx,&len); _tmt213 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt213)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccNTot() (n int64,err error) {
  if _tmt214 := C.MSK_getaccntot(self.ptr(),&n); _tmt214 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt214)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccs() (domidxlist []int64,afeidxlist []int64,b []float64,err error) {
  var _tmt217 *int64
  var _tmt215 int64
  if _tmt216 := C.MSK_getnumacc(task.nativep,addr(_tmt215)); _tmt216 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt216)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt215)
  if len(domidxlist) > 0 { _tmt217 = (*int64)(&n[0]) }
  var _tmt220 *int64
  var _tmt218 int64
  if _tmt219 := C.MSK_getaccntot(task.nativep,addr(_tmt218)); _tmt219 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt219)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt218)
  if len(afeidxlist) > 0 { _tmt220 = (*int64)(&n[0]) }
  var _tmt223 *float64
  var _tmt221 int64
  if _tmt222 := C.MSK_getaccntot(task.nativep,addr(_tmt221)); _tmt222 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt222)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt221)
  if len(b) > 0 { _tmt223 = (*float64)(&n[0]) }
  if _tmt224 := C.MSK_getaccs(self.ptr(),_tmt217,_tmt220,_tmt223); _tmt224 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt224)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetACol(j int32) (nzj int32,subj []int32,valj []float64,err error) {
  var _tmt227 *int32
  var _tmt225 int32
  if _tmt226 := C.MSK_getacolnumnz(task.nativep,j,addr(_tmt225)); _tmt226 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt226)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  subj := make([]int32,_tmt225)
  if len(subj) > 0 { _tmt227 = (*int32)(&n[0]) }
  var _tmt230 *float64
  var _tmt228 int32
  if _tmt229 := C.MSK_getacolnumnz(task.nativep,j,addr(_tmt228)); _tmt229 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt229)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  valj := make([]float64,_tmt228)
  if len(valj) > 0 { _tmt230 = (*float64)(&n[0]) }
  if _tmt231 := C.MSK_getacol(self.ptr(),j,&nzj,_tmt227,_tmt230); _tmt231 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt231)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColNumNz(i int32) (nzj int32,err error) {
  if _tmt232 := C.MSK_getacolnumnz(self.ptr(),i,&nzj); _tmt232 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt232)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSlice(first int32,last int32) (ptrb []int64,ptre []int64,sub []int32,val []float64,err error) {
  var _tmt233 int64
  if _tmt234 := C.MSK_getacolslicenumnz64(task.nativep,first,last,addr(_tmt233)); _tmt234 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt234)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt233
  var _tmt235 *int64
  ptrb := make([]int64,(last - first))
  if len(ptrb) > 0 { _tmt235 = (*int64)(&n[0]) }
  var _tmt236 *int64
  ptre := make([]int64,(last - first))
  if len(ptre) > 0 { _tmt236 = (*int64)(&n[0]) }
  var _tmt237 *int32
  sub := make([]int32,maxnumnz)
  if len(sub) > 0 { _tmt237 = (*int32)(&n[0]) }
  var _tmt238 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt238 = (*float64)(&n[0]) }
  if _tmt239 := C.MSK_getacolslice64(self.ptr(),first,last,maxnumnz,_tmt235,_tmt236,_tmt237,_tmt238); _tmt239 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt239)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSliceNumNz(first int32,last int32) (numnz int64,err error) {
  if _tmt240 := C.MSK_getacolslicenumnz64(self.ptr(),first,last,&numnz); _tmt240 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt240)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSliceTrip(first int32,last int32) (subi []int32,subj []int32,val []float64,err error) {
  var _tmt241 int64
  if _tmt242 := C.MSK_getacolslicenumnz64(task.nativep,first,last,addr(_tmt241)); _tmt242 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt242)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt241
  var _tmt243 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt243 = (*int32)(&n[0]) }
  var _tmt244 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt244 = (*int32)(&n[0]) }
  var _tmt245 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt245 = (*float64)(&n[0]) }
  if _tmt246 := C.MSK_getacolslicetrip(self.ptr(),first,last,maxnumnz,_tmt243,_tmt244,_tmt245); _tmt246 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt246)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfBlockTriplet() (numtrip int64,afeidx []int64,barvaridx []int32,subk []int32,subl []int32,valkl []float64,err error) {
  var _tmt247 int64
  if _tmt248 := C.MSK_getafebarfnumblocktriplets(task.nativep,addr(_tmt247)); _tmt248 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt248)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumtrip int64 = _tmt247
  var _tmt249 *int64
  afeidx := make([]int64,maxnumtrip)
  if len(afeidx) > 0 { _tmt249 = (*int64)(&n[0]) }
  var _tmt250 *int32
  barvaridx := make([]int32,maxnumtrip)
  if len(barvaridx) > 0 { _tmt250 = (*int32)(&n[0]) }
  var _tmt251 *int32
  subk := make([]int32,maxnumtrip)
  if len(subk) > 0 { _tmt251 = (*int32)(&n[0]) }
  var _tmt252 *int32
  subl := make([]int32,maxnumtrip)
  if len(subl) > 0 { _tmt252 = (*int32)(&n[0]) }
  var _tmt253 *float64
  valkl := make([]float64,maxnumtrip)
  if len(valkl) > 0 { _tmt253 = (*float64)(&n[0]) }
  if _tmt254 := C.MSK_getafebarfblocktriplet(self.ptr(),maxnumtrip,&numtrip,_tmt249,_tmt250,_tmt251,_tmt252,_tmt253); _tmt254 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt254)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfNumBlockTriplets() (numtrip int64,err error) {
  if _tmt255 := C.MSK_getafebarfnumblocktriplets(self.ptr(),&numtrip); _tmt255 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt255)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfNumRowEntries(afeidx int64) (numentr int32,err error) {
  if _tmt256 := C.MSK_getafebarfnumrowentries(self.ptr(),afeidx,&numentr); _tmt256 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt256)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfRow(afeidx int64) (barvaridx []int32,ptrterm []int64,numterm []int64,termidx []int64,termweight []float64,err error) {
  var _tmt260 *int32
  var _tmt257 int32
  var _tmt258 int64
  if _tmt259 := C.MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt257),addr(_tmt258)); _tmt259 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt259)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barvaridx := make([]int32,_tmt257)
  if len(barvaridx) > 0 { _tmt260 = (*int32)(&n[0]) }
  var _tmt264 *int64
  var _tmt261 int32
  var _tmt262 int64
  if _tmt263 := C.MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt261),addr(_tmt262)); _tmt263 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt263)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  ptrterm := make([]int64,_tmt261)
  if len(ptrterm) > 0 { _tmt264 = (*int64)(&n[0]) }
  var _tmt268 *int64
  var _tmt265 int32
  var _tmt266 int64
  if _tmt267 := C.MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt265),addr(_tmt266)); _tmt267 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt267)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  numterm := make([]int64,_tmt265)
  if len(numterm) > 0 { _tmt268 = (*int64)(&n[0]) }
  var _tmt272 *int64
  var _tmt269 int32
  var _tmt270 int64
  if _tmt271 := C.MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt269),addr(_tmt270)); _tmt271 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt271)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termidx := make([]int64,_tmt270)
  if len(termidx) > 0 { _tmt272 = (*int64)(&n[0]) }
  var _tmt276 *float64
  var _tmt273 int32
  var _tmt274 int64
  if _tmt275 := C.MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt273),addr(_tmt274)); _tmt275 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt275)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termweight := make([]float64,_tmt274)
  if len(termweight) > 0 { _tmt276 = (*float64)(&n[0]) }
  if _tmt277 := C.MSK_getafebarfrow(self.ptr(),afeidx,_tmt260,_tmt264,_tmt268,_tmt272,_tmt276); _tmt277 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt277)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfRowInfo(afeidx int64) (numentr int32,numterm int64,err error) {
  if _tmt278 := C.MSK_getafebarfrowinfo(self.ptr(),afeidx,&numentr,&numterm); _tmt278 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt278)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFNumNz() (numnz int64,err error) {
  if _tmt279 := C.MSK_getafefnumnz(self.ptr(),&numnz); _tmt279 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt279)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFRow(afeidx int64) (numnz int32,varidx []int32,val []float64,err error) {
  var _tmt282 *int32
  var _tmt280 int32
  if _tmt281 := C.MSK_getafefrownumnz(task.nativep,afeidx,addr(_tmt280)); _tmt281 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt281)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  varidx := make([]int32,_tmt280)
  if len(varidx) > 0 { _tmt282 = (*int32)(&n[0]) }
  var _tmt285 *float64
  var _tmt283 int32
  if _tmt284 := C.MSK_getafefrownumnz(task.nativep,afeidx,addr(_tmt283)); _tmt284 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt284)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  val := make([]float64,_tmt283)
  if len(val) > 0 { _tmt285 = (*float64)(&n[0]) }
  if _tmt286 := C.MSK_getafefrow(self.ptr(),afeidx,&numnz,_tmt282,_tmt285); _tmt286 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt286)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFRowNumNz(afeidx int64) (numnz int32,err error) {
  if _tmt287 := C.MSK_getafefrownumnz(self.ptr(),afeidx,&numnz); _tmt287 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt287)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFTrip() (afeidx []int64,varidx []int32,val []float64,err error) {
  var _tmt290 *int64
  var _tmt288 int64
  if _tmt289 := C.MSK_getafefnumnz(task.nativep,addr(_tmt288)); _tmt289 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt289)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidx := make([]int64,_tmt288)
  if len(afeidx) > 0 { _tmt290 = (*int64)(&n[0]) }
  var _tmt293 *int32
  var _tmt291 int64
  if _tmt292 := C.MSK_getafefnumnz(task.nativep,addr(_tmt291)); _tmt292 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt292)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  varidx := make([]int32,_tmt291)
  if len(varidx) > 0 { _tmt293 = (*int32)(&n[0]) }
  var _tmt296 *float64
  var _tmt294 int64
  if _tmt295 := C.MSK_getafefnumnz(task.nativep,addr(_tmt294)); _tmt295 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt295)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  val := make([]float64,_tmt294)
  if len(val) > 0 { _tmt296 = (*float64)(&n[0]) }
  if _tmt297 := C.MSK_getafeftrip(self.ptr(),_tmt290,_tmt293,_tmt296); _tmt297 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt297)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeG(afeidx int64) (g float64,err error) {
  if _tmt298 := C.MSK_getafeg(self.ptr(),afeidx,&g); _tmt298 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt298)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeGSlice(first int64,last int64) (g []float64,err error) {
  var _tmt299 *float64
  g := make([]float64,(last - first))
  if len(g) > 0 { _tmt299 = (*float64)(&n[0]) }
  if _tmt300 := C.MSK_getafegslice(self.ptr(),first,last,_tmt299); _tmt300 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt300)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAij(i int32,j int32) (aij float64,err error) {
  if _tmt301 := C.MSK_getaij(self.ptr(),i,j,&aij); _tmt301 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt301)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAPieceNumNz(firsti int32,lasti int32,firstj int32,lastj int32) (numnz int32,err error) {
  if _tmt302 := C.MSK_getapiecenumnz(self.ptr(),firsti,lasti,firstj,lastj,&numnz); _tmt302 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt302)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARow(i int32) (nzi int32,subi []int32,vali []float64,err error) {
  var _tmt305 *int32
  var _tmt303 int32
  if _tmt304 := C.MSK_getarownumnz(task.nativep,i,addr(_tmt303)); _tmt304 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt304)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  subi := make([]int32,_tmt303)
  if len(subi) > 0 { _tmt305 = (*int32)(&n[0]) }
  var _tmt308 *float64
  var _tmt306 int32
  if _tmt307 := C.MSK_getarownumnz(task.nativep,i,addr(_tmt306)); _tmt307 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt307)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  vali := make([]float64,_tmt306)
  if len(vali) > 0 { _tmt308 = (*float64)(&n[0]) }
  if _tmt309 := C.MSK_getarow(self.ptr(),i,&nzi,_tmt305,_tmt308); _tmt309 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt309)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowNumNz(i int32) (nzi int32,err error) {
  if _tmt310 := C.MSK_getarownumnz(self.ptr(),i,&nzi); _tmt310 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt310)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSlice(first int32,last int32) (ptrb []int64,ptre []int64,sub []int32,val []float64,err error) {
  var _tmt311 int64
  if _tmt312 := C.MSK_getarowslicenumnz64(task.nativep,first,last,addr(_tmt311)); _tmt312 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt312)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt311
  var _tmt313 *int64
  ptrb := make([]int64,(last - first))
  if len(ptrb) > 0 { _tmt313 = (*int64)(&n[0]) }
  var _tmt314 *int64
  ptre := make([]int64,(last - first))
  if len(ptre) > 0 { _tmt314 = (*int64)(&n[0]) }
  var _tmt315 *int32
  sub := make([]int32,maxnumnz)
  if len(sub) > 0 { _tmt315 = (*int32)(&n[0]) }
  var _tmt316 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt316 = (*float64)(&n[0]) }
  if _tmt317 := C.MSK_getarowslice64(self.ptr(),first,last,maxnumnz,_tmt313,_tmt314,_tmt315,_tmt316); _tmt317 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt317)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSliceNumNz(first int32,last int32) (numnz int64,err error) {
  if _tmt318 := C.MSK_getarowslicenumnz64(self.ptr(),first,last,&numnz); _tmt318 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt318)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSliceTrip(first int32,last int32) (subi []int32,subj []int32,val []float64,err error) {
  var _tmt319 int64
  if _tmt320 := C.MSK_getarowslicenumnz64(task.nativep,first,last,addr(_tmt319)); _tmt320 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt320)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt319
  var _tmt321 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt321 = (*int32)(&n[0]) }
  var _tmt322 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt322 = (*int32)(&n[0]) }
  var _tmt323 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt323 = (*float64)(&n[0]) }
  if _tmt324 := C.MSK_getarowslicetrip(self.ptr(),first,last,maxnumnz,_tmt321,_tmt322,_tmt323); _tmt324 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt324)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetATrip() (subi []int32,subj []int32,val []float64,err error) {
  var _tmt325 int64
  if _tmt326 := C.MSK_getnumanz64(task.nativep,addr(_tmt325)); _tmt326 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt326)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt325
  var _tmt327 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt327 = (*int32)(&n[0]) }
  var _tmt328 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt328 = (*int32)(&n[0]) }
  var _tmt329 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt329 = (*float64)(&n[0]) }
  if _tmt330 := C.MSK_getatrip(self.ptr(),maxnumnz,_tmt327,_tmt328,_tmt329); _tmt330 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt330)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetATruncateTol() (tolzero []float64,err error) {
  var _tmt331 *float64
  tolzero := make([]float64,1)
  if len(tolzero) > 0 { _tmt331 = (*float64)(&n[0]) }
  if _tmt332 := C.MSK_getatruncatetol(self.ptr(),_tmt331); _tmt332 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt332)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraBlockTriplet() (num int64,subi []int32,subj []int32,subk []int32,subl []int32,valijkl []float64,err error) {
  var _tmt333 int64
  if _tmt334 := C.MSK_getnumbarablocktriplets(task.nativep,addr(_tmt333)); _tmt334 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt334)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt333
  var _tmt335 *int32
  subi := make([]int32,maxnum)
  if len(subi) > 0 { _tmt335 = (*int32)(&n[0]) }
  var _tmt336 *int32
  subj := make([]int32,maxnum)
  if len(subj) > 0 { _tmt336 = (*int32)(&n[0]) }
  var _tmt337 *int32
  subk := make([]int32,maxnum)
  if len(subk) > 0 { _tmt337 = (*int32)(&n[0]) }
  var _tmt338 *int32
  subl := make([]int32,maxnum)
  if len(subl) > 0 { _tmt338 = (*int32)(&n[0]) }
  var _tmt339 *float64
  valijkl := make([]float64,maxnum)
  if len(valijkl) > 0 { _tmt339 = (*float64)(&n[0]) }
  if _tmt340 := C.MSK_getbarablocktriplet(self.ptr(),maxnum,&num,_tmt335,_tmt336,_tmt337,_tmt338,_tmt339); _tmt340 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt340)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdx(idx int64) (i int32,j int32,num int64,sub []int64,weights []float64,err error) {
  var _tmt341 int64
  if _tmt342 := C.MSK_getbaraidxinfo(task.nativep,idx,addr(_tmt341)); _tmt342 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt342)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt341
  var _tmt343 *int64
  sub := make([]int64,maxnum)
  if len(sub) > 0 { _tmt343 = (*int64)(&n[0]) }
  var _tmt344 *float64
  weights := make([]float64,maxnum)
  if len(weights) > 0 { _tmt344 = (*float64)(&n[0]) }
  if _tmt345 := C.MSK_getbaraidx(self.ptr(),idx,maxnum,&i,&j,&num,_tmt343,_tmt344); _tmt345 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt345)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdxIJ(idx int64) (i int32,j int32,err error) {
  if _tmt346 := C.MSK_getbaraidxij(self.ptr(),idx,&i,&j); _tmt346 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt346)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdxInfo(idx int64) (num int64,err error) {
  if _tmt347 := C.MSK_getbaraidxinfo(self.ptr(),idx,&num); _tmt347 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt347)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraSparsity() (numnz int64,idxij []int64,err error) {
  var _tmt348 int64
  if _tmt349 := C.MSK_getnumbaranz(task.nativep,addr(_tmt348)); _tmt349 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt349)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt348
  var _tmt350 *int64
  idxij := make([]int64,maxnumnz)
  if len(idxij) > 0 { _tmt350 = (*int64)(&n[0]) }
  if _tmt351 := C.MSK_getbarasparsity(self.ptr(),maxnumnz,&numnz,_tmt350); _tmt351 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt351)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcBlockTriplet() (num int64,subj []int32,subk []int32,subl []int32,valjkl []float64,err error) {
  var _tmt352 int64
  if _tmt353 := C.MSK_getnumbarcblocktriplets(task.nativep,addr(_tmt352)); _tmt353 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt353)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt352
  var _tmt354 *int32
  subj := make([]int32,maxnum)
  if len(subj) > 0 { _tmt354 = (*int32)(&n[0]) }
  var _tmt355 *int32
  subk := make([]int32,maxnum)
  if len(subk) > 0 { _tmt355 = (*int32)(&n[0]) }
  var _tmt356 *int32
  subl := make([]int32,maxnum)
  if len(subl) > 0 { _tmt356 = (*int32)(&n[0]) }
  var _tmt357 *float64
  valjkl := make([]float64,maxnum)
  if len(valjkl) > 0 { _tmt357 = (*float64)(&n[0]) }
  if _tmt358 := C.MSK_getbarcblocktriplet(self.ptr(),maxnum,&num,_tmt354,_tmt355,_tmt356,_tmt357); _tmt358 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt358)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdx(idx int64) (j int32,num int64,sub []int64,weights []float64,err error) {
  var _tmt359 int64
  if _tmt360 := C.MSK_getbarcidxinfo(task.nativep,idx,addr(_tmt359)); _tmt360 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt360)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt359
  var _tmt361 *int64
  sub := make([]int64,maxnum)
  if len(sub) > 0 { _tmt361 = (*int64)(&n[0]) }
  var _tmt362 *float64
  weights := make([]float64,maxnum)
  if len(weights) > 0 { _tmt362 = (*float64)(&n[0]) }
  if _tmt363 := C.MSK_getbarcidx(self.ptr(),idx,maxnum,&j,&num,_tmt361,_tmt362); _tmt363 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt363)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdxInfo(idx int64) (num int64,err error) {
  if _tmt364 := C.MSK_getbarcidxinfo(self.ptr(),idx,&num); _tmt364 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt364)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdxJ(idx int64) (j int32,err error) {
  if _tmt365 := C.MSK_getbarcidxj(self.ptr(),idx,&j); _tmt365 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt365)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcSparsity() (numnz int64,idxj []int64,err error) {
  var _tmt366 int64
  if _tmt367 := C.MSK_getnumbarcnz(task.nativep,addr(_tmt366)); _tmt367 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt367)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt366
  var _tmt368 *int64
  idxj := make([]int64,maxnumnz)
  if len(idxj) > 0 { _tmt368 = (*int64)(&n[0]) }
  if _tmt369 := C.MSK_getbarcsparsity(self.ptr(),maxnumnz,&numnz,_tmt368); _tmt369 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt369)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarsJ(whichsol Soltype,j int32) (barsj []float64,err error) {
  var _tmt372 *float64
  var _tmt370 int64
  if _tmt371 := C.MSK_getlenbarvarj(task.nativep,j,addr(_tmt370)); _tmt371 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt371)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barsj := make([]float64,_tmt370)
  if len(barsj) > 0 { _tmt372 = (*float64)(&n[0]) }
  if _tmt373 := C.MSK_getbarsj(self.ptr(),whichsol,j,_tmt372); _tmt373 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt373)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarsSlice(whichsol Soltype,first int32,last int32,slicesize int64) (barsslice []float64,err error) {
  var _tmt374 *float64
  barsslice := make([]float64,slicesize)
  if len(barsslice) > 0 { _tmt374 = (*float64)(&n[0]) }
  if _tmt375 := C.MSK_getbarsslice(self.ptr(),whichsol,first,last,slicesize,_tmt374); _tmt375 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt375)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarvarName(i int32) (name string,err error) {
  var _tmt376 int32
  if _tmt377 := C.MSK_getbarvarnamelen(task.nativep,i,addr(_tmt376)); _tmt377 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt377)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt376)
  _tmt378 := make([]byte,sizename)
  if _tmt379 := C.MSK_getbarvarname(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt379 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt379)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt378,byte(0)); p < 0 {
    name = string(_tmt378)
  } else {
    name = string(_tmt378[:p])
  }
  return
}
func (self *Task) GetBarvarNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt380 := C.CString(somename)
  if _tmt381 := C.MSK_getbarvarnameindex(self.ptr(),_tmt380,&asgn,&index); _tmt381 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt381)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarvarNameLen(i int32) (len int32,err error) {
  if _tmt382 := C.MSK_getbarvarnamelen(self.ptr(),i,&len); _tmt382 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt382)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarxJ(whichsol Soltype,j int32) (barxj []float64,err error) {
  var _tmt385 *float64
  var _tmt383 int64
  if _tmt384 := C.MSK_getlenbarvarj(task.nativep,j,addr(_tmt383)); _tmt384 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt384)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barxj := make([]float64,_tmt383)
  if len(barxj) > 0 { _tmt385 = (*float64)(&n[0]) }
  if _tmt386 := C.MSK_getbarxj(self.ptr(),whichsol,j,_tmt385); _tmt386 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt386)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarxSlice(whichsol Soltype,first int32,last int32,slicesize int64) (barxslice []float64,err error) {
  var _tmt387 *float64
  barxslice := make([]float64,slicesize)
  if len(barxslice) > 0 { _tmt387 = (*float64)(&n[0]) }
  if _tmt388 := C.MSK_getbarxslice(self.ptr(),whichsol,first,last,slicesize,_tmt387); _tmt388 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt388)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetC() (c []float64,err error) {
  var _tmt391 *float64
  var _tmt389 int32
  if _tmt390 := C.MSK_getnumvar(task.nativep,addr(_tmt389)); _tmt390 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt390)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  c := make([]float64,_tmt389)
  if len(c) > 0 { _tmt391 = (*float64)(&n[0]) }
  if _tmt392 := C.MSK_getc(self.ptr(),_tmt391); _tmt392 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt392)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCfix() (cfix float64,err error) {
  if _tmt393 := C.MSK_getcfix(self.ptr(),&cfix); _tmt393 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt393)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCJ(j int32) (cj float64,err error) {
  if _tmt394 := C.MSK_getcj(self.ptr(),j,&cj); _tmt394 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt394)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCList(subj []int32) (c []float64,err error) {
  _tmt395 := len(subj)
  var num int32 = int32(_tmt395)
  var _tmt396 *int32
  if subj != nil { _tmt396 = (*C.MSKint32t)(&subj[0]) }
  var _tmt397 *float64
  c := make([]float64,num)
  if len(c) > 0 { _tmt397 = (*float64)(&n[0]) }
  if _tmt398 := C.MSK_getclist(self.ptr(),num,_tmt396,_tmt397); _tmt398 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt398)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConBound(i int32) (bk Boundkey,bl float64,bu float64,err error) {
  if _tmt399 := C.MSK_getconbound(self.ptr(),i,&bk,&bl,&bu); _tmt399 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt399)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConBoundSlice(first int32,last int32) (bk []Boundkey,bl []float64,bu []float64,err error) {
  var _tmt400 *Boundkey
  bk := make([]Boundkey,(last - first))
  if len(bk) > 0 { _tmt400 = (*Boundkey)(&n[0]) }
  var _tmt401 *float64
  bl := make([]float64,(last - first))
  if len(bl) > 0 { _tmt401 = (*float64)(&n[0]) }
  var _tmt402 *float64
  bu := make([]float64,(last - first))
  if len(bu) > 0 { _tmt402 = (*float64)(&n[0]) }
  if _tmt403 := C.MSK_getconboundslice(self.ptr(),first,last,_tmt400,_tmt401,_tmt402); _tmt403 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt403)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCone(k int32) (ct Conetype,conepar float64,nummem int32,submem []int32,err error) {
  var _tmt408 *int32
  var _tmt404 conetype
  var _tmt405 float64
  var _tmt406 int32
  if _tmt407 := C.MSK_getconeinfo(task.nativep,k,addr(_tmt404),addr(_tmt405),addr(_tmt406)); _tmt407 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt407)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  submem := make([]int32,_tmt406)
  if len(submem) > 0 { _tmt408 = (*int32)(&n[0]) }
  if _tmt409 := C.MSK_getcone(self.ptr(),k,&ct,&conepar,&nummem,_tmt408); _tmt409 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt409)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeInfo(k int32) (ct Conetype,conepar float64,nummem int32,err error) {
  if _tmt410 := C.MSK_getconeinfo(self.ptr(),k,&ct,&conepar,&nummem); _tmt410 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt410)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeName(i int32) (name string,err error) {
  var _tmt411 int32
  if _tmt412 := C.MSK_getconenamelen(task.nativep,i,addr(_tmt411)); _tmt412 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt412)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt411)
  _tmt413 := make([]byte,sizename)
  if _tmt414 := C.MSK_getconename(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt414 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt414)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt413,byte(0)); p < 0 {
    name = string(_tmt413)
  } else {
    name = string(_tmt413[:p])
  }
  return
}
func (self *Task) GetConeNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt415 := C.CString(somename)
  if _tmt416 := C.MSK_getconenameindex(self.ptr(),_tmt415,&asgn,&index); _tmt416 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt416)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeNameLen(i int32) (len int32,err error) {
  if _tmt417 := C.MSK_getconenamelen(self.ptr(),i,&len); _tmt417 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt417)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConName(i int32) (name string,err error) {
  var _tmt418 int32
  if _tmt419 := C.MSK_getconnamelen(task.nativep,i,addr(_tmt418)); _tmt419 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt419)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt418)
  _tmt420 := make([]byte,sizename)
  if _tmt421 := C.MSK_getconname(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt421 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt421)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt420,byte(0)); p < 0 {
    name = string(_tmt420)
  } else {
    name = string(_tmt420[:p])
  }
  return
}
func (self *Task) GetConNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt422 := C.CString(somename)
  if _tmt423 := C.MSK_getconnameindex(self.ptr(),_tmt422,&asgn,&index); _tmt423 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt423)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConNameLen(i int32) (len int32,err error) {
  if _tmt424 := C.MSK_getconnamelen(self.ptr(),i,&len); _tmt424 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt424)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCSlice(first int32,last int32) (c []float64,err error) {
  var _tmt425 *float64
  c := make([]float64,(last - first))
  if len(c) > 0 { _tmt425 = (*float64)(&n[0]) }
  if _tmt426 := C.MSK_getcslice(self.ptr(),first,last,_tmt425); _tmt426 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt426)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDimBarvarJ(j int32) (dimbarvarj int32,err error) {
  if _tmt427 := C.MSK_getdimbarvarj(self.ptr(),j,&dimbarvarj); _tmt427 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt427)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcAfeIdxList(djcidx int64) (afeidxlist []int64,err error) {
  var _tmt430 *int64
  var _tmt428 int64
  if _tmt429 := C.MSK_getdjcnumafe(task.nativep,djcidx,addr(_tmt428)); _tmt429 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt429)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt428)
  if len(afeidxlist) > 0 { _tmt430 = (*int64)(&n[0]) }
  if _tmt431 := C.MSK_getdjcafeidxlist(self.ptr(),djcidx,_tmt430); _tmt431 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt431)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcB(djcidx int64) (b []float64,err error) {
  var _tmt434 *float64
  var _tmt432 int64
  if _tmt433 := C.MSK_getdjcnumafe(task.nativep,djcidx,addr(_tmt432)); _tmt433 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt433)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt432)
  if len(b) > 0 { _tmt434 = (*float64)(&n[0]) }
  if _tmt435 := C.MSK_getdjcb(self.ptr(),djcidx,_tmt434); _tmt435 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt435)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcDomainIdxList(djcidx int64) (domidxlist []int64,err error) {
  var _tmt438 *int64
  var _tmt436 int64
  if _tmt437 := C.MSK_getdjcnumdomain(task.nativep,djcidx,addr(_tmt436)); _tmt437 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt437)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt436)
  if len(domidxlist) > 0 { _tmt438 = (*int64)(&n[0]) }
  if _tmt439 := C.MSK_getdjcdomainidxlist(self.ptr(),djcidx,_tmt438); _tmt439 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt439)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcName(djcidx int64) (name string,err error) {
  var _tmt440 int32
  if _tmt441 := C.MSK_getdjcnamelen(task.nativep,djcidx,addr(_tmt440)); _tmt441 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt441)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt440)
  _tmt442 := make([]byte,sizename)
  if _tmt443 := C.MSK_getdjcname(self.ptr(),djcidx,sizename,C.CString(&tmpvar1[0])); _tmt443 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt443)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt442,byte(0)); p < 0 {
    name = string(_tmt442)
  } else {
    name = string(_tmt442[:p])
  }
  return
}
func (self *Task) GetDjcNameLen(djcidx int64) (len int32,err error) {
  if _tmt444 := C.MSK_getdjcnamelen(self.ptr(),djcidx,&len); _tmt444 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt444)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumAfe(djcidx int64) (numafe int64,err error) {
  if _tmt445 := C.MSK_getdjcnumafe(self.ptr(),djcidx,&numafe); _tmt445 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt445)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumAfeTot() (numafetot int64,err error) {
  if _tmt446 := C.MSK_getdjcnumafetot(self.ptr(),&numafetot); _tmt446 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt446)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumDomain(djcidx int64) (numdomain int64,err error) {
  if _tmt447 := C.MSK_getdjcnumdomain(self.ptr(),djcidx,&numdomain); _tmt447 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt447)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumDomainTot() (numdomaintot int64,err error) {
  if _tmt448 := C.MSK_getdjcnumdomaintot(self.ptr(),&numdomaintot); _tmt448 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt448)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumTerm(djcidx int64) (numterm int64,err error) {
  if _tmt449 := C.MSK_getdjcnumterm(self.ptr(),djcidx,&numterm); _tmt449 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt449)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumTermTot() (numtermtot int64,err error) {
  if _tmt450 := C.MSK_getdjcnumtermtot(self.ptr(),&numtermtot); _tmt450 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt450)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcs() (domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64,numterms []int64,err error) {
  var _tmt453 *int64
  var _tmt451 int64
  if _tmt452 := C.MSK_getdjcnumdomaintot(task.nativep,addr(_tmt451)); _tmt452 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt452)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt451)
  if len(domidxlist) > 0 { _tmt453 = (*int64)(&n[0]) }
  var _tmt456 *int64
  var _tmt454 int64
  if _tmt455 := C.MSK_getdjcnumafetot(task.nativep,addr(_tmt454)); _tmt455 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt455)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt454)
  if len(afeidxlist) > 0 { _tmt456 = (*int64)(&n[0]) }
  var _tmt459 *float64
  var _tmt457 int64
  if _tmt458 := C.MSK_getdjcnumafetot(task.nativep,addr(_tmt457)); _tmt458 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt458)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt457)
  if len(b) > 0 { _tmt459 = (*float64)(&n[0]) }
  var _tmt462 *int64
  var _tmt460 int64
  if _tmt461 := C.MSK_getdjcnumtermtot(task.nativep,addr(_tmt460)); _tmt461 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt461)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termsizelist := make([]int64,_tmt460)
  if len(termsizelist) > 0 { _tmt462 = (*int64)(&n[0]) }
  var _tmt465 *int64
  var _tmt463 int64
  if _tmt464 := C.MSK_getnumdjc(task.nativep,addr(_tmt463)); _tmt464 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt464)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  numterms := make([]int64,_tmt463)
  if len(numterms) > 0 { _tmt465 = (*int64)(&n[0]) }
  if _tmt466 := C.MSK_getdjcs(self.ptr(),_tmt453,_tmt456,_tmt459,_tmt462,_tmt465); _tmt466 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt466)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcTermSizeList(djcidx int64) (termsizelist []int64,err error) {
  var _tmt469 *int64
  var _tmt467 int64
  if _tmt468 := C.MSK_getdjcnumterm(task.nativep,djcidx,addr(_tmt467)); _tmt468 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt468)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termsizelist := make([]int64,_tmt467)
  if len(termsizelist) > 0 { _tmt469 = (*int64)(&n[0]) }
  if _tmt470 := C.MSK_getdjctermsizelist(self.ptr(),djcidx,_tmt469); _tmt470 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt470)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainN(domidx int64) (n int64,err error) {
  if _tmt471 := C.MSK_getdomainn(self.ptr(),domidx,&n); _tmt471 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt471)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainName(domidx int64) (name string,err error) {
  var _tmt472 int32
  if _tmt473 := C.MSK_getdomainnamelen(task.nativep,domidx,addr(_tmt472)); _tmt473 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt473)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt472)
  _tmt474 := make([]byte,sizename)
  if _tmt475 := C.MSK_getdomainname(self.ptr(),domidx,sizename,C.CString(&tmpvar1[0])); _tmt475 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt475)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt474,byte(0)); p < 0 {
    name = string(_tmt474)
  } else {
    name = string(_tmt474[:p])
  }
  return
}
func (self *Task) GetDomainNameLen(domidx int64) (len int32,err error) {
  if _tmt476 := C.MSK_getdomainnamelen(self.ptr(),domidx,&len); _tmt476 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt476)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainType(domidx int64) (domtype Domaintype,err error) {
  if _tmt477 := C.MSK_getdomaintype(self.ptr(),domidx,&domtype); _tmt477 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt477)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDouInf(whichdinf Dinfitem) (dvalue float64,err error) {
  if _tmt478 := C.MSK_getdouinf(self.ptr(),whichdinf,&dvalue); _tmt478 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt478)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDouParam(param Dparam) (parvalue float64,err error) {
  if _tmt479 := C.MSK_getdouparam(self.ptr(),param,&parvalue); _tmt479 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt479)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDualObj(whichsol Soltype) (dualobj float64,err error) {
  if _tmt480 := C.MSK_getdualobj(self.ptr(),whichsol,&dualobj); _tmt480 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt480)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDualSolutionNorms(whichsol Soltype) (nrmy float64,nrmslc float64,nrmsuc float64,nrmslx float64,nrmsux float64,nrmsnx float64,nrmbars float64,err error) {
  if _tmt481 := C.MSK_getdualsolutionnorms(self.ptr(),whichsol,&nrmy,&nrmslc,&nrmsuc,&nrmslx,&nrmsux,&nrmsnx,&nrmbars); _tmt481 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt481)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolAcc(whichsol Soltype,accidxlist []int64) (viol []float64,err error) {
  _tmt482 := len(accidxlist)
  var numaccidx int64 = int32(_tmt482)
  var _tmt483 *int64
  if accidxlist != nil { _tmt483 = (*C.MSKint32t)(&accidxlist[0]) }
  var _tmt484 *float64
  viol := make([]float64,numaccidx)
  if len(viol) > 0 { _tmt484 = (*float64)(&n[0]) }
  if _tmt485 := C.MSK_getdviolacc(self.ptr(),whichsol,numaccidx,_tmt483,_tmt484); _tmt485 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt485)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolBarvar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt486 := len(sub)
  var num int32 = int32(_tmt486)
  var _tmt487 *int32
  if sub != nil { _tmt487 = (*C.MSKint32t)(&sub[0]) }
  var _tmt488 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt488 = (*float64)(&n[0]) }
  if _tmt489 := C.MSK_getdviolbarvar(self.ptr(),whichsol,num,_tmt487,_tmt488); _tmt489 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt489)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolCon(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt490 := len(sub)
  var num int32 = int32(_tmt490)
  var _tmt491 *int32
  if sub != nil { _tmt491 = (*C.MSKint32t)(&sub[0]) }
  var _tmt492 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt492 = (*float64)(&n[0]) }
  if _tmt493 := C.MSK_getdviolcon(self.ptr(),whichsol,num,_tmt491,_tmt492); _tmt493 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt493)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolCones(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt494 := len(sub)
  var num int32 = int32(_tmt494)
  var _tmt495 *int32
  if sub != nil { _tmt495 = (*C.MSKint32t)(&sub[0]) }
  var _tmt496 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt496 = (*float64)(&n[0]) }
  if _tmt497 := C.MSK_getdviolcones(self.ptr(),whichsol,num,_tmt495,_tmt496); _tmt497 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt497)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolVar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt498 := len(sub)
  var num int32 = int32(_tmt498)
  var _tmt499 *int32
  if sub != nil { _tmt499 = (*C.MSKint32t)(&sub[0]) }
  var _tmt500 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt500 = (*float64)(&n[0]) }
  if _tmt501 := C.MSK_getdviolvar(self.ptr(),whichsol,num,_tmt499,_tmt500); _tmt501 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt501)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetInfIndex(inftype Inftype,infname string) (infindex int32,err error) {
  _tmt502 := C.CString(infname)
  if _tmt503 := C.MSK_getinfindex(self.ptr(),inftype,_tmt502,&infindex); _tmt503 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt503)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetInfMax(inftype Inftype) (infmax []int32,err error) {
  var _tmt504 *int32
  infmax := make([]int32,max_str_len)
  if len(infmax) > 0 { _tmt504 = (*int32)(&n[0]) }
  if _tmt505 := C.MSK_getinfmax(self.ptr(),inftype,_tmt504); _tmt505 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt505)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetInfName(inftype Inftype,whichinf int32) (infname string,err error) {
  _tmt506 := make([]byte,max_str_len)
  if _tmt507 := C.MSK_getinfname(self.ptr(),inftype,whichinf,C.CString(&tmpvar1[0])); _tmt507 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt507)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var infname string
  if p := strings.IndexByte(_tmt506,byte(0)); p < 0 {
    infname = string(_tmt506)
  } else {
    infname = string(_tmt506[:p])
  }
  return
}
func (self *Task) GetIntInf(whichiinf Iinfitem) (ivalue int32,err error) {
  if _tmt508 := C.MSK_getintinf(self.ptr(),whichiinf,&ivalue); _tmt508 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt508)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetIntParam(param Iparam) (parvalue int32,err error) {
  if _tmt509 := C.MSK_getintparam(self.ptr(),param,&parvalue); _tmt509 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt509)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetLenBarvarJ(j int32) (lenbarvarj int64,err error) {
  if _tmt510 := C.MSK_getlenbarvarj(self.ptr(),j,&lenbarvarj); _tmt510 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt510)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetLintInf(whichliinf Liinfitem) (ivalue int64,err error) {
  if _tmt511 := C.MSK_getlintinf(self.ptr(),whichliinf,&ivalue); _tmt511 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt511)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumANz() (maxnumanz int64,err error) {
  if _tmt512 := C.MSK_getmaxnumanz64(self.ptr(),&maxnumanz); _tmt512 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt512)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumBarvar() (maxnumbarvar int32,err error) {
  if _tmt513 := C.MSK_getmaxnumbarvar(self.ptr(),&maxnumbarvar); _tmt513 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt513)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumCon() (maxnumcon int32,err error) {
  if _tmt514 := C.MSK_getmaxnumcon(self.ptr(),&maxnumcon); _tmt514 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt514)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumCone() (maxnumcone int32,err error) {
  if _tmt515 := C.MSK_getmaxnumcone(self.ptr(),&maxnumcone); _tmt515 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt515)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumQNz() (maxnumqnz int64,err error) {
  if _tmt516 := C.MSK_getmaxnumqnz64(self.ptr(),&maxnumqnz); _tmt516 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt516)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumVar() (maxnumvar int32,err error) {
  if _tmt517 := C.MSK_getmaxnumvar(self.ptr(),&maxnumvar); _tmt517 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt517)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMemUsage() (meminuse int64,maxmemuse int64,err error) {
  if _tmt518 := C.MSK_getmemusagetask(self.ptr(),&meminuse,&maxmemuse); _tmt518 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt518)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumAcc() (num int64,err error) {
  if _tmt519 := C.MSK_getnumacc(self.ptr(),&num); _tmt519 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt519)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumAfe() (numafe int64,err error) {
  if _tmt520 := C.MSK_getnumafe(self.ptr(),&numafe); _tmt520 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt520)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumANz() (numanz int32,err error) {
  if _tmt521 := C.MSK_getnumanz(self.ptr(),&numanz); _tmt521 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt521)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumANz64() (numanz int64,err error) {
  if _tmt522 := C.MSK_getnumanz64(self.ptr(),&numanz); _tmt522 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt522)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBaraBlockTriplets() (num int64,err error) {
  if _tmt523 := C.MSK_getnumbarablocktriplets(self.ptr(),&num); _tmt523 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt523)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBaraNz() (nz int64,err error) {
  if _tmt524 := C.MSK_getnumbaranz(self.ptr(),&nz); _tmt524 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt524)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarcBlockTriplets() (num int64,err error) {
  if _tmt525 := C.MSK_getnumbarcblocktriplets(self.ptr(),&num); _tmt525 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt525)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarcNz() (nz int64,err error) {
  if _tmt526 := C.MSK_getnumbarcnz(self.ptr(),&nz); _tmt526 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt526)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarvar() (numbarvar int32,err error) {
  if _tmt527 := C.MSK_getnumbarvar(self.ptr(),&numbarvar); _tmt527 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt527)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumCon() (numcon int32,err error) {
  if _tmt528 := C.MSK_getnumcon(self.ptr(),&numcon); _tmt528 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt528)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumCone() (numcone int32,err error) {
  if _tmt529 := C.MSK_getnumcone(self.ptr(),&numcone); _tmt529 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt529)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumConeMem(k int32) (nummem int32,err error) {
  if _tmt530 := C.MSK_getnumconemem(self.ptr(),k,&nummem); _tmt530 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt530)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumDjc() (num int64,err error) {
  if _tmt531 := C.MSK_getnumdjc(self.ptr(),&num); _tmt531 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt531)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumDomain() (numdomain int64,err error) {
  if _tmt532 := C.MSK_getnumdomain(self.ptr(),&numdomain); _tmt532 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt532)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumIntVar() (numintvar int32,err error) {
  if _tmt533 := C.MSK_getnumintvar(self.ptr(),&numintvar); _tmt533 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt533)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumParam(partype Parametertype) (numparam int32,err error) {
  if _tmt534 := C.MSK_getnumparam(self.ptr(),partype,&numparam); _tmt534 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt534)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumQConKNz(k int32) (numqcnz int64,err error) {
  if _tmt535 := C.MSK_getnumqconknz64(self.ptr(),k,&numqcnz); _tmt535 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt535)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumQObjNz() (numqonz int64,err error) {
  if _tmt536 := C.MSK_getnumqobjnz64(self.ptr(),&numqonz); _tmt536 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt536)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumSymMat() (num int64,err error) {
  if _tmt537 := C.MSK_getnumsymmat(self.ptr(),&num); _tmt537 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt537)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumVar() (numvar int32,err error) {
  if _tmt538 := C.MSK_getnumvar(self.ptr(),&numvar); _tmt538 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt538)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetObjName() (objname string,err error) {
  var _tmt539 int32
  if _tmt540 := C.MSK_getobjnamelen(task.nativep,addr(_tmt539)); _tmt540 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt540)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizeobjname int32 = (1 + _tmt539)
  _tmt541 := make([]byte,sizeobjname)
  if _tmt542 := C.MSK_getobjname(self.ptr(),sizeobjname,C.CString(&tmpvar1[0])); _tmt542 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt542)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var objname string
  if p := strings.IndexByte(_tmt541,byte(0)); p < 0 {
    objname = string(_tmt541)
  } else {
    objname = string(_tmt541[:p])
  }
  return
}
func (self *Task) GetObjNameLen() (len int32,err error) {
  if _tmt543 := C.MSK_getobjnamelen(self.ptr(),&len); _tmt543 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt543)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetObjSense() (sense Objsense,err error) {
  if _tmt544 := C.MSK_getobjsense(self.ptr(),&sense); _tmt544 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt544)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetParamMax(partype Parametertype) (parammax int32,err error) {
  if _tmt545 := C.MSK_getparammax(self.ptr(),partype,&parammax); _tmt545 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt545)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetParamName(partype Parametertype,param int32) (parname string,err error) {
  _tmt546 := make([]byte,max_str_len)
  if _tmt547 := C.MSK_getparamname(self.ptr(),partype,param,C.CString(&tmpvar1[0])); _tmt547 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt547)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var parname string
  if p := strings.IndexByte(_tmt546,byte(0)); p < 0 {
    parname = string(_tmt546)
  } else {
    parname = string(_tmt546[:p])
  }
  return
}
func (self *Task) GetPowerDomainAlpha(domidx int64) (alpha []float64,err error) {
  var _tmt551 *float64
  var _tmt548 int64
  var _tmt549 int64
  if _tmt550 := C.MSK_getpowerdomaininfo(task.nativep,domidx,addr(_tmt548),addr(_tmt549)); _tmt550 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt550)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  alpha := make([]float64,_tmt549)
  if len(alpha) > 0 { _tmt551 = (*float64)(&n[0]) }
  if _tmt552 := C.MSK_getpowerdomainalpha(self.ptr(),domidx,_tmt551); _tmt552 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt552)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPowerDomainInfo(domidx int64) (n int64,nleft int64,err error) {
  if _tmt553 := C.MSK_getpowerdomaininfo(self.ptr(),domidx,&n,&nleft); _tmt553 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt553)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPrimalObj(whichsol Soltype) (primalobj float64,err error) {
  if _tmt554 := C.MSK_getprimalobj(self.ptr(),whichsol,&primalobj); _tmt554 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt554)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPrimalSolutionNorms(whichsol Soltype) (nrmxc float64,nrmxx float64,nrmbarx float64,err error) {
  if _tmt555 := C.MSK_getprimalsolutionnorms(self.ptr(),whichsol,&nrmxc,&nrmxx,&nrmbarx); _tmt555 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt555)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetProbType() (probtype Problemtype,err error) {
  if _tmt556 := C.MSK_getprobtype(self.ptr(),&probtype); _tmt556 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt556)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetProSta(whichsol Soltype) (problemsta Prosta,err error) {
  if _tmt557 := C.MSK_getprosta(self.ptr(),whichsol,&problemsta); _tmt557 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt557)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolAcc(whichsol Soltype,accidxlist []int64) (viol []float64,err error) {
  _tmt558 := len(accidxlist)
  var numaccidx int64 = int32(_tmt558)
  var _tmt559 *int64
  if accidxlist != nil { _tmt559 = (*C.MSKint32t)(&accidxlist[0]) }
  var _tmt560 *float64
  viol := make([]float64,numaccidx)
  if len(viol) > 0 { _tmt560 = (*float64)(&n[0]) }
  if _tmt561 := C.MSK_getpviolacc(self.ptr(),whichsol,numaccidx,_tmt559,_tmt560); _tmt561 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt561)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolBarvar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt562 := len(sub)
  var num int32 = int32(_tmt562)
  var _tmt563 *int32
  if sub != nil { _tmt563 = (*C.MSKint32t)(&sub[0]) }
  var _tmt564 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt564 = (*float64)(&n[0]) }
  if _tmt565 := C.MSK_getpviolbarvar(self.ptr(),whichsol,num,_tmt563,_tmt564); _tmt565 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt565)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolCon(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt566 := len(sub)
  var num int32 = int32(_tmt566)
  var _tmt567 *int32
  if sub != nil { _tmt567 = (*C.MSKint32t)(&sub[0]) }
  var _tmt568 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt568 = (*float64)(&n[0]) }
  if _tmt569 := C.MSK_getpviolcon(self.ptr(),whichsol,num,_tmt567,_tmt568); _tmt569 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt569)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolCones(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt570 := len(sub)
  var num int32 = int32(_tmt570)
  var _tmt571 *int32
  if sub != nil { _tmt571 = (*C.MSKint32t)(&sub[0]) }
  var _tmt572 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt572 = (*float64)(&n[0]) }
  if _tmt573 := C.MSK_getpviolcones(self.ptr(),whichsol,num,_tmt571,_tmt572); _tmt573 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt573)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolDjc(whichsol Soltype,djcidxlist []int64) (viol []float64,err error) {
  _tmt574 := len(djcidxlist)
  var numdjcidx int64 = int32(_tmt574)
  var _tmt575 *int64
  if djcidxlist != nil { _tmt575 = (*C.MSKint32t)(&djcidxlist[0]) }
  var _tmt576 *float64
  viol := make([]float64,numdjcidx)
  if len(viol) > 0 { _tmt576 = (*float64)(&n[0]) }
  if _tmt577 := C.MSK_getpvioldjc(self.ptr(),whichsol,numdjcidx,_tmt575,_tmt576); _tmt577 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt577)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolVar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt578 := len(sub)
  var num int32 = int32(_tmt578)
  var _tmt579 *int32
  if sub != nil { _tmt579 = (*C.MSKint32t)(&sub[0]) }
  var _tmt580 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt580 = (*float64)(&n[0]) }
  if _tmt581 := C.MSK_getpviolvar(self.ptr(),whichsol,num,_tmt579,_tmt580); _tmt581 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt581)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQConK(k int32) (numqcnz int64,qcsubi []int32,qcsubj []int32,qcval []float64,err error) {
  var _tmt582 int64
  if _tmt583 := C.MSK_getnumqconknz64(task.nativep,k,addr(_tmt582)); _tmt583 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt583)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumqcnz int64 = _tmt582
  var _tmt586 *int32
  var _tmt584 int64
  if _tmt585 := C.MSK_getnumqconknz64(task.nativep,k,addr(_tmt584)); _tmt585 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt585)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcsubi := make([]int32,_tmt584)
  if len(qcsubi) > 0 { _tmt586 = (*int32)(&n[0]) }
  var _tmt589 *int32
  var _tmt587 int64
  if _tmt588 := C.MSK_getnumqconknz64(task.nativep,k,addr(_tmt587)); _tmt588 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt588)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcsubj := make([]int32,_tmt587)
  if len(qcsubj) > 0 { _tmt589 = (*int32)(&n[0]) }
  var _tmt592 *float64
  var _tmt590 int64
  if _tmt591 := C.MSK_getnumqconknz64(task.nativep,k,addr(_tmt590)); _tmt591 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt591)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcval := make([]float64,_tmt590)
  if len(qcval) > 0 { _tmt592 = (*float64)(&n[0]) }
  if _tmt593 := C.MSK_getqconk64(self.ptr(),k,maxnumqcnz,&numqcnz,_tmt586,_tmt589,_tmt592); _tmt593 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt593)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQObj() (numqonz int64,qosubi []int32,qosubj []int32,qoval []float64,err error) {
  var _tmt594 int64
  if _tmt595 := C.MSK_getnumqobjnz64(task.nativep,addr(_tmt594)); _tmt595 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt595)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumqonz int64 = _tmt594
  var _tmt596 *int32
  qosubi := make([]int32,maxnumqonz)
  if len(qosubi) > 0 { _tmt596 = (*int32)(&n[0]) }
  var _tmt597 *int32
  qosubj := make([]int32,maxnumqonz)
  if len(qosubj) > 0 { _tmt597 = (*int32)(&n[0]) }
  var _tmt598 *float64
  qoval := make([]float64,maxnumqonz)
  if len(qoval) > 0 { _tmt598 = (*float64)(&n[0]) }
  if _tmt599 := C.MSK_getqobj64(self.ptr(),maxnumqonz,&numqonz,_tmt596,_tmt597,_tmt598); _tmt599 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt599)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQObjIJ(i int32,j int32) (qoij float64,err error) {
  if _tmt600 := C.MSK_getqobjij(self.ptr(),i,j,&qoij); _tmt600 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt600)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetReducedCosts(whichsol Soltype,first int32,last int32) (redcosts []float64,err error) {
  var _tmt601 *float64
  redcosts := make([]float64,(last - first))
  if len(redcosts) > 0 { _tmt601 = (*float64)(&n[0]) }
  if _tmt602 := C.MSK_getreducedcosts(self.ptr(),whichsol,first,last,_tmt601); _tmt602 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt602)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkc(whichsol Soltype) (skc []Stakey,err error) {
  var _tmt605 *Stakey
  var _tmt603 int32
  if _tmt604 := C.MSK_getnumcon(task.nativep,addr(_tmt603)); _tmt604 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt604)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt603)
  if len(skc) > 0 { _tmt605 = (*Stakey)(&n[0]) }
  if _tmt606 := C.MSK_getskc(self.ptr(),whichsol,_tmt605); _tmt606 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt606)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkcSlice(whichsol Soltype,first int32,last int32) (skc []Stakey,err error) {
  var _tmt607 *Stakey
  skc := make([]Stakey,(last - first))
  if len(skc) > 0 { _tmt607 = (*Stakey)(&n[0]) }
  if _tmt608 := C.MSK_getskcslice(self.ptr(),whichsol,first,last,_tmt607); _tmt608 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt608)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkn(whichsol Soltype) (skn []Stakey,err error) {
  var _tmt611 *Stakey
  var _tmt609 int32
  if _tmt610 := C.MSK_getnumcone(task.nativep,addr(_tmt609)); _tmt610 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt610)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt609)
  if len(skn) > 0 { _tmt611 = (*Stakey)(&n[0]) }
  if _tmt612 := C.MSK_getskn(self.ptr(),whichsol,_tmt611); _tmt612 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt612)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkx(whichsol Soltype) (skx []Stakey,err error) {
  var _tmt615 *Stakey
  var _tmt613 int32
  if _tmt614 := C.MSK_getnumvar(task.nativep,addr(_tmt613)); _tmt614 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt614)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt613)
  if len(skx) > 0 { _tmt615 = (*Stakey)(&n[0]) }
  if _tmt616 := C.MSK_getskx(self.ptr(),whichsol,_tmt615); _tmt616 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt616)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkxSlice(whichsol Soltype,first int32,last int32) (skx []Stakey,err error) {
  var _tmt617 *Stakey
  skx := make([]Stakey,(last - first))
  if len(skx) > 0 { _tmt617 = (*Stakey)(&n[0]) }
  if _tmt618 := C.MSK_getskxslice(self.ptr(),whichsol,first,last,_tmt617); _tmt618 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt618)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlc(whichsol Soltype) (slc []float64,err error) {
  var _tmt621 *float64
  var _tmt619 int32
  if _tmt620 := C.MSK_getnumcon(task.nativep,addr(_tmt619)); _tmt620 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt620)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt619)
  if len(slc) > 0 { _tmt621 = (*float64)(&n[0]) }
  if _tmt622 := C.MSK_getslc(self.ptr(),whichsol,_tmt621); _tmt622 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt622)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlcSlice(whichsol Soltype,first int32,last int32) (slc []float64,err error) {
  var _tmt623 *float64
  slc := make([]float64,(last - first))
  if len(slc) > 0 { _tmt623 = (*float64)(&n[0]) }
  if _tmt624 := C.MSK_getslcslice(self.ptr(),whichsol,first,last,_tmt623); _tmt624 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt624)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlx(whichsol Soltype) (slx []float64,err error) {
  var _tmt627 *float64
  var _tmt625 int32
  if _tmt626 := C.MSK_getnumvar(task.nativep,addr(_tmt625)); _tmt626 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt626)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt625)
  if len(slx) > 0 { _tmt627 = (*float64)(&n[0]) }
  if _tmt628 := C.MSK_getslx(self.ptr(),whichsol,_tmt627); _tmt628 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt628)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlxSlice(whichsol Soltype,first int32,last int32) (slx []float64,err error) {
  var _tmt629 *float64
  slx := make([]float64,(last - first))
  if len(slx) > 0 { _tmt629 = (*float64)(&n[0]) }
  if _tmt630 := C.MSK_getslxslice(self.ptr(),whichsol,first,last,_tmt629); _tmt630 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt630)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSnx(whichsol Soltype) (snx []float64,err error) {
  var _tmt633 *float64
  var _tmt631 int32
  if _tmt632 := C.MSK_getnumvar(task.nativep,addr(_tmt631)); _tmt632 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt632)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt631)
  if len(snx) > 0 { _tmt633 = (*float64)(&n[0]) }
  if _tmt634 := C.MSK_getsnx(self.ptr(),whichsol,_tmt633); _tmt634 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt634)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSnxSlice(whichsol Soltype,first int32,last int32) (snx []float64,err error) {
  var _tmt635 *float64
  snx := make([]float64,(last - first))
  if len(snx) > 0 { _tmt635 = (*float64)(&n[0]) }
  if _tmt636 := C.MSK_getsnxslice(self.ptr(),whichsol,first,last,_tmt635); _tmt636 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt636)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolSta(whichsol Soltype) (solutionsta Solsta,err error) {
  if _tmt637 := C.MSK_getsolsta(self.ptr(),whichsol,&solutionsta); _tmt637 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt637)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolution(whichsol Soltype) (problemsta Prosta,solutionsta Solsta,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,err error) {
  var _tmt640 *Stakey
  var _tmt638 int32
  if _tmt639 := C.MSK_getnumcon(task.nativep,addr(_tmt638)); _tmt639 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt639)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt638)
  if len(skc) > 0 { _tmt640 = (*Stakey)(&n[0]) }
  var _tmt643 *Stakey
  var _tmt641 int32
  if _tmt642 := C.MSK_getnumvar(task.nativep,addr(_tmt641)); _tmt642 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt642)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt641)
  if len(skx) > 0 { _tmt643 = (*Stakey)(&n[0]) }
  var _tmt646 *Stakey
  var _tmt644 int32
  if _tmt645 := C.MSK_getnumcone(task.nativep,addr(_tmt644)); _tmt645 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt645)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt644)
  if len(skn) > 0 { _tmt646 = (*Stakey)(&n[0]) }
  var _tmt649 *float64
  var _tmt647 int32
  if _tmt648 := C.MSK_getnumcon(task.nativep,addr(_tmt647)); _tmt648 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt648)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt647)
  if len(xc) > 0 { _tmt649 = (*float64)(&n[0]) }
  var _tmt652 *float64
  var _tmt650 int32
  if _tmt651 := C.MSK_getnumvar(task.nativep,addr(_tmt650)); _tmt651 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt651)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt650)
  if len(xx) > 0 { _tmt652 = (*float64)(&n[0]) }
  var _tmt655 *float64
  var _tmt653 int32
  if _tmt654 := C.MSK_getnumcon(task.nativep,addr(_tmt653)); _tmt654 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt654)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt653)
  if len(y) > 0 { _tmt655 = (*float64)(&n[0]) }
  var _tmt658 *float64
  var _tmt656 int32
  if _tmt657 := C.MSK_getnumcon(task.nativep,addr(_tmt656)); _tmt657 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt657)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt656)
  if len(slc) > 0 { _tmt658 = (*float64)(&n[0]) }
  var _tmt661 *float64
  var _tmt659 int32
  if _tmt660 := C.MSK_getnumcon(task.nativep,addr(_tmt659)); _tmt660 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt660)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt659)
  if len(suc) > 0 { _tmt661 = (*float64)(&n[0]) }
  var _tmt664 *float64
  var _tmt662 int32
  if _tmt663 := C.MSK_getnumvar(task.nativep,addr(_tmt662)); _tmt663 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt663)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt662)
  if len(slx) > 0 { _tmt664 = (*float64)(&n[0]) }
  var _tmt667 *float64
  var _tmt665 int32
  if _tmt666 := C.MSK_getnumvar(task.nativep,addr(_tmt665)); _tmt666 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt666)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt665)
  if len(sux) > 0 { _tmt667 = (*float64)(&n[0]) }
  var _tmt670 *float64
  var _tmt668 int32
  if _tmt669 := C.MSK_getnumvar(task.nativep,addr(_tmt668)); _tmt669 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt669)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt668)
  if len(snx) > 0 { _tmt670 = (*float64)(&n[0]) }
  if _tmt671 := C.MSK_getsolution(self.ptr(),whichsol,&problemsta,&solutionsta,_tmt640,_tmt643,_tmt646,_tmt649,_tmt652,_tmt655,_tmt658,_tmt661,_tmt664,_tmt667,_tmt670); _tmt671 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt671)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionInfo(whichsol Soltype) (pobj float64,pviolcon float64,pviolvar float64,pviolbarvar float64,pviolcone float64,pviolitg float64,dobj float64,dviolcon float64,dviolvar float64,dviolbarvar float64,dviolcone float64,err error) {
  if _tmt672 := C.MSK_getsolutioninfo(self.ptr(),whichsol,&pobj,&pviolcon,&pviolvar,&pviolbarvar,&pviolcone,&pviolitg,&dobj,&dviolcon,&dviolvar,&dviolbarvar,&dviolcone); _tmt672 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt672)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionInfoNew(whichsol Soltype) (pobj float64,pviolcon float64,pviolvar float64,pviolbarvar float64,pviolcone float64,pviolacc float64,pvioldjc float64,pviolitg float64,dobj float64,dviolcon float64,dviolvar float64,dviolbarvar float64,dviolcone float64,dviolacc float64,err error) {
  if _tmt673 := C.MSK_getsolutioninfonew(self.ptr(),whichsol,&pobj,&pviolcon,&pviolvar,&pviolbarvar,&pviolcone,&pviolacc,&pvioldjc,&pviolitg,&dobj,&dviolcon,&dviolvar,&dviolbarvar,&dviolcone,&dviolacc); _tmt673 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt673)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionNew(whichsol Soltype) (problemsta Prosta,solutionsta Solsta,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,doty []float64,err error) {
  var _tmt676 *Stakey
  var _tmt674 int32
  if _tmt675 := C.MSK_getnumcon(task.nativep,addr(_tmt674)); _tmt675 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt675)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt674)
  if len(skc) > 0 { _tmt676 = (*Stakey)(&n[0]) }
  var _tmt679 *Stakey
  var _tmt677 int32
  if _tmt678 := C.MSK_getnumvar(task.nativep,addr(_tmt677)); _tmt678 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt678)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt677)
  if len(skx) > 0 { _tmt679 = (*Stakey)(&n[0]) }
  var _tmt682 *Stakey
  var _tmt680 int32
  if _tmt681 := C.MSK_getnumcone(task.nativep,addr(_tmt680)); _tmt681 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt681)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt680)
  if len(skn) > 0 { _tmt682 = (*Stakey)(&n[0]) }
  var _tmt685 *float64
  var _tmt683 int32
  if _tmt684 := C.MSK_getnumcon(task.nativep,addr(_tmt683)); _tmt684 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt684)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt683)
  if len(xc) > 0 { _tmt685 = (*float64)(&n[0]) }
  var _tmt688 *float64
  var _tmt686 int32
  if _tmt687 := C.MSK_getnumvar(task.nativep,addr(_tmt686)); _tmt687 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt687)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt686)
  if len(xx) > 0 { _tmt688 = (*float64)(&n[0]) }
  var _tmt691 *float64
  var _tmt689 int32
  if _tmt690 := C.MSK_getnumcon(task.nativep,addr(_tmt689)); _tmt690 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt690)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt689)
  if len(y) > 0 { _tmt691 = (*float64)(&n[0]) }
  var _tmt694 *float64
  var _tmt692 int32
  if _tmt693 := C.MSK_getnumcon(task.nativep,addr(_tmt692)); _tmt693 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt693)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt692)
  if len(slc) > 0 { _tmt694 = (*float64)(&n[0]) }
  var _tmt697 *float64
  var _tmt695 int32
  if _tmt696 := C.MSK_getnumcon(task.nativep,addr(_tmt695)); _tmt696 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt696)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt695)
  if len(suc) > 0 { _tmt697 = (*float64)(&n[0]) }
  var _tmt700 *float64
  var _tmt698 int32
  if _tmt699 := C.MSK_getnumvar(task.nativep,addr(_tmt698)); _tmt699 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt699)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt698)
  if len(slx) > 0 { _tmt700 = (*float64)(&n[0]) }
  var _tmt703 *float64
  var _tmt701 int32
  if _tmt702 := C.MSK_getnumvar(task.nativep,addr(_tmt701)); _tmt702 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt702)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt701)
  if len(sux) > 0 { _tmt703 = (*float64)(&n[0]) }
  var _tmt706 *float64
  var _tmt704 int32
  if _tmt705 := C.MSK_getnumvar(task.nativep,addr(_tmt704)); _tmt705 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt705)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt704)
  if len(snx) > 0 { _tmt706 = (*float64)(&n[0]) }
  var _tmt709 *float64
  var _tmt707 int64
  if _tmt708 := C.MSK_getaccntot(task.nativep,addr(_tmt707)); _tmt708 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt708)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt707)
  if len(doty) > 0 { _tmt709 = (*float64)(&n[0]) }
  if _tmt710 := C.MSK_getsolutionnew(self.ptr(),whichsol,&problemsta,&solutionsta,_tmt676,_tmt679,_tmt682,_tmt685,_tmt688,_tmt691,_tmt694,_tmt697,_tmt700,_tmt703,_tmt706,_tmt709); _tmt710 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt710)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionSlice(whichsol Soltype,solitem Solitem,first int32,last int32) (values []float64,err error) {
  var _tmt711 *float64
  values := make([]float64,(last - first))
  if len(values) > 0 { _tmt711 = (*float64)(&n[0]) }
  if _tmt712 := C.MSK_getsolutionslice(self.ptr(),whichsol,solitem,first,last,_tmt711); _tmt712 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt712)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSparseSymMat(idx int64) (subi []int32,subj []int32,valij []float64,err error) {
  var _tmt713 int32
  var _tmt714 int64
  var _tmt715 symmattype
  if _tmt716 := C.MSK_getsymmatinfo(task.nativep,idx,addr(_tmt713),addr(_tmt714),addr(_tmt715)); _tmt716 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt716)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxlen int64 = _tmt714
  var _tmt717 *int32
  subi := make([]int32,maxlen)
  if len(subi) > 0 { _tmt717 = (*int32)(&n[0]) }
  var _tmt718 *int32
  subj := make([]int32,maxlen)
  if len(subj) > 0 { _tmt718 = (*int32)(&n[0]) }
  var _tmt719 *float64
  valij := make([]float64,maxlen)
  if len(valij) > 0 { _tmt719 = (*float64)(&n[0]) }
  if _tmt720 := C.MSK_getsparsesymmat(self.ptr(),idx,maxlen,_tmt717,_tmt718,_tmt719); _tmt720 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt720)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetStrParam(param Sparam) (len int32,parvalue string,err error) {
  var _tmt721 int32
  if _tmt722 := C.MSK_getstrparamlen(task.nativep,param,addr(_tmt721)); _tmt722 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt722)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxlen int32 = (1 + _tmt721)
  _tmt723 := make([]byte,maxlen)
  if _tmt724 := C.MSK_getstrparam(self.ptr(),param,maxlen,&len,C.CString(&tmpvar1[0])); _tmt724 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt724)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var parvalue string
  if p := strings.IndexByte(_tmt723,byte(0)); p < 0 {
    parvalue = string(_tmt723)
  } else {
    parvalue = string(_tmt723[:p])
  }
  return
}
func (self *Task) GetStrParamLen(param Sparam) (len int32,err error) {
  if _tmt725 := C.MSK_getstrparamlen(self.ptr(),param,&len); _tmt725 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt725)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSuc(whichsol Soltype) (suc []float64,err error) {
  var _tmt728 *float64
  var _tmt726 int32
  if _tmt727 := C.MSK_getnumcon(task.nativep,addr(_tmt726)); _tmt727 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt727)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt726)
  if len(suc) > 0 { _tmt728 = (*float64)(&n[0]) }
  if _tmt729 := C.MSK_getsuc(self.ptr(),whichsol,_tmt728); _tmt729 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt729)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSucSlice(whichsol Soltype,first int32,last int32) (suc []float64,err error) {
  var _tmt730 *float64
  suc := make([]float64,(last - first))
  if len(suc) > 0 { _tmt730 = (*float64)(&n[0]) }
  if _tmt731 := C.MSK_getsucslice(self.ptr(),whichsol,first,last,_tmt730); _tmt731 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt731)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSux(whichsol Soltype) (sux []float64,err error) {
  var _tmt734 *float64
  var _tmt732 int32
  if _tmt733 := C.MSK_getnumvar(task.nativep,addr(_tmt732)); _tmt733 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt733)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt732)
  if len(sux) > 0 { _tmt734 = (*float64)(&n[0]) }
  if _tmt735 := C.MSK_getsux(self.ptr(),whichsol,_tmt734); _tmt735 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt735)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSuxSlice(whichsol Soltype,first int32,last int32) (sux []float64,err error) {
  var _tmt736 *float64
  sux := make([]float64,(last - first))
  if len(sux) > 0 { _tmt736 = (*float64)(&n[0]) }
  if _tmt737 := C.MSK_getsuxslice(self.ptr(),whichsol,first,last,_tmt736); _tmt737 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt737)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSymMatInfo(idx int64) (dim int32,nz int64,mattype Symmattype,err error) {
  if _tmt738 := C.MSK_getsymmatinfo(self.ptr(),idx,&dim,&nz,&mattype); _tmt738 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt738)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetTaskName() (taskname string,err error) {
  var _tmt739 int32
  if _tmt740 := C.MSK_gettasknamelen(task.nativep,addr(_tmt739)); _tmt740 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt740)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizetaskname int32 = (1 + _tmt739)
  _tmt741 := make([]byte,sizetaskname)
  if _tmt742 := C.MSK_gettaskname(self.ptr(),sizetaskname,C.CString(&tmpvar1[0])); _tmt742 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt742)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var taskname string
  if p := strings.IndexByte(_tmt741,byte(0)); p < 0 {
    taskname = string(_tmt741)
  } else {
    taskname = string(_tmt741[:p])
  }
  return
}
func (self *Task) GetTaskNameLen() (len int32,err error) {
  if _tmt743 := C.MSK_gettasknamelen(self.ptr(),&len); _tmt743 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt743)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarBound(i int32) (bk Boundkey,bl float64,bu float64,err error) {
  if _tmt744 := C.MSK_getvarbound(self.ptr(),i,&bk,&bl,&bu); _tmt744 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt744)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarBoundSlice(first int32,last int32) (bk []Boundkey,bl []float64,bu []float64,err error) {
  var _tmt745 *Boundkey
  bk := make([]Boundkey,(last - first))
  if len(bk) > 0 { _tmt745 = (*Boundkey)(&n[0]) }
  var _tmt746 *float64
  bl := make([]float64,(last - first))
  if len(bl) > 0 { _tmt746 = (*float64)(&n[0]) }
  var _tmt747 *float64
  bu := make([]float64,(last - first))
  if len(bu) > 0 { _tmt747 = (*float64)(&n[0]) }
  if _tmt748 := C.MSK_getvarboundslice(self.ptr(),first,last,_tmt745,_tmt746,_tmt747); _tmt748 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt748)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarName(j int32) (name string,err error) {
  var _tmt749 int32
  if _tmt750 := C.MSK_getvarnamelen(task.nativep,j,addr(_tmt749)); _tmt750 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt750)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt749)
  _tmt751 := make([]byte,sizename)
  if _tmt752 := C.MSK_getvarname(self.ptr(),j,sizename,C.CString(&tmpvar1[0])); _tmt752 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt752)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt751,byte(0)); p < 0 {
    name = string(_tmt751)
  } else {
    name = string(_tmt751[:p])
  }
  return
}
func (self *Task) GetVarNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt753 := C.CString(somename)
  if _tmt754 := C.MSK_getvarnameindex(self.ptr(),_tmt753,&asgn,&index); _tmt754 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt754)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarNameLen(i int32) (len int32,err error) {
  if _tmt755 := C.MSK_getvarnamelen(self.ptr(),i,&len); _tmt755 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt755)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarType(j int32) (vartype Variabletype,err error) {
  if _tmt756 := C.MSK_getvartype(self.ptr(),j,&vartype); _tmt756 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt756)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarTypeList(subj []int32) (vartype []Variabletype,err error) {
  _tmt757 := len(subj)
  var num int32 = int32(_tmt757)
  var _tmt758 *int32
  if subj != nil { _tmt758 = (*C.MSKint32t)(&subj[0]) }
  var _tmt759 *Variabletype
  vartype := make([]Variabletype,num)
  if len(vartype) > 0 { _tmt759 = (*Variabletype)(&n[0]) }
  if _tmt760 := C.MSK_getvartypelist(self.ptr(),num,_tmt758,_tmt759); _tmt760 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt760)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXc(whichsol Soltype) (xc []float64,err error) {
  var _tmt763 *float64
  var _tmt761 int32
  if _tmt762 := C.MSK_getnumcon(task.nativep,addr(_tmt761)); _tmt762 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt762)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt761)
  if len(xc) > 0 { _tmt763 = (*float64)(&n[0]) }
  if _tmt764 := C.MSK_getxc(self.ptr(),whichsol,_tmt763); _tmt764 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt764)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXcSlice(whichsol Soltype,first int32,last int32) (xc []float64,err error) {
  var _tmt765 *float64
  xc := make([]float64,(last - first))
  if len(xc) > 0 { _tmt765 = (*float64)(&n[0]) }
  if _tmt766 := C.MSK_getxcslice(self.ptr(),whichsol,first,last,_tmt765); _tmt766 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt766)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXx(whichsol Soltype) (xx []float64,err error) {
  var _tmt769 *float64
  var _tmt767 int32
  if _tmt768 := C.MSK_getnumvar(task.nativep,addr(_tmt767)); _tmt768 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt768)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt767)
  if len(xx) > 0 { _tmt769 = (*float64)(&n[0]) }
  if _tmt770 := C.MSK_getxx(self.ptr(),whichsol,_tmt769); _tmt770 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt770)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXxSlice(whichsol Soltype,first int32,last int32) (xx []float64,err error) {
  var _tmt771 *float64
  xx := make([]float64,(last - first))
  if len(xx) > 0 { _tmt771 = (*float64)(&n[0]) }
  if _tmt772 := C.MSK_getxxslice(self.ptr(),whichsol,first,last,_tmt771); _tmt772 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt772)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetY(whichsol Soltype) (y []float64,err error) {
  var _tmt775 *float64
  var _tmt773 int32
  if _tmt774 := C.MSK_getnumcon(task.nativep,addr(_tmt773)); _tmt774 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt774)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt773)
  if len(y) > 0 { _tmt775 = (*float64)(&n[0]) }
  if _tmt776 := C.MSK_gety(self.ptr(),whichsol,_tmt775); _tmt776 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt776)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetYSlice(whichsol Soltype,first int32,last int32) (y []float64,err error) {
  var _tmt777 *float64
  y := make([]float64,(last - first))
  if len(y) > 0 { _tmt777 = (*float64)(&n[0]) }
  if _tmt778 := C.MSK_getyslice(self.ptr(),whichsol,first,last,_tmt777); _tmt778 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt778)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InfeasibilityReport(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt779 := C.MSK_infeasibilityreport(self.ptr(),whichstream,whichsol); _tmt779 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt779)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InitBasisSolve() (basis []int32,err error) {
  var _tmt782 *int32
  var _tmt780 int32
  if _tmt781 := C.MSK_getnumcon(task.nativep,addr(_tmt780)); _tmt781 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt781)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  basis := make([]int32,_tmt780)
  if len(basis) > 0 { _tmt782 = (*int32)(&n[0]) }
  if _tmt783 := C.MSK_initbasissolve(self.ptr(),_tmt782); _tmt783 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt783)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InputData(maxnumcon int32,maxnumvar int32,c []float64,cfix float64,aptrb []int64,aptre []int64,asub []int32,aval []float64,bkc []Boundkey,blc []float64,buc []float64,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  _tmt784 := len(buc)
  if _tmt784 < bkc { _tmt784 = lof["name"] }
  if _tmt784 < blc { _tmt784 = lof["name"] }
  var numcon int32 = int32(_tmt784)
  _tmt785 := len(aptrb)
  if _tmt785 < blx { _tmt785 = lof["name"] }
  if _tmt785 < bux { _tmt785 = lof["name"] }
  if _tmt785 < bkx { _tmt785 = lof["name"] }
  if _tmt785 < aptre { _tmt785 = lof["name"] }
  if _tmt785 < c { _tmt785 = lof["name"] }
  var numvar int32 = int32(_tmt785)
  var _tmt786 *float64
  if c != nil { _tmt786 = (*C.MSKint32t)(&c[0]) }
  var _tmt787 *int64
  if aptrb != nil { _tmt787 = (*C.MSKint32t)(&aptrb[0]) }
  var _tmt788 *int64
  if aptre != nil { _tmt788 = (*C.MSKint32t)(&aptre[0]) }
  var _tmt789 *int32
  if asub != nil { _tmt789 = (*C.MSKint32t)(&asub[0]) }
  var _tmt790 *float64
  if aval != nil { _tmt790 = (*C.MSKint32t)(&aval[0]) }
  var _tmt791 *Boundkey
  if bkc != nil { _tmt791 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt792 *float64
  if blc != nil { _tmt792 = (*C.MSKint32t)(&blc[0]) }
  var _tmt793 *float64
  if buc != nil { _tmt793 = (*C.MSKint32t)(&buc[0]) }
  var _tmt794 *Boundkey
  if bkx != nil { _tmt794 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt795 *float64
  if blx != nil { _tmt795 = (*C.MSKint32t)(&blx[0]) }
  var _tmt796 *float64
  if bux != nil { _tmt796 = (*C.MSKint32t)(&bux[0]) }
  if _tmt797 := C.MSK_inputdata64(self.ptr(),maxnumcon,maxnumvar,numcon,numvar,_tmt786,cfix,_tmt787,_tmt788,_tmt789,_tmt790,_tmt791,_tmt792,_tmt793,_tmt794,_tmt795,_tmt796); _tmt797 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt797)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsDouParName(parname string) (param Dparam,err error) {
  _tmt798 := C.CString(parname)
  if _tmt799 := C.MSK_isdouparname(self.ptr(),_tmt798,&param); _tmt799 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt799)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsIntParName(parname string) (param Iparam,err error) {
  _tmt800 := C.CString(parname)
  if _tmt801 := C.MSK_isintparname(self.ptr(),_tmt800,&param); _tmt801 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt801)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsStrParName(parname string) (param Sparam,err error) {
  _tmt802 := C.CString(parname)
  if _tmt803 := C.MSK_isstrparname(self.ptr(),_tmt802,&param); _tmt803 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt803)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) LinkFileToStream(whichstream Streamtype,filename string,append int32) (err error) {
  _tmt804 := C.CString(filename)
  if _tmt805 := C.MSK_linkfiletotaskstream(self.ptr(),whichstream,_tmt804,append); _tmt805 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt805)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) OneSolutionSummary(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt806 := C.MSK_onesolutionsummary(self.ptr(),whichstream,whichsol); _tmt806 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt806)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) OptimizerSummary(whichstream Streamtype) (err error) {
  if _tmt807 := C.MSK_optimizersummary(self.ptr(),whichstream); _tmt807 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt807)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) Optimize() (trmcode Rescode,err error) {
  if _tmt808 := C.MSK_optimizetrm(self.ptr(),&trmcode); _tmt808 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt808)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PrimalRepair(wlc []float64,wuc []float64,wlx []float64,wux []float64) (err error) {
  var _tmt811 *float64
  var _tmt809 int32
  if _tmt810 := C.MSK_getnumcon(task.nativep,addr(_tmt809)); _tmt810 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt810)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wlc) < _tmt809 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wlc"}
    return
  }
  if wlc != nil { _tmt811 = (*C.MSKint32t)(&wlc[0]) }
  var _tmt814 *float64
  var _tmt812 int32
  if _tmt813 := C.MSK_getnumcon(task.nativep,addr(_tmt812)); _tmt813 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt813)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wuc) < _tmt812 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wuc"}
    return
  }
  if wuc != nil { _tmt814 = (*C.MSKint32t)(&wuc[0]) }
  var _tmt817 *float64
  var _tmt815 int32
  if _tmt816 := C.MSK_getnumvar(task.nativep,addr(_tmt815)); _tmt816 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt816)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wlx) < _tmt815 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wlx"}
    return
  }
  if wlx != nil { _tmt817 = (*C.MSKint32t)(&wlx[0]) }
  var _tmt820 *float64
  var _tmt818 int32
  if _tmt819 := C.MSK_getnumvar(task.nativep,addr(_tmt818)); _tmt819 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt819)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wux) < _tmt818 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wux"}
    return
  }
  if wux != nil { _tmt820 = (*C.MSKint32t)(&wux[0]) }
  if _tmt821 := C.MSK_primalrepair(self.ptr(),_tmt811,_tmt814,_tmt817,_tmt820); _tmt821 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt821)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PrimalSensitivity(subi []int32,marki []Mark,subj []int32,markj []Mark) (leftpricei []float64,rightpricei []float64,leftrangei []float64,rightrangei []float64,leftpricej []float64,rightpricej []float64,leftrangej []float64,rightrangej []float64,err error) {
  _tmt822 := len(subi)
  if _tmt822 < marki { _tmt822 = lof["name"] }
  var numi int32 = int32(_tmt822)
  var _tmt823 *int32
  if subi != nil { _tmt823 = (*C.MSKint32t)(&subi[0]) }
  var _tmt824 *Mark
  if marki != nil { _tmt824 = (*C.MSKint32t)(&marki[0]) }
  _tmt825 := len(markj)
  if _tmt825 < subj { _tmt825 = lof["name"] }
  var numj int32 = int32(_tmt825)
  var _tmt826 *int32
  if subj != nil { _tmt826 = (*C.MSKint32t)(&subj[0]) }
  var _tmt827 *Mark
  if markj != nil { _tmt827 = (*C.MSKint32t)(&markj[0]) }
  var _tmt828 *float64
  leftpricei := make([]float64,numi)
  if len(leftpricei) > 0 { _tmt828 = (*float64)(&n[0]) }
  var _tmt829 *float64
  rightpricei := make([]float64,numi)
  if len(rightpricei) > 0 { _tmt829 = (*float64)(&n[0]) }
  var _tmt830 *float64
  leftrangei := make([]float64,numi)
  if len(leftrangei) > 0 { _tmt830 = (*float64)(&n[0]) }
  var _tmt831 *float64
  rightrangei := make([]float64,numi)
  if len(rightrangei) > 0 { _tmt831 = (*float64)(&n[0]) }
  var _tmt832 *float64
  leftpricej := make([]float64,numj)
  if len(leftpricej) > 0 { _tmt832 = (*float64)(&n[0]) }
  var _tmt833 *float64
  rightpricej := make([]float64,numj)
  if len(rightpricej) > 0 { _tmt833 = (*float64)(&n[0]) }
  var _tmt834 *float64
  leftrangej := make([]float64,numj)
  if len(leftrangej) > 0 { _tmt834 = (*float64)(&n[0]) }
  var _tmt835 *float64
  rightrangej := make([]float64,numj)
  if len(rightrangej) > 0 { _tmt835 = (*float64)(&n[0]) }
  if _tmt836 := C.MSK_primalsensitivity(self.ptr(),numi,_tmt823,_tmt824,numj,_tmt826,_tmt827,_tmt828,_tmt829,_tmt830,_tmt831,_tmt832,_tmt833,_tmt834,_tmt835); _tmt836 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt836)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ProbTypeToStr(probtype Problemtype) (str string,err error) {
  _tmt837 := make([]byte,max_str_len)
  if _tmt838 := C.MSK_probtypetostr(self.ptr(),probtype,C.CString(&tmpvar1[0])); _tmt838 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt838)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var str string
  if p := strings.IndexByte(_tmt837,byte(0)); p < 0 {
    str = string(_tmt837)
  } else {
    str = string(_tmt837[:p])
  }
  return
}
func (self *Task) ProStaToStr(problemsta Prosta) (str string,err error) {
  _tmt839 := make([]byte,max_str_len)
  if _tmt840 := C.MSK_prostatostr(self.ptr(),problemsta,C.CString(&tmpvar1[0])); _tmt840 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt840)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var str string
  if p := strings.IndexByte(_tmt839,byte(0)); p < 0 {
    str = string(_tmt839)
  } else {
    str = string(_tmt839[:p])
  }
  return
}
func (self *Task) PutAcc(accidx int64,domidx int64,afeidxlist []int64,b []float64) (err error) {
  _tmt841 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt841)
  var _tmt842 *int64
  if afeidxlist != nil { _tmt842 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt843 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutAcc",arg:"b"}
    return
  }
  if b != nil { _tmt843 = (*C.MSKint32t)(&b[0]) }
  if _tmt844 := C.MSK_putacc(self.ptr(),accidx,domidx,numafeidx,_tmt842,_tmt843); _tmt844 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt844)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccB(accidx int64,b []float64) (err error) {
  _tmt845 := len(b)
  var lengthb int64 = int32(_tmt845)
  var _tmt846 *float64
  if b != nil { _tmt846 = (*C.MSKint32t)(&b[0]) }
  if _tmt847 := C.MSK_putaccb(self.ptr(),accidx,lengthb,_tmt846); _tmt847 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt847)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccBJ(accidx int64,j int64,bj float64) (err error) {
  if _tmt848 := C.MSK_putaccbj(self.ptr(),accidx,j,bj); _tmt848 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt848)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccDotY(whichsol Soltype,accidx int64) (doty []float64,err error) {
  var _tmt851 *float64
  var _tmt849 int64
  if _tmt850 := C.MSK_getaccn(task.nativep,accidx,addr(_tmt849)); _tmt850 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt850)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt849)
  if len(doty) > 0 { _tmt851 = (*float64)(&n[0]) }
  if _tmt852 := C.MSK_putaccdoty(self.ptr(),whichsol,accidx,_tmt851); _tmt852 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt852)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccList(accidxs []int64,domidxs []int64,afeidxlist []int64,b []float64) (err error) {
  _tmt853 := len(accidxs)
  if _tmt853 < domidxs { _tmt853 = lof["name"] }
  var numaccs int64 = int32(_tmt853)
  var _tmt854 *int64
  if accidxs != nil { _tmt854 = (*C.MSKint32t)(&accidxs[0]) }
  var _tmt855 *int64
  if domidxs != nil { _tmt855 = (*C.MSKint32t)(&domidxs[0]) }
  _tmt856 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt856)
  var _tmt857 *int64
  if afeidxlist != nil { _tmt857 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt858 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutAccList",arg:"b"}
    return
  }
  if b != nil { _tmt858 = (*C.MSKint32t)(&b[0]) }
  if _tmt859 := C.MSK_putacclist(self.ptr(),numaccs,_tmt854,_tmt855,numafeidx,_tmt857,_tmt858); _tmt859 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt859)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccName(accidx int64,name string) (err error) {
  _tmt860 := C.CString(name)
  if _tmt861 := C.MSK_putaccname(self.ptr(),accidx,_tmt860); _tmt861 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt861)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutACol(j int32,subj []int32,valj []float64) (err error) {
  _tmt862 := len(valj)
  if _tmt862 < subj { _tmt862 = lof["name"] }
  var nzj int32 = int32(_tmt862)
  var _tmt863 *int32
  if subj != nil { _tmt863 = (*C.MSKint32t)(&subj[0]) }
  var _tmt864 *float64
  if valj != nil { _tmt864 = (*C.MSKint32t)(&valj[0]) }
  if _tmt865 := C.MSK_putacol(self.ptr(),j,nzj,_tmt863,_tmt864); _tmt865 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt865)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAColList(sub []int32,ptrb []int32,ptre []int32,asub []int32,aval []float64) (err error) {
  _tmt866 := len(ptrb)
  if _tmt866 < ptre { _tmt866 = lof["name"] }
  if _tmt866 < sub { _tmt866 = lof["name"] }
  var num int32 = int32(_tmt866)
  var _tmt867 *int32
  if sub != nil { _tmt867 = (*C.MSKint32t)(&sub[0]) }
  var _tmt868 *int32
  if ptrb != nil { _tmt868 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt869 *int32
  if ptre != nil { _tmt869 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt870 *int32
  if asub != nil { _tmt870 = (*C.MSKint32t)(&asub[0]) }
  var _tmt871 *float64
  if aval != nil { _tmt871 = (*C.MSKint32t)(&aval[0]) }
  if _tmt872 := C.MSK_putacollist(self.ptr(),num,_tmt867,_tmt868,_tmt869,_tmt870,_tmt871); _tmt872 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt872)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAColSlice(first int32,last int32,ptrb []int64,ptre []int64,asub []int32,aval []float64) (err error) {
  var _tmt873 *int64
  if ptrb != nil { _tmt873 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt874 *int64
  if ptre != nil { _tmt874 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt875 *int32
  if asub != nil { _tmt875 = (*C.MSKint32t)(&asub[0]) }
  var _tmt876 *float64
  if aval != nil { _tmt876 = (*C.MSKint32t)(&aval[0]) }
  if _tmt877 := C.MSK_putacolslice64(self.ptr(),first,last,_tmt873,_tmt874,_tmt875,_tmt876); _tmt877 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt877)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfBlockTriplet(afeidx []int64,barvaridx []int32,subk []int32,subl []int32,valkl []float64) (err error) {
  _tmt878 := len(subl)
  if _tmt878 < subk { _tmt878 = lof["name"] }
  if _tmt878 < barvaridx { _tmt878 = lof["name"] }
  if _tmt878 < valkl { _tmt878 = lof["name"] }
  if _tmt878 < afeidx { _tmt878 = lof["name"] }
  var numtrip int64 = int32(_tmt878)
  var _tmt879 *int64
  if len(afeidx) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"afeidx"}
    return
  }
  if afeidx != nil { _tmt879 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt880 *int32
  if len(barvaridx) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"barvaridx"}
    return
  }
  if barvaridx != nil { _tmt880 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt881 *int32
  if len(subk) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt881 = (*C.MSKint32t)(&subk[0]) }
  var _tmt882 *int32
  if len(subl) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt882 = (*C.MSKint32t)(&subl[0]) }
  var _tmt883 *float64
  if len(valkl) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"valkl"}
    return
  }
  if valkl != nil { _tmt883 = (*C.MSKint32t)(&valkl[0]) }
  if _tmt884 := C.MSK_putafebarfblocktriplet(self.ptr(),numtrip,_tmt879,_tmt880,_tmt881,_tmt882,_tmt883); _tmt884 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt884)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfEntry(afeidx int64,barvaridx int32,termidx []int64,termweight []float64) (err error) {
  _tmt885 := len(termidx)
  if _tmt885 < termweight { _tmt885 = lof["name"] }
  var numterm int64 = int32(_tmt885)
  var _tmt886 *int64
  if termidx != nil { _tmt886 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt887 *float64
  if termweight != nil { _tmt887 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt888 := C.MSK_putafebarfentry(self.ptr(),afeidx,barvaridx,numterm,_tmt886,_tmt887); _tmt888 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt888)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfEntryList(afeidx []int64,barvaridx []int32,numterm []int64,ptrterm []int64,termidx []int64,termweight []float64) (err error) {
  _tmt889 := len(barvaridx)
  if _tmt889 < ptrterm { _tmt889 = lof["name"] }
  if _tmt889 < numterm { _tmt889 = lof["name"] }
  if _tmt889 < afeidx { _tmt889 = lof["name"] }
  var numafeidx int64 = int32(_tmt889)
  var _tmt890 *int64
  if afeidx != nil { _tmt890 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt891 *int32
  if barvaridx != nil { _tmt891 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt892 *int64
  if numterm != nil { _tmt892 = (*C.MSKint32t)(&numterm[0]) }
  var _tmt893 *int64
  if ptrterm != nil { _tmt893 = (*C.MSKint32t)(&ptrterm[0]) }
  _tmt894 := len(termidx)
  if _tmt894 < termweight { _tmt894 = lof["name"] }
  var lenterm int64 = int32(_tmt894)
  var _tmt895 *int64
  if termidx != nil { _tmt895 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt896 *float64
  if termweight != nil { _tmt896 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt897 := C.MSK_putafebarfentrylist(self.ptr(),numafeidx,_tmt890,_tmt891,_tmt892,_tmt893,lenterm,_tmt895,_tmt896); _tmt897 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt897)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfRow(afeidx int64,barvaridx []int32,numterm []int64,ptrterm []int64,termidx []int64,termweight []float64) (err error) {
  _tmt898 := len(barvaridx)
  if _tmt898 < ptrterm { _tmt898 = lof["name"] }
  if _tmt898 < numterm { _tmt898 = lof["name"] }
  var numentr int32 = int32(_tmt898)
  var _tmt899 *int32
  if barvaridx != nil { _tmt899 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt900 *int64
  if numterm != nil { _tmt900 = (*C.MSKint32t)(&numterm[0]) }
  var _tmt901 *int64
  if ptrterm != nil { _tmt901 = (*C.MSKint32t)(&ptrterm[0]) }
  _tmt902 := len(termidx)
  if _tmt902 < termweight { _tmt902 = lof["name"] }
  var lenterm int64 = int32(_tmt902)
  var _tmt903 *int64
  if termidx != nil { _tmt903 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt904 *float64
  if termweight != nil { _tmt904 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt905 := C.MSK_putafebarfrow(self.ptr(),afeidx,numentr,_tmt899,_tmt900,_tmt901,lenterm,_tmt903,_tmt904); _tmt905 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt905)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFCol(varidx int32,afeidx []int64,val []float64) (err error) {
  _tmt906 := len(val)
  if _tmt906 < afeidx { _tmt906 = lof["name"] }
  var numnz int64 = int32(_tmt906)
  var _tmt907 *int64
  if afeidx != nil { _tmt907 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt908 *float64
  if val != nil { _tmt908 = (*C.MSKint32t)(&val[0]) }
  if _tmt909 := C.MSK_putafefcol(self.ptr(),varidx,numnz,_tmt907,_tmt908); _tmt909 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt909)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFEntry(afeidx int64,varidx int32,value float64) (err error) {
  if _tmt910 := C.MSK_putafefentry(self.ptr(),afeidx,varidx,value); _tmt910 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt910)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFEntryList(afeidx []int64,varidx []int32,val []float64) (err error) {
  _tmt911 := len(val)
  if _tmt911 < varidx { _tmt911 = lof["name"] }
  if _tmt911 < afeidx { _tmt911 = lof["name"] }
  var numentr int64 = int32(_tmt911)
  var _tmt912 *int64
  if afeidx != nil { _tmt912 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt913 *int32
  if varidx != nil { _tmt913 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt914 *float64
  if val != nil { _tmt914 = (*C.MSKint32t)(&val[0]) }
  if _tmt915 := C.MSK_putafefentrylist(self.ptr(),numentr,_tmt912,_tmt913,_tmt914); _tmt915 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt915)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFRow(afeidx int64,varidx []int32,val []float64) (err error) {
  _tmt916 := len(varidx)
  if _tmt916 < val { _tmt916 = lof["name"] }
  var numnz int32 = int32(_tmt916)
  var _tmt917 *int32
  if varidx != nil { _tmt917 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt918 *float64
  if val != nil { _tmt918 = (*C.MSKint32t)(&val[0]) }
  if _tmt919 := C.MSK_putafefrow(self.ptr(),afeidx,numnz,_tmt917,_tmt918); _tmt919 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt919)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFRowList(afeidx []int64,numnzrow []int32,ptrrow []int64,varidx []int32,val []float64) (err error) {
  _tmt920 := len(ptrrow)
  if _tmt920 < numnzrow { _tmt920 = lof["name"] }
  if _tmt920 < afeidx { _tmt920 = lof["name"] }
  var numafeidx int64 = int32(_tmt920)
  var _tmt921 *int64
  if afeidx != nil { _tmt921 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt922 *int32
  if numnzrow != nil { _tmt922 = (*C.MSKint32t)(&numnzrow[0]) }
  var _tmt923 *int64
  if ptrrow != nil { _tmt923 = (*C.MSKint32t)(&ptrrow[0]) }
  _tmt924 := len(varidx)
  if _tmt924 < val { _tmt924 = lof["name"] }
  var lenidxval int64 = int32(_tmt924)
  var _tmt925 *int32
  if varidx != nil { _tmt925 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt926 *float64
  if val != nil { _tmt926 = (*C.MSKint32t)(&val[0]) }
  if _tmt927 := C.MSK_putafefrowlist(self.ptr(),numafeidx,_tmt921,_tmt922,_tmt923,lenidxval,_tmt925,_tmt926); _tmt927 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt927)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeG(afeidx int64,g float64) (err error) {
  if _tmt928 := C.MSK_putafeg(self.ptr(),afeidx,g); _tmt928 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt928)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeGList(afeidx []int64,g []float64) (err error) {
  _tmt929 := len(g)
  if _tmt929 < afeidx { _tmt929 = lof["name"] }
  var numafeidx int64 = int32(_tmt929)
  var _tmt930 *int64
  if afeidx != nil { _tmt930 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt931 *float64
  if g != nil { _tmt931 = (*C.MSKint32t)(&g[0]) }
  if _tmt932 := C.MSK_putafeglist(self.ptr(),numafeidx,_tmt930,_tmt931); _tmt932 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt932)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeGSlice(first int64,last int64,slice []float64) (err error) {
  var _tmt933 *float64
  if len(slice) < (last - first) {
    err = &ArrayLengthError{fun:"PutAfeGSlice",arg:"slice"}
    return
  }
  if slice != nil { _tmt933 = (*C.MSKint32t)(&slice[0]) }
  if _tmt934 := C.MSK_putafegslice(self.ptr(),first,last,_tmt933); _tmt934 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt934)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAij(i int32,j int32,aij float64) (err error) {
  if _tmt935 := C.MSK_putaij(self.ptr(),i,j,aij); _tmt935 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt935)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAijList(subi []int32,subj []int32,valij []float64) (err error) {
  _tmt936 := len(subi)
  if _tmt936 < valij { _tmt936 = lof["name"] }
  if _tmt936 < subj { _tmt936 = lof["name"] }
  var num int64 = int32(_tmt936)
  var _tmt937 *int32
  if subi != nil { _tmt937 = (*C.MSKint32t)(&subi[0]) }
  var _tmt938 *int32
  if subj != nil { _tmt938 = (*C.MSKint32t)(&subj[0]) }
  var _tmt939 *float64
  if valij != nil { _tmt939 = (*C.MSKint32t)(&valij[0]) }
  if _tmt940 := C.MSK_putaijlist64(self.ptr(),num,_tmt937,_tmt938,_tmt939); _tmt940 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt940)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutARow(i int32,subi []int32,vali []float64) (err error) {
  _tmt941 := len(vali)
  if _tmt941 < subi { _tmt941 = lof["name"] }
  var nzi int32 = int32(_tmt941)
  var _tmt942 *int32
  if subi != nil { _tmt942 = (*C.MSKint32t)(&subi[0]) }
  var _tmt943 *float64
  if vali != nil { _tmt943 = (*C.MSKint32t)(&vali[0]) }
  if _tmt944 := C.MSK_putarow(self.ptr(),i,nzi,_tmt942,_tmt943); _tmt944 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt944)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutARowList(sub []int32,ptrb []int64,ptre []int64,asub []int32,aval []float64) (err error) {
  _tmt945 := len(ptrb)
  if _tmt945 < ptre { _tmt945 = lof["name"] }
  if _tmt945 < sub { _tmt945 = lof["name"] }
  var num int32 = int32(_tmt945)
  var _tmt946 *int32
  if sub != nil { _tmt946 = (*C.MSKint32t)(&sub[0]) }
  var _tmt947 *int64
  if ptrb != nil { _tmt947 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt948 *int64
  if ptre != nil { _tmt948 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt949 *int32
  if asub != nil { _tmt949 = (*C.MSKint32t)(&asub[0]) }
  var _tmt950 *float64
  if aval != nil { _tmt950 = (*C.MSKint32t)(&aval[0]) }
  if _tmt951 := C.MSK_putarowlist64(self.ptr(),num,_tmt946,_tmt947,_tmt948,_tmt949,_tmt950); _tmt951 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt951)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutARowSlice(first int32,last int32,ptrb []int64,ptre []int64,asub []int32,aval []float64) (err error) {
  var _tmt952 *int64
  if len(ptrb) < (last - first) {
    err = &ArrayLengthError{fun:"PutARowSlice",arg:"ptrb"}
    return
  }
  if ptrb != nil { _tmt952 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt953 *int64
  if len(ptre) < (last - first) {
    err = &ArrayLengthError{fun:"PutARowSlice",arg:"ptre"}
    return
  }
  if ptre != nil { _tmt953 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt954 *int32
  if asub != nil { _tmt954 = (*C.MSKint32t)(&asub[0]) }
  var _tmt955 *float64
  if aval != nil { _tmt955 = (*C.MSKint32t)(&aval[0]) }
  if _tmt956 := C.MSK_putarowslice64(self.ptr(),first,last,_tmt952,_tmt953,_tmt954,_tmt955); _tmt956 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt956)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutATruncateTol(tolzero float64) (err error) {
  if _tmt957 := C.MSK_putatruncatetol(self.ptr(),tolzero); _tmt957 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt957)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraBlockTriplet(subi []int32,subj []int32,subk []int32,subl []int32,valijkl []float64) (err error) {
  _tmt958 := len(subl)
  if _tmt958 < valijkl { _tmt958 = lof["name"] }
  if _tmt958 < subk { _tmt958 = lof["name"] }
  if _tmt958 < subj { _tmt958 = lof["name"] }
  var num int64 = int32(_tmt958)
  var _tmt959 *int32
  if len(subi) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subi"}
    return
  }
  if subi != nil { _tmt959 = (*C.MSKint32t)(&subi[0]) }
  var _tmt960 *int32
  if len(subj) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subj"}
    return
  }
  if subj != nil { _tmt960 = (*C.MSKint32t)(&subj[0]) }
  var _tmt961 *int32
  if len(subk) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt961 = (*C.MSKint32t)(&subk[0]) }
  var _tmt962 *int32
  if len(subl) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt962 = (*C.MSKint32t)(&subl[0]) }
  var _tmt963 *float64
  if len(valijkl) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"valijkl"}
    return
  }
  if valijkl != nil { _tmt963 = (*C.MSKint32t)(&valijkl[0]) }
  if _tmt964 := C.MSK_putbarablocktriplet(self.ptr(),num,_tmt959,_tmt960,_tmt961,_tmt962,_tmt963); _tmt964 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt964)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraIj(i int32,j int32,sub []int64,weights []float64) (err error) {
  _tmt965 := len(weights)
  if _tmt965 < sub { _tmt965 = lof["name"] }
  var num int64 = int32(_tmt965)
  var _tmt966 *int64
  if sub != nil { _tmt966 = (*C.MSKint32t)(&sub[0]) }
  var _tmt967 *float64
  if weights != nil { _tmt967 = (*C.MSKint32t)(&weights[0]) }
  if _tmt968 := C.MSK_putbaraij(self.ptr(),i,j,num,_tmt966,_tmt967); _tmt968 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt968)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraIjList(subi []int32,subj []int32,alphaptrb []int64,alphaptre []int64,matidx []int64,weights []float64) (err error) {
  _tmt969 := len(alphaptrb)
  if _tmt969 < subi { _tmt969 = lof["name"] }
  if _tmt969 < alphaptre { _tmt969 = lof["name"] }
  if _tmt969 < subj { _tmt969 = lof["name"] }
  var num int32 = int32(_tmt969)
  var _tmt970 *int32
  if subi != nil { _tmt970 = (*C.MSKint32t)(&subi[0]) }
  var _tmt971 *int32
  if subj != nil { _tmt971 = (*C.MSKint32t)(&subj[0]) }
  var _tmt972 *int64
  if alphaptrb != nil { _tmt972 = (*C.MSKint32t)(&alphaptrb[0]) }
  var _tmt973 *int64
  if alphaptre != nil { _tmt973 = (*C.MSKint32t)(&alphaptre[0]) }
  var _tmt974 *int64
  if matidx != nil { _tmt974 = (*C.MSKint32t)(&matidx[0]) }
  var _tmt975 *float64
  if weights != nil { _tmt975 = (*C.MSKint32t)(&weights[0]) }
  if _tmt976 := C.MSK_putbaraijlist(self.ptr(),num,_tmt970,_tmt971,_tmt972,_tmt973,_tmt974,_tmt975); _tmt976 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt976)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraRowList(subi []int32,ptrb []int64,ptre []int64,subj []int32,nummat []int64,matidx []int64,weights []float64) (err error) {
  _tmt977 := len(ptrb)
  if _tmt977 < ptre { _tmt977 = lof["name"] }
  if _tmt977 < subi { _tmt977 = lof["name"] }
  var num int32 = int32(_tmt977)
  var _tmt978 *int32
  if subi != nil { _tmt978 = (*C.MSKint32t)(&subi[0]) }
  var _tmt979 *int64
  if ptrb != nil { _tmt979 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt980 *int64
  if ptre != nil { _tmt980 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt981 *int32
  if subj != nil { _tmt981 = (*C.MSKint32t)(&subj[0]) }
  var _tmt982 *int64
  if len(nummat) < cast[int32](subj.len) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"nummat"}
    return
  }
  if nummat != nil { _tmt982 = (*C.MSKint32t)(&nummat[0]) }
  var _tmt983 *int64
  if len(matidx) < nummat.foldl(a+b) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"matidx"}
    return
  }
  if matidx != nil { _tmt983 = (*C.MSKint32t)(&matidx[0]) }
  var _tmt984 *float64
  if len(weights) < nummat.foldl(a+b) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"weights"}
    return
  }
  if weights != nil { _tmt984 = (*C.MSKint32t)(&weights[0]) }
  if _tmt985 := C.MSK_putbararowlist(self.ptr(),num,_tmt978,_tmt979,_tmt980,_tmt981,_tmt982,_tmt983,_tmt984); _tmt985 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt985)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarcBlockTriplet(subj []int32,subk []int32,subl []int32,valjkl []float64) (err error) {
  _tmt986 := len(valjkl)
  if _tmt986 < subl { _tmt986 = lof["name"] }
  if _tmt986 < subk { _tmt986 = lof["name"] }
  if _tmt986 < subj { _tmt986 = lof["name"] }
  var num int64 = int32(_tmt986)
  var _tmt987 *int32
  if len(subj) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subj"}
    return
  }
  if subj != nil { _tmt987 = (*C.MSKint32t)(&subj[0]) }
  var _tmt988 *int32
  if len(subk) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt988 = (*C.MSKint32t)(&subk[0]) }
  var _tmt989 *int32
  if len(subl) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt989 = (*C.MSKint32t)(&subl[0]) }
  var _tmt990 *float64
  if len(valjkl) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"valjkl"}
    return
  }
  if valjkl != nil { _tmt990 = (*C.MSKint32t)(&valjkl[0]) }
  if _tmt991 := C.MSK_putbarcblocktriplet(self.ptr(),num,_tmt987,_tmt988,_tmt989,_tmt990); _tmt991 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt991)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarcJ(j int32,sub []int64,weights []float64) (err error) {
  _tmt992 := len(weights)
  if _tmt992 < sub { _tmt992 = lof["name"] }
  var num int64 = int32(_tmt992)
  var _tmt993 *int64
  if sub != nil { _tmt993 = (*C.MSKint32t)(&sub[0]) }
  var _tmt994 *float64
  if weights != nil { _tmt994 = (*C.MSKint32t)(&weights[0]) }
  if _tmt995 := C.MSK_putbarcj(self.ptr(),j,num,_tmt993,_tmt994); _tmt995 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt995)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarsJ(whichsol Soltype,j int32,barsj []float64) (err error) {
  var _tmt998 *float64
  var _tmt996 int64
  if _tmt997 := C.MSK_getlenbarvarj(task.nativep,j,addr(_tmt996)); _tmt997 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt997)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(barsj) < _tmt996 {
    err = &ArrayLengthError{fun:"PutBarsJ",arg:"barsj"}
    return
  }
  if barsj != nil { _tmt998 = (*C.MSKint32t)(&barsj[0]) }
  if _tmt999 := C.MSK_putbarsj(self.ptr(),whichsol,j,_tmt998); _tmt999 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt999)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarvarName(j int32,name string) (err error) {
  _tmt1000 := C.CString(name)
  if _tmt1001 := C.MSK_putbarvarname(self.ptr(),j,_tmt1000); _tmt1001 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1001)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarxJ(whichsol Soltype,j int32,barxj []float64) (err error) {
  var _tmt1004 *float64
  var _tmt1002 int64
  if _tmt1003 := C.MSK_getlenbarvarj(task.nativep,j,addr(_tmt1002)); _tmt1003 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1003)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(barxj) < _tmt1002 {
    err = &ArrayLengthError{fun:"PutBarxJ",arg:"barxj"}
    return
  }
  if barxj != nil { _tmt1004 = (*C.MSKint32t)(&barxj[0]) }
  if _tmt1005 := C.MSK_putbarxj(self.ptr(),whichsol,j,_tmt1004); _tmt1005 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1005)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCfix(cfix float64) (err error) {
  if _tmt1006 := C.MSK_putcfix(self.ptr(),cfix); _tmt1006 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1006)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCJ(j int32,cj float64) (err error) {
  if _tmt1007 := C.MSK_putcj(self.ptr(),j,cj); _tmt1007 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1007)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCList(subj []int32,val []float64) (err error) {
  _tmt1008 := len(val)
  if _tmt1008 < subj { _tmt1008 = lof["name"] }
  var num int32 = int32(_tmt1008)
  var _tmt1009 *int32
  if subj != nil { _tmt1009 = (*C.MSKint32t)(&subj[0]) }
  var _tmt1010 *float64
  if val != nil { _tmt1010 = (*C.MSKint32t)(&val[0]) }
  if _tmt1011 := C.MSK_putclist(self.ptr(),num,_tmt1009,_tmt1010); _tmt1011 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1011)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBound(i int32,bkc Boundkey,blc float64,buc float64) (err error) {
  if _tmt1012 := C.MSK_putconbound(self.ptr(),i,bkc,blc,buc); _tmt1012 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1012)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundList(sub []int32,bkc []Boundkey,blc []float64,buc []float64) (err error) {
  _tmt1013 := len(bkc)
  if _tmt1013 < blc { _tmt1013 = lof["name"] }
  if _tmt1013 < buc { _tmt1013 = lof["name"] }
  if _tmt1013 < sub { _tmt1013 = lof["name"] }
  var num int32 = int32(_tmt1013)
  var _tmt1014 *int32
  if sub != nil { _tmt1014 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1015 *Boundkey
  if bkc != nil { _tmt1015 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt1016 *float64
  if blc != nil { _tmt1016 = (*C.MSKint32t)(&blc[0]) }
  var _tmt1017 *float64
  if buc != nil { _tmt1017 = (*C.MSKint32t)(&buc[0]) }
  if _tmt1018 := C.MSK_putconboundlist(self.ptr(),num,_tmt1014,_tmt1015,_tmt1016,_tmt1017); _tmt1018 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1018)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundListConst(sub []int32,bkc Boundkey,blc float64,buc float64) (err error) {
  _tmt1019 := len(sub)
  var num int32 = int32(_tmt1019)
  var _tmt1020 *int32
  if sub != nil { _tmt1020 = (*C.MSKint32t)(&sub[0]) }
  if _tmt1021 := C.MSK_putconboundlistconst(self.ptr(),num,_tmt1020,bkc,blc,buc); _tmt1021 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1021)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundSlice(first int32,last int32,bkc []Boundkey,blc []float64,buc []float64) (err error) {
  var _tmt1022 *Boundkey
  if len(bkc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"bkc"}
    return
  }
  if bkc != nil { _tmt1022 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt1023 *float64
  if len(blc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"blc"}
    return
  }
  if blc != nil { _tmt1023 = (*C.MSKint32t)(&blc[0]) }
  var _tmt1024 *float64
  if len(buc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"buc"}
    return
  }
  if buc != nil { _tmt1024 = (*C.MSKint32t)(&buc[0]) }
  if _tmt1025 := C.MSK_putconboundslice(self.ptr(),first,last,_tmt1022,_tmt1023,_tmt1024); _tmt1025 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1025)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundSliceConst(first int32,last int32,bkc Boundkey,blc float64,buc float64) (err error) {
  if _tmt1026 := C.MSK_putconboundsliceconst(self.ptr(),first,last,bkc,blc,buc); _tmt1026 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1026)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCone(k int32,ct Conetype,conepar float64,submem []int32) (err error) {
  _tmt1027 := len(submem)
  var nummem int32 = int32(_tmt1027)
  var _tmt1028 *int32
  if submem != nil { _tmt1028 = (*C.MSKint32t)(&submem[0]) }
  if _tmt1029 := C.MSK_putcone(self.ptr(),k,ct,conepar,nummem,_tmt1028); _tmt1029 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1029)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConeName(j int32,name string) (err error) {
  _tmt1030 := C.CString(name)
  if _tmt1031 := C.MSK_putconename(self.ptr(),j,_tmt1030); _tmt1031 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1031)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConName(i int32,name string) (err error) {
  _tmt1032 := C.CString(name)
  if _tmt1033 := C.MSK_putconname(self.ptr(),i,_tmt1032); _tmt1033 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1033)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConSolutionI(i int32,whichsol Soltype,sk Stakey,x float64,sl float64,su float64) (err error) {
  if _tmt1034 := C.MSK_putconsolutioni(self.ptr(),i,whichsol,sk,x,sl,su); _tmt1034 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1034)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCSlice(first int32,last int32,slice []float64) (err error) {
  var _tmt1035 *float64
  if len(slice) < (last - first) {
    err = &ArrayLengthError{fun:"PutCSlice",arg:"slice"}
    return
  }
  if slice != nil { _tmt1035 = (*C.MSKint32t)(&slice[0]) }
  if _tmt1036 := C.MSK_putcslice(self.ptr(),first,last,_tmt1035); _tmt1036 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1036)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjc(djcidx int64,domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64) (err error) {
  _tmt1037 := len(domidxlist)
  var numdomidx int64 = int32(_tmt1037)
  var _tmt1038 *int64
  if domidxlist != nil { _tmt1038 = (*C.MSKint32t)(&domidxlist[0]) }
  _tmt1039 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt1039)
  var _tmt1040 *int64
  if afeidxlist != nil { _tmt1040 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt1041 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutDjc",arg:"b"}
    return
  }
  if b != nil { _tmt1041 = (*C.MSKint32t)(&b[0]) }
  _tmt1042 := len(termsizelist)
  var numterms int64 = int32(_tmt1042)
  var _tmt1043 *int64
  if termsizelist != nil { _tmt1043 = (*C.MSKint32t)(&termsizelist[0]) }
  if _tmt1044 := C.MSK_putdjc(self.ptr(),djcidx,numdomidx,_tmt1038,numafeidx,_tmt1040,_tmt1041,numterms,_tmt1043); _tmt1044 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1044)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjcName(djcidx int64,name string) (err error) {
  _tmt1045 := C.CString(name)
  if _tmt1046 := C.MSK_putdjcname(self.ptr(),djcidx,_tmt1045); _tmt1046 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1046)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjcSlice(idxfirst int64,idxlast int64,domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64,termsindjc []int64) (err error) {
  _tmt1047 := len(domidxlist)
  var numdomidx int64 = int32(_tmt1047)
  var _tmt1048 *int64
  if domidxlist != nil { _tmt1048 = (*C.MSKint32t)(&domidxlist[0]) }
  _tmt1049 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt1049)
  var _tmt1050 *int64
  if afeidxlist != nil { _tmt1050 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt1051 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutDjcSlice",arg:"b"}
    return
  }
  if b != nil { _tmt1051 = (*C.MSKint32t)(&b[0]) }
  _tmt1052 := len(termsizelist)
  var numterms int64 = int32(_tmt1052)
  var _tmt1053 *int64
  if termsizelist != nil { _tmt1053 = (*C.MSKint32t)(&termsizelist[0]) }
  var _tmt1054 *int64
  if len(termsindjc) < (idxlast - idxfirst) {
    err = &ArrayLengthError{fun:"PutDjcSlice",arg:"termsindjc"}
    return
  }
  if termsindjc != nil { _tmt1054 = (*C.MSKint32t)(&termsindjc[0]) }
  if _tmt1055 := C.MSK_putdjcslice(self.ptr(),idxfirst,idxlast,numdomidx,_tmt1048,numafeidx,_tmt1050,_tmt1051,numterms,_tmt1053,_tmt1054); _tmt1055 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1055)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDomainName(domidx int64,name string) (err error) {
  _tmt1056 := C.CString(name)
  if _tmt1057 := C.MSK_putdomainname(self.ptr(),domidx,_tmt1056); _tmt1057 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1057)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDouParam(param Dparam,parvalue float64) (err error) {
  if _tmt1058 := C.MSK_putdouparam(self.ptr(),param,parvalue); _tmt1058 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1058)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutIntParam(param Iparam,parvalue int32) (err error) {
  if _tmt1059 := C.MSK_putintparam(self.ptr(),param,parvalue); _tmt1059 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1059)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumAcc(maxnumacc int64) (err error) {
  if _tmt1060 := C.MSK_putmaxnumacc(self.ptr(),maxnumacc); _tmt1060 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1060)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumAfe(maxnumafe int64) (err error) {
  if _tmt1061 := C.MSK_putmaxnumafe(self.ptr(),maxnumafe); _tmt1061 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1061)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumANz(maxnumanz int64) (err error) {
  if _tmt1062 := C.MSK_putmaxnumanz(self.ptr(),maxnumanz); _tmt1062 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1062)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumBarvar(maxnumbarvar int32) (err error) {
  if _tmt1063 := C.MSK_putmaxnumbarvar(self.ptr(),maxnumbarvar); _tmt1063 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1063)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumCon(maxnumcon int32) (err error) {
  if _tmt1064 := C.MSK_putmaxnumcon(self.ptr(),maxnumcon); _tmt1064 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1064)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumCone(maxnumcone int32) (err error) {
  if _tmt1065 := C.MSK_putmaxnumcone(self.ptr(),maxnumcone); _tmt1065 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1065)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumDjc(maxnumdjc int64) (err error) {
  if _tmt1066 := C.MSK_putmaxnumdjc(self.ptr(),maxnumdjc); _tmt1066 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1066)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumDomain(maxnumdomain int64) (err error) {
  if _tmt1067 := C.MSK_putmaxnumdomain(self.ptr(),maxnumdomain); _tmt1067 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1067)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumQNz(maxnumqnz int64) (err error) {
  if _tmt1068 := C.MSK_putmaxnumqnz(self.ptr(),maxnumqnz); _tmt1068 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1068)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumVar(maxnumvar int32) (err error) {
  if _tmt1069 := C.MSK_putmaxnumvar(self.ptr(),maxnumvar); _tmt1069 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1069)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaDouParam(paramname string,parvalue float64) (err error) {
  _tmt1070 := C.CString(paramname)
  if _tmt1071 := C.MSK_putnadouparam(self.ptr(),_tmt1070,parvalue); _tmt1071 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1071)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaIntParam(paramname string,parvalue int32) (err error) {
  _tmt1072 := C.CString(paramname)
  if _tmt1073 := C.MSK_putnaintparam(self.ptr(),_tmt1072,parvalue); _tmt1073 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1073)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaStrParam(paramname string,parvalue string) (err error) {
  _tmt1074 := C.CString(paramname)
  _tmt1075 := C.CString(parvalue)
  if _tmt1076 := C.MSK_putnastrparam(self.ptr(),_tmt1074,_tmt1075); _tmt1076 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1076)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutObjName(objname string) (err error) {
  _tmt1077 := C.CString(objname)
  if _tmt1078 := C.MSK_putobjname(self.ptr(),_tmt1077); _tmt1078 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1078)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutObjSense(sense Objsense) (err error) {
  if _tmt1079 := C.MSK_putobjsense(self.ptr(),sense); _tmt1079 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1079)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutOptserverHost(host string) (err error) {
  _tmt1080 := C.CString(host)
  if _tmt1081 := C.MSK_putoptserverhost(self.ptr(),_tmt1080); _tmt1081 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1081)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutParam(parname string,parvalue string) (err error) {
  _tmt1082 := C.CString(parname)
  _tmt1083 := C.CString(parvalue)
  if _tmt1084 := C.MSK_putparam(self.ptr(),_tmt1082,_tmt1083); _tmt1084 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1084)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQCon(qcsubk []int32,qcsubi []int32,qcsubj []int32,qcval []float64) (err error) {
  _tmt1085 := len(qcval)
  if _tmt1085 < qcsubi { _tmt1085 = lof["name"] }
  if _tmt1085 < qcsubj { _tmt1085 = lof["name"] }
  var numqcnz int32 = int32(_tmt1085)
  var _tmt1086 *int32
  if qcsubk != nil { _tmt1086 = (*C.MSKint32t)(&qcsubk[0]) }
  var _tmt1087 *int32
  if qcsubi != nil { _tmt1087 = (*C.MSKint32t)(&qcsubi[0]) }
  var _tmt1088 *int32
  if qcsubj != nil { _tmt1088 = (*C.MSKint32t)(&qcsubj[0]) }
  var _tmt1089 *float64
  if qcval != nil { _tmt1089 = (*C.MSKint32t)(&qcval[0]) }
  if _tmt1090 := C.MSK_putqcon(self.ptr(),numqcnz,_tmt1086,_tmt1087,_tmt1088,_tmt1089); _tmt1090 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1090)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQConK(k int32,qcsubi []int32,qcsubj []int32,qcval []float64) (err error) {
  _tmt1091 := len(qcval)
  if _tmt1091 < qcsubi { _tmt1091 = lof["name"] }
  if _tmt1091 < qcsubj { _tmt1091 = lof["name"] }
  var numqcnz int32 = int32(_tmt1091)
  var _tmt1092 *int32
  if qcsubi != nil { _tmt1092 = (*C.MSKint32t)(&qcsubi[0]) }
  var _tmt1093 *int32
  if qcsubj != nil { _tmt1093 = (*C.MSKint32t)(&qcsubj[0]) }
  var _tmt1094 *float64
  if qcval != nil { _tmt1094 = (*C.MSKint32t)(&qcval[0]) }
  if _tmt1095 := C.MSK_putqconk(self.ptr(),k,numqcnz,_tmt1092,_tmt1093,_tmt1094); _tmt1095 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1095)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQObj(qosubi []int32,qosubj []int32,qoval []float64) (err error) {
  _tmt1096 := len(qosubi)
  if _tmt1096 < qoval { _tmt1096 = lof["name"] }
  if _tmt1096 < qosubj { _tmt1096 = lof["name"] }
  var numqonz int32 = int32(_tmt1096)
  var _tmt1097 *int32
  if qosubi != nil { _tmt1097 = (*C.MSKint32t)(&qosubi[0]) }
  var _tmt1098 *int32
  if qosubj != nil { _tmt1098 = (*C.MSKint32t)(&qosubj[0]) }
  var _tmt1099 *float64
  if qoval != nil { _tmt1099 = (*C.MSKint32t)(&qoval[0]) }
  if _tmt1100 := C.MSK_putqobj(self.ptr(),numqonz,_tmt1097,_tmt1098,_tmt1099); _tmt1100 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1100)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQObjIJ(i int32,j int32,qoij float64) (err error) {
  if _tmt1101 := C.MSK_putqobjij(self.ptr(),i,j,qoij); _tmt1101 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1101)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkc(whichsol Soltype,skc []Stakey) (err error) {
  var _tmt1104 *Stakey
  var _tmt1102 int32
  if _tmt1103 := C.MSK_getnumcon(task.nativep,addr(_tmt1102)); _tmt1103 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1103)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(skc) < _tmt1102 {
    err = &ArrayLengthError{fun:"PutSkc",arg:"skc"}
    return
  }
  if skc != nil { _tmt1104 = (*C.MSKint32t)(&skc[0]) }
  if _tmt1105 := C.MSK_putskc(self.ptr(),whichsol,_tmt1104); _tmt1105 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1105)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkcSlice(whichsol Soltype,first int32,last int32,skc []Stakey) (err error) {
  var _tmt1106 *Stakey
  if len(skc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSkcSlice",arg:"skc"}
    return
  }
  if skc != nil { _tmt1106 = (*C.MSKint32t)(&skc[0]) }
  if _tmt1107 := C.MSK_putskcslice(self.ptr(),whichsol,first,last,_tmt1106); _tmt1107 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1107)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkx(whichsol Soltype,skx []Stakey) (err error) {
  var _tmt1110 *Stakey
  var _tmt1108 int32
  if _tmt1109 := C.MSK_getnumvar(task.nativep,addr(_tmt1108)); _tmt1109 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1109)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(skx) < _tmt1108 {
    err = &ArrayLengthError{fun:"PutSkx",arg:"skx"}
    return
  }
  if skx != nil { _tmt1110 = (*C.MSKint32t)(&skx[0]) }
  if _tmt1111 := C.MSK_putskx(self.ptr(),whichsol,_tmt1110); _tmt1111 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1111)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkxSlice(whichsol Soltype,first int32,last int32,skx []Stakey) (err error) {
  var _tmt1112 *Stakey
  if len(skx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSkxSlice",arg:"skx"}
    return
  }
  if skx != nil { _tmt1112 = (*C.MSKint32t)(&skx[0]) }
  if _tmt1113 := C.MSK_putskxslice(self.ptr(),whichsol,first,last,_tmt1112); _tmt1113 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1113)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlc(whichsol Soltype,slc []float64) (err error) {
  var _tmt1116 *float64
  var _tmt1114 int32
  if _tmt1115 := C.MSK_getnumcon(task.nativep,addr(_tmt1114)); _tmt1115 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1115)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(slc) < _tmt1114 {
    err = &ArrayLengthError{fun:"PutSlc",arg:"slc"}
    return
  }
  if slc != nil { _tmt1116 = (*C.MSKint32t)(&slc[0]) }
  if _tmt1117 := C.MSK_putslc(self.ptr(),whichsol,_tmt1116); _tmt1117 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1117)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlcSlice(whichsol Soltype,first int32,last int32,slc []float64) (err error) {
  var _tmt1118 *float64
  if len(slc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSlcSlice",arg:"slc"}
    return
  }
  if slc != nil { _tmt1118 = (*C.MSKint32t)(&slc[0]) }
  if _tmt1119 := C.MSK_putslcslice(self.ptr(),whichsol,first,last,_tmt1118); _tmt1119 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1119)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlx(whichsol Soltype,slx []float64) (err error) {
  var _tmt1122 *float64
  var _tmt1120 int32
  if _tmt1121 := C.MSK_getnumvar(task.nativep,addr(_tmt1120)); _tmt1121 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1121)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(slx) < _tmt1120 {
    err = &ArrayLengthError{fun:"PutSlx",arg:"slx"}
    return
  }
  if slx != nil { _tmt1122 = (*C.MSKint32t)(&slx[0]) }
  if _tmt1123 := C.MSK_putslx(self.ptr(),whichsol,_tmt1122); _tmt1123 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1123)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlxSlice(whichsol Soltype,first int32,last int32,slx []float64) (err error) {
  var _tmt1124 *float64
  if len(slx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSlxSlice",arg:"slx"}
    return
  }
  if slx != nil { _tmt1124 = (*C.MSKint32t)(&slx[0]) }
  if _tmt1125 := C.MSK_putslxslice(self.ptr(),whichsol,first,last,_tmt1124); _tmt1125 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1125)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSnx(whichsol Soltype,sux []float64) (err error) {
  var _tmt1128 *float64
  var _tmt1126 int32
  if _tmt1127 := C.MSK_getnumvar(task.nativep,addr(_tmt1126)); _tmt1127 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1127)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sux) < _tmt1126 {
    err = &ArrayLengthError{fun:"PutSnx",arg:"sux"}
    return
  }
  if sux != nil { _tmt1128 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1129 := C.MSK_putsnx(self.ptr(),whichsol,_tmt1128); _tmt1129 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1129)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSnxSlice(whichsol Soltype,first int32,last int32,snx []float64) (err error) {
  var _tmt1130 *float64
  if len(snx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSnxSlice",arg:"snx"}
    return
  }
  if snx != nil { _tmt1130 = (*C.MSKint32t)(&snx[0]) }
  if _tmt1131 := C.MSK_putsnxslice(self.ptr(),whichsol,first,last,_tmt1130); _tmt1131 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1131)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolution(whichsol Soltype,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64) (err error) {
  var _tmt1132 *Stakey
  if skc != nil { _tmt1132 = (*C.MSKint32t)(&skc[0]) }
  var _tmt1133 *Stakey
  if skx != nil { _tmt1133 = (*C.MSKint32t)(&skx[0]) }
  var _tmt1134 *Stakey
  if skn != nil { _tmt1134 = (*C.MSKint32t)(&skn[0]) }
  var _tmt1135 *float64
  if xc != nil { _tmt1135 = (*C.MSKint32t)(&xc[0]) }
  var _tmt1136 *float64
  if xx != nil { _tmt1136 = (*C.MSKint32t)(&xx[0]) }
  var _tmt1137 *float64
  if y != nil { _tmt1137 = (*C.MSKint32t)(&y[0]) }
  var _tmt1138 *float64
  if slc != nil { _tmt1138 = (*C.MSKint32t)(&slc[0]) }
  var _tmt1139 *float64
  if suc != nil { _tmt1139 = (*C.MSKint32t)(&suc[0]) }
  var _tmt1140 *float64
  if slx != nil { _tmt1140 = (*C.MSKint32t)(&slx[0]) }
  var _tmt1141 *float64
  if sux != nil { _tmt1141 = (*C.MSKint32t)(&sux[0]) }
  var _tmt1142 *float64
  if snx != nil { _tmt1142 = (*C.MSKint32t)(&snx[0]) }
  if _tmt1143 := C.MSK_putsolution(self.ptr(),whichsol,_tmt1132,_tmt1133,_tmt1134,_tmt1135,_tmt1136,_tmt1137,_tmt1138,_tmt1139,_tmt1140,_tmt1141,_tmt1142); _tmt1143 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1143)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolutionNew(whichsol Soltype,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,doty []float64) (err error) {
  var _tmt1144 *Stakey
  if skc != nil { _tmt1144 = (*C.MSKint32t)(&skc[0]) }
  var _tmt1145 *Stakey
  if skx != nil { _tmt1145 = (*C.MSKint32t)(&skx[0]) }
  var _tmt1146 *Stakey
  if skn != nil { _tmt1146 = (*C.MSKint32t)(&skn[0]) }
  var _tmt1147 *float64
  if xc != nil { _tmt1147 = (*C.MSKint32t)(&xc[0]) }
  var _tmt1148 *float64
  if xx != nil { _tmt1148 = (*C.MSKint32t)(&xx[0]) }
  var _tmt1149 *float64
  if y != nil { _tmt1149 = (*C.MSKint32t)(&y[0]) }
  var _tmt1150 *float64
  if slc != nil { _tmt1150 = (*C.MSKint32t)(&slc[0]) }
  var _tmt1151 *float64
  if suc != nil { _tmt1151 = (*C.MSKint32t)(&suc[0]) }
  var _tmt1152 *float64
  if slx != nil { _tmt1152 = (*C.MSKint32t)(&slx[0]) }
  var _tmt1153 *float64
  if sux != nil { _tmt1153 = (*C.MSKint32t)(&sux[0]) }
  var _tmt1154 *float64
  if snx != nil { _tmt1154 = (*C.MSKint32t)(&snx[0]) }
  var _tmt1155 *float64
  if doty != nil { _tmt1155 = (*C.MSKint32t)(&doty[0]) }
  if _tmt1156 := C.MSK_putsolutionnew(self.ptr(),whichsol,_tmt1144,_tmt1145,_tmt1146,_tmt1147,_tmt1148,_tmt1149,_tmt1150,_tmt1151,_tmt1152,_tmt1153,_tmt1154,_tmt1155); _tmt1156 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1156)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolutionYI(i int32,whichsol Soltype,y float64) (err error) {
  if _tmt1157 := C.MSK_putsolutionyi(self.ptr(),i,whichsol,y); _tmt1157 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1157)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutStrParam(param Sparam,parvalue string) (err error) {
  _tmt1158 := C.CString(parvalue)
  if _tmt1159 := C.MSK_putstrparam(self.ptr(),param,_tmt1158); _tmt1159 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1159)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSuc(whichsol Soltype,suc []float64) (err error) {
  var _tmt1162 *float64
  var _tmt1160 int32
  if _tmt1161 := C.MSK_getnumcon(task.nativep,addr(_tmt1160)); _tmt1161 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1161)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(suc) < _tmt1160 {
    err = &ArrayLengthError{fun:"PutSuc",arg:"suc"}
    return
  }
  if suc != nil { _tmt1162 = (*C.MSKint32t)(&suc[0]) }
  if _tmt1163 := C.MSK_putsuc(self.ptr(),whichsol,_tmt1162); _tmt1163 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1163)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSucSlice(whichsol Soltype,first int32,last int32,suc []float64) (err error) {
  var _tmt1164 *float64
  if len(suc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSucSlice",arg:"suc"}
    return
  }
  if suc != nil { _tmt1164 = (*C.MSKint32t)(&suc[0]) }
  if _tmt1165 := C.MSK_putsucslice(self.ptr(),whichsol,first,last,_tmt1164); _tmt1165 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1165)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSux(whichsol Soltype,sux []float64) (err error) {
  var _tmt1168 *float64
  var _tmt1166 int32
  if _tmt1167 := C.MSK_getnumvar(task.nativep,addr(_tmt1166)); _tmt1167 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1167)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sux) < _tmt1166 {
    err = &ArrayLengthError{fun:"PutSux",arg:"sux"}
    return
  }
  if sux != nil { _tmt1168 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1169 := C.MSK_putsux(self.ptr(),whichsol,_tmt1168); _tmt1169 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1169)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSuxSlice(whichsol Soltype,first int32,last int32,sux []float64) (err error) {
  var _tmt1170 *float64
  if len(sux) < (last - first) {
    err = &ArrayLengthError{fun:"PutSuxSlice",arg:"sux"}
    return
  }
  if sux != nil { _tmt1170 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1171 := C.MSK_putsuxslice(self.ptr(),whichsol,first,last,_tmt1170); _tmt1171 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1171)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutTaskName(taskname string) (err error) {
  _tmt1172 := C.CString(taskname)
  if _tmt1173 := C.MSK_puttaskname(self.ptr(),_tmt1172); _tmt1173 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1173)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBound(j int32,bkx Boundkey,blx float64,bux float64) (err error) {
  if _tmt1174 := C.MSK_putvarbound(self.ptr(),j,bkx,blx,bux); _tmt1174 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1174)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundList(sub []int32,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  _tmt1175 := len(bkx)
  if _tmt1175 < blx { _tmt1175 = lof["name"] }
  if _tmt1175 < bux { _tmt1175 = lof["name"] }
  if _tmt1175 < sub { _tmt1175 = lof["name"] }
  var num int32 = int32(_tmt1175)
  var _tmt1176 *int32
  if sub != nil { _tmt1176 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1177 *Boundkey
  if bkx != nil { _tmt1177 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt1178 *float64
  if blx != nil { _tmt1178 = (*C.MSKint32t)(&blx[0]) }
  var _tmt1179 *float64
  if bux != nil { _tmt1179 = (*C.MSKint32t)(&bux[0]) }
  if _tmt1180 := C.MSK_putvarboundlist(self.ptr(),num,_tmt1176,_tmt1177,_tmt1178,_tmt1179); _tmt1180 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1180)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundListConst(sub []int32,bkx Boundkey,blx float64,bux float64) (err error) {
  _tmt1181 := len(sub)
  var num int32 = int32(_tmt1181)
  var _tmt1182 *int32
  if sub != nil { _tmt1182 = (*C.MSKint32t)(&sub[0]) }
  if _tmt1183 := C.MSK_putvarboundlistconst(self.ptr(),num,_tmt1182,bkx,blx,bux); _tmt1183 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1183)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundSlice(first int32,last int32,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  var _tmt1184 *Boundkey
  if len(bkx) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"bkx"}
    return
  }
  if bkx != nil { _tmt1184 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt1185 *float64
  if len(blx) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"blx"}
    return
  }
  if blx != nil { _tmt1185 = (*C.MSKint32t)(&blx[0]) }
  var _tmt1186 *float64
  if len(bux) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"bux"}
    return
  }
  if bux != nil { _tmt1186 = (*C.MSKint32t)(&bux[0]) }
  if _tmt1187 := C.MSK_putvarboundslice(self.ptr(),first,last,_tmt1184,_tmt1185,_tmt1186); _tmt1187 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1187)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundSliceConst(first int32,last int32,bkx Boundkey,blx float64,bux float64) (err error) {
  if _tmt1188 := C.MSK_putvarboundsliceconst(self.ptr(),first,last,bkx,blx,bux); _tmt1188 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1188)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarName(j int32,name string) (err error) {
  _tmt1189 := C.CString(name)
  if _tmt1190 := C.MSK_putvarname(self.ptr(),j,_tmt1189); _tmt1190 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1190)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarSolutionJ(j int32,whichsol Soltype,sk Stakey,x float64,sl float64,su float64,sn float64) (err error) {
  if _tmt1191 := C.MSK_putvarsolutionj(self.ptr(),j,whichsol,sk,x,sl,su,sn); _tmt1191 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1191)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarType(j int32,vartype Variabletype) (err error) {
  if _tmt1192 := C.MSK_putvartype(self.ptr(),j,vartype); _tmt1192 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1192)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarTypeList(subj []int32,vartype []Variabletype) (err error) {
  _tmt1193 := len(vartype)
  if _tmt1193 < subj { _tmt1193 = lof["name"] }
  var num int32 = int32(_tmt1193)
  var _tmt1194 *int32
  if subj != nil { _tmt1194 = (*C.MSKint32t)(&subj[0]) }
  var _tmt1195 *Variabletype
  if vartype != nil { _tmt1195 = (*C.MSKint32t)(&vartype[0]) }
  if _tmt1196 := C.MSK_putvartypelist(self.ptr(),num,_tmt1194,_tmt1195); _tmt1196 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1196)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXc(whichsol Soltype) (xc []float64,err error) {
  var _tmt1199 *float64
  var _tmt1197 int32
  if _tmt1198 := C.MSK_getnumcon(task.nativep,addr(_tmt1197)); _tmt1198 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1198)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt1197)
  if len(xc) > 0 { _tmt1199 = (*float64)(&n[0]) }
  if _tmt1200 := C.MSK_putxc(self.ptr(),whichsol,_tmt1199); _tmt1200 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1200)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXcSlice(whichsol Soltype,first int32,last int32,xc []float64) (err error) {
  var _tmt1201 *float64
  if len(xc) < (last - first) {
    err = &ArrayLengthError{fun:"PutXcSlice",arg:"xc"}
    return
  }
  if xc != nil { _tmt1201 = (*C.MSKint32t)(&xc[0]) }
  if _tmt1202 := C.MSK_putxcslice(self.ptr(),whichsol,first,last,_tmt1201); _tmt1202 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1202)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXx(whichsol Soltype,xx []float64) (err error) {
  var _tmt1205 *float64
  var _tmt1203 int32
  if _tmt1204 := C.MSK_getnumvar(task.nativep,addr(_tmt1203)); _tmt1204 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1204)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(xx) < _tmt1203 {
    err = &ArrayLengthError{fun:"PutXx",arg:"xx"}
    return
  }
  if xx != nil { _tmt1205 = (*C.MSKint32t)(&xx[0]) }
  if _tmt1206 := C.MSK_putxx(self.ptr(),whichsol,_tmt1205); _tmt1206 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1206)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXxSlice(whichsol Soltype,first int32,last int32,xx []float64) (err error) {
  var _tmt1207 *float64
  if len(xx) < (last - first) {
    err = &ArrayLengthError{fun:"PutXxSlice",arg:"xx"}
    return
  }
  if xx != nil { _tmt1207 = (*C.MSKint32t)(&xx[0]) }
  if _tmt1208 := C.MSK_putxxslice(self.ptr(),whichsol,first,last,_tmt1207); _tmt1208 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1208)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutY(whichsol Soltype,y []float64) (err error) {
  var _tmt1211 *float64
  var _tmt1209 int32
  if _tmt1210 := C.MSK_getnumcon(task.nativep,addr(_tmt1209)); _tmt1210 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1210)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(y) < _tmt1209 {
    err = &ArrayLengthError{fun:"PutY",arg:"y"}
    return
  }
  if y != nil { _tmt1211 = (*C.MSKint32t)(&y[0]) }
  if _tmt1212 := C.MSK_puty(self.ptr(),whichsol,_tmt1211); _tmt1212 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1212)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutYSlice(whichsol Soltype,first int32,last int32,y []float64) (err error) {
  var _tmt1213 *float64
  if len(y) < (last - first) {
    err = &ArrayLengthError{fun:"PutYSlice",arg:"y"}
    return
  }
  if y != nil { _tmt1213 = (*C.MSKint32t)(&y[0]) }
  if _tmt1214 := C.MSK_putyslice(self.ptr(),whichsol,first,last,_tmt1213); _tmt1214 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1214)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadBSolution(filename string,compress Compresstype) (err error) {
  _tmt1215 := C.CString(filename)
  if _tmt1216 := C.MSK_readbsolution(self.ptr(),_tmt1215,compress); _tmt1216 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1216)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadData(filename string) (err error) {
  _tmt1217 := C.CString(filename)
  if _tmt1218 := C.MSK_readdataautoformat(self.ptr(),_tmt1217); _tmt1218 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1218)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadDataFormat(filename string,format Dataformat,compress Compresstype) (err error) {
  _tmt1219 := C.CString(filename)
  if _tmt1220 := C.MSK_readdataformat(self.ptr(),_tmt1219,format,compress); _tmt1220 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1220)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadJsonSol(filename string) (err error) {
  _tmt1221 := C.CString(filename)
  if _tmt1222 := C.MSK_readjsonsol(self.ptr(),_tmt1221); _tmt1222 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1222)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadJsonString(data string) (err error) {
  _tmt1223 := C.CString(data)
  if _tmt1224 := C.MSK_readjsonstring(self.ptr(),_tmt1223); _tmt1224 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1224)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadLpString(data string) (err error) {
  _tmt1225 := C.CString(data)
  if _tmt1226 := C.MSK_readlpstring(self.ptr(),_tmt1225); _tmt1226 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1226)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadOpfString(data string) (err error) {
  _tmt1227 := C.CString(data)
  if _tmt1228 := C.MSK_readopfstring(self.ptr(),_tmt1227); _tmt1228 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1228)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadParamFile(filename string) (err error) {
  _tmt1229 := C.CString(filename)
  if _tmt1230 := C.MSK_readparamfile(self.ptr(),_tmt1229); _tmt1230 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1230)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadPtfString(data string) (err error) {
  _tmt1231 := C.CString(data)
  if _tmt1232 := C.MSK_readptfstring(self.ptr(),_tmt1231); _tmt1232 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1232)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSolution(whichsol Soltype,filename string) (err error) {
  _tmt1233 := C.CString(filename)
  if _tmt1234 := C.MSK_readsolution(self.ptr(),whichsol,_tmt1233); _tmt1234 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1234)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSolutionFile(filename string) (err error) {
  _tmt1235 := C.CString(filename)
  if _tmt1236 := C.MSK_readsolutionfile(self.ptr(),_tmt1235); _tmt1236 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1236)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSummary(whichstream Streamtype) (err error) {
  if _tmt1237 := C.MSK_readsummary(self.ptr(),whichstream); _tmt1237 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1237)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadTask(filename string) (err error) {
  _tmt1238 := C.CString(filename)
  if _tmt1239 := C.MSK_readtask(self.ptr(),_tmt1238); _tmt1239 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1239)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveBarvars(subset []int32) (err error) {
  _tmt1240 := len(subset)
  var num int32 = int32(_tmt1240)
  var _tmt1241 *int32
  if subset != nil { _tmt1241 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1242 := C.MSK_removebarvars(self.ptr(),num,_tmt1241); _tmt1242 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1242)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveCones(subset []int32) (err error) {
  _tmt1243 := len(subset)
  var num int32 = int32(_tmt1243)
  var _tmt1244 *int32
  if subset != nil { _tmt1244 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1245 := C.MSK_removecones(self.ptr(),num,_tmt1244); _tmt1245 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1245)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveCons(subset []int32) (err error) {
  _tmt1246 := len(subset)
  var num int32 = int32(_tmt1246)
  var _tmt1247 *int32
  if subset != nil { _tmt1247 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1248 := C.MSK_removecons(self.ptr(),num,_tmt1247); _tmt1248 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1248)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveVars(subset []int32) (err error) {
  _tmt1249 := len(subset)
  var num int32 = int32(_tmt1249)
  var _tmt1250 *int32
  if subset != nil { _tmt1250 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1251 := C.MSK_removevars(self.ptr(),num,_tmt1250); _tmt1251 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1251)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ResizeTask(maxnumcon int32,maxnumvar int32,maxnumcone int32,maxnumanz int64,maxnumqnz int64) (err error) {
  if _tmt1252 := C.MSK_resizetask(self.ptr(),maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz); _tmt1252 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1252)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SensitivityReport(whichstream Streamtype) (err error) {
  if _tmt1253 := C.MSK_sensitivityreport(self.ptr(),whichstream); _tmt1253 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1253)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SetDefaults() (err error) {
  if _tmt1254 := C.MSK_setdefaults(self.ptr()); _tmt1254 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1254)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SkToStr(sk Stakey) (str string,err error) {
  _tmt1255 := make([]byte,max_str_len)
  if _tmt1256 := C.MSK_sktostr(self.ptr(),sk,C.CString(&tmpvar1[0])); _tmt1256 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1256)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var str string
  if p := strings.IndexByte(_tmt1255,byte(0)); p < 0 {
    str = string(_tmt1255)
  } else {
    str = string(_tmt1255[:p])
  }
  return
}
func (self *Task) SolStaToStr(solutionsta Solsta) (str string,err error) {
  _tmt1257 := make([]byte,max_str_len)
  if _tmt1258 := C.MSK_solstatostr(self.ptr(),solutionsta,C.CString(&tmpvar1[0])); _tmt1258 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1258)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var str string
  if p := strings.IndexByte(_tmt1257,byte(0)); p < 0 {
    str = string(_tmt1257)
  } else {
    str = string(_tmt1257[:p])
  }
  return
}
func (self *Task) SolutionDef(whichsol Soltype) (isdef bool,err error) {
  if _tmt1259 := C.MSK_solutiondef(self.ptr(),whichsol,&isdef); _tmt1259 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1259)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SolutionSummary(whichstream Streamtype) (err error) {
  if _tmt1260 := C.MSK_solutionsummary(self.ptr(),whichstream); _tmt1260 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1260)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SolveWithBasis(transp bool,numnz int32,sub []int32,val []float64) (numnzout int32,err error) {
  var _tmt1263 *int32
  var _tmt1261 int32
  if _tmt1262 := C.MSK_getnumcon(task.nativep,addr(_tmt1261)); _tmt1262 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1262)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sub) < _tmt1261 {
    err = &ArrayLengthError{fun:"SolveWithBasis",arg:"sub"}
    return
  }
  if sub != nil { _tmt1263 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1266 *float64
  var _tmt1264 int32
  if _tmt1265 := C.MSK_getnumcon(task.nativep,addr(_tmt1264)); _tmt1265 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1265)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(val) < _tmt1264 {
    err = &ArrayLengthError{fun:"SolveWithBasis",arg:"val"}
    return
  }
  if val != nil { _tmt1266 = (*C.MSKint32t)(&val[0]) }
  if _tmt1267 := C.MSK_solvewithbasis(self.ptr(),transp,numnz,_tmt1263,_tmt1266,&numnzout); _tmt1267 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1267)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) StrToConeType(str string) (conetype Conetype,err error) {
  _tmt1268 := C.CString(str)
  if _tmt1269 := C.MSK_strtoconetype(self.ptr(),_tmt1268,&conetype); _tmt1269 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1269)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) StrToSk(str string) (sk Stakey,err error) {
  _tmt1270 := C.CString(str)
  if _tmt1271 := C.MSK_strtosk(self.ptr(),_tmt1270,&sk); _tmt1271 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1271)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) Toconic() (err error) {
  if _tmt1272 := C.MSK_toconic(self.ptr()); _tmt1272 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1272)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) UpdateSolutionInfo(whichsol Soltype) (err error) {
  if _tmt1273 := C.MSK_updatesolutioninfo(self.ptr(),whichsol); _tmt1273 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1273)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteBSolution(filename string,compress Compresstype) (err error) {
  _tmt1274 := C.CString(filename)
  if _tmt1275 := C.MSK_writebsolution(self.ptr(),_tmt1274,compress); _tmt1275 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1275)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteData(filename string) (err error) {
  _tmt1276 := C.CString(filename)
  if _tmt1277 := C.MSK_writedata(self.ptr(),_tmt1276); _tmt1277 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1277)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteJsonSol(filename string) (err error) {
  _tmt1278 := C.CString(filename)
  if _tmt1279 := C.MSK_writejsonsol(self.ptr(),_tmt1278); _tmt1279 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1279)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteParamFile(filename string) (err error) {
  _tmt1280 := C.CString(filename)
  if _tmt1281 := C.MSK_writeparamfile(self.ptr(),_tmt1280); _tmt1281 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1281)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteSolution(whichsol Soltype,filename string) (err error) {
  _tmt1282 := C.CString(filename)
  if _tmt1283 := C.MSK_writesolution(self.ptr(),whichsol,_tmt1282); _tmt1283 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1283)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteSolutionFile(filename string) (err error) {
  _tmt1284 := C.CString(filename)
  if _tmt1285 := C.MSK_writesolutionfile(self.ptr(),_tmt1284); _tmt1285 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1285)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteTask(filename string) (err error) {
  _tmt1287 := C.CString(filename)
  if _tmt1288 := C.MSK_writetask(self.ptr(),_tmt1287); _tmt1288 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1288)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Axpy(n int32,alpha float64,x []float64,y []float64) (err error) {
  var _tmt1289 *float64
  if len(x) < n {
    err = &ArrayLengthError{fun:"Axpy",arg:"x"}
    return
  }
  if x != nil { _tmt1289 = (*C.MSKint32t)(&x[0]) }
  var _tmt1290 *float64
  if len(y) < n {
    err = &ArrayLengthError{fun:"Axpy",arg:"y"}
    return
  }
  if y != nil { _tmt1290 = (*C.MSKint32t)(&y[0]) }
  if _tmt1291 := C.MSK_axpy(self.ptr(),n,alpha,_tmt1289,_tmt1290); _tmt1291 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1291)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckInAll() (err error) {
  if _tmt1292 := C.MSK_checkinall(self.ptr()); _tmt1292 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1292)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckInLicense(feature Feature) (err error) {
  if _tmt1293 := C.MSK_checkinlicense(self.ptr(),feature); _tmt1293 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1293)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckOutLicense(feature Feature) (err error) {
  if _tmt1294 := C.MSK_checkoutlicense(self.ptr(),feature); _tmt1294 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1294)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Dot(n int32,x []float64,y []float64) (xty float64,err error) {
  var _tmt1295 *float64
  if len(x) < n {
    err = &ArrayLengthError{fun:"Dot",arg:"x"}
    return
  }
  if x != nil { _tmt1295 = (*C.MSKint32t)(&x[0]) }
  var _tmt1296 *float64
  if len(y) < n {
    err = &ArrayLengthError{fun:"Dot",arg:"y"}
    return
  }
  if y != nil { _tmt1296 = (*C.MSKint32t)(&y[0]) }
  if _tmt1297 := C.MSK_dot(self.ptr(),n,_tmt1295,_tmt1296,&xty); _tmt1297 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1297)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) EchoIntro(longver int32) (err error) {
  if _tmt1298 := C.MSK_echointro(self.ptr(),longver); _tmt1298 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1298)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Expirylicenses() (expiry int64,err error) {
  if _tmt1299 := C.MSK_expirylicenses(self.ptr(),&expiry); _tmt1299 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1299)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Gemm(transa Transpose,transb Transpose,m int32,n int32,k int32,alpha float64,a []float64,b []float64,beta float64,c []float64) (err error) {
  var _tmt1300 *float64
  if len(a) < (m * k) {
    err = &ArrayLengthError{fun:"Gemm",arg:"a"}
    return
  }
  if a != nil { _tmt1300 = (*C.MSKint32t)(&a[0]) }
  var _tmt1301 *float64
  if len(b) < (k * n) {
    err = &ArrayLengthError{fun:"Gemm",arg:"b"}
    return
  }
  if b != nil { _tmt1301 = (*C.MSKint32t)(&b[0]) }
  var _tmt1302 *float64
  if len(c) < (m * n) {
    err = &ArrayLengthError{fun:"Gemm",arg:"c"}
    return
  }
  if c != nil { _tmt1302 = (*C.MSKint32t)(&c[0]) }
  if _tmt1303 := C.MSK_gemm(self.ptr(),transa,transb,m,n,k,alpha,_tmt1300,_tmt1301,beta,_tmt1302); _tmt1303 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1303)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Gemv(transa Transpose,m int32,n int32,alpha float64,a []float64,x []float64,beta float64,y []float64) (err error) {
  var _tmt1304 *float64
  if len(a) < (n * m) {
    err = &ArrayLengthError{fun:"Gemv",arg:"a"}
    return
  }
  if a != nil { _tmt1304 = (*C.MSKint32t)(&a[0]) }
  var _tmt1306 *float64
  var _tmt1305 int32
  if (transa == transpose_no) {
    _tmt1305 = n
  } else {
    _tmt1305 = m
  }
  if len(x) < _tmt1305 {
    err = &ArrayLengthError{fun:"Gemv",arg:"x"}
    return
  }
  if x != nil { _tmt1306 = (*C.MSKint32t)(&x[0]) }
  var _tmt1308 *float64
  var _tmt1307 int32
  if (transa == transpose_no) {
    _tmt1307 = m
  } else {
    _tmt1307 = n
  }
  if len(y) < _tmt1307 {
    err = &ArrayLengthError{fun:"Gemv",arg:"y"}
    return
  }
  if y != nil { _tmt1308 = (*C.MSKint32t)(&y[0]) }
  if _tmt1309 := C.MSK_gemv(self.ptr(),transa,m,n,alpha,_tmt1304,_tmt1306,beta,_tmt1308); _tmt1309 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1309)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func GetCodeDesc(code Rescode) (symname string,str string,err error) {
  _tmt1310 := make([]byte,max_str_len)
  _tmt1311 := make([]byte,max_str_len)
  if _tmt1312 := C.MSK_getcodedesc(code,C.CString(&tmpvar1[0]),C.CString(&tmpvar1[0])); _tmt1312 != 0 {
    err = &MosekError{ code:_tmt1312 }
    return
  }
  var symname string
  if p := strings.IndexByte(_tmt1310,byte(0)); p < 0 {
    symname = string(_tmt1310)
  } else {
    symname = string(_tmt1310[:p])
  }
  var str string
  if p := strings.IndexByte(_tmt1311,byte(0)); p < 0 {
    str = string(_tmt1311)
  } else {
    str = string(_tmt1311[:p])
  }
  return
}
func GetVersion() (major int32,minor int32,revision int32,err error) {
  if _tmt1313 := C.MSK_getversion(&major,&minor,&revision); _tmt1313 != 0 {
    err = &MosekError{ code:_tmt1313 }
    return
  }
  return
}
func LicenseCleanup() (err error) {
  if _tmt1314 := C.MSK_licensecleanup(); _tmt1314 != 0 {
    err = &MosekError{ code:_tmt1314 }
    return
  }
  return
}
func (self *Env) Linkfiletostream(whichstream Streamtype,filename string,append int32) (err error) {
  _tmt1315 := C.CString(filename)
  if _tmt1316 := C.MSK_linkfiletoenvstream(self.ptr(),whichstream,_tmt1315,append); _tmt1316 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1316)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Potrf(uplo Uplo,n int32,a []float64) (err error) {
  var _tmt1317 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Potrf",arg:"a"}
    return
  }
  if a != nil { _tmt1317 = (*C.MSKint32t)(&a[0]) }
  if _tmt1318 := C.MSK_potrf(self.ptr(),uplo,n,_tmt1317); _tmt1318 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1318)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseCode(code []int32) (err error) {
  var _tmt1319 *int32
  if len(code) < license_buffer_length {
    err = &ArrayLengthError{fun:"PutLicenseCode",arg:"code"}
    return
  }
  if code != nil { _tmt1319 = (*C.MSKint32t)(&code[0]) }
  if _tmt1320 := C.MSK_putlicensecode(self.ptr(),_tmt1319); _tmt1320 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1320)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseDebug(licdebug int32) (err error) {
  if _tmt1321 := C.MSK_putlicensedebug(self.ptr(),licdebug); _tmt1321 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1321)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicensePath(licensepath string) (err error) {
  _tmt1322 := C.CString(licensepath)
  if _tmt1323 := C.MSK_putlicensepath(self.ptr(),_tmt1322); _tmt1323 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1323)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseWait(licwait int32) (err error) {
  if _tmt1324 := C.MSK_putlicensewait(self.ptr(),licwait); _tmt1324 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1324)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) ResetExpiryLicenses() (err error) {
  if _tmt1325 := C.MSK_resetexpirylicenses(self.ptr()); _tmt1325 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1325)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syeig(uplo Uplo,n int32,a []float64) (w []float64,err error) {
  var _tmt1326 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Syeig",arg:"a"}
    return
  }
  if a != nil { _tmt1326 = (*C.MSKint32t)(&a[0]) }
  var _tmt1327 *float64
  w := make([]float64,n)
  if len(w) > 0 { _tmt1327 = (*float64)(&n[0]) }
  if _tmt1328 := C.MSK_syeig(self.ptr(),uplo,n,_tmt1326,_tmt1327); _tmt1328 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1328)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syevd(uplo Uplo,n int32,a []float64) (w []float64,err error) {
  var _tmt1329 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Syevd",arg:"a"}
    return
  }
  if a != nil { _tmt1329 = (*C.MSKint32t)(&a[0]) }
  var _tmt1330 *float64
  w := make([]float64,n)
  if len(w) > 0 { _tmt1330 = (*float64)(&n[0]) }
  if _tmt1331 := C.MSK_syevd(self.ptr(),uplo,n,_tmt1329,_tmt1330); _tmt1331 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1331)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syrk(uplo Uplo,trans Transpose,n int32,k int32,alpha float64,a []float64,beta float64,c []float64) (err error) {
  var _tmt1332 *float64
  if len(a) < (n * k) {
    err = &ArrayLengthError{fun:"Syrk",arg:"a"}
    return
  }
  if a != nil { _tmt1332 = (*C.MSKint32t)(&a[0]) }
  var _tmt1333 *float64
  if len(c) < (n * n) {
    err = &ArrayLengthError{fun:"Syrk",arg:"c"}
    return
  }
  if c != nil { _tmt1333 = (*C.MSKint32t)(&c[0]) }
  if _tmt1334 := C.MSK_syrk(self.ptr(),uplo,trans,n,k,alpha,_tmt1332,beta,_tmt1333); _tmt1334 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1334)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}


