package mosek

// Generated for MOSEK [10, 1, 8]

// #include <stdlib.h>
// #include <mosek.h>
// #cgo LDFLAGS: -lmosek64
//
// extern void streamfunc_log(void *, char *);
// extern void streamfunc_wrn(void *, char *);
// extern void streamfunc_msg(void *, char *);
// extern void streamfunc_err(void *, char *);
// extern int callbackfunc(void *, void *, int, double *, int *, long long *);
import (
    "C"
    "unsafe"
    "fmt"
    "golang.org/x/exp/constraints"
)

// Constants
type Basindtype int32
const (
    MSK_BI_NEVER Basindtype = 0
    MSK_BI_ALWAYS Basindtype = 1
    MSK_BI_NO_ERROR Basindtype = 2
    MSK_BI_IF_FEASIBLE Basindtype = 3
    MSK_BI_RESERVERED Basindtype = 4
)
type Boundkey int32
const (
    MSK_BK_LO Boundkey = 0
    MSK_BK_UP Boundkey = 1
    MSK_BK_FX Boundkey = 2
    MSK_BK_FR Boundkey = 3
    MSK_BK_RA Boundkey = 4
)
type Mark int32
const (
    MSK_MARK_LO Mark = 0
    MSK_MARK_UP Mark = 1
)
type Simdegen int32
const (
    MSK_SIM_DEGEN_NONE Simdegen = 0
    MSK_SIM_DEGEN_FREE Simdegen = 1
    MSK_SIM_DEGEN_AGGRESSIVE Simdegen = 2
    MSK_SIM_DEGEN_MODERATE Simdegen = 3
    MSK_SIM_DEGEN_MINIMUM Simdegen = 4
)
type Transpose int32
const (
    MSK_TRANSPOSE_NO Transpose = 0
    MSK_TRANSPOSE_YES Transpose = 1
)
type Uplo int32
const (
    MSK_UPLO_LO Uplo = 0
    MSK_UPLO_UP Uplo = 1
)
type Simreform int32
const (
    MSK_SIM_REFORMULATION_OFF Simreform = 0
    MSK_SIM_REFORMULATION_ON Simreform = 1
    MSK_SIM_REFORMULATION_FREE Simreform = 2
    MSK_SIM_REFORMULATION_AGGRESSIVE Simreform = 3
)
type Simdupvec int32
const (
    MSK_SIM_EXPLOIT_DUPVEC_OFF Simdupvec = 0
    MSK_SIM_EXPLOIT_DUPVEC_ON Simdupvec = 1
    MSK_SIM_EXPLOIT_DUPVEC_FREE Simdupvec = 2
)
type Simhotstart int32
const (
    MSK_SIM_HOTSTART_NONE Simhotstart = 0
    MSK_SIM_HOTSTART_FREE Simhotstart = 1
    MSK_SIM_HOTSTART_STATUS_KEYS Simhotstart = 2
)
type Intpnthotstart int32
const (
    MSK_INTPNT_HOTSTART_NONE Intpnthotstart = 0
    MSK_INTPNT_HOTSTART_PRIMAL Intpnthotstart = 1
    MSK_INTPNT_HOTSTART_DUAL Intpnthotstart = 2
    MSK_INTPNT_HOTSTART_PRIMAL_DUAL Intpnthotstart = 3
)
type Purify int32
const (
    MSK_PURIFY_NONE Purify = 0
    MSK_PURIFY_PRIMAL Purify = 1
    MSK_PURIFY_DUAL Purify = 2
    MSK_PURIFY_PRIMAL_DUAL Purify = 3
    MSK_PURIFY_AUTO Purify = 4
)
type Callbackcode int32
const (
    MSK_CALLBACK_BEGIN_BI Callbackcode = 0
    MSK_CALLBACK_BEGIN_CONIC Callbackcode = 1
    MSK_CALLBACK_BEGIN_DUAL_BI Callbackcode = 2
    MSK_CALLBACK_BEGIN_DUAL_SENSITIVITY Callbackcode = 3
    MSK_CALLBACK_BEGIN_DUAL_SETUP_BI Callbackcode = 4
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX Callbackcode = 5
    MSK_CALLBACK_BEGIN_DUAL_SIMPLEX_BI Callbackcode = 6
    MSK_CALLBACK_BEGIN_INFEAS_ANA Callbackcode = 7
    MSK_CALLBACK_BEGIN_INTPNT Callbackcode = 8
    MSK_CALLBACK_BEGIN_LICENSE_WAIT Callbackcode = 9
    MSK_CALLBACK_BEGIN_MIO Callbackcode = 10
    MSK_CALLBACK_BEGIN_OPTIMIZER Callbackcode = 11
    MSK_CALLBACK_BEGIN_PRESOLVE Callbackcode = 12
    MSK_CALLBACK_BEGIN_PRIMAL_BI Callbackcode = 13
    MSK_CALLBACK_BEGIN_PRIMAL_REPAIR Callbackcode = 14
    MSK_CALLBACK_BEGIN_PRIMAL_SENSITIVITY Callbackcode = 15
    MSK_CALLBACK_BEGIN_PRIMAL_SETUP_BI Callbackcode = 16
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX Callbackcode = 17
    MSK_CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI Callbackcode = 18
    MSK_CALLBACK_BEGIN_QCQO_REFORMULATE Callbackcode = 19
    MSK_CALLBACK_BEGIN_READ Callbackcode = 20
    MSK_CALLBACK_BEGIN_ROOT_CUTGEN Callbackcode = 21
    MSK_CALLBACK_BEGIN_SIMPLEX Callbackcode = 22
    MSK_CALLBACK_BEGIN_SIMPLEX_BI Callbackcode = 23
    MSK_CALLBACK_BEGIN_SOLVE_ROOT_RELAX Callbackcode = 24
    MSK_CALLBACK_BEGIN_TO_CONIC Callbackcode = 25
    MSK_CALLBACK_BEGIN_WRITE Callbackcode = 26
    MSK_CALLBACK_CONIC Callbackcode = 27
    MSK_CALLBACK_DUAL_SIMPLEX Callbackcode = 28
    MSK_CALLBACK_END_BI Callbackcode = 29
    MSK_CALLBACK_END_CONIC Callbackcode = 30
    MSK_CALLBACK_END_DUAL_BI Callbackcode = 31
    MSK_CALLBACK_END_DUAL_SENSITIVITY Callbackcode = 32
    MSK_CALLBACK_END_DUAL_SETUP_BI Callbackcode = 33
    MSK_CALLBACK_END_DUAL_SIMPLEX Callbackcode = 34
    MSK_CALLBACK_END_DUAL_SIMPLEX_BI Callbackcode = 35
    MSK_CALLBACK_END_INFEAS_ANA Callbackcode = 36
    MSK_CALLBACK_END_INTPNT Callbackcode = 37
    MSK_CALLBACK_END_LICENSE_WAIT Callbackcode = 38
    MSK_CALLBACK_END_MIO Callbackcode = 39
    MSK_CALLBACK_END_OPTIMIZER Callbackcode = 40
    MSK_CALLBACK_END_PRESOLVE Callbackcode = 41
    MSK_CALLBACK_END_PRIMAL_BI Callbackcode = 42
    MSK_CALLBACK_END_PRIMAL_REPAIR Callbackcode = 43
    MSK_CALLBACK_END_PRIMAL_SENSITIVITY Callbackcode = 44
    MSK_CALLBACK_END_PRIMAL_SETUP_BI Callbackcode = 45
    MSK_CALLBACK_END_PRIMAL_SIMPLEX Callbackcode = 46
    MSK_CALLBACK_END_PRIMAL_SIMPLEX_BI Callbackcode = 47
    MSK_CALLBACK_END_QCQO_REFORMULATE Callbackcode = 48
    MSK_CALLBACK_END_READ Callbackcode = 49
    MSK_CALLBACK_END_ROOT_CUTGEN Callbackcode = 50
    MSK_CALLBACK_END_SIMPLEX Callbackcode = 51
    MSK_CALLBACK_END_SIMPLEX_BI Callbackcode = 52
    MSK_CALLBACK_END_SOLVE_ROOT_RELAX Callbackcode = 53
    MSK_CALLBACK_END_TO_CONIC Callbackcode = 54
    MSK_CALLBACK_END_WRITE Callbackcode = 55
    MSK_CALLBACK_IM_BI Callbackcode = 56
    MSK_CALLBACK_IM_CONIC Callbackcode = 57
    MSK_CALLBACK_IM_DUAL_BI Callbackcode = 58
    MSK_CALLBACK_IM_DUAL_SENSIVITY Callbackcode = 59
    MSK_CALLBACK_IM_DUAL_SIMPLEX Callbackcode = 60
    MSK_CALLBACK_IM_INTPNT Callbackcode = 61
    MSK_CALLBACK_IM_LICENSE_WAIT Callbackcode = 62
    MSK_CALLBACK_IM_LU Callbackcode = 63
    MSK_CALLBACK_IM_MIO Callbackcode = 64
    MSK_CALLBACK_IM_MIO_DUAL_SIMPLEX Callbackcode = 65
    MSK_CALLBACK_IM_MIO_INTPNT Callbackcode = 66
    MSK_CALLBACK_IM_MIO_PRIMAL_SIMPLEX Callbackcode = 67
    MSK_CALLBACK_IM_ORDER Callbackcode = 68
    MSK_CALLBACK_IM_PRESOLVE Callbackcode = 69
    MSK_CALLBACK_IM_PRIMAL_BI Callbackcode = 70
    MSK_CALLBACK_IM_PRIMAL_SENSIVITY Callbackcode = 71
    MSK_CALLBACK_IM_PRIMAL_SIMPLEX Callbackcode = 72
    MSK_CALLBACK_IM_QO_REFORMULATE Callbackcode = 73
    MSK_CALLBACK_IM_READ Callbackcode = 74
    MSK_CALLBACK_IM_ROOT_CUTGEN Callbackcode = 75
    MSK_CALLBACK_IM_SIMPLEX Callbackcode = 76
    MSK_CALLBACK_IM_SIMPLEX_BI Callbackcode = 77
    MSK_CALLBACK_INTPNT Callbackcode = 78
    MSK_CALLBACK_NEW_INT_MIO Callbackcode = 79
    MSK_CALLBACK_PRIMAL_SIMPLEX Callbackcode = 80
    MSK_CALLBACK_READ_OPF Callbackcode = 81
    MSK_CALLBACK_READ_OPF_SECTION Callbackcode = 82
    MSK_CALLBACK_RESTART_MIO Callbackcode = 83
    MSK_CALLBACK_SOLVING_REMOTE Callbackcode = 84
    MSK_CALLBACK_UPDATE_DUAL_BI Callbackcode = 85
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX Callbackcode = 86
    MSK_CALLBACK_UPDATE_DUAL_SIMPLEX_BI Callbackcode = 87
    MSK_CALLBACK_UPDATE_PRESOLVE Callbackcode = 88
    MSK_CALLBACK_UPDATE_PRIMAL_BI Callbackcode = 89
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX Callbackcode = 90
    MSK_CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI Callbackcode = 91
    MSK_CALLBACK_UPDATE_SIMPLEX Callbackcode = 92
    MSK_CALLBACK_WRITE_OPF Callbackcode = 93
)
type Compresstype int32
const (
    MSK_COMPRESS_NONE Compresstype = 0
    MSK_COMPRESS_FREE Compresstype = 1
    MSK_COMPRESS_GZIP Compresstype = 2
    MSK_COMPRESS_ZSTD Compresstype = 3
)
type Conetype int32
const (
    MSK_CT_QUAD Conetype = 0
    MSK_CT_RQUAD Conetype = 1
    MSK_CT_PEXP Conetype = 2
    MSK_CT_DEXP Conetype = 3
    MSK_CT_PPOW Conetype = 4
    MSK_CT_DPOW Conetype = 5
    MSK_CT_ZERO Conetype = 6
)
type Domaintype int32
const (
    MSK_DOMAIN_R Domaintype = 0
    MSK_DOMAIN_RZERO Domaintype = 1
    MSK_DOMAIN_RPLUS Domaintype = 2
    MSK_DOMAIN_RMINUS Domaintype = 3
    MSK_DOMAIN_QUADRATIC_CONE Domaintype = 4
    MSK_DOMAIN_RQUADRATIC_CONE Domaintype = 5
    MSK_DOMAIN_PRIMAL_EXP_CONE Domaintype = 6
    MSK_DOMAIN_DUAL_EXP_CONE Domaintype = 7
    MSK_DOMAIN_PRIMAL_POWER_CONE Domaintype = 8
    MSK_DOMAIN_DUAL_POWER_CONE Domaintype = 9
    MSK_DOMAIN_PRIMAL_GEO_MEAN_CONE Domaintype = 10
    MSK_DOMAIN_DUAL_GEO_MEAN_CONE Domaintype = 11
    MSK_DOMAIN_SVEC_PSD_CONE Domaintype = 12
)
type Nametype int32
const (
    MSK_NAME_TYPE_GEN Nametype = 0
    MSK_NAME_TYPE_MPS Nametype = 1
    MSK_NAME_TYPE_LP Nametype = 2
)
type Symmattype int32
const (
    MSK_SYMMAT_TYPE_SPARSE Symmattype = 0
)
type Dataformat int32
const (
    MSK_DATA_FORMAT_EXTENSION Dataformat = 0
    MSK_DATA_FORMAT_MPS Dataformat = 1
    MSK_DATA_FORMAT_LP Dataformat = 2
    MSK_DATA_FORMAT_OP Dataformat = 3
    MSK_DATA_FORMAT_FREE_MPS Dataformat = 4
    MSK_DATA_FORMAT_TASK Dataformat = 5
    MSK_DATA_FORMAT_PTF Dataformat = 6
    MSK_DATA_FORMAT_CB Dataformat = 7
    MSK_DATA_FORMAT_JSON_TASK Dataformat = 8
)
type Solformat int32
const (
    MSK_SOL_FORMAT_EXTENSION Solformat = 0
    MSK_SOL_FORMAT_B Solformat = 1
    MSK_SOL_FORMAT_TASK Solformat = 2
    MSK_SOL_FORMAT_JSON_TASK Solformat = 3
)
type Dinfitem int32
const (
    MSK_DINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY Dinfitem = 0
    MSK_DINF_BI_CLEAN_DUAL_TIME Dinfitem = 1
    MSK_DINF_BI_CLEAN_PRIMAL_TIME Dinfitem = 2
    MSK_DINF_BI_CLEAN_TIME Dinfitem = 3
    MSK_DINF_BI_DUAL_TIME Dinfitem = 4
    MSK_DINF_BI_PRIMAL_TIME Dinfitem = 5
    MSK_DINF_BI_TIME Dinfitem = 6
    MSK_DINF_INTPNT_DUAL_FEAS Dinfitem = 7
    MSK_DINF_INTPNT_DUAL_OBJ Dinfitem = 8
    MSK_DINF_INTPNT_FACTOR_NUM_FLOPS Dinfitem = 9
    MSK_DINF_INTPNT_OPT_STATUS Dinfitem = 10
    MSK_DINF_INTPNT_ORDER_TIME Dinfitem = 11
    MSK_DINF_INTPNT_PRIMAL_FEAS Dinfitem = 12
    MSK_DINF_INTPNT_PRIMAL_OBJ Dinfitem = 13
    MSK_DINF_INTPNT_TIME Dinfitem = 14
    MSK_DINF_MIO_CLIQUE_SELECTION_TIME Dinfitem = 15
    MSK_DINF_MIO_CLIQUE_SEPARATION_TIME Dinfitem = 16
    MSK_DINF_MIO_CMIR_SELECTION_TIME Dinfitem = 17
    MSK_DINF_MIO_CMIR_SEPARATION_TIME Dinfitem = 18
    MSK_DINF_MIO_CONSTRUCT_SOLUTION_OBJ Dinfitem = 19
    MSK_DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE Dinfitem = 20
    MSK_DINF_MIO_GMI_SELECTION_TIME Dinfitem = 21
    MSK_DINF_MIO_GMI_SEPARATION_TIME Dinfitem = 22
    MSK_DINF_MIO_IMPLIED_BOUND_SELECTION_TIME Dinfitem = 23
    MSK_DINF_MIO_IMPLIED_BOUND_SEPARATION_TIME Dinfitem = 24
    MSK_DINF_MIO_INITIAL_FEASIBLE_SOLUTION_OBJ Dinfitem = 25
    MSK_DINF_MIO_KNAPSACK_COVER_SELECTION_TIME Dinfitem = 26
    MSK_DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME Dinfitem = 27
    MSK_DINF_MIO_LIPRO_SELECTION_TIME Dinfitem = 28
    MSK_DINF_MIO_LIPRO_SEPARATION_TIME Dinfitem = 29
    MSK_DINF_MIO_OBJ_ABS_GAP Dinfitem = 30
    MSK_DINF_MIO_OBJ_BOUND Dinfitem = 31
    MSK_DINF_MIO_OBJ_INT Dinfitem = 32
    MSK_DINF_MIO_OBJ_REL_GAP Dinfitem = 33
    MSK_DINF_MIO_PROBING_TIME Dinfitem = 34
    MSK_DINF_MIO_ROOT_CUT_SELECTION_TIME Dinfitem = 35
    MSK_DINF_MIO_ROOT_CUT_SEPARATION_TIME Dinfitem = 36
    MSK_DINF_MIO_ROOT_OPTIMIZER_TIME Dinfitem = 37
    MSK_DINF_MIO_ROOT_PRESOLVE_TIME Dinfitem = 38
    MSK_DINF_MIO_ROOT_TIME Dinfitem = 39
    MSK_DINF_MIO_SYMMETRY_DETECTION_TIME Dinfitem = 40
    MSK_DINF_MIO_SYMMETRY_FACTOR Dinfitem = 41
    MSK_DINF_MIO_TIME Dinfitem = 42
    MSK_DINF_MIO_USER_OBJ_CUT Dinfitem = 43
    MSK_DINF_OPTIMIZER_TICKS Dinfitem = 44
    MSK_DINF_OPTIMIZER_TIME Dinfitem = 45
    MSK_DINF_PRESOLVE_ELI_TIME Dinfitem = 46
    MSK_DINF_PRESOLVE_LINDEP_TIME Dinfitem = 47
    MSK_DINF_PRESOLVE_TIME Dinfitem = 48
    MSK_DINF_PRESOLVE_TOTAL_PRIMAL_PERTURBATION Dinfitem = 49
    MSK_DINF_PRIMAL_REPAIR_PENALTY_OBJ Dinfitem = 50
    MSK_DINF_QCQO_REFORMULATE_MAX_PERTURBATION Dinfitem = 51
    MSK_DINF_QCQO_REFORMULATE_TIME Dinfitem = 52
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING Dinfitem = 53
    MSK_DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING Dinfitem = 54
    MSK_DINF_READ_DATA_TIME Dinfitem = 55
    MSK_DINF_REMOTE_TIME Dinfitem = 56
    MSK_DINF_SIM_DUAL_TIME Dinfitem = 57
    MSK_DINF_SIM_FEAS Dinfitem = 58
    MSK_DINF_SIM_OBJ Dinfitem = 59
    MSK_DINF_SIM_PRIMAL_TIME Dinfitem = 60
    MSK_DINF_SIM_TIME Dinfitem = 61
    MSK_DINF_SOL_BAS_DUAL_OBJ Dinfitem = 62
    MSK_DINF_SOL_BAS_DVIOLCON Dinfitem = 63
    MSK_DINF_SOL_BAS_DVIOLVAR Dinfitem = 64
    MSK_DINF_SOL_BAS_NRM_BARX Dinfitem = 65
    MSK_DINF_SOL_BAS_NRM_SLC Dinfitem = 66
    MSK_DINF_SOL_BAS_NRM_SLX Dinfitem = 67
    MSK_DINF_SOL_BAS_NRM_SUC Dinfitem = 68
    MSK_DINF_SOL_BAS_NRM_SUX Dinfitem = 69
    MSK_DINF_SOL_BAS_NRM_XC Dinfitem = 70
    MSK_DINF_SOL_BAS_NRM_XX Dinfitem = 71
    MSK_DINF_SOL_BAS_NRM_Y Dinfitem = 72
    MSK_DINF_SOL_BAS_PRIMAL_OBJ Dinfitem = 73
    MSK_DINF_SOL_BAS_PVIOLCON Dinfitem = 74
    MSK_DINF_SOL_BAS_PVIOLVAR Dinfitem = 75
    MSK_DINF_SOL_ITG_NRM_BARX Dinfitem = 76
    MSK_DINF_SOL_ITG_NRM_XC Dinfitem = 77
    MSK_DINF_SOL_ITG_NRM_XX Dinfitem = 78
    MSK_DINF_SOL_ITG_PRIMAL_OBJ Dinfitem = 79
    MSK_DINF_SOL_ITG_PVIOLACC Dinfitem = 80
    MSK_DINF_SOL_ITG_PVIOLBARVAR Dinfitem = 81
    MSK_DINF_SOL_ITG_PVIOLCON Dinfitem = 82
    MSK_DINF_SOL_ITG_PVIOLCONES Dinfitem = 83
    MSK_DINF_SOL_ITG_PVIOLDJC Dinfitem = 84
    MSK_DINF_SOL_ITG_PVIOLITG Dinfitem = 85
    MSK_DINF_SOL_ITG_PVIOLVAR Dinfitem = 86
    MSK_DINF_SOL_ITR_DUAL_OBJ Dinfitem = 87
    MSK_DINF_SOL_ITR_DVIOLACC Dinfitem = 88
    MSK_DINF_SOL_ITR_DVIOLBARVAR Dinfitem = 89
    MSK_DINF_SOL_ITR_DVIOLCON Dinfitem = 90
    MSK_DINF_SOL_ITR_DVIOLCONES Dinfitem = 91
    MSK_DINF_SOL_ITR_DVIOLVAR Dinfitem = 92
    MSK_DINF_SOL_ITR_NRM_BARS Dinfitem = 93
    MSK_DINF_SOL_ITR_NRM_BARX Dinfitem = 94
    MSK_DINF_SOL_ITR_NRM_SLC Dinfitem = 95
    MSK_DINF_SOL_ITR_NRM_SLX Dinfitem = 96
    MSK_DINF_SOL_ITR_NRM_SNX Dinfitem = 97
    MSK_DINF_SOL_ITR_NRM_SUC Dinfitem = 98
    MSK_DINF_SOL_ITR_NRM_SUX Dinfitem = 99
    MSK_DINF_SOL_ITR_NRM_XC Dinfitem = 100
    MSK_DINF_SOL_ITR_NRM_XX Dinfitem = 101
    MSK_DINF_SOL_ITR_NRM_Y Dinfitem = 102
    MSK_DINF_SOL_ITR_PRIMAL_OBJ Dinfitem = 103
    MSK_DINF_SOL_ITR_PVIOLACC Dinfitem = 104
    MSK_DINF_SOL_ITR_PVIOLBARVAR Dinfitem = 105
    MSK_DINF_SOL_ITR_PVIOLCON Dinfitem = 106
    MSK_DINF_SOL_ITR_PVIOLCONES Dinfitem = 107
    MSK_DINF_SOL_ITR_PVIOLVAR Dinfitem = 108
    MSK_DINF_TO_CONIC_TIME Dinfitem = 109
    MSK_DINF_WRITE_DATA_TIME Dinfitem = 110
)
type Feature int32
const (
    MSK_FEATURE_PTS Feature = 0
    MSK_FEATURE_PTON Feature = 1
)
type Dparam int32
const (
    MSK_DPAR_ANA_SOL_INFEAS_TOL Dparam = 0
    MSK_DPAR_BASIS_REL_TOL_S Dparam = 1
    MSK_DPAR_BASIS_TOL_S Dparam = 2
    MSK_DPAR_BASIS_TOL_X Dparam = 3
    MSK_DPAR_CHECK_CONVEXITY_REL_TOL Dparam = 4
    MSK_DPAR_DATA_SYM_MAT_TOL Dparam = 5
    MSK_DPAR_DATA_SYM_MAT_TOL_HUGE Dparam = 6
    MSK_DPAR_DATA_SYM_MAT_TOL_LARGE Dparam = 7
    MSK_DPAR_DATA_TOL_AIJ_HUGE Dparam = 8
    MSK_DPAR_DATA_TOL_AIJ_LARGE Dparam = 9
    MSK_DPAR_DATA_TOL_BOUND_INF Dparam = 10
    MSK_DPAR_DATA_TOL_BOUND_WRN Dparam = 11
    MSK_DPAR_DATA_TOL_C_HUGE Dparam = 12
    MSK_DPAR_DATA_TOL_CJ_LARGE Dparam = 13
    MSK_DPAR_DATA_TOL_QIJ Dparam = 14
    MSK_DPAR_DATA_TOL_X Dparam = 15
    MSK_DPAR_INTPNT_CO_TOL_DFEAS Dparam = 16
    MSK_DPAR_INTPNT_CO_TOL_INFEAS Dparam = 17
    MSK_DPAR_INTPNT_CO_TOL_MU_RED Dparam = 18
    MSK_DPAR_INTPNT_CO_TOL_NEAR_REL Dparam = 19
    MSK_DPAR_INTPNT_CO_TOL_PFEAS Dparam = 20
    MSK_DPAR_INTPNT_CO_TOL_REL_GAP Dparam = 21
    MSK_DPAR_INTPNT_QO_TOL_DFEAS Dparam = 22
    MSK_DPAR_INTPNT_QO_TOL_INFEAS Dparam = 23
    MSK_DPAR_INTPNT_QO_TOL_MU_RED Dparam = 24
    MSK_DPAR_INTPNT_QO_TOL_NEAR_REL Dparam = 25
    MSK_DPAR_INTPNT_QO_TOL_PFEAS Dparam = 26
    MSK_DPAR_INTPNT_QO_TOL_REL_GAP Dparam = 27
    MSK_DPAR_INTPNT_TOL_DFEAS Dparam = 28
    MSK_DPAR_INTPNT_TOL_DSAFE Dparam = 29
    MSK_DPAR_INTPNT_TOL_INFEAS Dparam = 30
    MSK_DPAR_INTPNT_TOL_MU_RED Dparam = 31
    MSK_DPAR_INTPNT_TOL_PATH Dparam = 32
    MSK_DPAR_INTPNT_TOL_PFEAS Dparam = 33
    MSK_DPAR_INTPNT_TOL_PSAFE Dparam = 34
    MSK_DPAR_INTPNT_TOL_REL_GAP Dparam = 35
    MSK_DPAR_INTPNT_TOL_REL_STEP Dparam = 36
    MSK_DPAR_INTPNT_TOL_STEP_SIZE Dparam = 37
    MSK_DPAR_LOWER_OBJ_CUT Dparam = 38
    MSK_DPAR_LOWER_OBJ_CUT_FINITE_TRH Dparam = 39
    MSK_DPAR_MIO_DJC_MAX_BIGM Dparam = 40
    MSK_DPAR_MIO_MAX_TIME Dparam = 41
    MSK_DPAR_MIO_REL_GAP_CONST Dparam = 42
    MSK_DPAR_MIO_TOL_ABS_GAP Dparam = 43
    MSK_DPAR_MIO_TOL_ABS_RELAX_INT Dparam = 44
    MSK_DPAR_MIO_TOL_FEAS Dparam = 45
    MSK_DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT Dparam = 46
    MSK_DPAR_MIO_TOL_REL_GAP Dparam = 47
    MSK_DPAR_OPTIMIZER_MAX_TICKS Dparam = 48
    MSK_DPAR_OPTIMIZER_MAX_TIME Dparam = 49
    MSK_DPAR_PRESOLVE_TOL_ABS_LINDEP Dparam = 50
    MSK_DPAR_PRESOLVE_TOL_AIJ Dparam = 51
    MSK_DPAR_PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION Dparam = 52
    MSK_DPAR_PRESOLVE_TOL_REL_LINDEP Dparam = 53
    MSK_DPAR_PRESOLVE_TOL_S Dparam = 54
    MSK_DPAR_PRESOLVE_TOL_X Dparam = 55
    MSK_DPAR_QCQO_REFORMULATE_REL_DROP_TOL Dparam = 56
    MSK_DPAR_SEMIDEFINITE_TOL_APPROX Dparam = 57
    MSK_DPAR_SIM_LU_TOL_REL_PIV Dparam = 58
    MSK_DPAR_SIMPLEX_ABS_TOL_PIV Dparam = 59
    MSK_DPAR_UPPER_OBJ_CUT Dparam = 60
    MSK_DPAR_UPPER_OBJ_CUT_FINITE_TRH Dparam = 61
)
type Liinfitem int32
const (
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS Liinfitem = 0
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ Liinfitem = 1
    MSK_LIINF_ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS Liinfitem = 2
    MSK_LIINF_BI_CLEAN_DUAL_DEG_ITER Liinfitem = 3
    MSK_LIINF_BI_CLEAN_DUAL_ITER Liinfitem = 4
    MSK_LIINF_BI_CLEAN_PRIMAL_DEG_ITER Liinfitem = 5
    MSK_LIINF_BI_CLEAN_PRIMAL_ITER Liinfitem = 6
    MSK_LIINF_BI_DUAL_ITER Liinfitem = 7
    MSK_LIINF_BI_PRIMAL_ITER Liinfitem = 8
    MSK_LIINF_INTPNT_FACTOR_NUM_NZ Liinfitem = 9
    MSK_LIINF_MIO_ANZ Liinfitem = 10
    MSK_LIINF_MIO_INTPNT_ITER Liinfitem = 11
    MSK_LIINF_MIO_NUM_DUAL_ILLPOSED_CER Liinfitem = 12
    MSK_LIINF_MIO_NUM_PRIM_ILLPOSED_CER Liinfitem = 13
    MSK_LIINF_MIO_PRESOLVED_ANZ Liinfitem = 14
    MSK_LIINF_MIO_SIMPLEX_ITER Liinfitem = 15
    MSK_LIINF_RD_NUMACC Liinfitem = 16
    MSK_LIINF_RD_NUMANZ Liinfitem = 17
    MSK_LIINF_RD_NUMDJC Liinfitem = 18
    MSK_LIINF_RD_NUMQNZ Liinfitem = 19
    MSK_LIINF_SIMPLEX_ITER Liinfitem = 20
)
type Iinfitem int32
const (
    MSK_IINF_ANA_PRO_NUM_CON Iinfitem = 0
    MSK_IINF_ANA_PRO_NUM_CON_EQ Iinfitem = 1
    MSK_IINF_ANA_PRO_NUM_CON_FR Iinfitem = 2
    MSK_IINF_ANA_PRO_NUM_CON_LO Iinfitem = 3
    MSK_IINF_ANA_PRO_NUM_CON_RA Iinfitem = 4
    MSK_IINF_ANA_PRO_NUM_CON_UP Iinfitem = 5
    MSK_IINF_ANA_PRO_NUM_VAR Iinfitem = 6
    MSK_IINF_ANA_PRO_NUM_VAR_BIN Iinfitem = 7
    MSK_IINF_ANA_PRO_NUM_VAR_CONT Iinfitem = 8
    MSK_IINF_ANA_PRO_NUM_VAR_EQ Iinfitem = 9
    MSK_IINF_ANA_PRO_NUM_VAR_FR Iinfitem = 10
    MSK_IINF_ANA_PRO_NUM_VAR_INT Iinfitem = 11
    MSK_IINF_ANA_PRO_NUM_VAR_LO Iinfitem = 12
    MSK_IINF_ANA_PRO_NUM_VAR_RA Iinfitem = 13
    MSK_IINF_ANA_PRO_NUM_VAR_UP Iinfitem = 14
    MSK_IINF_INTPNT_FACTOR_DIM_DENSE Iinfitem = 15
    MSK_IINF_INTPNT_ITER Iinfitem = 16
    MSK_IINF_INTPNT_NUM_THREADS Iinfitem = 17
    MSK_IINF_INTPNT_SOLVE_DUAL Iinfitem = 18
    MSK_IINF_MIO_ABSGAP_SATISFIED Iinfitem = 19
    MSK_IINF_MIO_CLIQUE_TABLE_SIZE Iinfitem = 20
    MSK_IINF_MIO_CONSTRUCT_SOLUTION Iinfitem = 21
    MSK_IINF_MIO_INITIAL_FEASIBLE_SOLUTION Iinfitem = 22
    MSK_IINF_MIO_NODE_DEPTH Iinfitem = 23
    MSK_IINF_MIO_NUM_ACTIVE_NODES Iinfitem = 24
    MSK_IINF_MIO_NUM_ACTIVE_ROOT_CUTS Iinfitem = 25
    MSK_IINF_MIO_NUM_BRANCH Iinfitem = 26
    MSK_IINF_MIO_NUM_INT_SOLUTIONS Iinfitem = 27
    MSK_IINF_MIO_NUM_RELAX Iinfitem = 28
    MSK_IINF_MIO_NUM_REPEATED_PRESOLVE Iinfitem = 29
    MSK_IINF_MIO_NUM_RESTARTS Iinfitem = 30
    MSK_IINF_MIO_NUM_ROOT_CUT_ROUNDS Iinfitem = 31
    MSK_IINF_MIO_NUM_SELECTED_CLIQUE_CUTS Iinfitem = 32
    MSK_IINF_MIO_NUM_SELECTED_CMIR_CUTS Iinfitem = 33
    MSK_IINF_MIO_NUM_SELECTED_GOMORY_CUTS Iinfitem = 34
    MSK_IINF_MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS Iinfitem = 35
    MSK_IINF_MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS Iinfitem = 36
    MSK_IINF_MIO_NUM_SELECTED_LIPRO_CUTS Iinfitem = 37
    MSK_IINF_MIO_NUM_SEPARATED_CLIQUE_CUTS Iinfitem = 38
    MSK_IINF_MIO_NUM_SEPARATED_CMIR_CUTS Iinfitem = 39
    MSK_IINF_MIO_NUM_SEPARATED_GOMORY_CUTS Iinfitem = 40
    MSK_IINF_MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS Iinfitem = 41
    MSK_IINF_MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS Iinfitem = 42
    MSK_IINF_MIO_NUM_SEPARATED_LIPRO_CUTS Iinfitem = 43
    MSK_IINF_MIO_NUM_SOLVED_NODES Iinfitem = 44
    MSK_IINF_MIO_NUMBIN Iinfitem = 45
    MSK_IINF_MIO_NUMBINCONEVAR Iinfitem = 46
    MSK_IINF_MIO_NUMCON Iinfitem = 47
    MSK_IINF_MIO_NUMCONE Iinfitem = 48
    MSK_IINF_MIO_NUMCONEVAR Iinfitem = 49
    MSK_IINF_MIO_NUMCONT Iinfitem = 50
    MSK_IINF_MIO_NUMCONTCONEVAR Iinfitem = 51
    MSK_IINF_MIO_NUMDEXPCONES Iinfitem = 52
    MSK_IINF_MIO_NUMDJC Iinfitem = 53
    MSK_IINF_MIO_NUMDPOWCONES Iinfitem = 54
    MSK_IINF_MIO_NUMINT Iinfitem = 55
    MSK_IINF_MIO_NUMINTCONEVAR Iinfitem = 56
    MSK_IINF_MIO_NUMPEXPCONES Iinfitem = 57
    MSK_IINF_MIO_NUMPPOWCONES Iinfitem = 58
    MSK_IINF_MIO_NUMQCONES Iinfitem = 59
    MSK_IINF_MIO_NUMRQCONES Iinfitem = 60
    MSK_IINF_MIO_NUMVAR Iinfitem = 61
    MSK_IINF_MIO_OBJ_BOUND_DEFINED Iinfitem = 62
    MSK_IINF_MIO_PRESOLVED_NUMBIN Iinfitem = 63
    MSK_IINF_MIO_PRESOLVED_NUMBINCONEVAR Iinfitem = 64
    MSK_IINF_MIO_PRESOLVED_NUMCON Iinfitem = 65
    MSK_IINF_MIO_PRESOLVED_NUMCONE Iinfitem = 66
    MSK_IINF_MIO_PRESOLVED_NUMCONEVAR Iinfitem = 67
    MSK_IINF_MIO_PRESOLVED_NUMCONT Iinfitem = 68
    MSK_IINF_MIO_PRESOLVED_NUMCONTCONEVAR Iinfitem = 69
    MSK_IINF_MIO_PRESOLVED_NUMDEXPCONES Iinfitem = 70
    MSK_IINF_MIO_PRESOLVED_NUMDJC Iinfitem = 71
    MSK_IINF_MIO_PRESOLVED_NUMDPOWCONES Iinfitem = 72
    MSK_IINF_MIO_PRESOLVED_NUMINT Iinfitem = 73
    MSK_IINF_MIO_PRESOLVED_NUMINTCONEVAR Iinfitem = 74
    MSK_IINF_MIO_PRESOLVED_NUMPEXPCONES Iinfitem = 75
    MSK_IINF_MIO_PRESOLVED_NUMPPOWCONES Iinfitem = 76
    MSK_IINF_MIO_PRESOLVED_NUMQCONES Iinfitem = 77
    MSK_IINF_MIO_PRESOLVED_NUMRQCONES Iinfitem = 78
    MSK_IINF_MIO_PRESOLVED_NUMVAR Iinfitem = 79
    MSK_IINF_MIO_RELGAP_SATISFIED Iinfitem = 80
    MSK_IINF_MIO_TOTAL_NUM_SELECTED_CUTS Iinfitem = 81
    MSK_IINF_MIO_TOTAL_NUM_SEPARATED_CUTS Iinfitem = 82
    MSK_IINF_MIO_USER_OBJ_CUT Iinfitem = 83
    MSK_IINF_OPT_NUMCON Iinfitem = 84
    MSK_IINF_OPT_NUMVAR Iinfitem = 85
    MSK_IINF_OPTIMIZE_RESPONSE Iinfitem = 86
    MSK_IINF_PRESOLVE_NUM_PRIMAL_PERTURBATIONS Iinfitem = 87
    MSK_IINF_PURIFY_DUAL_SUCCESS Iinfitem = 88
    MSK_IINF_PURIFY_PRIMAL_SUCCESS Iinfitem = 89
    MSK_IINF_RD_NUMBARVAR Iinfitem = 90
    MSK_IINF_RD_NUMCON Iinfitem = 91
    MSK_IINF_RD_NUMCONE Iinfitem = 92
    MSK_IINF_RD_NUMINTVAR Iinfitem = 93
    MSK_IINF_RD_NUMQ Iinfitem = 94
    MSK_IINF_RD_NUMVAR Iinfitem = 95
    MSK_IINF_RD_PROTYPE Iinfitem = 96
    MSK_IINF_SIM_DUAL_DEG_ITER Iinfitem = 97
    MSK_IINF_SIM_DUAL_HOTSTART Iinfitem = 98
    MSK_IINF_SIM_DUAL_HOTSTART_LU Iinfitem = 99
    MSK_IINF_SIM_DUAL_INF_ITER Iinfitem = 100
    MSK_IINF_SIM_DUAL_ITER Iinfitem = 101
    MSK_IINF_SIM_NUMCON Iinfitem = 102
    MSK_IINF_SIM_NUMVAR Iinfitem = 103
    MSK_IINF_SIM_PRIMAL_DEG_ITER Iinfitem = 104
    MSK_IINF_SIM_PRIMAL_HOTSTART Iinfitem = 105
    MSK_IINF_SIM_PRIMAL_HOTSTART_LU Iinfitem = 106
    MSK_IINF_SIM_PRIMAL_INF_ITER Iinfitem = 107
    MSK_IINF_SIM_PRIMAL_ITER Iinfitem = 108
    MSK_IINF_SIM_SOLVE_DUAL Iinfitem = 109
    MSK_IINF_SOL_BAS_PROSTA Iinfitem = 110
    MSK_IINF_SOL_BAS_SOLSTA Iinfitem = 111
    MSK_IINF_SOL_ITG_PROSTA Iinfitem = 112
    MSK_IINF_SOL_ITG_SOLSTA Iinfitem = 113
    MSK_IINF_SOL_ITR_PROSTA Iinfitem = 114
    MSK_IINF_SOL_ITR_SOLSTA Iinfitem = 115
    MSK_IINF_STO_NUM_A_REALLOC Iinfitem = 116
)
type Inftype int32
const (
    MSK_INF_DOU_TYPE Inftype = 0
    MSK_INF_INT_TYPE Inftype = 1
    MSK_INF_LINT_TYPE Inftype = 2
)
type Iomode int32
const (
    MSK_IOMODE_READ Iomode = 0
    MSK_IOMODE_WRITE Iomode = 1
    MSK_IOMODE_READWRITE Iomode = 2
)
type Iparam int32
const (
    MSK_IPAR_ANA_SOL_BASIS Iparam = 0
    MSK_IPAR_ANA_SOL_PRINT_VIOLATED Iparam = 1
    MSK_IPAR_AUTO_SORT_A_BEFORE_OPT Iparam = 2
    MSK_IPAR_AUTO_UPDATE_SOL_INFO Iparam = 3
    MSK_IPAR_BASIS_SOLVE_USE_PLUS_ONE Iparam = 4
    MSK_IPAR_BI_CLEAN_OPTIMIZER Iparam = 5
    MSK_IPAR_BI_IGNORE_MAX_ITER Iparam = 6
    MSK_IPAR_BI_IGNORE_NUM_ERROR Iparam = 7
    MSK_IPAR_BI_MAX_ITERATIONS Iparam = 8
    MSK_IPAR_CACHE_LICENSE Iparam = 9
    MSK_IPAR_COMPRESS_STATFILE Iparam = 10
    MSK_IPAR_INFEAS_GENERIC_NAMES Iparam = 11
    MSK_IPAR_INFEAS_PREFER_PRIMAL Iparam = 12
    MSK_IPAR_INFEAS_REPORT_AUTO Iparam = 13
    MSK_IPAR_INFEAS_REPORT_LEVEL Iparam = 14
    MSK_IPAR_INTPNT_BASIS Iparam = 15
    MSK_IPAR_INTPNT_DIFF_STEP Iparam = 16
    MSK_IPAR_INTPNT_HOTSTART Iparam = 17
    MSK_IPAR_INTPNT_MAX_ITERATIONS Iparam = 18
    MSK_IPAR_INTPNT_MAX_NUM_COR Iparam = 19
    MSK_IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS Iparam = 20
    MSK_IPAR_INTPNT_OFF_COL_TRH Iparam = 21
    MSK_IPAR_INTPNT_ORDER_GP_NUM_SEEDS Iparam = 22
    MSK_IPAR_INTPNT_ORDER_METHOD Iparam = 23
    MSK_IPAR_INTPNT_PURIFY Iparam = 24
    MSK_IPAR_INTPNT_REGULARIZATION_USE Iparam = 25
    MSK_IPAR_INTPNT_SCALING Iparam = 26
    MSK_IPAR_INTPNT_SOLVE_FORM Iparam = 27
    MSK_IPAR_INTPNT_STARTING_POINT Iparam = 28
    MSK_IPAR_LICENSE_DEBUG Iparam = 29
    MSK_IPAR_LICENSE_PAUSE_TIME Iparam = 30
    MSK_IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS Iparam = 31
    MSK_IPAR_LICENSE_TRH_EXPIRY_WRN Iparam = 32
    MSK_IPAR_LICENSE_WAIT Iparam = 33
    MSK_IPAR_LOG Iparam = 34
    MSK_IPAR_LOG_ANA_PRO Iparam = 35
    MSK_IPAR_LOG_BI Iparam = 36
    MSK_IPAR_LOG_BI_FREQ Iparam = 37
    MSK_IPAR_LOG_CUT_SECOND_OPT Iparam = 38
    MSK_IPAR_LOG_EXPAND Iparam = 39
    MSK_IPAR_LOG_FEAS_REPAIR Iparam = 40
    MSK_IPAR_LOG_FILE Iparam = 41
    MSK_IPAR_LOG_INCLUDE_SUMMARY Iparam = 42
    MSK_IPAR_LOG_INFEAS_ANA Iparam = 43
    MSK_IPAR_LOG_INTPNT Iparam = 44
    MSK_IPAR_LOG_LOCAL_INFO Iparam = 45
    MSK_IPAR_LOG_MIO Iparam = 46
    MSK_IPAR_LOG_MIO_FREQ Iparam = 47
    MSK_IPAR_LOG_ORDER Iparam = 48
    MSK_IPAR_LOG_PRESOLVE Iparam = 49
    MSK_IPAR_LOG_RESPONSE Iparam = 50
    MSK_IPAR_LOG_SENSITIVITY Iparam = 51
    MSK_IPAR_LOG_SENSITIVITY_OPT Iparam = 52
    MSK_IPAR_LOG_SIM Iparam = 53
    MSK_IPAR_LOG_SIM_FREQ Iparam = 54
    MSK_IPAR_LOG_SIM_MINOR Iparam = 55
    MSK_IPAR_LOG_STORAGE Iparam = 56
    MSK_IPAR_MAX_NUM_WARNINGS Iparam = 57
    MSK_IPAR_MIO_BRANCH_DIR Iparam = 58
    MSK_IPAR_MIO_CONIC_OUTER_APPROXIMATION Iparam = 59
    MSK_IPAR_MIO_CONSTRUCT_SOL Iparam = 60
    MSK_IPAR_MIO_CUT_CLIQUE Iparam = 61
    MSK_IPAR_MIO_CUT_CMIR Iparam = 62
    MSK_IPAR_MIO_CUT_GMI Iparam = 63
    MSK_IPAR_MIO_CUT_IMPLIED_BOUND Iparam = 64
    MSK_IPAR_MIO_CUT_KNAPSACK_COVER Iparam = 65
    MSK_IPAR_MIO_CUT_LIPRO Iparam = 66
    MSK_IPAR_MIO_CUT_SELECTION_LEVEL Iparam = 67
    MSK_IPAR_MIO_DATA_PERMUTATION_METHOD Iparam = 68
    MSK_IPAR_MIO_DUAL_RAY_ANALYSIS_LEVEL Iparam = 69
    MSK_IPAR_MIO_FEASPUMP_LEVEL Iparam = 70
    MSK_IPAR_MIO_HEURISTIC_LEVEL Iparam = 71
    MSK_IPAR_MIO_MAX_NUM_BRANCHES Iparam = 72
    MSK_IPAR_MIO_MAX_NUM_RELAXS Iparam = 73
    MSK_IPAR_MIO_MAX_NUM_RESTARTS Iparam = 74
    MSK_IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS Iparam = 75
    MSK_IPAR_MIO_MAX_NUM_SOLUTIONS Iparam = 76
    MSK_IPAR_MIO_MEMORY_EMPHASIS_LEVEL Iparam = 77
    MSK_IPAR_MIO_MIN_REL Iparam = 78
    MSK_IPAR_MIO_MODE Iparam = 79
    MSK_IPAR_MIO_NODE_OPTIMIZER Iparam = 80
    MSK_IPAR_MIO_NODE_SELECTION Iparam = 81
    MSK_IPAR_MIO_NUMERICAL_EMPHASIS_LEVEL Iparam = 82
    MSK_IPAR_MIO_PERSPECTIVE_REFORMULATE Iparam = 83
    MSK_IPAR_MIO_PRESOLVE_AGGREGATOR_USE Iparam = 84
    MSK_IPAR_MIO_PROBING_LEVEL Iparam = 85
    MSK_IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT Iparam = 86
    MSK_IPAR_MIO_QCQO_REFORMULATION_METHOD Iparam = 87
    MSK_IPAR_MIO_RINS_MAX_NODES Iparam = 88
    MSK_IPAR_MIO_ROOT_OPTIMIZER Iparam = 89
    MSK_IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL Iparam = 90
    MSK_IPAR_MIO_SEED Iparam = 91
    MSK_IPAR_MIO_SYMMETRY_LEVEL Iparam = 92
    MSK_IPAR_MIO_VAR_SELECTION Iparam = 93
    MSK_IPAR_MIO_VB_DETECTION_LEVEL Iparam = 94
    MSK_IPAR_MT_SPINCOUNT Iparam = 95
    MSK_IPAR_NG Iparam = 96
    MSK_IPAR_NUM_THREADS Iparam = 97
    MSK_IPAR_OPF_WRITE_HEADER Iparam = 98
    MSK_IPAR_OPF_WRITE_HINTS Iparam = 99
    MSK_IPAR_OPF_WRITE_LINE_LENGTH Iparam = 100
    MSK_IPAR_OPF_WRITE_PARAMETERS Iparam = 101
    MSK_IPAR_OPF_WRITE_PROBLEM Iparam = 102
    MSK_IPAR_OPF_WRITE_SOL_BAS Iparam = 103
    MSK_IPAR_OPF_WRITE_SOL_ITG Iparam = 104
    MSK_IPAR_OPF_WRITE_SOL_ITR Iparam = 105
    MSK_IPAR_OPF_WRITE_SOLUTIONS Iparam = 106
    MSK_IPAR_OPTIMIZER Iparam = 107
    MSK_IPAR_PARAM_READ_CASE_NAME Iparam = 108
    MSK_IPAR_PARAM_READ_IGN_ERROR Iparam = 109
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_FILL Iparam = 110
    MSK_IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES Iparam = 111
    MSK_IPAR_PRESOLVE_LEVEL Iparam = 112
    MSK_IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH Iparam = 113
    MSK_IPAR_PRESOLVE_LINDEP_NEW Iparam = 114
    MSK_IPAR_PRESOLVE_LINDEP_REL_WORK_TRH Iparam = 115
    MSK_IPAR_PRESOLVE_LINDEP_USE Iparam = 116
    MSK_IPAR_PRESOLVE_MAX_NUM_PASS Iparam = 117
    MSK_IPAR_PRESOLVE_MAX_NUM_REDUCTIONS Iparam = 118
    MSK_IPAR_PRESOLVE_USE Iparam = 119
    MSK_IPAR_PRIMAL_REPAIR_OPTIMIZER Iparam = 120
    MSK_IPAR_PTF_WRITE_PARAMETERS Iparam = 121
    MSK_IPAR_PTF_WRITE_SOLUTIONS Iparam = 122
    MSK_IPAR_PTF_WRITE_TRANSFORM Iparam = 123
    MSK_IPAR_READ_DEBUG Iparam = 124
    MSK_IPAR_READ_KEEP_FREE_CON Iparam = 125
    MSK_IPAR_READ_MPS_FORMAT Iparam = 126
    MSK_IPAR_READ_MPS_WIDTH Iparam = 127
    MSK_IPAR_READ_TASK_IGNORE_PARAM Iparam = 128
    MSK_IPAR_REMOTE_USE_COMPRESSION Iparam = 129
    MSK_IPAR_REMOVE_UNUSED_SOLUTIONS Iparam = 130
    MSK_IPAR_SENSITIVITY_ALL Iparam = 131
    MSK_IPAR_SENSITIVITY_OPTIMIZER Iparam = 132
    MSK_IPAR_SENSITIVITY_TYPE Iparam = 133
    MSK_IPAR_SIM_BASIS_FACTOR_USE Iparam = 134
    MSK_IPAR_SIM_DEGEN Iparam = 135
    MSK_IPAR_SIM_DETECT_PWL Iparam = 136
    MSK_IPAR_SIM_DUAL_CRASH Iparam = 137
    MSK_IPAR_SIM_DUAL_PHASEONE_METHOD Iparam = 138
    MSK_IPAR_SIM_DUAL_RESTRICT_SELECTION Iparam = 139
    MSK_IPAR_SIM_DUAL_SELECTION Iparam = 140
    MSK_IPAR_SIM_EXPLOIT_DUPVEC Iparam = 141
    MSK_IPAR_SIM_HOTSTART Iparam = 142
    MSK_IPAR_SIM_HOTSTART_LU Iparam = 143
    MSK_IPAR_SIM_MAX_ITERATIONS Iparam = 144
    MSK_IPAR_SIM_MAX_NUM_SETBACKS Iparam = 145
    MSK_IPAR_SIM_NON_SINGULAR Iparam = 146
    MSK_IPAR_SIM_PRIMAL_CRASH Iparam = 147
    MSK_IPAR_SIM_PRIMAL_PHASEONE_METHOD Iparam = 148
    MSK_IPAR_SIM_PRIMAL_RESTRICT_SELECTION Iparam = 149
    MSK_IPAR_SIM_PRIMAL_SELECTION Iparam = 150
    MSK_IPAR_SIM_REFACTOR_FREQ Iparam = 151
    MSK_IPAR_SIM_REFORMULATION Iparam = 152
    MSK_IPAR_SIM_SAVE_LU Iparam = 153
    MSK_IPAR_SIM_SCALING Iparam = 154
    MSK_IPAR_SIM_SCALING_METHOD Iparam = 155
    MSK_IPAR_SIM_SEED Iparam = 156
    MSK_IPAR_SIM_SOLVE_FORM Iparam = 157
    MSK_IPAR_SIM_STABILITY_PRIORITY Iparam = 158
    MSK_IPAR_SIM_SWITCH_OPTIMIZER Iparam = 159
    MSK_IPAR_SOL_FILTER_KEEP_BASIC Iparam = 160
    MSK_IPAR_SOL_FILTER_KEEP_RANGED Iparam = 161
    MSK_IPAR_SOL_READ_NAME_WIDTH Iparam = 162
    MSK_IPAR_SOL_READ_WIDTH Iparam = 163
    MSK_IPAR_SOLUTION_CALLBACK Iparam = 164
    MSK_IPAR_TIMING_LEVEL Iparam = 165
    MSK_IPAR_WRITE_BAS_CONSTRAINTS Iparam = 166
    MSK_IPAR_WRITE_BAS_HEAD Iparam = 167
    MSK_IPAR_WRITE_BAS_VARIABLES Iparam = 168
    MSK_IPAR_WRITE_COMPRESSION Iparam = 169
    MSK_IPAR_WRITE_DATA_PARAM Iparam = 170
    MSK_IPAR_WRITE_FREE_CON Iparam = 171
    MSK_IPAR_WRITE_GENERIC_NAMES Iparam = 172
    MSK_IPAR_WRITE_GENERIC_NAMES_IO Iparam = 173
    MSK_IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS Iparam = 174
    MSK_IPAR_WRITE_INT_CONSTRAINTS Iparam = 175
    MSK_IPAR_WRITE_INT_HEAD Iparam = 176
    MSK_IPAR_WRITE_INT_VARIABLES Iparam = 177
    MSK_IPAR_WRITE_JSON_INDENTATION Iparam = 178
    MSK_IPAR_WRITE_LP_FULL_OBJ Iparam = 179
    MSK_IPAR_WRITE_LP_LINE_WIDTH Iparam = 180
    MSK_IPAR_WRITE_MPS_FORMAT Iparam = 181
    MSK_IPAR_WRITE_MPS_INT Iparam = 182
    MSK_IPAR_WRITE_SOL_BARVARIABLES Iparam = 183
    MSK_IPAR_WRITE_SOL_CONSTRAINTS Iparam = 184
    MSK_IPAR_WRITE_SOL_HEAD Iparam = 185
    MSK_IPAR_WRITE_SOL_IGNORE_INVALID_NAMES Iparam = 186
    MSK_IPAR_WRITE_SOL_VARIABLES Iparam = 187
    MSK_IPAR_WRITE_TASK_INC_SOL Iparam = 188
    MSK_IPAR_WRITE_XML_MODE Iparam = 189
)
type Branchdir int32
const (
    MSK_BRANCH_DIR_FREE Branchdir = 0
    MSK_BRANCH_DIR_UP Branchdir = 1
    MSK_BRANCH_DIR_DOWN Branchdir = 2
    MSK_BRANCH_DIR_NEAR Branchdir = 3
    MSK_BRANCH_DIR_FAR Branchdir = 4
    MSK_BRANCH_DIR_ROOT_LP Branchdir = 5
    MSK_BRANCH_DIR_GUIDED Branchdir = 6
    MSK_BRANCH_DIR_PSEUDOCOST Branchdir = 7
)
type Miqcqoreformmethod int32
const (
    MSK_MIO_QCQO_REFORMULATION_METHOD_FREE Miqcqoreformmethod = 0
    MSK_MIO_QCQO_REFORMULATION_METHOD_NONE Miqcqoreformmethod = 1
    MSK_MIO_QCQO_REFORMULATION_METHOD_LINEARIZATION Miqcqoreformmethod = 2
    MSK_MIO_QCQO_REFORMULATION_METHOD_EIGEN_VAL_METHOD Miqcqoreformmethod = 3
    MSK_MIO_QCQO_REFORMULATION_METHOD_DIAG_SDP Miqcqoreformmethod = 4
    MSK_MIO_QCQO_REFORMULATION_METHOD_RELAX_SDP Miqcqoreformmethod = 5
)
type Miodatapermmethod int32
const (
    MSK_MIO_DATA_PERMUTATION_METHOD_NONE Miodatapermmethod = 0
    MSK_MIO_DATA_PERMUTATION_METHOD_CYCLIC_SHIFT Miodatapermmethod = 1
    MSK_MIO_DATA_PERMUTATION_METHOD_RANDOM Miodatapermmethod = 2
)
type Miocontsoltype int32
const (
    MSK_MIO_CONT_SOL_NONE Miocontsoltype = 0
    MSK_MIO_CONT_SOL_ROOT Miocontsoltype = 1
    MSK_MIO_CONT_SOL_ITG Miocontsoltype = 2
    MSK_MIO_CONT_SOL_ITG_REL Miocontsoltype = 3
)
type Miomode int32
const (
    MSK_MIO_MODE_IGNORED Miomode = 0
    MSK_MIO_MODE_SATISFIED Miomode = 1
)
type Mionodeseltype int32
const (
    MSK_MIO_NODE_SELECTION_FREE Mionodeseltype = 0
    MSK_MIO_NODE_SELECTION_FIRST Mionodeseltype = 1
    MSK_MIO_NODE_SELECTION_BEST Mionodeseltype = 2
    MSK_MIO_NODE_SELECTION_PSEUDO Mionodeseltype = 3
)
type Miovarseltype int32
const (
    MSK_MIO_VAR_SELECTION_FREE Miovarseltype = 0
    MSK_MIO_VAR_SELECTION_PSEUDOCOST Miovarseltype = 1
    MSK_MIO_VAR_SELECTION_STRONG Miovarseltype = 2
)
type Mpsformat int32
const (
    MSK_MPS_FORMAT_STRICT Mpsformat = 0
    MSK_MPS_FORMAT_RELAXED Mpsformat = 1
    MSK_MPS_FORMAT_FREE Mpsformat = 2
    MSK_MPS_FORMAT_CPLEX Mpsformat = 3
)
type Objsense int32
const (
    MSK_OBJECTIVE_SENSE_MINIMIZE Objsense = 0
    MSK_OBJECTIVE_SENSE_MAXIMIZE Objsense = 1
)
type Onoffkey int32
const (
    MSK_OFF Onoffkey = 0
    MSK_ON Onoffkey = 1
)
type Optimizertype int32
const (
    MSK_OPTIMIZER_CONIC Optimizertype = 0
    MSK_OPTIMIZER_DUAL_SIMPLEX Optimizertype = 1
    MSK_OPTIMIZER_FREE Optimizertype = 2
    MSK_OPTIMIZER_FREE_SIMPLEX Optimizertype = 3
    MSK_OPTIMIZER_INTPNT Optimizertype = 4
    MSK_OPTIMIZER_MIXED_INT Optimizertype = 5
    MSK_OPTIMIZER_PRIMAL_SIMPLEX Optimizertype = 6
)
type Orderingtype int32
const (
    MSK_ORDER_METHOD_FREE Orderingtype = 0
    MSK_ORDER_METHOD_APPMINLOC Orderingtype = 1
    MSK_ORDER_METHOD_EXPERIMENTAL Orderingtype = 2
    MSK_ORDER_METHOD_TRY_GRAPHPAR Orderingtype = 3
    MSK_ORDER_METHOD_FORCE_GRAPHPAR Orderingtype = 4
    MSK_ORDER_METHOD_NONE Orderingtype = 5
)
type Presolvemode int32
const (
    MSK_PRESOLVE_MODE_OFF Presolvemode = 0
    MSK_PRESOLVE_MODE_ON Presolvemode = 1
    MSK_PRESOLVE_MODE_FREE Presolvemode = 2
)
type Parametertype int32
const (
    MSK_PAR_INVALID_TYPE Parametertype = 0
    MSK_PAR_DOU_TYPE Parametertype = 1
    MSK_PAR_INT_TYPE Parametertype = 2
    MSK_PAR_STR_TYPE Parametertype = 3
)
type Problemitem int32
const (
    MSK_PI_VAR Problemitem = 0
    MSK_PI_CON Problemitem = 1
    MSK_PI_CONE Problemitem = 2
)
type Problemtype int32
const (
    MSK_PROBTYPE_LO Problemtype = 0
    MSK_PROBTYPE_QO Problemtype = 1
    MSK_PROBTYPE_QCQO Problemtype = 2
    MSK_PROBTYPE_CONIC Problemtype = 3
    MSK_PROBTYPE_MIXED Problemtype = 4
)
type Prosta int32
const (
    MSK_PRO_STA_UNKNOWN Prosta = 0
    MSK_PRO_STA_PRIM_AND_DUAL_FEAS Prosta = 1
    MSK_PRO_STA_PRIM_FEAS Prosta = 2
    MSK_PRO_STA_DUAL_FEAS Prosta = 3
    MSK_PRO_STA_PRIM_INFEAS Prosta = 4
    MSK_PRO_STA_DUAL_INFEAS Prosta = 5
    MSK_PRO_STA_PRIM_AND_DUAL_INFEAS Prosta = 6
    MSK_PRO_STA_ILL_POSED Prosta = 7
    MSK_PRO_STA_PRIM_INFEAS_OR_UNBOUNDED Prosta = 8
)
type Xmlwriteroutputtype int32
const (
    MSK_WRITE_XML_MODE_ROW Xmlwriteroutputtype = 0
    MSK_WRITE_XML_MODE_COL Xmlwriteroutputtype = 1
)
type Rescode int32
const (
    MSK_RES_OK Rescode = 0
    MSK_RES_WRN_OPEN_PARAM_FILE Rescode = 50
    MSK_RES_WRN_LARGE_BOUND Rescode = 51
    MSK_RES_WRN_LARGE_LO_BOUND Rescode = 52
    MSK_RES_WRN_LARGE_UP_BOUND Rescode = 53
    MSK_RES_WRN_LARGE_CON_FX Rescode = 54
    MSK_RES_WRN_LARGE_CJ Rescode = 57
    MSK_RES_WRN_LARGE_AIJ Rescode = 62
    MSK_RES_WRN_ZERO_AIJ Rescode = 63
    MSK_RES_WRN_NAME_MAX_LEN Rescode = 65
    MSK_RES_WRN_SPAR_MAX_LEN Rescode = 66
    MSK_RES_WRN_MPS_SPLIT_RHS_VECTOR Rescode = 70
    MSK_RES_WRN_MPS_SPLIT_RAN_VECTOR Rescode = 71
    MSK_RES_WRN_MPS_SPLIT_BOU_VECTOR Rescode = 72
    MSK_RES_WRN_LP_OLD_QUAD_FORMAT Rescode = 80
    MSK_RES_WRN_LP_DROP_VARIABLE Rescode = 85
    MSK_RES_WRN_NZ_IN_UPR_TRI Rescode = 200
    MSK_RES_WRN_DROPPED_NZ_QOBJ Rescode = 201
    MSK_RES_WRN_IGNORE_INTEGER Rescode = 250
    MSK_RES_WRN_NO_GLOBAL_OPTIMIZER Rescode = 251
    MSK_RES_WRN_MIO_INFEASIBLE_FINAL Rescode = 270
    MSK_RES_WRN_SOL_FILTER Rescode = 300
    MSK_RES_WRN_UNDEF_SOL_FILE_NAME Rescode = 350
    MSK_RES_WRN_SOL_FILE_IGNORED_CON Rescode = 351
    MSK_RES_WRN_SOL_FILE_IGNORED_VAR Rescode = 352
    MSK_RES_WRN_TOO_FEW_BASIS_VARS Rescode = 400
    MSK_RES_WRN_TOO_MANY_BASIS_VARS Rescode = 405
    MSK_RES_WRN_LICENSE_EXPIRE Rescode = 500
    MSK_RES_WRN_LICENSE_SERVER Rescode = 501
    MSK_RES_WRN_EMPTY_NAME Rescode = 502
    MSK_RES_WRN_USING_GENERIC_NAMES Rescode = 503
    MSK_RES_WRN_INVALID_MPS_NAME Rescode = 504
    MSK_RES_WRN_INVALID_MPS_OBJ_NAME Rescode = 505
    MSK_RES_WRN_LICENSE_FEATURE_EXPIRE Rescode = 509
    MSK_RES_WRN_PARAM_NAME_DOU Rescode = 510
    MSK_RES_WRN_PARAM_NAME_INT Rescode = 511
    MSK_RES_WRN_PARAM_NAME_STR Rescode = 512
    MSK_RES_WRN_PARAM_STR_VALUE Rescode = 515
    MSK_RES_WRN_PARAM_IGNORED_CMIO Rescode = 516
    MSK_RES_WRN_ZEROS_IN_SPARSE_ROW Rescode = 705
    MSK_RES_WRN_ZEROS_IN_SPARSE_COL Rescode = 710
    MSK_RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK Rescode = 800
    MSK_RES_WRN_ELIMINATOR_SPACE Rescode = 801
    MSK_RES_WRN_PRESOLVE_OUTOFSPACE Rescode = 802
    MSK_RES_WRN_PRESOLVE_PRIMAL_PERTUBATIONS Rescode = 803
    MSK_RES_WRN_WRITE_CHANGED_NAMES Rescode = 830
    MSK_RES_WRN_WRITE_DISCARDED_CFIX Rescode = 831
    MSK_RES_WRN_DUPLICATE_CONSTRAINT_NAMES Rescode = 850
    MSK_RES_WRN_DUPLICATE_VARIABLE_NAMES Rescode = 851
    MSK_RES_WRN_DUPLICATE_BARVARIABLE_NAMES Rescode = 852
    MSK_RES_WRN_DUPLICATE_CONE_NAMES Rescode = 853
    MSK_RES_WRN_WRITE_LP_INVALID_VAR_NAMES Rescode = 854
    MSK_RES_WRN_WRITE_LP_DUPLICATE_VAR_NAMES Rescode = 855
    MSK_RES_WRN_WRITE_LP_INVALID_CON_NAMES Rescode = 856
    MSK_RES_WRN_WRITE_LP_DUPLICATE_CON_NAMES Rescode = 857
    MSK_RES_WRN_ANA_LARGE_BOUNDS Rescode = 900
    MSK_RES_WRN_ANA_C_ZERO Rescode = 901
    MSK_RES_WRN_ANA_EMPTY_COLS Rescode = 902
    MSK_RES_WRN_ANA_CLOSE_BOUNDS Rescode = 903
    MSK_RES_WRN_ANA_ALMOST_INT_BOUNDS Rescode = 904
    MSK_RES_WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES Rescode = 930
    MSK_RES_WRN_NO_DUALIZER Rescode = 950
    MSK_RES_WRN_SYM_MAT_LARGE Rescode = 960
    MSK_RES_WRN_MODIFIED_DOUBLE_PARAMETER Rescode = 970
    MSK_RES_WRN_LARGE_FIJ Rescode = 980
    MSK_RES_ERR_LICENSE Rescode = 1000
    MSK_RES_ERR_LICENSE_EXPIRED Rescode = 1001
    MSK_RES_ERR_LICENSE_VERSION Rescode = 1002
    MSK_RES_ERR_LICENSE_OLD_SERVER_VERSION Rescode = 1003
    MSK_RES_ERR_SIZE_LICENSE Rescode = 1005
    MSK_RES_ERR_PROB_LICENSE Rescode = 1006
    MSK_RES_ERR_FILE_LICENSE Rescode = 1007
    MSK_RES_ERR_MISSING_LICENSE_FILE Rescode = 1008
    MSK_RES_ERR_SIZE_LICENSE_CON Rescode = 1010
    MSK_RES_ERR_SIZE_LICENSE_VAR Rescode = 1011
    MSK_RES_ERR_SIZE_LICENSE_INTVAR Rescode = 1012
    MSK_RES_ERR_OPTIMIZER_LICENSE Rescode = 1013
    MSK_RES_ERR_FLEXLM Rescode = 1014
    MSK_RES_ERR_LICENSE_SERVER Rescode = 1015
    MSK_RES_ERR_LICENSE_MAX Rescode = 1016
    MSK_RES_ERR_LICENSE_MOSEKLM_DAEMON Rescode = 1017
    MSK_RES_ERR_LICENSE_FEATURE Rescode = 1018
    MSK_RES_ERR_PLATFORM_NOT_LICENSED Rescode = 1019
    MSK_RES_ERR_LICENSE_CANNOT_ALLOCATE Rescode = 1020
    MSK_RES_ERR_LICENSE_CANNOT_CONNECT Rescode = 1021
    MSK_RES_ERR_LICENSE_INVALID_HOSTID Rescode = 1025
    MSK_RES_ERR_LICENSE_SERVER_VERSION Rescode = 1026
    MSK_RES_ERR_LICENSE_NO_SERVER_SUPPORT Rescode = 1027
    MSK_RES_ERR_LICENSE_NO_SERVER_LINE Rescode = 1028
    MSK_RES_ERR_OLDER_DLL Rescode = 1035
    MSK_RES_ERR_NEWER_DLL Rescode = 1036
    MSK_RES_ERR_LINK_FILE_DLL Rescode = 1040
    MSK_RES_ERR_THREAD_MUTEX_INIT Rescode = 1045
    MSK_RES_ERR_THREAD_MUTEX_LOCK Rescode = 1046
    MSK_RES_ERR_THREAD_MUTEX_UNLOCK Rescode = 1047
    MSK_RES_ERR_THREAD_CREATE Rescode = 1048
    MSK_RES_ERR_THREAD_COND_INIT Rescode = 1049
    MSK_RES_ERR_UNKNOWN Rescode = 1050
    MSK_RES_ERR_SPACE Rescode = 1051
    MSK_RES_ERR_FILE_OPEN Rescode = 1052
    MSK_RES_ERR_FILE_READ Rescode = 1053
    MSK_RES_ERR_FILE_WRITE Rescode = 1054
    MSK_RES_ERR_DATA_FILE_EXT Rescode = 1055
    MSK_RES_ERR_INVALID_FILE_NAME Rescode = 1056
    MSK_RES_ERR_INVALID_SOL_FILE_NAME Rescode = 1057
    MSK_RES_ERR_END_OF_FILE Rescode = 1059
    MSK_RES_ERR_NULL_ENV Rescode = 1060
    MSK_RES_ERR_NULL_TASK Rescode = 1061
    MSK_RES_ERR_INVALID_STREAM Rescode = 1062
    MSK_RES_ERR_NO_INIT_ENV Rescode = 1063
    MSK_RES_ERR_INVALID_TASK Rescode = 1064
    MSK_RES_ERR_NULL_POINTER Rescode = 1065
    MSK_RES_ERR_LIVING_TASKS Rescode = 1066
    MSK_RES_ERR_READ_GZIP Rescode = 1067
    MSK_RES_ERR_READ_ZSTD Rescode = 1068
    MSK_RES_ERR_BLANK_NAME Rescode = 1070
    MSK_RES_ERR_DUP_NAME Rescode = 1071
    MSK_RES_ERR_FORMAT_STRING Rescode = 1072
    MSK_RES_ERR_SPARSITY_SPECIFICATION Rescode = 1073
    MSK_RES_ERR_MISMATCHING_DIMENSION Rescode = 1074
    MSK_RES_ERR_INVALID_OBJ_NAME Rescode = 1075
    MSK_RES_ERR_INVALID_CON_NAME Rescode = 1076
    MSK_RES_ERR_INVALID_VAR_NAME Rescode = 1077
    MSK_RES_ERR_INVALID_CONE_NAME Rescode = 1078
    MSK_RES_ERR_INVALID_BARVAR_NAME Rescode = 1079
    MSK_RES_ERR_SPACE_LEAKING Rescode = 1080
    MSK_RES_ERR_SPACE_NO_INFO Rescode = 1081
    MSK_RES_ERR_DIMENSION_SPECIFICATION Rescode = 1082
    MSK_RES_ERR_AXIS_NAME_SPECIFICATION Rescode = 1083
    MSK_RES_ERR_READ_FORMAT Rescode = 1090
    MSK_RES_ERR_MPS_FILE Rescode = 1100
    MSK_RES_ERR_MPS_INV_FIELD Rescode = 1101
    MSK_RES_ERR_MPS_INV_MARKER Rescode = 1102
    MSK_RES_ERR_MPS_NULL_CON_NAME Rescode = 1103
    MSK_RES_ERR_MPS_NULL_VAR_NAME Rescode = 1104
    MSK_RES_ERR_MPS_UNDEF_CON_NAME Rescode = 1105
    MSK_RES_ERR_MPS_UNDEF_VAR_NAME Rescode = 1106
    MSK_RES_ERR_MPS_INVALID_CON_KEY Rescode = 1107
    MSK_RES_ERR_MPS_INVALID_BOUND_KEY Rescode = 1108
    MSK_RES_ERR_MPS_INVALID_SEC_NAME Rescode = 1109
    MSK_RES_ERR_MPS_NO_OBJECTIVE Rescode = 1110
    MSK_RES_ERR_MPS_SPLITTED_VAR Rescode = 1111
    MSK_RES_ERR_MPS_MUL_CON_NAME Rescode = 1112
    MSK_RES_ERR_MPS_MUL_QSEC Rescode = 1113
    MSK_RES_ERR_MPS_MUL_QOBJ Rescode = 1114
    MSK_RES_ERR_MPS_INV_SEC_ORDER Rescode = 1115
    MSK_RES_ERR_MPS_MUL_CSEC Rescode = 1116
    MSK_RES_ERR_MPS_CONE_TYPE Rescode = 1117
    MSK_RES_ERR_MPS_CONE_OVERLAP Rescode = 1118
    MSK_RES_ERR_MPS_CONE_REPEAT Rescode = 1119
    MSK_RES_ERR_MPS_NON_SYMMETRIC_Q Rescode = 1120
    MSK_RES_ERR_MPS_DUPLICATE_Q_ELEMENT Rescode = 1121
    MSK_RES_ERR_MPS_INVALID_OBJSENSE Rescode = 1122
    MSK_RES_ERR_MPS_TAB_IN_FIELD2 Rescode = 1125
    MSK_RES_ERR_MPS_TAB_IN_FIELD3 Rescode = 1126
    MSK_RES_ERR_MPS_TAB_IN_FIELD5 Rescode = 1127
    MSK_RES_ERR_MPS_INVALID_OBJ_NAME Rescode = 1128
    MSK_RES_ERR_MPS_INVALID_KEY Rescode = 1129
    MSK_RES_ERR_MPS_INVALID_INDICATOR_CONSTRAINT Rescode = 1130
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VARIABLE Rescode = 1131
    MSK_RES_ERR_MPS_INVALID_INDICATOR_VALUE Rescode = 1132
    MSK_RES_ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT Rescode = 1133
    MSK_RES_ERR_OPF_SYNTAX Rescode = 1134
    MSK_RES_ERR_OPF_PREMATURE_EOF Rescode = 1136
    MSK_RES_ERR_OPF_MISMATCHED_TAG Rescode = 1137
    MSK_RES_ERR_OPF_DUPLICATE_BOUND Rescode = 1138
    MSK_RES_ERR_OPF_DUPLICATE_CONSTRAINT_NAME Rescode = 1139
    MSK_RES_ERR_OPF_INVALID_CONE_TYPE Rescode = 1140
    MSK_RES_ERR_OPF_INCORRECT_TAG_PARAM Rescode = 1141
    MSK_RES_ERR_OPF_INVALID_TAG Rescode = 1142
    MSK_RES_ERR_OPF_DUPLICATE_CONE_ENTRY Rescode = 1143
    MSK_RES_ERR_OPF_TOO_LARGE Rescode = 1144
    MSK_RES_ERR_OPF_DUAL_INTEGER_SOLUTION Rescode = 1146
    MSK_RES_ERR_LP_EMPTY Rescode = 1151
    MSK_RES_ERR_WRITE_MPS_INVALID_NAME Rescode = 1153
    MSK_RES_ERR_LP_INVALID_VAR_NAME Rescode = 1154
    MSK_RES_ERR_WRITE_OPF_INVALID_VAR_NAME Rescode = 1156
    MSK_RES_ERR_LP_FILE_FORMAT Rescode = 1157
    MSK_RES_ERR_LP_EXPECTED_NUMBER Rescode = 1158
    MSK_RES_ERR_READ_LP_MISSING_END_TAG Rescode = 1159
    MSK_RES_ERR_LP_INDICATOR_VAR Rescode = 1160
    MSK_RES_ERR_LP_EXPECTED_OBJECTIVE Rescode = 1161
    MSK_RES_ERR_LP_EXPECTED_CONSTRAINT_RELATION Rescode = 1162
    MSK_RES_ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND Rescode = 1163
    MSK_RES_ERR_LP_DUPLICATE_SECTION Rescode = 1164
    MSK_RES_ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED Rescode = 1165
    MSK_RES_ERR_WRITING_FILE Rescode = 1166
    MSK_RES_ERR_INVALID_NAME_IN_SOL_FILE Rescode = 1170
    MSK_RES_ERR_JSON_SYNTAX Rescode = 1175
    MSK_RES_ERR_JSON_STRING Rescode = 1176
    MSK_RES_ERR_JSON_NUMBER_OVERFLOW Rescode = 1177
    MSK_RES_ERR_JSON_FORMAT Rescode = 1178
    MSK_RES_ERR_JSON_DATA Rescode = 1179
    MSK_RES_ERR_JSON_MISSING_DATA Rescode = 1180
    MSK_RES_ERR_PTF_INCOMPATIBILITY Rescode = 1181
    MSK_RES_ERR_PTF_UNDEFINED_ITEM Rescode = 1182
    MSK_RES_ERR_PTF_INCONSISTENCY Rescode = 1183
    MSK_RES_ERR_PTF_FORMAT Rescode = 1184
    MSK_RES_ERR_ARGUMENT_LENNEQ Rescode = 1197
    MSK_RES_ERR_ARGUMENT_TYPE Rescode = 1198
    MSK_RES_ERR_NUM_ARGUMENTS Rescode = 1199
    MSK_RES_ERR_IN_ARGUMENT Rescode = 1200
    MSK_RES_ERR_ARGUMENT_DIMENSION Rescode = 1201
    MSK_RES_ERR_SHAPE_IS_TOO_LARGE Rescode = 1202
    MSK_RES_ERR_INDEX_IS_TOO_SMALL Rescode = 1203
    MSK_RES_ERR_INDEX_IS_TOO_LARGE Rescode = 1204
    MSK_RES_ERR_INDEX_IS_NOT_UNIQUE Rescode = 1205
    MSK_RES_ERR_PARAM_NAME Rescode = 1206
    MSK_RES_ERR_PARAM_NAME_DOU Rescode = 1207
    MSK_RES_ERR_PARAM_NAME_INT Rescode = 1208
    MSK_RES_ERR_PARAM_NAME_STR Rescode = 1209
    MSK_RES_ERR_PARAM_INDEX Rescode = 1210
    MSK_RES_ERR_PARAM_IS_TOO_LARGE Rescode = 1215
    MSK_RES_ERR_PARAM_IS_TOO_SMALL Rescode = 1216
    MSK_RES_ERR_PARAM_VALUE_STR Rescode = 1217
    MSK_RES_ERR_PARAM_TYPE Rescode = 1218
    MSK_RES_ERR_INF_DOU_INDEX Rescode = 1219
    MSK_RES_ERR_INF_INT_INDEX Rescode = 1220
    MSK_RES_ERR_INDEX_ARR_IS_TOO_SMALL Rescode = 1221
    MSK_RES_ERR_INDEX_ARR_IS_TOO_LARGE Rescode = 1222
    MSK_RES_ERR_INF_LINT_INDEX Rescode = 1225
    MSK_RES_ERR_ARG_IS_TOO_SMALL Rescode = 1226
    MSK_RES_ERR_ARG_IS_TOO_LARGE Rescode = 1227
    MSK_RES_ERR_INVALID_WHICHSOL Rescode = 1228
    MSK_RES_ERR_INF_DOU_NAME Rescode = 1230
    MSK_RES_ERR_INF_INT_NAME Rescode = 1231
    MSK_RES_ERR_INF_TYPE Rescode = 1232
    MSK_RES_ERR_INF_LINT_NAME Rescode = 1234
    MSK_RES_ERR_INDEX Rescode = 1235
    MSK_RES_ERR_WHICHSOL Rescode = 1236
    MSK_RES_ERR_SOLITEM Rescode = 1237
    MSK_RES_ERR_WHICHITEM_NOT_ALLOWED Rescode = 1238
    MSK_RES_ERR_MAXNUMCON Rescode = 1240
    MSK_RES_ERR_MAXNUMVAR Rescode = 1241
    MSK_RES_ERR_MAXNUMBARVAR Rescode = 1242
    MSK_RES_ERR_MAXNUMQNZ Rescode = 1243
    MSK_RES_ERR_TOO_SMALL_MAX_NUM_NZ Rescode = 1245
    MSK_RES_ERR_INVALID_IDX Rescode = 1246
    MSK_RES_ERR_INVALID_MAX_NUM Rescode = 1247
    MSK_RES_ERR_UNALLOWED_WHICHSOL Rescode = 1248
    MSK_RES_ERR_NUMCONLIM Rescode = 1250
    MSK_RES_ERR_NUMVARLIM Rescode = 1251
    MSK_RES_ERR_TOO_SMALL_MAXNUMANZ Rescode = 1252
    MSK_RES_ERR_INV_APTRE Rescode = 1253
    MSK_RES_ERR_MUL_A_ELEMENT Rescode = 1254
    MSK_RES_ERR_INV_BK Rescode = 1255
    MSK_RES_ERR_INV_BKC Rescode = 1256
    MSK_RES_ERR_INV_BKX Rescode = 1257
    MSK_RES_ERR_INV_VAR_TYPE Rescode = 1258
    MSK_RES_ERR_SOLVER_PROBTYPE Rescode = 1259
    MSK_RES_ERR_OBJECTIVE_RANGE Rescode = 1260
    MSK_RES_ERR_INV_RESCODE Rescode = 1261
    MSK_RES_ERR_INV_IINF Rescode = 1262
    MSK_RES_ERR_INV_LIINF Rescode = 1263
    MSK_RES_ERR_INV_DINF Rescode = 1264
    MSK_RES_ERR_BASIS Rescode = 1266
    MSK_RES_ERR_INV_SKC Rescode = 1267
    MSK_RES_ERR_INV_SKX Rescode = 1268
    MSK_RES_ERR_INV_SK_STR Rescode = 1269
    MSK_RES_ERR_INV_SK Rescode = 1270
    MSK_RES_ERR_INV_CONE_TYPE_STR Rescode = 1271
    MSK_RES_ERR_INV_CONE_TYPE Rescode = 1272
    MSK_RES_ERR_INV_SKN Rescode = 1274
    MSK_RES_ERR_INVALID_SURPLUS Rescode = 1275
    MSK_RES_ERR_INV_NAME_ITEM Rescode = 1280
    MSK_RES_ERR_PRO_ITEM Rescode = 1281
    MSK_RES_ERR_INVALID_FORMAT_TYPE Rescode = 1283
    MSK_RES_ERR_FIRSTI Rescode = 1285
    MSK_RES_ERR_LASTI Rescode = 1286
    MSK_RES_ERR_FIRSTJ Rescode = 1287
    MSK_RES_ERR_LASTJ Rescode = 1288
    MSK_RES_ERR_MAX_LEN_IS_TOO_SMALL Rescode = 1289
    MSK_RES_ERR_NONLINEAR_EQUALITY Rescode = 1290
    MSK_RES_ERR_NONCONVEX Rescode = 1291
    MSK_RES_ERR_NONLINEAR_RANGED Rescode = 1292
    MSK_RES_ERR_CON_Q_NOT_PSD Rescode = 1293
    MSK_RES_ERR_CON_Q_NOT_NSD Rescode = 1294
    MSK_RES_ERR_OBJ_Q_NOT_PSD Rescode = 1295
    MSK_RES_ERR_OBJ_Q_NOT_NSD Rescode = 1296
    MSK_RES_ERR_ARGUMENT_PERM_ARRAY Rescode = 1299
    MSK_RES_ERR_CONE_INDEX Rescode = 1300
    MSK_RES_ERR_CONE_SIZE Rescode = 1301
    MSK_RES_ERR_CONE_OVERLAP Rescode = 1302
    MSK_RES_ERR_CONE_REP_VAR Rescode = 1303
    MSK_RES_ERR_MAXNUMCONE Rescode = 1304
    MSK_RES_ERR_CONE_TYPE Rescode = 1305
    MSK_RES_ERR_CONE_TYPE_STR Rescode = 1306
    MSK_RES_ERR_CONE_OVERLAP_APPEND Rescode = 1307
    MSK_RES_ERR_REMOVE_CONE_VARIABLE Rescode = 1310
    MSK_RES_ERR_APPENDING_TOO_BIG_CONE Rescode = 1311
    MSK_RES_ERR_CONE_PARAMETER Rescode = 1320
    MSK_RES_ERR_SOL_FILE_INVALID_NUMBER Rescode = 1350
    MSK_RES_ERR_HUGE_C Rescode = 1375
    MSK_RES_ERR_HUGE_AIJ Rescode = 1380
    MSK_RES_ERR_DUPLICATE_AIJ Rescode = 1385
    MSK_RES_ERR_LOWER_BOUND_IS_A_NAN Rescode = 1390
    MSK_RES_ERR_UPPER_BOUND_IS_A_NAN Rescode = 1391
    MSK_RES_ERR_INFINITE_BOUND Rescode = 1400
    MSK_RES_ERR_INV_QOBJ_SUBI Rescode = 1401
    MSK_RES_ERR_INV_QOBJ_SUBJ Rescode = 1402
    MSK_RES_ERR_INV_QOBJ_VAL Rescode = 1403
    MSK_RES_ERR_INV_QCON_SUBK Rescode = 1404
    MSK_RES_ERR_INV_QCON_SUBI Rescode = 1405
    MSK_RES_ERR_INV_QCON_SUBJ Rescode = 1406
    MSK_RES_ERR_INV_QCON_VAL Rescode = 1407
    MSK_RES_ERR_QCON_SUBI_TOO_SMALL Rescode = 1408
    MSK_RES_ERR_QCON_SUBI_TOO_LARGE Rescode = 1409
    MSK_RES_ERR_QOBJ_UPPER_TRIANGLE Rescode = 1415
    MSK_RES_ERR_QCON_UPPER_TRIANGLE Rescode = 1417
    MSK_RES_ERR_FIXED_BOUND_VALUES Rescode = 1420
    MSK_RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE Rescode = 1421
    MSK_RES_ERR_INVALID_OBJECTIVE_SENSE Rescode = 1445
    MSK_RES_ERR_UNDEFINED_OBJECTIVE_SENSE Rescode = 1446
    MSK_RES_ERR_Y_IS_UNDEFINED Rescode = 1449
    MSK_RES_ERR_NAN_IN_DOUBLE_DATA Rescode = 1450
    MSK_RES_ERR_INF_IN_DOUBLE_DATA Rescode = 1451
    MSK_RES_ERR_NAN_IN_BLC Rescode = 1461
    MSK_RES_ERR_NAN_IN_BUC Rescode = 1462
    MSK_RES_ERR_INVALID_CFIX Rescode = 1469
    MSK_RES_ERR_NAN_IN_C Rescode = 1470
    MSK_RES_ERR_NAN_IN_BLX Rescode = 1471
    MSK_RES_ERR_NAN_IN_BUX Rescode = 1472
    MSK_RES_ERR_INVALID_AIJ Rescode = 1473
    MSK_RES_ERR_INVALID_CJ Rescode = 1474
    MSK_RES_ERR_SYM_MAT_INVALID Rescode = 1480
    MSK_RES_ERR_SYM_MAT_HUGE Rescode = 1482
    MSK_RES_ERR_INV_PROBLEM Rescode = 1500
    MSK_RES_ERR_MIXED_CONIC_AND_NL Rescode = 1501
    MSK_RES_ERR_GLOBAL_INV_CONIC_PROBLEM Rescode = 1503
    MSK_RES_ERR_INV_OPTIMIZER Rescode = 1550
    MSK_RES_ERR_MIO_NO_OPTIMIZER Rescode = 1551
    MSK_RES_ERR_NO_OPTIMIZER_VAR_TYPE Rescode = 1552
    MSK_RES_ERR_FINAL_SOLUTION Rescode = 1560
    MSK_RES_ERR_FIRST Rescode = 1570
    MSK_RES_ERR_LAST Rescode = 1571
    MSK_RES_ERR_SLICE_SIZE Rescode = 1572
    MSK_RES_ERR_NEGATIVE_SURPLUS Rescode = 1573
    MSK_RES_ERR_NEGATIVE_APPEND Rescode = 1578
    MSK_RES_ERR_POSTSOLVE Rescode = 1580
    MSK_RES_ERR_OVERFLOW Rescode = 1590
    MSK_RES_ERR_NO_BASIS_SOL Rescode = 1600
    MSK_RES_ERR_BASIS_FACTOR Rescode = 1610
    MSK_RES_ERR_BASIS_SINGULAR Rescode = 1615
    MSK_RES_ERR_FACTOR Rescode = 1650
    MSK_RES_ERR_FEASREPAIR_CANNOT_RELAX Rescode = 1700
    MSK_RES_ERR_FEASREPAIR_SOLVING_RELAXED Rescode = 1701
    MSK_RES_ERR_FEASREPAIR_INCONSISTENT_BOUND Rescode = 1702
    MSK_RES_ERR_REPAIR_INVALID_PROBLEM Rescode = 1710
    MSK_RES_ERR_REPAIR_OPTIMIZATION_FAILED Rescode = 1711
    MSK_RES_ERR_NAME_MAX_LEN Rescode = 1750
    MSK_RES_ERR_NAME_IS_NULL Rescode = 1760
    MSK_RES_ERR_INVALID_COMPRESSION Rescode = 1800
    MSK_RES_ERR_INVALID_IOMODE Rescode = 1801
    MSK_RES_ERR_NO_PRIMAL_INFEAS_CER Rescode = 2000
    MSK_RES_ERR_NO_DUAL_INFEAS_CER Rescode = 2001
    MSK_RES_ERR_NO_SOLUTION_IN_CALLBACK Rescode = 2500
    MSK_RES_ERR_INV_MARKI Rescode = 2501
    MSK_RES_ERR_INV_MARKJ Rescode = 2502
    MSK_RES_ERR_INV_NUMI Rescode = 2503
    MSK_RES_ERR_INV_NUMJ Rescode = 2504
    MSK_RES_ERR_TASK_INCOMPATIBLE Rescode = 2560
    MSK_RES_ERR_TASK_INVALID Rescode = 2561
    MSK_RES_ERR_TASK_WRITE Rescode = 2562
    MSK_RES_ERR_LU_MAX_NUM_TRIES Rescode = 2800
    MSK_RES_ERR_INVALID_UTF8 Rescode = 2900
    MSK_RES_ERR_INVALID_WCHAR Rescode = 2901
    MSK_RES_ERR_NO_DUAL_FOR_ITG_SOL Rescode = 2950
    MSK_RES_ERR_NO_SNX_FOR_BAS_SOL Rescode = 2953
    MSK_RES_ERR_INTERNAL Rescode = 3000
    MSK_RES_ERR_API_ARRAY_TOO_SMALL Rescode = 3001
    MSK_RES_ERR_API_CB_CONNECT Rescode = 3002
    MSK_RES_ERR_API_FATAL_ERROR Rescode = 3005
    MSK_RES_ERR_SEN_FORMAT Rescode = 3050
    MSK_RES_ERR_SEN_UNDEF_NAME Rescode = 3051
    MSK_RES_ERR_SEN_INDEX_RANGE Rescode = 3052
    MSK_RES_ERR_SEN_BOUND_INVALID_UP Rescode = 3053
    MSK_RES_ERR_SEN_BOUND_INVALID_LO Rescode = 3054
    MSK_RES_ERR_SEN_INDEX_INVALID Rescode = 3055
    MSK_RES_ERR_SEN_INVALID_REGEXP Rescode = 3056
    MSK_RES_ERR_SEN_SOLUTION_STATUS Rescode = 3057
    MSK_RES_ERR_SEN_NUMERICAL Rescode = 3058
    MSK_RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE Rescode = 3080
    MSK_RES_ERR_UNB_STEP_SIZE Rescode = 3100
    MSK_RES_ERR_IDENTICAL_TASKS Rescode = 3101
    MSK_RES_ERR_AD_INVALID_CODELIST Rescode = 3102
    MSK_RES_ERR_INTERNAL_TEST_FAILED Rescode = 3500
    MSK_RES_ERR_XML_INVALID_PROBLEM_TYPE Rescode = 3600
    MSK_RES_ERR_INVALID_AMPL_STUB Rescode = 3700
    MSK_RES_ERR_INT64_TO_INT32_CAST Rescode = 3800
    MSK_RES_ERR_SIZE_LICENSE_NUMCORES Rescode = 3900
    MSK_RES_ERR_INFEAS_UNDEFINED Rescode = 3910
    MSK_RES_ERR_NO_BARX_FOR_SOLUTION Rescode = 3915
    MSK_RES_ERR_NO_BARS_FOR_SOLUTION Rescode = 3916
    MSK_RES_ERR_BAR_VAR_DIM Rescode = 3920
    MSK_RES_ERR_SYM_MAT_INVALID_ROW_INDEX Rescode = 3940
    MSK_RES_ERR_SYM_MAT_INVALID_COL_INDEX Rescode = 3941
    MSK_RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR Rescode = 3942
    MSK_RES_ERR_SYM_MAT_INVALID_VALUE Rescode = 3943
    MSK_RES_ERR_SYM_MAT_DUPLICATE Rescode = 3944
    MSK_RES_ERR_INVALID_SYM_MAT_DIM Rescode = 3950
    MSK_RES_ERR_API_INTERNAL Rescode = 3999
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT Rescode = 4000
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX Rescode = 4001
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS Rescode = 4002
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS Rescode = 4003
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_CONES Rescode = 4005
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS Rescode = 4006
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR Rescode = 4010
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS Rescode = 4011
    MSK_RES_ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS Rescode = 4012
    MSK_RES_ERR_DUPLICATE_CONSTRAINT_NAMES Rescode = 4500
    MSK_RES_ERR_DUPLICATE_VARIABLE_NAMES Rescode = 4501
    MSK_RES_ERR_DUPLICATE_BARVARIABLE_NAMES Rescode = 4502
    MSK_RES_ERR_DUPLICATE_CONE_NAMES Rescode = 4503
    MSK_RES_ERR_DUPLICATE_DOMAIN_NAMES Rescode = 4504
    MSK_RES_ERR_DUPLICATE_DJC_NAMES Rescode = 4505
    MSK_RES_ERR_NON_UNIQUE_ARRAY Rescode = 5000
    MSK_RES_ERR_ARGUMENT_IS_TOO_SMALL Rescode = 5004
    MSK_RES_ERR_ARGUMENT_IS_TOO_LARGE Rescode = 5005
    MSK_RES_ERR_MIO_INTERNAL Rescode = 5010
    MSK_RES_ERR_INVALID_PROBLEM_TYPE Rescode = 6000
    MSK_RES_ERR_UNHANDLED_SOLUTION_STATUS Rescode = 6010
    MSK_RES_ERR_UPPER_TRIANGLE Rescode = 6020
    MSK_RES_ERR_LAU_SINGULAR_MATRIX Rescode = 7000
    MSK_RES_ERR_LAU_NOT_POSITIVE_DEFINITE Rescode = 7001
    MSK_RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX Rescode = 7002
    MSK_RES_ERR_LAU_UNKNOWN Rescode = 7005
    MSK_RES_ERR_LAU_ARG_M Rescode = 7010
    MSK_RES_ERR_LAU_ARG_N Rescode = 7011
    MSK_RES_ERR_LAU_ARG_K Rescode = 7012
    MSK_RES_ERR_LAU_ARG_TRANSA Rescode = 7015
    MSK_RES_ERR_LAU_ARG_TRANSB Rescode = 7016
    MSK_RES_ERR_LAU_ARG_UPLO Rescode = 7017
    MSK_RES_ERR_LAU_ARG_TRANS Rescode = 7018
    MSK_RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX Rescode = 7019
    MSK_RES_ERR_CBF_PARSE Rescode = 7100
    MSK_RES_ERR_CBF_OBJ_SENSE Rescode = 7101
    MSK_RES_ERR_CBF_NO_VARIABLES Rescode = 7102
    MSK_RES_ERR_CBF_TOO_MANY_CONSTRAINTS Rescode = 7103
    MSK_RES_ERR_CBF_TOO_MANY_VARIABLES Rescode = 7104
    MSK_RES_ERR_CBF_NO_VERSION_SPECIFIED Rescode = 7105
    MSK_RES_ERR_CBF_SYNTAX Rescode = 7106
    MSK_RES_ERR_CBF_DUPLICATE_OBJ Rescode = 7107
    MSK_RES_ERR_CBF_DUPLICATE_CON Rescode = 7108
    MSK_RES_ERR_CBF_DUPLICATE_VAR Rescode = 7110
    MSK_RES_ERR_CBF_DUPLICATE_INT Rescode = 7111
    MSK_RES_ERR_CBF_INVALID_VAR_TYPE Rescode = 7112
    MSK_RES_ERR_CBF_INVALID_CON_TYPE Rescode = 7113
    MSK_RES_ERR_CBF_INVALID_DOMAIN_DIMENSION Rescode = 7114
    MSK_RES_ERR_CBF_DUPLICATE_OBJACOORD Rescode = 7115
    MSK_RES_ERR_CBF_DUPLICATE_BCOORD Rescode = 7116
    MSK_RES_ERR_CBF_DUPLICATE_ACOORD Rescode = 7117
    MSK_RES_ERR_CBF_TOO_FEW_VARIABLES Rescode = 7118
    MSK_RES_ERR_CBF_TOO_FEW_CONSTRAINTS Rescode = 7119
    MSK_RES_ERR_CBF_TOO_FEW_INTS Rescode = 7120
    MSK_RES_ERR_CBF_TOO_MANY_INTS Rescode = 7121
    MSK_RES_ERR_CBF_INVALID_INT_INDEX Rescode = 7122
    MSK_RES_ERR_CBF_UNSUPPORTED Rescode = 7123
    MSK_RES_ERR_CBF_DUPLICATE_PSDVAR Rescode = 7124
    MSK_RES_ERR_CBF_INVALID_PSDVAR_DIMENSION Rescode = 7125
    MSK_RES_ERR_CBF_TOO_FEW_PSDVAR Rescode = 7126
    MSK_RES_ERR_CBF_INVALID_EXP_DIMENSION Rescode = 7127
    MSK_RES_ERR_CBF_DUPLICATE_POW_CONES Rescode = 7130
    MSK_RES_ERR_CBF_DUPLICATE_POW_STAR_CONES Rescode = 7131
    MSK_RES_ERR_CBF_INVALID_POWER Rescode = 7132
    MSK_RES_ERR_CBF_POWER_CONE_IS_TOO_LONG Rescode = 7133
    MSK_RES_ERR_CBF_INVALID_POWER_CONE_INDEX Rescode = 7134
    MSK_RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX Rescode = 7135
    MSK_RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE Rescode = 7136
    MSK_RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE Rescode = 7137
    MSK_RES_ERR_CBF_POWER_CONE_MISMATCH Rescode = 7138
    MSK_RES_ERR_CBF_POWER_STAR_CONE_MISMATCH Rescode = 7139
    MSK_RES_ERR_CBF_INVALID_NUMBER_OF_CONES Rescode = 7140
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_CONES Rescode = 7141
    MSK_RES_ERR_CBF_INVALID_NUM_OBJACOORD Rescode = 7150
    MSK_RES_ERR_CBF_INVALID_NUM_OBJFCOORD Rescode = 7151
    MSK_RES_ERR_CBF_INVALID_NUM_ACOORD Rescode = 7152
    MSK_RES_ERR_CBF_INVALID_NUM_BCOORD Rescode = 7153
    MSK_RES_ERR_CBF_INVALID_NUM_FCOORD Rescode = 7155
    MSK_RES_ERR_CBF_INVALID_NUM_HCOORD Rescode = 7156
    MSK_RES_ERR_CBF_INVALID_NUM_DCOORD Rescode = 7157
    MSK_RES_ERR_CBF_EXPECTED_A_KEYWORD Rescode = 7158
    MSK_RES_ERR_CBF_INVALID_NUM_PSDCON Rescode = 7200
    MSK_RES_ERR_CBF_DUPLICATE_PSDCON Rescode = 7201
    MSK_RES_ERR_CBF_INVALID_DIMENSION_OF_PSDCON Rescode = 7202
    MSK_RES_ERR_CBF_INVALID_PSDCON_INDEX Rescode = 7203
    MSK_RES_ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX Rescode = 7204
    MSK_RES_ERR_CBF_INVALID_PSDCON_BLOCK_INDEX Rescode = 7205
    MSK_RES_ERR_CBF_UNSUPPORTED_CHANGE Rescode = 7210
    MSK_RES_ERR_MIO_INVALID_ROOT_OPTIMIZER Rescode = 7700
    MSK_RES_ERR_MIO_INVALID_NODE_OPTIMIZER Rescode = 7701
    MSK_RES_ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE Rescode = 7750
    MSK_RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD Rescode = 7800
    MSK_RES_ERR_TOCONIC_CONSTRAINT_FX Rescode = 7801
    MSK_RES_ERR_TOCONIC_CONSTRAINT_RA Rescode = 7802
    MSK_RES_ERR_TOCONIC_CONSTR_NOT_CONIC Rescode = 7803
    MSK_RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD Rescode = 7804
    MSK_RES_ERR_SERVER_CONNECT Rescode = 8000
    MSK_RES_ERR_SERVER_PROTOCOL Rescode = 8001
    MSK_RES_ERR_SERVER_STATUS Rescode = 8002
    MSK_RES_ERR_SERVER_TOKEN Rescode = 8003
    MSK_RES_ERR_SERVER_ADDRESS Rescode = 8004
    MSK_RES_ERR_SERVER_CERTIFICATE Rescode = 8005
    MSK_RES_ERR_SERVER_TLS_CLIENT Rescode = 8006
    MSK_RES_ERR_SERVER_ACCESS_TOKEN Rescode = 8007
    MSK_RES_ERR_SERVER_PROBLEM_SIZE Rescode = 8008
    MSK_RES_ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX Rescode = 20050
    MSK_RES_ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST Rescode = 20060
    MSK_RES_ERR_DUPLICATE_FIJ Rescode = 20100
    MSK_RES_ERR_INVALID_FIJ Rescode = 20101
    MSK_RES_ERR_HUGE_FIJ Rescode = 20102
    MSK_RES_ERR_INVALID_G Rescode = 20103
    MSK_RES_ERR_INVALID_B Rescode = 20150
    MSK_RES_ERR_DOMAIN_INVALID_INDEX Rescode = 20400
    MSK_RES_ERR_DOMAIN_DIMENSION Rescode = 20401
    MSK_RES_ERR_DOMAIN_DIMENSION_PSD Rescode = 20402
    MSK_RES_ERR_NOT_POWER_DOMAIN Rescode = 20403
    MSK_RES_ERR_DOMAIN_POWER_INVALID_ALPHA Rescode = 20404
    MSK_RES_ERR_DOMAIN_POWER_NEGATIVE_ALPHA Rescode = 20405
    MSK_RES_ERR_DOMAIN_POWER_NLEFT Rescode = 20406
    MSK_RES_ERR_AFE_INVALID_INDEX Rescode = 20500
    MSK_RES_ERR_ACC_INVALID_INDEX Rescode = 20600
    MSK_RES_ERR_ACC_INVALID_ENTRY_INDEX Rescode = 20601
    MSK_RES_ERR_ACC_AFE_DOMAIN_MISMATCH Rescode = 20602
    MSK_RES_ERR_DJC_INVALID_INDEX Rescode = 20700
    MSK_RES_ERR_DJC_UNSUPPORTED_DOMAIN_TYPE Rescode = 20701
    MSK_RES_ERR_DJC_AFE_DOMAIN_MISMATCH Rescode = 20702
    MSK_RES_ERR_DJC_INVALID_TERM_SIZE Rescode = 20703
    MSK_RES_ERR_DJC_DOMAIN_TERMSIZE_MISMATCH Rescode = 20704
    MSK_RES_ERR_DJC_TOTAL_NUM_TERMS_MISMATCH Rescode = 20705
    MSK_RES_ERR_UNDEF_SOLUTION Rescode = 22000
    MSK_RES_ERR_NO_DOTY Rescode = 22010
    MSK_RES_TRM_MAX_ITERATIONS Rescode = 100000
    MSK_RES_TRM_MAX_TIME Rescode = 100001
    MSK_RES_TRM_OBJECTIVE_RANGE Rescode = 100002
    MSK_RES_TRM_STALL Rescode = 100006
    MSK_RES_TRM_USER_CALLBACK Rescode = 100007
    MSK_RES_TRM_MIO_NUM_RELAXS Rescode = 100008
    MSK_RES_TRM_MIO_NUM_BRANCHES Rescode = 100009
    MSK_RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS Rescode = 100015
    MSK_RES_TRM_MAX_NUM_SETBACKS Rescode = 100020
    MSK_RES_TRM_NUMERICAL_PROBLEM Rescode = 100025
    MSK_RES_TRM_LOST_RACE Rescode = 100027
    MSK_RES_TRM_INTERNAL Rescode = 100030
    MSK_RES_TRM_INTERNAL_STOP Rescode = 100031
)
type Rescodetype int32
const (
    MSK_RESPONSE_OK Rescodetype = 0
    MSK_RESPONSE_WRN Rescodetype = 1
    MSK_RESPONSE_TRM Rescodetype = 2
    MSK_RESPONSE_ERR Rescodetype = 3
    MSK_RESPONSE_UNK Rescodetype = 4
)
type Scalingtype int32
const (
    MSK_SCALING_FREE Scalingtype = 0
    MSK_SCALING_NONE Scalingtype = 1
)
type Scalingmethod int32
const (
    MSK_SCALING_METHOD_POW2 Scalingmethod = 0
    MSK_SCALING_METHOD_FREE Scalingmethod = 1
)
type Sensitivitytype int32
const (
    MSK_SENSITIVITY_TYPE_BASIS Sensitivitytype = 0
)
type Simseltype int32
const (
    MSK_SIM_SELECTION_FREE Simseltype = 0
    MSK_SIM_SELECTION_FULL Simseltype = 1
    MSK_SIM_SELECTION_ASE Simseltype = 2
    MSK_SIM_SELECTION_DEVEX Simseltype = 3
    MSK_SIM_SELECTION_SE Simseltype = 4
    MSK_SIM_SELECTION_PARTIAL Simseltype = 5
)
type Solitem int32
const (
    MSK_SOL_ITEM_XC Solitem = 0
    MSK_SOL_ITEM_XX Solitem = 1
    MSK_SOL_ITEM_Y Solitem = 2
    MSK_SOL_ITEM_SLC Solitem = 3
    MSK_SOL_ITEM_SUC Solitem = 4
    MSK_SOL_ITEM_SLX Solitem = 5
    MSK_SOL_ITEM_SUX Solitem = 6
    MSK_SOL_ITEM_SNX Solitem = 7
)
type Solsta int32
const (
    MSK_SOL_STA_UNKNOWN Solsta = 0
    MSK_SOL_STA_OPTIMAL Solsta = 1
    MSK_SOL_STA_PRIM_FEAS Solsta = 2
    MSK_SOL_STA_DUAL_FEAS Solsta = 3
    MSK_SOL_STA_PRIM_AND_DUAL_FEAS Solsta = 4
    MSK_SOL_STA_PRIM_INFEAS_CER Solsta = 5
    MSK_SOL_STA_DUAL_INFEAS_CER Solsta = 6
    MSK_SOL_STA_PRIM_ILLPOSED_CER Solsta = 7
    MSK_SOL_STA_DUAL_ILLPOSED_CER Solsta = 8
    MSK_SOL_STA_INTEGER_OPTIMAL Solsta = 9
)
type Soltype int32
const (
    MSK_SOL_ITR Soltype = 0
    MSK_SOL_BAS Soltype = 1
    MSK_SOL_ITG Soltype = 2
)
type Solveform int32
const (
    MSK_SOLVE_FREE Solveform = 0
    MSK_SOLVE_PRIMAL Solveform = 1
    MSK_SOLVE_DUAL Solveform = 2
)
type Sparam int32
const (
    MSK_SPAR_BAS_SOL_FILE_NAME Sparam = 0
    MSK_SPAR_DATA_FILE_NAME Sparam = 1
    MSK_SPAR_DEBUG_FILE_NAME Sparam = 2
    MSK_SPAR_INT_SOL_FILE_NAME Sparam = 3
    MSK_SPAR_ITR_SOL_FILE_NAME Sparam = 4
    MSK_SPAR_MIO_DEBUG_STRING Sparam = 5
    MSK_SPAR_PARAM_COMMENT_SIGN Sparam = 6
    MSK_SPAR_PARAM_READ_FILE_NAME Sparam = 7
    MSK_SPAR_PARAM_WRITE_FILE_NAME Sparam = 8
    MSK_SPAR_READ_MPS_BOU_NAME Sparam = 9
    MSK_SPAR_READ_MPS_OBJ_NAME Sparam = 10
    MSK_SPAR_READ_MPS_RAN_NAME Sparam = 11
    MSK_SPAR_READ_MPS_RHS_NAME Sparam = 12
    MSK_SPAR_REMOTE_OPTSERVER_HOST Sparam = 13
    MSK_SPAR_REMOTE_TLS_CERT Sparam = 14
    MSK_SPAR_REMOTE_TLS_CERT_PATH Sparam = 15
    MSK_SPAR_SENSITIVITY_FILE_NAME Sparam = 16
    MSK_SPAR_SENSITIVITY_RES_FILE_NAME Sparam = 17
    MSK_SPAR_SOL_FILTER_XC_LOW Sparam = 18
    MSK_SPAR_SOL_FILTER_XC_UPR Sparam = 19
    MSK_SPAR_SOL_FILTER_XX_LOW Sparam = 20
    MSK_SPAR_SOL_FILTER_XX_UPR Sparam = 21
    MSK_SPAR_STAT_KEY Sparam = 22
    MSK_SPAR_STAT_NAME Sparam = 23
    MSK_SPAR_WRITE_LP_GEN_VAR_NAME Sparam = 24
)
type Stakey int32
const (
    MSK_SK_UNK Stakey = 0
    MSK_SK_BAS Stakey = 1
    MSK_SK_SUPBAS Stakey = 2
    MSK_SK_LOW Stakey = 3
    MSK_SK_UPR Stakey = 4
    MSK_SK_FIX Stakey = 5
    MSK_SK_INF Stakey = 6
)
type Startpointtype int32
const (
    MSK_STARTING_POINT_FREE Startpointtype = 0
    MSK_STARTING_POINT_GUESS Startpointtype = 1
    MSK_STARTING_POINT_CONSTANT Startpointtype = 2
)
type Streamtype int32
const (
    MSK_STREAM_LOG Streamtype = 0
    MSK_STREAM_MSG Streamtype = 1
    MSK_STREAM_ERR Streamtype = 2
    MSK_STREAM_WRN Streamtype = 3
)
type Value int32
const (
    MSK_LICENSE_BUFFER_LENGTH Value = 21
    MSK_MAX_STR_LEN Value = 1024
)
type Variabletype int32
const (
    MSK_VAR_TYPE_CONT Variabletype = 0
    MSK_VAR_TYPE_INT Variabletype = 1
)



type MosekError struct {
    code int32
    msg string
}
func (self*MosekError) Error() string {
    return fmt.Sprintf("%d: %s",self.code,self.msg)
}


type ArrayLengthError struct {
    fun string
    arg string
}
func (self*ArrayLengthError) Error() string {
    return fmt.Sprintf("%s: Argument %s is too short",self.fun,self.arg)   
}


type Env struct {
        r    int32
        cptr unsafe.Pointer
}

type Task struct {
        r               int32
        cptr            unsafe.Pointer
	streamfunc      [4]func(string)
	callbackfunc    func(int32)int
	infcallbackfunc func(int32,[]float64,[]int32,[]int64)int
}

func (t * Task) ptr() C.MSKtask_t { return C.MSKtask_t(t.cptr) }
func (e * Env)  ptr() C.MSKenv_t  { return C.MSKenv_t(e.cptr) }

func (self * Task) getlasterror(res int32) (int32,string) {
    return res,""
}
func (self * Task) getlasterror(res int32) (int32,string) {
    var lastcode int32 = res
    var lastmsglen int64
    if 0 != MSK_getlasterror64(self.ptr(),&lastcode,0, &lastmsglen, nil) {
        return lastcode,""
    } else {
        lastmsgbytes := make([]byte,lastmsglen+1)
        if 0 != MSK_getlasterror64(self.ptr(),&lastcode,lastmsglen,&lastmsglen,&lastmsgbytes[0]) {
            return lastcode,""
        } else {
            return lastcode,string(lastmsgbytes[:lastmsglen])
        }
    }
}


//export streamfunc_log
func streamfunc_log(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_LOG] != nil { task.streamfunc[STREAM_LOG](C.GoString(msg)) }
}

//export streamfunc_msg
func streamfunc_msg(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_MSG] != nil { task.streamfunc[STREAM_MSG](C.GoString(msg)) }
}

//export streamfunc_wrn
func streamfunc_wrn(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_WRN] != nil { task.streamfunc[STREAM_WRN](C.GoString(msg)) }
}

//export streamfunc_err
func streamfunc_err(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_ERR] != nil { task.streamfunc[STREAM_ERR](C.GoString(msg)) }
}

//export callbackfunc
func callbackfunc(
	nativetask unsafe.Pointer,
	handle  unsafe.Pointer,
	code    C.int,
	dinf  * C.MSKrealt,
	iinf  * C.MSKint32t,
	liinf * C.MSKint64t) (C.int) {

	task := (*Task)(handle)

	var r int = 0

	if task.infcallbackfunc != nil {
		_dinf  := (*[int(DINF_END)]float64)(unsafe.Pointer(dinf))[0:DINF_END]
		_iinf  := (*[int(IINF_END)]int32)  (unsafe.Pointer(iinf))[0:IINF_END]
		_liinf := (*[int(LIINF_END)]int64) (unsafe.Pointer(liinf))[0:LIINF_END]

		r = task.infcallbackfunc(int32(code),_dinf,_iinf,_liinf)
	} else if task.callbackfunc != nil {
		r = task.callbackfunc(int32(code))
	}
	return C.int(r)
}


func MakeEnv() (env Env, res int32) {
        var envptr C.MSKenv_t
        res = int32(C.MSK_makeenv(&envptr,nil))
        if res == 0 {
                env.cptr = unsafe.Pointer(envptr)
        }
        return
}

func (env *Env) MakeTask() (task Task, res int32) {
        var taskptr C.MSKtask_t
        res = int32(C.MSK_makeemptytask(env.ptr(), &taskptr))
        if res != 0 { return }
	task.cptr            = unsafe.Pointer(taskptr)
	task.streamfunc[0]   = nil
	task.streamfunc[1]   = nil
	task.streamfunc[2]   = nil
	task.streamfunc[3]   = nil
	task.callbackfunc    = nil
	task.infcallbackfunc = nil

        return
}

func (e *Env) Delete() {
        envptr := e.ptr()
        _ = C.MSK_deleteenv(&envptr)
        e.cptr = nil
}

func (t *Task) Delete() {
        taskptr := t.ptr()
        C.MSK_deletetask(&taskptr)
        t.cptr = nil
}

func (t *Task) PutStreamFunc(whichstream int32, fun func(string)) {
	t.streamfunc[whichstream] = fun

	if fun == nil {
		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			nil,
			nil)
	} else {
		var strmfun (*[0]byte)
		switch whichstream {
		case STREAM_MSG: strmfun = (*[0]byte)(C.streamfunc_msg)
		case STREAM_LOG: strmfun = (*[0]byte)(C.streamfunc_log)
		case STREAM_ERR: strmfun = (*[0]byte)(C.streamfunc_err)
		case STREAM_WRN: strmfun = (*[0]byte)(C.streamfunc_wrn)
		}

		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			C.MSKuserhandle_t(unsafe.Pointer(t)),
			strmfun) // ?!?
	}
}

func (t *Task) PutCallbackFunc(fun func(int32) int) {
	t.callbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (t *Task) PutInfoCallbackFunc(fun func(int32,[]float64,[]int32,[]int64) int) {
	t.infcallbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (e * Env)  ClearError() { e.r = RES_OK }
func (t * Task) ClearError() { t.r = RES_OK }

func (e * Env)  GetRes() int32 { return e.r }
func (t * Task) GetRes() int32 { return t.r }

func minint(a []int) (r int) {
        if len(a) == 0 { panic("Minimum of empty array") }
        r = a[0]
        for i := 1; i < len(a); i++ {
                if a[i] < r { r = a[i] }
        }
        return
}

func sum[T Number](data []T) T {
    var r T
    for _,v := range(self) { r += v }
    return v
}


// Methods
func (self *Task) AnalyzeNames(whichstream Streamtype,nametype Nametype) (err error) {
  if _tmt0 := MSK_analyzenames(self.ptr(),whichstream,nametype); _tmt0 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt0)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AnalyzeProblem(whichstream Streamtype) (err error) {
  if _tmt1 := MSK_analyzeproblem(self.ptr(),whichstream); _tmt1 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AnalyzeSolution(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt2 := MSK_analyzesolution(self.ptr(),whichstream,whichsol); _tmt2 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt2)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAcc(domidx int64,afeidxlist []int64,b []float64) (err error) {
  _tmt3 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt3)
  var _tmt4 *int64
  if afeidxlist != nil { _tmt4 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt5 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAcc",arg:"b"}
    return
  }
  if b != nil { _tmt5 = (*C.MSKint32t)(&b[0]) }
  if _tmt6 := MSK_appendacc(self.ptr(),domidx,numafeidx,_tmt4,_tmt5); _tmt6 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt6)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccs(domidxs []int64,afeidxlist []int64,b []float64) (err error) {
  _tmt7 := len(domidxs)
  var numaccs int64 = int32(_tmt7)
  var _tmt8 *int64
  if domidxs != nil { _tmt8 = (*C.MSKint32t)(&domidxs[0]) }
  _tmt9 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt9)
  var _tmt10 *int64
  if afeidxlist != nil { _tmt10 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt11 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccs",arg:"b"}
    return
  }
  if b != nil { _tmt11 = (*C.MSKint32t)(&b[0]) }
  if _tmt12 := MSK_appendaccs(self.ptr(),numaccs,_tmt8,numafeidx,_tmt10,_tmt11); _tmt12 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt12)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccSeq(domidx int64,afeidxfirst int64,b []float64) (err error) {
  var _tmt13 int64
  if _tmt14 := MSK_getdomainn(task.nativep,domidx,addr(_tmt13)); _tmt14 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt14)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var numafeidx int64 = _tmt13
  var _tmt15 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccSeq",arg:"b"}
    return
  }
  if b != nil { _tmt15 = (*C.MSKint32t)(&b[0]) }
  if _tmt16 := MSK_appendaccseq(self.ptr(),domidx,numafeidx,afeidxfirst,_tmt15); _tmt16 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt16)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAccsSeq(domidxs []int64,numafeidx int64,afeidxfirst int64,b []float64) (err error) {
  _tmt17 := len(domidxs)
  var numaccs int64 = int32(_tmt17)
  var _tmt18 *int64
  if domidxs != nil { _tmt18 = (*C.MSKint32t)(&domidxs[0]) }
  var _tmt19 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"AppendAccsSeq",arg:"b"}
    return
  }
  if b != nil { _tmt19 = (*C.MSKint32t)(&b[0]) }
  if _tmt20 := MSK_appendaccsseq(self.ptr(),numaccs,_tmt18,numafeidx,afeidxfirst,_tmt19); _tmt20 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt20)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendAfes(num int64) (err error) {
  if _tmt21 := MSK_appendafes(self.ptr(),num); _tmt21 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt21)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendBarvars(dim []int32) (err error) {
  _tmt22 := len(dim)
  var num int32 = int32(_tmt22)
  var _tmt23 *int32
  if dim != nil { _tmt23 = (*C.MSKint32t)(&dim[0]) }
  if _tmt24 := MSK_appendbarvars(self.ptr(),num,_tmt23); _tmt24 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt24)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendCone(ct Conetype,conepar float64,submem []int32) (err error) {
  _tmt25 := len(submem)
  var nummem int32 = int32(_tmt25)
  var _tmt26 *int32
  if submem != nil { _tmt26 = (*C.MSKint32t)(&submem[0]) }
  if _tmt27 := MSK_appendcone(self.ptr(),ct,conepar,nummem,_tmt26); _tmt27 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt27)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendConeSeq(ct Conetype,conepar float64,nummem int32,j int32) (err error) {
  if _tmt28 := MSK_appendconeseq(self.ptr(),ct,conepar,nummem,j); _tmt28 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt28)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendConesSeq(ct []Conetype,conepar []float64,nummem []int32,j int32) (err error) {
  _tmt29 := len(conepar)
  if _tmt29 < ct { _tmt29 = lof["name"] }
  if _tmt29 < nummem { _tmt29 = lof["name"] }
  var num int32 = int32(_tmt29)
  var _tmt30 *Conetype
  if ct != nil { _tmt30 = (*C.MSKint32t)(&ct[0]) }
  var _tmt31 *float64
  if conepar != nil { _tmt31 = (*C.MSKint32t)(&conepar[0]) }
  var _tmt32 *int32
  if nummem != nil { _tmt32 = (*C.MSKint32t)(&nummem[0]) }
  if _tmt33 := MSK_appendconesseq(self.ptr(),num,_tmt30,_tmt31,_tmt32,j); _tmt33 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt33)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendCons(num int32) (err error) {
  if _tmt34 := MSK_appendcons(self.ptr(),num); _tmt34 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt34)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDjcs(num int64) (err error) {
  if _tmt35 := MSK_appenddjcs(self.ptr(),num); _tmt35 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt35)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualExpConeDomain() (domidx int64,err error) {
  if _tmt36 := MSK_appenddualexpconedomain(self.ptr(),&domidx); _tmt36 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt36)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualGeoMeanConeDomain(n int64) (domidx int64,err error) {
  if _tmt37 := MSK_appenddualgeomeanconedomain(self.ptr(),n,&domidx); _tmt37 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt37)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendDualPowerConeDomain(n int64,alpha []float64) (domidx int64,err error) {
  _tmt38 := len(alpha)
  var nleft int64 = int32(_tmt38)
  var _tmt39 *float64
  if alpha != nil { _tmt39 = (*C.MSKint32t)(&alpha[0]) }
  if _tmt40 := MSK_appenddualpowerconedomain(self.ptr(),n,nleft,_tmt39,&domidx); _tmt40 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt40)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalExpConeDomain() (domidx int64,err error) {
  if _tmt41 := MSK_appendprimalexpconedomain(self.ptr(),&domidx); _tmt41 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt41)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalGeoMeanConeDomain(n int64) (domidx int64,err error) {
  if _tmt42 := MSK_appendprimalgeomeanconedomain(self.ptr(),n,&domidx); _tmt42 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt42)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendPrimalPowerConeDomain(n int64,alpha []float64) (domidx int64,err error) {
  _tmt43 := len(alpha)
  var nleft int64 = int32(_tmt43)
  var _tmt44 *float64
  if alpha != nil { _tmt44 = (*C.MSKint32t)(&alpha[0]) }
  if _tmt45 := MSK_appendprimalpowerconedomain(self.ptr(),n,nleft,_tmt44,&domidx); _tmt45 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt45)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendQuadraticConeDomain(n int64) (domidx int64,err error) {
  if _tmt46 := MSK_appendquadraticconedomain(self.ptr(),n,&domidx); _tmt46 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt46)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRDomain(n int64) (domidx int64,err error) {
  if _tmt47 := MSK_appendrdomain(self.ptr(),n,&domidx); _tmt47 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt47)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRminusDomain(n int64) (domidx int64,err error) {
  if _tmt48 := MSK_appendrminusdomain(self.ptr(),n,&domidx); _tmt48 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt48)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRplusDomain(n int64) (domidx int64,err error) {
  if _tmt49 := MSK_appendrplusdomain(self.ptr(),n,&domidx); _tmt49 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt49)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRQuadraticConeDomain(n int64) (domidx int64,err error) {
  if _tmt50 := MSK_appendrquadraticconedomain(self.ptr(),n,&domidx); _tmt50 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt50)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendRzeroDomain(n int64) (domidx int64,err error) {
  if _tmt51 := MSK_appendrzerodomain(self.ptr(),n,&domidx); _tmt51 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt51)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSparseSymMat(dim int32,subi []int32,subj []int32,valij []float64) (idx int64,err error) {
  _tmt52 := len(subi)
  if _tmt52 < valij { _tmt52 = lof["name"] }
  if _tmt52 < subj { _tmt52 = lof["name"] }
  var nz int64 = int32(_tmt52)
  var _tmt53 *int32
  if subi != nil { _tmt53 = (*C.MSKint32t)(&subi[0]) }
  var _tmt54 *int32
  if subj != nil { _tmt54 = (*C.MSKint32t)(&subj[0]) }
  var _tmt55 *float64
  if valij != nil { _tmt55 = (*C.MSKint32t)(&valij[0]) }
  if _tmt56 := MSK_appendsparsesymmat(self.ptr(),dim,nz,_tmt53,_tmt54,_tmt55,&idx); _tmt56 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt56)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSparseSymMatList(dims []int32,nz []int64,subi []int32,subj []int32,valij []float64) (idx []int64,err error) {
  _tmt57 := len(dims)
  if _tmt57 < nz { _tmt57 = lof["name"] }
  var num int32 = int32(_tmt57)
  var _tmt58 *int32
  if dims != nil { _tmt58 = (*C.MSKint32t)(&dims[0]) }
  var _tmt59 *int64
  if nz != nil { _tmt59 = (*C.MSKint32t)(&nz[0]) }
  var _tmt60 *int32
  if len(subi) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"subi"}
    return
  }
  if subi != nil { _tmt60 = (*C.MSKint32t)(&subi[0]) }
  var _tmt61 *int32
  if len(subj) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"subj"}
    return
  }
  if subj != nil { _tmt61 = (*C.MSKint32t)(&subj[0]) }
  var _tmt62 *float64
  if len(valij) < nz.foldl(a+b) {
    err = &ArrayLengthError{fun:"AppendSparseSymMatList",arg:"valij"}
    return
  }
  if valij != nil { _tmt62 = (*C.MSKint32t)(&valij[0]) }
  var _tmt63 *int64
  idx := make([]int64,num)
  if len(idx) > 0 { _tmt63 = (*int64)(&n[0]) }
  if _tmt64 := MSK_appendsparsesymmatlist(self.ptr(),num,_tmt58,_tmt59,_tmt60,_tmt61,_tmt62,_tmt63); _tmt64 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt64)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendSvecPsdConeDomain(n int64) (domidx int64,err error) {
  if _tmt65 := MSK_appendsvecpsdconedomain(self.ptr(),n,&domidx); _tmt65 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt65)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AppendVars(num int32) (err error) {
  if _tmt66 := MSK_appendvars(self.ptr(),num); _tmt66 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt66)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AsyncGetResult(address string,accesstoken string,token string) (respavailable bool,resp Rescode,trm Rescode,err error) {
  _tmt67 := C.CString(address)
  _tmt68 := C.CString(accesstoken)
  _tmt69 := C.CString(token)
  if _tmt70 := MSK_asyncgetresult(self.ptr(),_tmt67,_tmt68,_tmt69,&respavailable,&resp,&trm); _tmt70 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt70)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AsyncOptimize(address string,accesstoken string) (token string,err error) {
  _tmt71 := C.CString(address)
  _tmt72 := C.CString(accesstoken)
  _tmt73 := make([]byte,33)
  if _tmt74 := MSK_asyncoptimize(self.ptr(),_tmt71,_tmt72,C.CString(&tmpvar1[0])); _tmt74 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt74)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var token string
  if p := strings.IndexByte(_tmt73,byte(0)); p < 0 {
    token = string(_tmt73)
  } else {
    token = string(_tmt73[:p])
  }
  return
}
func (self *Task) AsyncPoll(address string,accesstoken string,token string) (respavailable bool,resp Rescode,trm Rescode,err error) {
  _tmt75 := C.CString(address)
  _tmt76 := C.CString(accesstoken)
  _tmt77 := C.CString(token)
  if _tmt78 := MSK_asyncpoll(self.ptr(),_tmt75,_tmt76,_tmt77,&respavailable,&resp,&trm); _tmt78 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt78)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) AsyncStop(address string,accesstoken string,token string) (err error) {
  _tmt79 := C.CString(address)
  _tmt80 := C.CString(accesstoken)
  _tmt81 := C.CString(token)
  if _tmt82 := MSK_asyncstop(self.ptr(),_tmt79,_tmt80,_tmt81); _tmt82 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt82)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) BasisCond() (nrmbasis float64,nrminvbasis float64,err error) {
  if _tmt83 := MSK_basiscond(self.ptr(),&nrmbasis,&nrminvbasis); _tmt83 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt83)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) CheckMem(file string,line int32) (err error) {
  _tmt84 := C.CString(file)
  if _tmt85 := MSK_checkmemtask(self.ptr(),_tmt84,line); _tmt85 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt85)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ChgConBound(i int32,lower int32,finite int32,value float64) (err error) {
  if _tmt86 := MSK_chgconbound(self.ptr(),i,lower,finite,value); _tmt86 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt86)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ChgVarBound(j int32,lower int32,finite int32,value float64) (err error) {
  if _tmt87 := MSK_chgvarbound(self.ptr(),j,lower,finite,value); _tmt87 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt87)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) CommitChanges() (err error) {
  if _tmt88 := MSK_commitchanges(self.ptr()); _tmt88 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt88)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) DeleteSolution(whichsol Soltype) (err error) {
  if _tmt89 := MSK_deletesolution(self.ptr(),whichsol); _tmt89 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt89)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) DualSensitivity(subj []int32) (leftpricej []float64,rightpricej []float64,leftrangej []float64,rightrangej []float64,err error) {
  _tmt90 := len(subj)
  var numj int32 = int32(_tmt90)
  var _tmt91 *int32
  if subj != nil { _tmt91 = (*C.MSKint32t)(&subj[0]) }
  var _tmt92 *float64
  leftpricej := make([]float64,numj)
  if len(leftpricej) > 0 { _tmt92 = (*float64)(&n[0]) }
  var _tmt93 *float64
  rightpricej := make([]float64,numj)
  if len(rightpricej) > 0 { _tmt93 = (*float64)(&n[0]) }
  var _tmt94 *float64
  leftrangej := make([]float64,numj)
  if len(leftrangej) > 0 { _tmt94 = (*float64)(&n[0]) }
  var _tmt95 *float64
  rightrangej := make([]float64,numj)
  if len(rightrangej) > 0 { _tmt95 = (*float64)(&n[0]) }
  if _tmt96 := MSK_dualsensitivity(self.ptr(),numj,_tmt91,_tmt92,_tmt93,_tmt94,_tmt95); _tmt96 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt96)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeBarfRow(afeidx int64) (err error) {
  if _tmt97 := MSK_emptyafebarfrow(self.ptr(),afeidx); _tmt97 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt97)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeBarfRowList(afeidxlist []int64) (err error) {
  _tmt98 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt98)
  var _tmt99 *int64
  if afeidxlist != nil { _tmt99 = (*C.MSKint32t)(&afeidxlist[0]) }
  if _tmt100 := MSK_emptyafebarfrowlist(self.ptr(),numafeidx,_tmt99); _tmt100 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt100)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFCol(varidx int32) (err error) {
  if _tmt101 := MSK_emptyafefcol(self.ptr(),varidx); _tmt101 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt101)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFColList(varidx []int32) (err error) {
  _tmt102 := len(varidx)
  var numvaridx int64 = int32(_tmt102)
  var _tmt103 *int32
  if varidx != nil { _tmt103 = (*C.MSKint32t)(&varidx[0]) }
  if _tmt104 := MSK_emptyafefcollist(self.ptr(),numvaridx,_tmt103); _tmt104 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt104)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFRow(afeidx int64) (err error) {
  if _tmt105 := MSK_emptyafefrow(self.ptr(),afeidx); _tmt105 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt105)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EmptyAfeFRowList(afeidx []int64) (err error) {
  _tmt106 := len(afeidx)
  var numafeidx int64 = int32(_tmt106)
  var _tmt107 *int64
  if afeidx != nil { _tmt107 = (*C.MSKint32t)(&afeidx[0]) }
  if _tmt108 := MSK_emptyafefrowlist(self.ptr(),numafeidx,_tmt107); _tmt108 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt108)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EvaluateAcc(whichsol Soltype,accidx int64) (activity []float64,err error) {
  var _tmt111 *float64
  var _tmt109 int64
  if _tmt110 := MSK_getaccn(task.nativep,accidx,addr(_tmt109)); _tmt110 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt110)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  activity := make([]float64,_tmt109)
  if len(activity) > 0 { _tmt111 = (*float64)(&n[0]) }
  if _tmt112 := MSK_evaluateacc(self.ptr(),whichsol,accidx,_tmt111); _tmt112 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt112)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) EvaluateAccs(whichsol Soltype) (activity []float64,err error) {
  var _tmt115 *float64
  var _tmt113 int64
  if _tmt114 := MSK_getaccntot(task.nativep,addr(_tmt113)); _tmt114 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt114)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  activity := make([]float64,_tmt113)
  if len(activity) > 0 { _tmt115 = (*float64)(&n[0]) }
  if _tmt116 := MSK_evaluateaccs(self.ptr(),whichsol,_tmt115); _tmt116 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt116)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateAccNames(sub []int64,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt117 := len(sub)
  var num int64 = int32(_tmt117)
  var _tmt118 *int64
  if sub != nil { _tmt118 = (*C.MSKint32t)(&sub[0]) }
  _tmt119 := C.CString(fmt)
  _tmt120 := len(dims)
  var ndims int32 = int32(_tmt120)
  var _tmt121 *int32
  if dims != nil { _tmt121 = (*C.MSKint32t)(&dims[0]) }
  var _tmt122 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateAccNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt122 = (*C.MSKint32t)(&sp[0]) }
  _tmt123 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt123)
  var _tmt124 *int32
  if namedaxisidxs != nil { _tmt124 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt125 := len(names)
  var numnames int64 = int32(_tmt125)
  var _tmt126 *string
  if names != nil { _tmt126 = (*C.MSKint32t)(&names[0]) }
  if _tmt127 := MSK_generateaccnames(self.ptr(),num,_tmt118,_tmt119,ndims,_tmt121,_tmt122,numnamedaxis,_tmt124,numnames,_tmt126); _tmt127 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt127)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateBarvarNames(subj []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt128 := len(subj)
  var num int32 = int32(_tmt128)
  var _tmt129 *int32
  if subj != nil { _tmt129 = (*C.MSKint32t)(&subj[0]) }
  _tmt130 := C.CString(fmt)
  _tmt131 := len(dims)
  var ndims int32 = int32(_tmt131)
  var _tmt132 *int32
  if dims != nil { _tmt132 = (*C.MSKint32t)(&dims[0]) }
  var _tmt133 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateBarvarNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt133 = (*C.MSKint32t)(&sp[0]) }
  _tmt134 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt134)
  var _tmt135 *int32
  if namedaxisidxs != nil { _tmt135 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt136 := len(names)
  var numnames int64 = int32(_tmt136)
  var _tmt137 *string
  if names != nil { _tmt137 = (*C.MSKint32t)(&names[0]) }
  if _tmt138 := MSK_generatebarvarnames(self.ptr(),num,_tmt129,_tmt130,ndims,_tmt132,_tmt133,numnamedaxis,_tmt135,numnames,_tmt137); _tmt138 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt138)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateConeNames(subk []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt139 := len(subk)
  var num int32 = int32(_tmt139)
  var _tmt140 *int32
  if subk != nil { _tmt140 = (*C.MSKint32t)(&subk[0]) }
  _tmt141 := C.CString(fmt)
  _tmt142 := len(dims)
  var ndims int32 = int32(_tmt142)
  var _tmt143 *int32
  if dims != nil { _tmt143 = (*C.MSKint32t)(&dims[0]) }
  var _tmt144 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateConeNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt144 = (*C.MSKint32t)(&sp[0]) }
  _tmt145 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt145)
  var _tmt146 *int32
  if namedaxisidxs != nil { _tmt146 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt147 := len(names)
  var numnames int64 = int32(_tmt147)
  var _tmt148 *string
  if names != nil { _tmt148 = (*C.MSKint32t)(&names[0]) }
  if _tmt149 := MSK_generateconenames(self.ptr(),num,_tmt140,_tmt141,ndims,_tmt143,_tmt144,numnamedaxis,_tmt146,numnames,_tmt148); _tmt149 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt149)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateConNames(subi []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt150 := len(subi)
  var num int32 = int32(_tmt150)
  var _tmt151 *int32
  if subi != nil { _tmt151 = (*C.MSKint32t)(&subi[0]) }
  _tmt152 := C.CString(fmt)
  _tmt153 := len(dims)
  var ndims int32 = int32(_tmt153)
  var _tmt154 *int32
  if dims != nil { _tmt154 = (*C.MSKint32t)(&dims[0]) }
  var _tmt155 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateConNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt155 = (*C.MSKint32t)(&sp[0]) }
  _tmt156 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt156)
  var _tmt157 *int32
  if namedaxisidxs != nil { _tmt157 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt158 := len(names)
  var numnames int64 = int32(_tmt158)
  var _tmt159 *string
  if names != nil { _tmt159 = (*C.MSKint32t)(&names[0]) }
  if _tmt160 := MSK_generateconnames(self.ptr(),num,_tmt151,_tmt152,ndims,_tmt154,_tmt155,numnamedaxis,_tmt157,numnames,_tmt159); _tmt160 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt160)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateDjcNames(sub []int64,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt161 := len(sub)
  var num int64 = int32(_tmt161)
  var _tmt162 *int64
  if sub != nil { _tmt162 = (*C.MSKint32t)(&sub[0]) }
  _tmt163 := C.CString(fmt)
  _tmt164 := len(dims)
  var ndims int32 = int32(_tmt164)
  var _tmt165 *int32
  if dims != nil { _tmt165 = (*C.MSKint32t)(&dims[0]) }
  var _tmt166 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateDjcNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt166 = (*C.MSKint32t)(&sp[0]) }
  _tmt167 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt167)
  var _tmt168 *int32
  if namedaxisidxs != nil { _tmt168 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt169 := len(names)
  var numnames int64 = int32(_tmt169)
  var _tmt170 *string
  if names != nil { _tmt170 = (*C.MSKint32t)(&names[0]) }
  if _tmt171 := MSK_generatedjcnames(self.ptr(),num,_tmt162,_tmt163,ndims,_tmt165,_tmt166,numnamedaxis,_tmt168,numnames,_tmt170); _tmt171 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt171)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GenerateVarNames(subj []int32,fmt string,dims []int32,sp []int64,namedaxisidxs []int32,names []string) (err error) {
  _tmt172 := len(subj)
  var num int32 = int32(_tmt172)
  var _tmt173 *int32
  if subj != nil { _tmt173 = (*C.MSKint32t)(&subj[0]) }
  _tmt174 := C.CString(fmt)
  _tmt175 := len(dims)
  var ndims int32 = int32(_tmt175)
  var _tmt176 *int32
  if dims != nil { _tmt176 = (*C.MSKint32t)(&dims[0]) }
  var _tmt177 *int64
  if len(sp) < num {
    err = &ArrayLengthError{fun:"GenerateVarNames",arg:"sp"}
    return
  }
  if sp != nil { _tmt177 = (*C.MSKint32t)(&sp[0]) }
  _tmt178 := len(namedaxisidxs)
  var numnamedaxis int32 = int32(_tmt178)
  var _tmt179 *int32
  if namedaxisidxs != nil { _tmt179 = (*C.MSKint32t)(&namedaxisidxs[0]) }
  _tmt180 := len(names)
  var numnames int64 = int32(_tmt180)
  var _tmt181 *string
  if names != nil { _tmt181 = (*C.MSKint32t)(&names[0]) }
  if _tmt182 := MSK_generatevarnames(self.ptr(),num,_tmt173,_tmt174,ndims,_tmt176,_tmt177,numnamedaxis,_tmt179,numnames,_tmt181); _tmt182 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt182)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccAfeIdxList(accidx int64) (afeidxlist []int64,err error) {
  var _tmt185 *int64
  var _tmt183 int64
  if _tmt184 := MSK_getaccn(task.nativep,accidx,addr(_tmt183)); _tmt184 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt184)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt183)
  if len(afeidxlist) > 0 { _tmt185 = (*int64)(&n[0]) }
  if _tmt186 := MSK_getaccafeidxlist(self.ptr(),accidx,_tmt185); _tmt186 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt186)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccB(accidx int64) (b []float64,err error) {
  var _tmt189 *float64
  var _tmt187 int64
  if _tmt188 := MSK_getaccn(task.nativep,accidx,addr(_tmt187)); _tmt188 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt188)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt187)
  if len(b) > 0 { _tmt189 = (*float64)(&n[0]) }
  if _tmt190 := MSK_getaccb(self.ptr(),accidx,_tmt189); _tmt190 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt190)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccBarfBlockTriplet() (numtrip int64,acc_afe []int64,bar_var []int32,blk_row []int32,blk_col []int32,blk_val []float64,err error) {
  var _tmt191 int64
  if _tmt192 := MSK_getaccbarfnumblocktriplets(task.nativep,addr(_tmt191)); _tmt192 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt192)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumtrip int64 = _tmt191
  var _tmt193 *int64
  acc_afe := make([]int64,maxnumtrip)
  if len(acc_afe) > 0 { _tmt193 = (*int64)(&n[0]) }
  var _tmt194 *int32
  bar_var := make([]int32,maxnumtrip)
  if len(bar_var) > 0 { _tmt194 = (*int32)(&n[0]) }
  var _tmt195 *int32
  blk_row := make([]int32,maxnumtrip)
  if len(blk_row) > 0 { _tmt195 = (*int32)(&n[0]) }
  var _tmt196 *int32
  blk_col := make([]int32,maxnumtrip)
  if len(blk_col) > 0 { _tmt196 = (*int32)(&n[0]) }
  var _tmt197 *float64
  blk_val := make([]float64,maxnumtrip)
  if len(blk_val) > 0 { _tmt197 = (*float64)(&n[0]) }
  if _tmt198 := MSK_getaccbarfblocktriplet(self.ptr(),maxnumtrip,&numtrip,_tmt193,_tmt194,_tmt195,_tmt196,_tmt197); _tmt198 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt198)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccBarfNumBlockTriplets() (numtrip int64,err error) {
  if _tmt199 := MSK_getaccbarfnumblocktriplets(self.ptr(),&numtrip); _tmt199 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt199)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDomain(accidx int64) (domidx int64,err error) {
  if _tmt200 := MSK_getaccdomain(self.ptr(),accidx,&domidx); _tmt200 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt200)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDotY(whichsol Soltype,accidx int64) (doty []float64,err error) {
  var _tmt203 *float64
  var _tmt201 int64
  if _tmt202 := MSK_getaccn(task.nativep,accidx,addr(_tmt201)); _tmt202 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt202)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt201)
  if len(doty) > 0 { _tmt203 = (*float64)(&n[0]) }
  if _tmt204 := MSK_getaccdoty(self.ptr(),whichsol,accidx,_tmt203); _tmt204 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt204)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccDotYS(whichsol Soltype) (doty []float64,err error) {
  var _tmt207 *float64
  var _tmt205 int64
  if _tmt206 := MSK_getaccntot(task.nativep,addr(_tmt205)); _tmt206 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt206)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt205)
  if len(doty) > 0 { _tmt207 = (*float64)(&n[0]) }
  if _tmt208 := MSK_getaccdotys(self.ptr(),whichsol,_tmt207); _tmt208 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt208)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccFNumnz() (accfnnz int64,err error) {
  if _tmt209 := MSK_getaccfnumnz(self.ptr(),&accfnnz); _tmt209 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt209)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccFTrip() (frow []int64,fcol []int32,fval []float64,err error) {
  var _tmt212 *int64
  var _tmt210 int64
  if _tmt211 := MSK_getaccfnumnz(task.nativep,addr(_tmt210)); _tmt211 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt211)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  frow := make([]int64,_tmt210)
  if len(frow) > 0 { _tmt212 = (*int64)(&n[0]) }
  var _tmt215 *int32
  var _tmt213 int64
  if _tmt214 := MSK_getaccfnumnz(task.nativep,addr(_tmt213)); _tmt214 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt214)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  fcol := make([]int32,_tmt213)
  if len(fcol) > 0 { _tmt215 = (*int32)(&n[0]) }
  var _tmt218 *float64
  var _tmt216 int64
  if _tmt217 := MSK_getaccfnumnz(task.nativep,addr(_tmt216)); _tmt217 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt217)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  fval := make([]float64,_tmt216)
  if len(fval) > 0 { _tmt218 = (*float64)(&n[0]) }
  if _tmt219 := MSK_getaccftrip(self.ptr(),_tmt212,_tmt215,_tmt218); _tmt219 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt219)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccGVector() (g []float64,err error) {
  var _tmt222 *float64
  var _tmt220 int64
  if _tmt221 := MSK_getaccntot(task.nativep,addr(_tmt220)); _tmt221 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt221)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  g := make([]float64,_tmt220)
  if len(g) > 0 { _tmt222 = (*float64)(&n[0]) }
  if _tmt223 := MSK_getaccgvector(self.ptr(),_tmt222); _tmt223 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt223)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccN(accidx int64) (n int64,err error) {
  if _tmt224 := MSK_getaccn(self.ptr(),accidx,&n); _tmt224 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt224)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccName(accidx int64) (name string,err error) {
  var _tmt225 int32
  if _tmt226 := MSK_getaccnamelen(task.nativep,accidx,addr(_tmt225)); _tmt226 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt226)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt225)
  _tmt227 := make([]byte,sizename)
  if _tmt228 := MSK_getaccname(self.ptr(),accidx,sizename,C.CString(&tmpvar1[0])); _tmt228 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt228)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt227,byte(0)); p < 0 {
    name = string(_tmt227)
  } else {
    name = string(_tmt227[:p])
  }
  return
}
func (self *Task) GetAccNameLen(accidx int64) (len int32,err error) {
  if _tmt229 := MSK_getaccnamelen(self.ptr(),accidx,&len); _tmt229 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt229)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccNTot() (n int64,err error) {
  if _tmt230 := MSK_getaccntot(self.ptr(),&n); _tmt230 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt230)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAccs() (domidxlist []int64,afeidxlist []int64,b []float64,err error) {
  var _tmt233 *int64
  var _tmt231 int64
  if _tmt232 := MSK_getnumacc(task.nativep,addr(_tmt231)); _tmt232 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt232)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt231)
  if len(domidxlist) > 0 { _tmt233 = (*int64)(&n[0]) }
  var _tmt236 *int64
  var _tmt234 int64
  if _tmt235 := MSK_getaccntot(task.nativep,addr(_tmt234)); _tmt235 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt235)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt234)
  if len(afeidxlist) > 0 { _tmt236 = (*int64)(&n[0]) }
  var _tmt239 *float64
  var _tmt237 int64
  if _tmt238 := MSK_getaccntot(task.nativep,addr(_tmt237)); _tmt238 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt238)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt237)
  if len(b) > 0 { _tmt239 = (*float64)(&n[0]) }
  if _tmt240 := MSK_getaccs(self.ptr(),_tmt233,_tmt236,_tmt239); _tmt240 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt240)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetACol(j int32) (nzj int32,subj []int32,valj []float64,err error) {
  var _tmt243 *int32
  var _tmt241 int32
  if _tmt242 := MSK_getacolnumnz(task.nativep,j,addr(_tmt241)); _tmt242 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt242)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  subj := make([]int32,_tmt241)
  if len(subj) > 0 { _tmt243 = (*int32)(&n[0]) }
  var _tmt246 *float64
  var _tmt244 int32
  if _tmt245 := MSK_getacolnumnz(task.nativep,j,addr(_tmt244)); _tmt245 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt245)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  valj := make([]float64,_tmt244)
  if len(valj) > 0 { _tmt246 = (*float64)(&n[0]) }
  if _tmt247 := MSK_getacol(self.ptr(),j,&nzj,_tmt243,_tmt246); _tmt247 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt247)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColNumNz(i int32) (nzj int32,err error) {
  if _tmt248 := MSK_getacolnumnz(self.ptr(),i,&nzj); _tmt248 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt248)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSlice(first int32,last int32) (ptrb []int64,ptre []int64,sub []int32,val []float64,err error) {
  var _tmt249 int64
  if _tmt250 := MSK_getacolslicenumnz64(task.nativep,first,last,addr(_tmt249)); _tmt250 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt250)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt249
  var _tmt251 *int64
  ptrb := make([]int64,(last - first))
  if len(ptrb) > 0 { _tmt251 = (*int64)(&n[0]) }
  var _tmt252 *int64
  ptre := make([]int64,(last - first))
  if len(ptre) > 0 { _tmt252 = (*int64)(&n[0]) }
  var _tmt253 *int32
  sub := make([]int32,maxnumnz)
  if len(sub) > 0 { _tmt253 = (*int32)(&n[0]) }
  var _tmt254 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt254 = (*float64)(&n[0]) }
  if _tmt255 := MSK_getacolslice64(self.ptr(),first,last,maxnumnz,_tmt251,_tmt252,_tmt253,_tmt254); _tmt255 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt255)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSliceNumNz(first int32,last int32) (numnz int64,err error) {
  if _tmt256 := MSK_getacolslicenumnz64(self.ptr(),first,last,&numnz); _tmt256 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt256)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAColSliceTrip(first int32,last int32) (subi []int32,subj []int32,val []float64,err error) {
  var _tmt257 int64
  if _tmt258 := MSK_getacolslicenumnz64(task.nativep,first,last,addr(_tmt257)); _tmt258 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt258)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt257
  var _tmt259 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt259 = (*int32)(&n[0]) }
  var _tmt260 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt260 = (*int32)(&n[0]) }
  var _tmt261 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt261 = (*float64)(&n[0]) }
  if _tmt262 := MSK_getacolslicetrip(self.ptr(),first,last,maxnumnz,_tmt259,_tmt260,_tmt261); _tmt262 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt262)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfBlockTriplet() (numtrip int64,afeidx []int64,barvaridx []int32,subk []int32,subl []int32,valkl []float64,err error) {
  var _tmt263 int64
  if _tmt264 := MSK_getafebarfnumblocktriplets(task.nativep,addr(_tmt263)); _tmt264 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt264)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumtrip int64 = _tmt263
  var _tmt265 *int64
  afeidx := make([]int64,maxnumtrip)
  if len(afeidx) > 0 { _tmt265 = (*int64)(&n[0]) }
  var _tmt266 *int32
  barvaridx := make([]int32,maxnumtrip)
  if len(barvaridx) > 0 { _tmt266 = (*int32)(&n[0]) }
  var _tmt267 *int32
  subk := make([]int32,maxnumtrip)
  if len(subk) > 0 { _tmt267 = (*int32)(&n[0]) }
  var _tmt268 *int32
  subl := make([]int32,maxnumtrip)
  if len(subl) > 0 { _tmt268 = (*int32)(&n[0]) }
  var _tmt269 *float64
  valkl := make([]float64,maxnumtrip)
  if len(valkl) > 0 { _tmt269 = (*float64)(&n[0]) }
  if _tmt270 := MSK_getafebarfblocktriplet(self.ptr(),maxnumtrip,&numtrip,_tmt265,_tmt266,_tmt267,_tmt268,_tmt269); _tmt270 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt270)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfNumBlockTriplets() (numtrip int64,err error) {
  if _tmt271 := MSK_getafebarfnumblocktriplets(self.ptr(),&numtrip); _tmt271 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt271)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfNumRowEntries(afeidx int64) (numentr int32,err error) {
  if _tmt272 := MSK_getafebarfnumrowentries(self.ptr(),afeidx,&numentr); _tmt272 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt272)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfRow(afeidx int64) (barvaridx []int32,ptrterm []int64,numterm []int64,termidx []int64,termweight []float64,err error) {
  var _tmt276 *int32
  var _tmt273 int32
  var _tmt274 int64
  if _tmt275 := MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt273),addr(_tmt274)); _tmt275 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt275)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barvaridx := make([]int32,_tmt273)
  if len(barvaridx) > 0 { _tmt276 = (*int32)(&n[0]) }
  var _tmt280 *int64
  var _tmt277 int32
  var _tmt278 int64
  if _tmt279 := MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt277),addr(_tmt278)); _tmt279 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt279)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  ptrterm := make([]int64,_tmt277)
  if len(ptrterm) > 0 { _tmt280 = (*int64)(&n[0]) }
  var _tmt284 *int64
  var _tmt281 int32
  var _tmt282 int64
  if _tmt283 := MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt281),addr(_tmt282)); _tmt283 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt283)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  numterm := make([]int64,_tmt281)
  if len(numterm) > 0 { _tmt284 = (*int64)(&n[0]) }
  var _tmt288 *int64
  var _tmt285 int32
  var _tmt286 int64
  if _tmt287 := MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt285),addr(_tmt286)); _tmt287 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt287)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termidx := make([]int64,_tmt286)
  if len(termidx) > 0 { _tmt288 = (*int64)(&n[0]) }
  var _tmt292 *float64
  var _tmt289 int32
  var _tmt290 int64
  if _tmt291 := MSK_getafebarfrowinfo(task.nativep,afeidx,addr(_tmt289),addr(_tmt290)); _tmt291 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt291)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termweight := make([]float64,_tmt290)
  if len(termweight) > 0 { _tmt292 = (*float64)(&n[0]) }
  if _tmt293 := MSK_getafebarfrow(self.ptr(),afeidx,_tmt276,_tmt280,_tmt284,_tmt288,_tmt292); _tmt293 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt293)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeBarfRowInfo(afeidx int64) (numentr int32,numterm int64,err error) {
  if _tmt294 := MSK_getafebarfrowinfo(self.ptr(),afeidx,&numentr,&numterm); _tmt294 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt294)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFNumNz() (numnz int64,err error) {
  if _tmt295 := MSK_getafefnumnz(self.ptr(),&numnz); _tmt295 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt295)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFRow(afeidx int64) (numnz int32,varidx []int32,val []float64,err error) {
  var _tmt298 *int32
  var _tmt296 int32
  if _tmt297 := MSK_getafefrownumnz(task.nativep,afeidx,addr(_tmt296)); _tmt297 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt297)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  varidx := make([]int32,_tmt296)
  if len(varidx) > 0 { _tmt298 = (*int32)(&n[0]) }
  var _tmt301 *float64
  var _tmt299 int32
  if _tmt300 := MSK_getafefrownumnz(task.nativep,afeidx,addr(_tmt299)); _tmt300 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt300)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  val := make([]float64,_tmt299)
  if len(val) > 0 { _tmt301 = (*float64)(&n[0]) }
  if _tmt302 := MSK_getafefrow(self.ptr(),afeidx,&numnz,_tmt298,_tmt301); _tmt302 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt302)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFRowNumNz(afeidx int64) (numnz int32,err error) {
  if _tmt303 := MSK_getafefrownumnz(self.ptr(),afeidx,&numnz); _tmt303 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt303)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeFTrip() (afeidx []int64,varidx []int32,val []float64,err error) {
  var _tmt306 *int64
  var _tmt304 int64
  if _tmt305 := MSK_getafefnumnz(task.nativep,addr(_tmt304)); _tmt305 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt305)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidx := make([]int64,_tmt304)
  if len(afeidx) > 0 { _tmt306 = (*int64)(&n[0]) }
  var _tmt309 *int32
  var _tmt307 int64
  if _tmt308 := MSK_getafefnumnz(task.nativep,addr(_tmt307)); _tmt308 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt308)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  varidx := make([]int32,_tmt307)
  if len(varidx) > 0 { _tmt309 = (*int32)(&n[0]) }
  var _tmt312 *float64
  var _tmt310 int64
  if _tmt311 := MSK_getafefnumnz(task.nativep,addr(_tmt310)); _tmt311 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt311)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  val := make([]float64,_tmt310)
  if len(val) > 0 { _tmt312 = (*float64)(&n[0]) }
  if _tmt313 := MSK_getafeftrip(self.ptr(),_tmt306,_tmt309,_tmt312); _tmt313 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt313)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeG(afeidx int64) (g float64,err error) {
  if _tmt314 := MSK_getafeg(self.ptr(),afeidx,&g); _tmt314 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt314)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAfeGSlice(first int64,last int64) (g []float64,err error) {
  var _tmt315 *float64
  g := make([]float64,(last - first))
  if len(g) > 0 { _tmt315 = (*float64)(&n[0]) }
  if _tmt316 := MSK_getafegslice(self.ptr(),first,last,_tmt315); _tmt316 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt316)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAij(i int32,j int32) (aij float64,err error) {
  if _tmt317 := MSK_getaij(self.ptr(),i,j,&aij); _tmt317 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt317)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetAPieceNumNz(firsti int32,lasti int32,firstj int32,lastj int32) (numnz int32,err error) {
  if _tmt318 := MSK_getapiecenumnz(self.ptr(),firsti,lasti,firstj,lastj,&numnz); _tmt318 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt318)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARow(i int32) (nzi int32,subi []int32,vali []float64,err error) {
  var _tmt321 *int32
  var _tmt319 int32
  if _tmt320 := MSK_getarownumnz(task.nativep,i,addr(_tmt319)); _tmt320 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt320)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  subi := make([]int32,_tmt319)
  if len(subi) > 0 { _tmt321 = (*int32)(&n[0]) }
  var _tmt324 *float64
  var _tmt322 int32
  if _tmt323 := MSK_getarownumnz(task.nativep,i,addr(_tmt322)); _tmt323 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt323)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  vali := make([]float64,_tmt322)
  if len(vali) > 0 { _tmt324 = (*float64)(&n[0]) }
  if _tmt325 := MSK_getarow(self.ptr(),i,&nzi,_tmt321,_tmt324); _tmt325 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt325)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowNumNz(i int32) (nzi int32,err error) {
  if _tmt326 := MSK_getarownumnz(self.ptr(),i,&nzi); _tmt326 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt326)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSlice(first int32,last int32) (ptrb []int64,ptre []int64,sub []int32,val []float64,err error) {
  var _tmt327 int64
  if _tmt328 := MSK_getarowslicenumnz64(task.nativep,first,last,addr(_tmt327)); _tmt328 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt328)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt327
  var _tmt329 *int64
  ptrb := make([]int64,(last - first))
  if len(ptrb) > 0 { _tmt329 = (*int64)(&n[0]) }
  var _tmt330 *int64
  ptre := make([]int64,(last - first))
  if len(ptre) > 0 { _tmt330 = (*int64)(&n[0]) }
  var _tmt331 *int32
  sub := make([]int32,maxnumnz)
  if len(sub) > 0 { _tmt331 = (*int32)(&n[0]) }
  var _tmt332 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt332 = (*float64)(&n[0]) }
  if _tmt333 := MSK_getarowslice64(self.ptr(),first,last,maxnumnz,_tmt329,_tmt330,_tmt331,_tmt332); _tmt333 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt333)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSliceNumNz(first int32,last int32) (numnz int64,err error) {
  if _tmt334 := MSK_getarowslicenumnz64(self.ptr(),first,last,&numnz); _tmt334 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt334)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetARowSliceTrip(first int32,last int32) (subi []int32,subj []int32,val []float64,err error) {
  var _tmt335 int64
  if _tmt336 := MSK_getarowslicenumnz64(task.nativep,first,last,addr(_tmt335)); _tmt336 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt336)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt335
  var _tmt337 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt337 = (*int32)(&n[0]) }
  var _tmt338 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt338 = (*int32)(&n[0]) }
  var _tmt339 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt339 = (*float64)(&n[0]) }
  if _tmt340 := MSK_getarowslicetrip(self.ptr(),first,last,maxnumnz,_tmt337,_tmt338,_tmt339); _tmt340 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt340)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetATrip() (subi []int32,subj []int32,val []float64,err error) {
  var _tmt341 int64
  if _tmt342 := MSK_getnumanz64(task.nativep,addr(_tmt341)); _tmt342 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt342)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt341
  var _tmt343 *int32
  subi := make([]int32,maxnumnz)
  if len(subi) > 0 { _tmt343 = (*int32)(&n[0]) }
  var _tmt344 *int32
  subj := make([]int32,maxnumnz)
  if len(subj) > 0 { _tmt344 = (*int32)(&n[0]) }
  var _tmt345 *float64
  val := make([]float64,maxnumnz)
  if len(val) > 0 { _tmt345 = (*float64)(&n[0]) }
  if _tmt346 := MSK_getatrip(self.ptr(),maxnumnz,_tmt343,_tmt344,_tmt345); _tmt346 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt346)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetATruncateTol() (tolzero []float64,err error) {
  var _tmt347 *float64
  tolzero := make([]float64,1)
  if len(tolzero) > 0 { _tmt347 = (*float64)(&n[0]) }
  if _tmt348 := MSK_getatruncatetol(self.ptr(),_tmt347); _tmt348 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt348)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraBlockTriplet() (num int64,subi []int32,subj []int32,subk []int32,subl []int32,valijkl []float64,err error) {
  var _tmt349 int64
  if _tmt350 := MSK_getnumbarablocktriplets(task.nativep,addr(_tmt349)); _tmt350 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt350)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt349
  var _tmt351 *int32
  subi := make([]int32,maxnum)
  if len(subi) > 0 { _tmt351 = (*int32)(&n[0]) }
  var _tmt352 *int32
  subj := make([]int32,maxnum)
  if len(subj) > 0 { _tmt352 = (*int32)(&n[0]) }
  var _tmt353 *int32
  subk := make([]int32,maxnum)
  if len(subk) > 0 { _tmt353 = (*int32)(&n[0]) }
  var _tmt354 *int32
  subl := make([]int32,maxnum)
  if len(subl) > 0 { _tmt354 = (*int32)(&n[0]) }
  var _tmt355 *float64
  valijkl := make([]float64,maxnum)
  if len(valijkl) > 0 { _tmt355 = (*float64)(&n[0]) }
  if _tmt356 := MSK_getbarablocktriplet(self.ptr(),maxnum,&num,_tmt351,_tmt352,_tmt353,_tmt354,_tmt355); _tmt356 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt356)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdx(idx int64) (i int32,j int32,num int64,sub []int64,weights []float64,err error) {
  var _tmt357 int64
  if _tmt358 := MSK_getbaraidxinfo(task.nativep,idx,addr(_tmt357)); _tmt358 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt358)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt357
  var _tmt359 *int64
  sub := make([]int64,maxnum)
  if len(sub) > 0 { _tmt359 = (*int64)(&n[0]) }
  var _tmt360 *float64
  weights := make([]float64,maxnum)
  if len(weights) > 0 { _tmt360 = (*float64)(&n[0]) }
  if _tmt361 := MSK_getbaraidx(self.ptr(),idx,maxnum,&i,&j,&num,_tmt359,_tmt360); _tmt361 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt361)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdxIJ(idx int64) (i int32,j int32,err error) {
  if _tmt362 := MSK_getbaraidxij(self.ptr(),idx,&i,&j); _tmt362 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt362)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraIdxInfo(idx int64) (num int64,err error) {
  if _tmt363 := MSK_getbaraidxinfo(self.ptr(),idx,&num); _tmt363 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt363)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBaraSparsity() (numnz int64,idxij []int64,err error) {
  var _tmt364 int64
  if _tmt365 := MSK_getnumbaranz(task.nativep,addr(_tmt364)); _tmt365 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt365)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt364
  var _tmt366 *int64
  idxij := make([]int64,maxnumnz)
  if len(idxij) > 0 { _tmt366 = (*int64)(&n[0]) }
  if _tmt367 := MSK_getbarasparsity(self.ptr(),maxnumnz,&numnz,_tmt366); _tmt367 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt367)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcBlockTriplet() (num int64,subj []int32,subk []int32,subl []int32,valjkl []float64,err error) {
  var _tmt368 int64
  if _tmt369 := MSK_getnumbarcblocktriplets(task.nativep,addr(_tmt368)); _tmt369 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt369)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt368
  var _tmt370 *int32
  subj := make([]int32,maxnum)
  if len(subj) > 0 { _tmt370 = (*int32)(&n[0]) }
  var _tmt371 *int32
  subk := make([]int32,maxnum)
  if len(subk) > 0 { _tmt371 = (*int32)(&n[0]) }
  var _tmt372 *int32
  subl := make([]int32,maxnum)
  if len(subl) > 0 { _tmt372 = (*int32)(&n[0]) }
  var _tmt373 *float64
  valjkl := make([]float64,maxnum)
  if len(valjkl) > 0 { _tmt373 = (*float64)(&n[0]) }
  if _tmt374 := MSK_getbarcblocktriplet(self.ptr(),maxnum,&num,_tmt370,_tmt371,_tmt372,_tmt373); _tmt374 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt374)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdx(idx int64) (j int32,num int64,sub []int64,weights []float64,err error) {
  var _tmt375 int64
  if _tmt376 := MSK_getbarcidxinfo(task.nativep,idx,addr(_tmt375)); _tmt376 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt376)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnum int64 = _tmt375
  var _tmt377 *int64
  sub := make([]int64,maxnum)
  if len(sub) > 0 { _tmt377 = (*int64)(&n[0]) }
  var _tmt378 *float64
  weights := make([]float64,maxnum)
  if len(weights) > 0 { _tmt378 = (*float64)(&n[0]) }
  if _tmt379 := MSK_getbarcidx(self.ptr(),idx,maxnum,&j,&num,_tmt377,_tmt378); _tmt379 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt379)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdxInfo(idx int64) (num int64,err error) {
  if _tmt380 := MSK_getbarcidxinfo(self.ptr(),idx,&num); _tmt380 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt380)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcIdxJ(idx int64) (j int32,err error) {
  if _tmt381 := MSK_getbarcidxj(self.ptr(),idx,&j); _tmt381 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt381)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarcSparsity() (numnz int64,idxj []int64,err error) {
  var _tmt382 int64
  if _tmt383 := MSK_getnumbarcnz(task.nativep,addr(_tmt382)); _tmt383 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt383)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumnz int64 = _tmt382
  var _tmt384 *int64
  idxj := make([]int64,maxnumnz)
  if len(idxj) > 0 { _tmt384 = (*int64)(&n[0]) }
  if _tmt385 := MSK_getbarcsparsity(self.ptr(),maxnumnz,&numnz,_tmt384); _tmt385 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt385)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarsJ(whichsol Soltype,j int32) (barsj []float64,err error) {
  var _tmt388 *float64
  var _tmt386 int64
  if _tmt387 := MSK_getlenbarvarj(task.nativep,j,addr(_tmt386)); _tmt387 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt387)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barsj := make([]float64,_tmt386)
  if len(barsj) > 0 { _tmt388 = (*float64)(&n[0]) }
  if _tmt389 := MSK_getbarsj(self.ptr(),whichsol,j,_tmt388); _tmt389 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt389)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarsSlice(whichsol Soltype,first int32,last int32,slicesize int64) (barsslice []float64,err error) {
  var _tmt390 *float64
  barsslice := make([]float64,slicesize)
  if len(barsslice) > 0 { _tmt390 = (*float64)(&n[0]) }
  if _tmt391 := MSK_getbarsslice(self.ptr(),whichsol,first,last,slicesize,_tmt390); _tmt391 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt391)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarvarName(i int32) (name string,err error) {
  var _tmt392 int32
  if _tmt393 := MSK_getbarvarnamelen(task.nativep,i,addr(_tmt392)); _tmt393 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt393)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt392)
  _tmt394 := make([]byte,sizename)
  if _tmt395 := MSK_getbarvarname(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt395 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt395)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt394,byte(0)); p < 0 {
    name = string(_tmt394)
  } else {
    name = string(_tmt394[:p])
  }
  return
}
func (self *Task) GetBarvarNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt396 := C.CString(somename)
  if _tmt397 := MSK_getbarvarnameindex(self.ptr(),_tmt396,&asgn,&index); _tmt397 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt397)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarvarNameLen(i int32) (len int32,err error) {
  if _tmt398 := MSK_getbarvarnamelen(self.ptr(),i,&len); _tmt398 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt398)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarxJ(whichsol Soltype,j int32) (barxj []float64,err error) {
  var _tmt401 *float64
  var _tmt399 int64
  if _tmt400 := MSK_getlenbarvarj(task.nativep,j,addr(_tmt399)); _tmt400 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt400)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  barxj := make([]float64,_tmt399)
  if len(barxj) > 0 { _tmt401 = (*float64)(&n[0]) }
  if _tmt402 := MSK_getbarxj(self.ptr(),whichsol,j,_tmt401); _tmt402 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt402)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetBarxSlice(whichsol Soltype,first int32,last int32,slicesize int64) (barxslice []float64,err error) {
  var _tmt403 *float64
  barxslice := make([]float64,slicesize)
  if len(barxslice) > 0 { _tmt403 = (*float64)(&n[0]) }
  if _tmt404 := MSK_getbarxslice(self.ptr(),whichsol,first,last,slicesize,_tmt403); _tmt404 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt404)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetC() (c []float64,err error) {
  var _tmt407 *float64
  var _tmt405 int32
  if _tmt406 := MSK_getnumvar(task.nativep,addr(_tmt405)); _tmt406 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt406)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  c := make([]float64,_tmt405)
  if len(c) > 0 { _tmt407 = (*float64)(&n[0]) }
  if _tmt408 := MSK_getc(self.ptr(),_tmt407); _tmt408 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt408)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCfix() (cfix float64,err error) {
  if _tmt409 := MSK_getcfix(self.ptr(),&cfix); _tmt409 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt409)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCJ(j int32) (cj float64,err error) {
  if _tmt410 := MSK_getcj(self.ptr(),j,&cj); _tmt410 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt410)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCList(subj []int32) (c []float64,err error) {
  _tmt411 := len(subj)
  var num int32 = int32(_tmt411)
  var _tmt412 *int32
  if subj != nil { _tmt412 = (*C.MSKint32t)(&subj[0]) }
  var _tmt413 *float64
  c := make([]float64,num)
  if len(c) > 0 { _tmt413 = (*float64)(&n[0]) }
  if _tmt414 := MSK_getclist(self.ptr(),num,_tmt412,_tmt413); _tmt414 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt414)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConBound(i int32) (bk Boundkey,bl float64,bu float64,err error) {
  if _tmt415 := MSK_getconbound(self.ptr(),i,&bk,&bl,&bu); _tmt415 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt415)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConBoundSlice(first int32,last int32) (bk []Boundkey,bl []float64,bu []float64,err error) {
  var _tmt416 *Boundkey
  bk := make([]Boundkey,(last - first))
  if len(bk) > 0 { _tmt416 = (*Boundkey)(&n[0]) }
  var _tmt417 *float64
  bl := make([]float64,(last - first))
  if len(bl) > 0 { _tmt417 = (*float64)(&n[0]) }
  var _tmt418 *float64
  bu := make([]float64,(last - first))
  if len(bu) > 0 { _tmt418 = (*float64)(&n[0]) }
  if _tmt419 := MSK_getconboundslice(self.ptr(),first,last,_tmt416,_tmt417,_tmt418); _tmt419 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt419)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCone(k int32) (ct Conetype,conepar float64,nummem int32,submem []int32,err error) {
  var _tmt424 *int32
  var _tmt420 conetype
  var _tmt421 float64
  var _tmt422 int32
  if _tmt423 := MSK_getconeinfo(task.nativep,k,addr(_tmt420),addr(_tmt421),addr(_tmt422)); _tmt423 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt423)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  submem := make([]int32,_tmt422)
  if len(submem) > 0 { _tmt424 = (*int32)(&n[0]) }
  if _tmt425 := MSK_getcone(self.ptr(),k,&ct,&conepar,&nummem,_tmt424); _tmt425 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt425)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeInfo(k int32) (ct Conetype,conepar float64,nummem int32,err error) {
  if _tmt426 := MSK_getconeinfo(self.ptr(),k,&ct,&conepar,&nummem); _tmt426 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt426)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeName(i int32) (name string,err error) {
  var _tmt427 int32
  if _tmt428 := MSK_getconenamelen(task.nativep,i,addr(_tmt427)); _tmt428 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt428)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt427)
  _tmt429 := make([]byte,sizename)
  if _tmt430 := MSK_getconename(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt430 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt430)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt429,byte(0)); p < 0 {
    name = string(_tmt429)
  } else {
    name = string(_tmt429[:p])
  }
  return
}
func (self *Task) GetConeNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt431 := C.CString(somename)
  if _tmt432 := MSK_getconenameindex(self.ptr(),_tmt431,&asgn,&index); _tmt432 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt432)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConeNameLen(i int32) (len int32,err error) {
  if _tmt433 := MSK_getconenamelen(self.ptr(),i,&len); _tmt433 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt433)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConName(i int32) (name string,err error) {
  var _tmt434 int32
  if _tmt435 := MSK_getconnamelen(task.nativep,i,addr(_tmt434)); _tmt435 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt435)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt434)
  _tmt436 := make([]byte,sizename)
  if _tmt437 := MSK_getconname(self.ptr(),i,sizename,C.CString(&tmpvar1[0])); _tmt437 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt437)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt436,byte(0)); p < 0 {
    name = string(_tmt436)
  } else {
    name = string(_tmt436[:p])
  }
  return
}
func (self *Task) GetConNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt438 := C.CString(somename)
  if _tmt439 := MSK_getconnameindex(self.ptr(),_tmt438,&asgn,&index); _tmt439 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt439)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetConNameLen(i int32) (len int32,err error) {
  if _tmt440 := MSK_getconnamelen(self.ptr(),i,&len); _tmt440 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt440)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetCSlice(first int32,last int32) (c []float64,err error) {
  var _tmt441 *float64
  c := make([]float64,(last - first))
  if len(c) > 0 { _tmt441 = (*float64)(&n[0]) }
  if _tmt442 := MSK_getcslice(self.ptr(),first,last,_tmt441); _tmt442 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt442)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDimBarvarJ(j int32) (dimbarvarj int32,err error) {
  if _tmt443 := MSK_getdimbarvarj(self.ptr(),j,&dimbarvarj); _tmt443 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt443)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcAfeIdxList(djcidx int64) (afeidxlist []int64,err error) {
  var _tmt446 *int64
  var _tmt444 int64
  if _tmt445 := MSK_getdjcnumafe(task.nativep,djcidx,addr(_tmt444)); _tmt445 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt445)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt444)
  if len(afeidxlist) > 0 { _tmt446 = (*int64)(&n[0]) }
  if _tmt447 := MSK_getdjcafeidxlist(self.ptr(),djcidx,_tmt446); _tmt447 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt447)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcB(djcidx int64) (b []float64,err error) {
  var _tmt450 *float64
  var _tmt448 int64
  if _tmt449 := MSK_getdjcnumafe(task.nativep,djcidx,addr(_tmt448)); _tmt449 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt449)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt448)
  if len(b) > 0 { _tmt450 = (*float64)(&n[0]) }
  if _tmt451 := MSK_getdjcb(self.ptr(),djcidx,_tmt450); _tmt451 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt451)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcDomainIdxList(djcidx int64) (domidxlist []int64,err error) {
  var _tmt454 *int64
  var _tmt452 int64
  if _tmt453 := MSK_getdjcnumdomain(task.nativep,djcidx,addr(_tmt452)); _tmt453 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt453)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt452)
  if len(domidxlist) > 0 { _tmt454 = (*int64)(&n[0]) }
  if _tmt455 := MSK_getdjcdomainidxlist(self.ptr(),djcidx,_tmt454); _tmt455 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt455)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcName(djcidx int64) (name string,err error) {
  var _tmt456 int32
  if _tmt457 := MSK_getdjcnamelen(task.nativep,djcidx,addr(_tmt456)); _tmt457 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt457)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt456)
  _tmt458 := make([]byte,sizename)
  if _tmt459 := MSK_getdjcname(self.ptr(),djcidx,sizename,C.CString(&tmpvar1[0])); _tmt459 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt459)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt458,byte(0)); p < 0 {
    name = string(_tmt458)
  } else {
    name = string(_tmt458[:p])
  }
  return
}
func (self *Task) GetDjcNameLen(djcidx int64) (len int32,err error) {
  if _tmt460 := MSK_getdjcnamelen(self.ptr(),djcidx,&len); _tmt460 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt460)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumAfe(djcidx int64) (numafe int64,err error) {
  if _tmt461 := MSK_getdjcnumafe(self.ptr(),djcidx,&numafe); _tmt461 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt461)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumAfeTot() (numafetot int64,err error) {
  if _tmt462 := MSK_getdjcnumafetot(self.ptr(),&numafetot); _tmt462 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt462)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumDomain(djcidx int64) (numdomain int64,err error) {
  if _tmt463 := MSK_getdjcnumdomain(self.ptr(),djcidx,&numdomain); _tmt463 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt463)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumDomainTot() (numdomaintot int64,err error) {
  if _tmt464 := MSK_getdjcnumdomaintot(self.ptr(),&numdomaintot); _tmt464 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt464)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumTerm(djcidx int64) (numterm int64,err error) {
  if _tmt465 := MSK_getdjcnumterm(self.ptr(),djcidx,&numterm); _tmt465 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt465)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcNumTermTot() (numtermtot int64,err error) {
  if _tmt466 := MSK_getdjcnumtermtot(self.ptr(),&numtermtot); _tmt466 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt466)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcs() (domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64,numterms []int64,err error) {
  var _tmt469 *int64
  var _tmt467 int64
  if _tmt468 := MSK_getdjcnumdomaintot(task.nativep,addr(_tmt467)); _tmt468 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt468)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  domidxlist := make([]int64,_tmt467)
  if len(domidxlist) > 0 { _tmt469 = (*int64)(&n[0]) }
  var _tmt472 *int64
  var _tmt470 int64
  if _tmt471 := MSK_getdjcnumafetot(task.nativep,addr(_tmt470)); _tmt471 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt471)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  afeidxlist := make([]int64,_tmt470)
  if len(afeidxlist) > 0 { _tmt472 = (*int64)(&n[0]) }
  var _tmt475 *float64
  var _tmt473 int64
  if _tmt474 := MSK_getdjcnumafetot(task.nativep,addr(_tmt473)); _tmt474 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt474)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  b := make([]float64,_tmt473)
  if len(b) > 0 { _tmt475 = (*float64)(&n[0]) }
  var _tmt478 *int64
  var _tmt476 int64
  if _tmt477 := MSK_getdjcnumtermtot(task.nativep,addr(_tmt476)); _tmt477 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt477)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termsizelist := make([]int64,_tmt476)
  if len(termsizelist) > 0 { _tmt478 = (*int64)(&n[0]) }
  var _tmt481 *int64
  var _tmt479 int64
  if _tmt480 := MSK_getnumdjc(task.nativep,addr(_tmt479)); _tmt480 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt480)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  numterms := make([]int64,_tmt479)
  if len(numterms) > 0 { _tmt481 = (*int64)(&n[0]) }
  if _tmt482 := MSK_getdjcs(self.ptr(),_tmt469,_tmt472,_tmt475,_tmt478,_tmt481); _tmt482 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt482)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDjcTermSizeList(djcidx int64) (termsizelist []int64,err error) {
  var _tmt485 *int64
  var _tmt483 int64
  if _tmt484 := MSK_getdjcnumterm(task.nativep,djcidx,addr(_tmt483)); _tmt484 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt484)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  termsizelist := make([]int64,_tmt483)
  if len(termsizelist) > 0 { _tmt485 = (*int64)(&n[0]) }
  if _tmt486 := MSK_getdjctermsizelist(self.ptr(),djcidx,_tmt485); _tmt486 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt486)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainN(domidx int64) (n int64,err error) {
  if _tmt487 := MSK_getdomainn(self.ptr(),domidx,&n); _tmt487 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt487)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainName(domidx int64) (name string,err error) {
  var _tmt488 int32
  if _tmt489 := MSK_getdomainnamelen(task.nativep,domidx,addr(_tmt488)); _tmt489 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt489)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt488)
  _tmt490 := make([]byte,sizename)
  if _tmt491 := MSK_getdomainname(self.ptr(),domidx,sizename,C.CString(&tmpvar1[0])); _tmt491 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt491)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt490,byte(0)); p < 0 {
    name = string(_tmt490)
  } else {
    name = string(_tmt490[:p])
  }
  return
}
func (self *Task) GetDomainNameLen(domidx int64) (len int32,err error) {
  if _tmt492 := MSK_getdomainnamelen(self.ptr(),domidx,&len); _tmt492 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt492)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDomainType(domidx int64) (domtype Domaintype,err error) {
  if _tmt493 := MSK_getdomaintype(self.ptr(),domidx,&domtype); _tmt493 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt493)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDouInf(whichdinf Dinfitem) (dvalue float64,err error) {
  if _tmt494 := MSK_getdouinf(self.ptr(),whichdinf,&dvalue); _tmt494 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt494)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDouParam(param Dparam) (parvalue float64,err error) {
  if _tmt495 := MSK_getdouparam(self.ptr(),param,&parvalue); _tmt495 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt495)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDualObj(whichsol Soltype) (dualobj float64,err error) {
  if _tmt496 := MSK_getdualobj(self.ptr(),whichsol,&dualobj); _tmt496 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt496)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDualSolutionNorms(whichsol Soltype) (nrmy float64,nrmslc float64,nrmsuc float64,nrmslx float64,nrmsux float64,nrmsnx float64,nrmbars float64,err error) {
  if _tmt497 := MSK_getdualsolutionnorms(self.ptr(),whichsol,&nrmy,&nrmslc,&nrmsuc,&nrmslx,&nrmsux,&nrmsnx,&nrmbars); _tmt497 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt497)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolAcc(whichsol Soltype,accidxlist []int64) (viol []float64,err error) {
  _tmt498 := len(accidxlist)
  var numaccidx int64 = int32(_tmt498)
  var _tmt499 *int64
  if accidxlist != nil { _tmt499 = (*C.MSKint32t)(&accidxlist[0]) }
  var _tmt500 *float64
  viol := make([]float64,numaccidx)
  if len(viol) > 0 { _tmt500 = (*float64)(&n[0]) }
  if _tmt501 := MSK_getdviolacc(self.ptr(),whichsol,numaccidx,_tmt499,_tmt500); _tmt501 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt501)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolBarvar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt502 := len(sub)
  var num int32 = int32(_tmt502)
  var _tmt503 *int32
  if sub != nil { _tmt503 = (*C.MSKint32t)(&sub[0]) }
  var _tmt504 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt504 = (*float64)(&n[0]) }
  if _tmt505 := MSK_getdviolbarvar(self.ptr(),whichsol,num,_tmt503,_tmt504); _tmt505 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt505)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolCon(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt506 := len(sub)
  var num int32 = int32(_tmt506)
  var _tmt507 *int32
  if sub != nil { _tmt507 = (*C.MSKint32t)(&sub[0]) }
  var _tmt508 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt508 = (*float64)(&n[0]) }
  if _tmt509 := MSK_getdviolcon(self.ptr(),whichsol,num,_tmt507,_tmt508); _tmt509 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt509)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolCones(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt510 := len(sub)
  var num int32 = int32(_tmt510)
  var _tmt511 *int32
  if sub != nil { _tmt511 = (*C.MSKint32t)(&sub[0]) }
  var _tmt512 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt512 = (*float64)(&n[0]) }
  if _tmt513 := MSK_getdviolcones(self.ptr(),whichsol,num,_tmt511,_tmt512); _tmt513 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt513)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetDviolVar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt514 := len(sub)
  var num int32 = int32(_tmt514)
  var _tmt515 *int32
  if sub != nil { _tmt515 = (*C.MSKint32t)(&sub[0]) }
  var _tmt516 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt516 = (*float64)(&n[0]) }
  if _tmt517 := MSK_getdviolvar(self.ptr(),whichsol,num,_tmt515,_tmt516); _tmt517 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt517)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetInfIndex(inftype Inftype,infname string) (infindex int32,err error) {
  _tmt518 := C.CString(infname)
  if _tmt519 := MSK_getinfindex(self.ptr(),inftype,_tmt518,&infindex); _tmt519 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt519)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetIntInf(whichiinf Iinfitem) (ivalue int32,err error) {
  if _tmt520 := MSK_getintinf(self.ptr(),whichiinf,&ivalue); _tmt520 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt520)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetIntParam(param Iparam) (parvalue int32,err error) {
  if _tmt521 := MSK_getintparam(self.ptr(),param,&parvalue); _tmt521 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt521)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetLenBarvarJ(j int32) (lenbarvarj int64,err error) {
  if _tmt522 := MSK_getlenbarvarj(self.ptr(),j,&lenbarvarj); _tmt522 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt522)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetLintInf(whichliinf Liinfitem) (ivalue int64,err error) {
  if _tmt523 := MSK_getlintinf(self.ptr(),whichliinf,&ivalue); _tmt523 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt523)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumANz() (maxnumanz int64,err error) {
  if _tmt524 := MSK_getmaxnumanz64(self.ptr(),&maxnumanz); _tmt524 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt524)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumBarvar() (maxnumbarvar int32,err error) {
  if _tmt525 := MSK_getmaxnumbarvar(self.ptr(),&maxnumbarvar); _tmt525 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt525)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumCon() (maxnumcon int32,err error) {
  if _tmt526 := MSK_getmaxnumcon(self.ptr(),&maxnumcon); _tmt526 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt526)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumCone() (maxnumcone int32,err error) {
  if _tmt527 := MSK_getmaxnumcone(self.ptr(),&maxnumcone); _tmt527 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt527)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumQNz() (maxnumqnz int64,err error) {
  if _tmt528 := MSK_getmaxnumqnz64(self.ptr(),&maxnumqnz); _tmt528 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt528)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMaxNumVar() (maxnumvar int32,err error) {
  if _tmt529 := MSK_getmaxnumvar(self.ptr(),&maxnumvar); _tmt529 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt529)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMemUsage() (meminuse int64,maxmemuse int64,err error) {
  if _tmt530 := MSK_getmemusagetask(self.ptr(),&meminuse,&maxmemuse); _tmt530 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt530)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetMioNumThreads() (numthreads int32,err error) {
  if _tmt531 := MSK_getmionumthreads(self.ptr(),&numthreads); _tmt531 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt531)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumAcc() (num int64,err error) {
  if _tmt532 := MSK_getnumacc(self.ptr(),&num); _tmt532 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt532)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumAfe() (numafe int64,err error) {
  if _tmt533 := MSK_getnumafe(self.ptr(),&numafe); _tmt533 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt533)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumANz() (numanz int32,err error) {
  if _tmt534 := MSK_getnumanz(self.ptr(),&numanz); _tmt534 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt534)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumANz64() (numanz int64,err error) {
  if _tmt535 := MSK_getnumanz64(self.ptr(),&numanz); _tmt535 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt535)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBaraBlockTriplets() (num int64,err error) {
  if _tmt536 := MSK_getnumbarablocktriplets(self.ptr(),&num); _tmt536 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt536)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBaraNz() (nz int64,err error) {
  if _tmt537 := MSK_getnumbaranz(self.ptr(),&nz); _tmt537 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt537)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarcBlockTriplets() (num int64,err error) {
  if _tmt538 := MSK_getnumbarcblocktriplets(self.ptr(),&num); _tmt538 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt538)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarcNz() (nz int64,err error) {
  if _tmt539 := MSK_getnumbarcnz(self.ptr(),&nz); _tmt539 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt539)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumBarvar() (numbarvar int32,err error) {
  if _tmt540 := MSK_getnumbarvar(self.ptr(),&numbarvar); _tmt540 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt540)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumCon() (numcon int32,err error) {
  if _tmt541 := MSK_getnumcon(self.ptr(),&numcon); _tmt541 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt541)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumCone() (numcone int32,err error) {
  if _tmt542 := MSK_getnumcone(self.ptr(),&numcone); _tmt542 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt542)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumConeMem(k int32) (nummem int32,err error) {
  if _tmt543 := MSK_getnumconemem(self.ptr(),k,&nummem); _tmt543 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt543)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumDjc() (num int64,err error) {
  if _tmt544 := MSK_getnumdjc(self.ptr(),&num); _tmt544 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt544)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumDomain() (numdomain int64,err error) {
  if _tmt545 := MSK_getnumdomain(self.ptr(),&numdomain); _tmt545 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt545)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumIntVar() (numintvar int32,err error) {
  if _tmt546 := MSK_getnumintvar(self.ptr(),&numintvar); _tmt546 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt546)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumParam(partype Parametertype) (numparam int32,err error) {
  if _tmt547 := MSK_getnumparam(self.ptr(),partype,&numparam); _tmt547 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt547)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumQConKNz(k int32) (numqcnz int64,err error) {
  if _tmt548 := MSK_getnumqconknz64(self.ptr(),k,&numqcnz); _tmt548 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt548)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumQObjNz() (numqonz int64,err error) {
  if _tmt549 := MSK_getnumqobjnz64(self.ptr(),&numqonz); _tmt549 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt549)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumSymMat() (num int64,err error) {
  if _tmt550 := MSK_getnumsymmat(self.ptr(),&num); _tmt550 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt550)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetNumVar() (numvar int32,err error) {
  if _tmt551 := MSK_getnumvar(self.ptr(),&numvar); _tmt551 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt551)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetObjName() (objname string,err error) {
  var _tmt552 int32
  if _tmt553 := MSK_getobjnamelen(task.nativep,addr(_tmt552)); _tmt553 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt553)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizeobjname int32 = (1 + _tmt552)
  _tmt554 := make([]byte,sizeobjname)
  if _tmt555 := MSK_getobjname(self.ptr(),sizeobjname,C.CString(&tmpvar1[0])); _tmt555 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt555)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var objname string
  if p := strings.IndexByte(_tmt554,byte(0)); p < 0 {
    objname = string(_tmt554)
  } else {
    objname = string(_tmt554[:p])
  }
  return
}
func (self *Task) GetObjNameLen() (len int32,err error) {
  if _tmt556 := MSK_getobjnamelen(self.ptr(),&len); _tmt556 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt556)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetObjSense() (sense Objsense,err error) {
  if _tmt557 := MSK_getobjsense(self.ptr(),&sense); _tmt557 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt557)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPowerDomainAlpha(domidx int64) (alpha []float64,err error) {
  var _tmt561 *float64
  var _tmt558 int64
  var _tmt559 int64
  if _tmt560 := MSK_getpowerdomaininfo(task.nativep,domidx,addr(_tmt558),addr(_tmt559)); _tmt560 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt560)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  alpha := make([]float64,_tmt559)
  if len(alpha) > 0 { _tmt561 = (*float64)(&n[0]) }
  if _tmt562 := MSK_getpowerdomainalpha(self.ptr(),domidx,_tmt561); _tmt562 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt562)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPowerDomainInfo(domidx int64) (n int64,nleft int64,err error) {
  if _tmt563 := MSK_getpowerdomaininfo(self.ptr(),domidx,&n,&nleft); _tmt563 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt563)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPrimalObj(whichsol Soltype) (primalobj float64,err error) {
  if _tmt564 := MSK_getprimalobj(self.ptr(),whichsol,&primalobj); _tmt564 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt564)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPrimalSolutionNorms(whichsol Soltype) (nrmxc float64,nrmxx float64,nrmbarx float64,err error) {
  if _tmt565 := MSK_getprimalsolutionnorms(self.ptr(),whichsol,&nrmxc,&nrmxx,&nrmbarx); _tmt565 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt565)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetProbType() (probtype Problemtype,err error) {
  if _tmt566 := MSK_getprobtype(self.ptr(),&probtype); _tmt566 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt566)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetProSta(whichsol Soltype) (problemsta Prosta,err error) {
  if _tmt567 := MSK_getprosta(self.ptr(),whichsol,&problemsta); _tmt567 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt567)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolAcc(whichsol Soltype,accidxlist []int64) (viol []float64,err error) {
  _tmt568 := len(accidxlist)
  var numaccidx int64 = int32(_tmt568)
  var _tmt569 *int64
  if accidxlist != nil { _tmt569 = (*C.MSKint32t)(&accidxlist[0]) }
  var _tmt570 *float64
  viol := make([]float64,numaccidx)
  if len(viol) > 0 { _tmt570 = (*float64)(&n[0]) }
  if _tmt571 := MSK_getpviolacc(self.ptr(),whichsol,numaccidx,_tmt569,_tmt570); _tmt571 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt571)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolBarvar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt572 := len(sub)
  var num int32 = int32(_tmt572)
  var _tmt573 *int32
  if sub != nil { _tmt573 = (*C.MSKint32t)(&sub[0]) }
  var _tmt574 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt574 = (*float64)(&n[0]) }
  if _tmt575 := MSK_getpviolbarvar(self.ptr(),whichsol,num,_tmt573,_tmt574); _tmt575 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt575)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolCon(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt576 := len(sub)
  var num int32 = int32(_tmt576)
  var _tmt577 *int32
  if sub != nil { _tmt577 = (*C.MSKint32t)(&sub[0]) }
  var _tmt578 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt578 = (*float64)(&n[0]) }
  if _tmt579 := MSK_getpviolcon(self.ptr(),whichsol,num,_tmt577,_tmt578); _tmt579 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt579)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolCones(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt580 := len(sub)
  var num int32 = int32(_tmt580)
  var _tmt581 *int32
  if sub != nil { _tmt581 = (*C.MSKint32t)(&sub[0]) }
  var _tmt582 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt582 = (*float64)(&n[0]) }
  if _tmt583 := MSK_getpviolcones(self.ptr(),whichsol,num,_tmt581,_tmt582); _tmt583 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt583)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolDjc(whichsol Soltype,djcidxlist []int64) (viol []float64,err error) {
  _tmt584 := len(djcidxlist)
  var numdjcidx int64 = int32(_tmt584)
  var _tmt585 *int64
  if djcidxlist != nil { _tmt585 = (*C.MSKint32t)(&djcidxlist[0]) }
  var _tmt586 *float64
  viol := make([]float64,numdjcidx)
  if len(viol) > 0 { _tmt586 = (*float64)(&n[0]) }
  if _tmt587 := MSK_getpvioldjc(self.ptr(),whichsol,numdjcidx,_tmt585,_tmt586); _tmt587 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt587)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetPviolVar(whichsol Soltype,sub []int32) (viol []float64,err error) {
  _tmt588 := len(sub)
  var num int32 = int32(_tmt588)
  var _tmt589 *int32
  if sub != nil { _tmt589 = (*C.MSKint32t)(&sub[0]) }
  var _tmt590 *float64
  viol := make([]float64,num)
  if len(viol) > 0 { _tmt590 = (*float64)(&n[0]) }
  if _tmt591 := MSK_getpviolvar(self.ptr(),whichsol,num,_tmt589,_tmt590); _tmt591 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt591)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQConK(k int32) (numqcnz int64,qcsubi []int32,qcsubj []int32,qcval []float64,err error) {
  var _tmt592 int64
  if _tmt593 := MSK_getnumqconknz64(task.nativep,k,addr(_tmt592)); _tmt593 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt593)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumqcnz int64 = _tmt592
  var _tmt596 *int32
  var _tmt594 int64
  if _tmt595 := MSK_getnumqconknz64(task.nativep,k,addr(_tmt594)); _tmt595 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt595)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcsubi := make([]int32,_tmt594)
  if len(qcsubi) > 0 { _tmt596 = (*int32)(&n[0]) }
  var _tmt599 *int32
  var _tmt597 int64
  if _tmt598 := MSK_getnumqconknz64(task.nativep,k,addr(_tmt597)); _tmt598 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt598)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcsubj := make([]int32,_tmt597)
  if len(qcsubj) > 0 { _tmt599 = (*int32)(&n[0]) }
  var _tmt602 *float64
  var _tmt600 int64
  if _tmt601 := MSK_getnumqconknz64(task.nativep,k,addr(_tmt600)); _tmt601 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt601)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  qcval := make([]float64,_tmt600)
  if len(qcval) > 0 { _tmt602 = (*float64)(&n[0]) }
  if _tmt603 := MSK_getqconk64(self.ptr(),k,maxnumqcnz,&numqcnz,_tmt596,_tmt599,_tmt602); _tmt603 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt603)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQObj() (numqonz int64,qosubi []int32,qosubj []int32,qoval []float64,err error) {
  var _tmt604 int64
  if _tmt605 := MSK_getnumqobjnz64(task.nativep,addr(_tmt604)); _tmt605 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt605)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxnumqonz int64 = _tmt604
  var _tmt606 *int32
  qosubi := make([]int32,maxnumqonz)
  if len(qosubi) > 0 { _tmt606 = (*int32)(&n[0]) }
  var _tmt607 *int32
  qosubj := make([]int32,maxnumqonz)
  if len(qosubj) > 0 { _tmt607 = (*int32)(&n[0]) }
  var _tmt608 *float64
  qoval := make([]float64,maxnumqonz)
  if len(qoval) > 0 { _tmt608 = (*float64)(&n[0]) }
  if _tmt609 := MSK_getqobj64(self.ptr(),maxnumqonz,&numqonz,_tmt606,_tmt607,_tmt608); _tmt609 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt609)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetQObjIJ(i int32,j int32) (qoij float64,err error) {
  if _tmt610 := MSK_getqobjij(self.ptr(),i,j,&qoij); _tmt610 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt610)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetReducedCosts(whichsol Soltype,first int32,last int32) (redcosts []float64,err error) {
  var _tmt611 *float64
  redcosts := make([]float64,(last - first))
  if len(redcosts) > 0 { _tmt611 = (*float64)(&n[0]) }
  if _tmt612 := MSK_getreducedcosts(self.ptr(),whichsol,first,last,_tmt611); _tmt612 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt612)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkc(whichsol Soltype) (skc []Stakey,err error) {
  var _tmt615 *Stakey
  var _tmt613 int32
  if _tmt614 := MSK_getnumcon(task.nativep,addr(_tmt613)); _tmt614 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt614)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt613)
  if len(skc) > 0 { _tmt615 = (*Stakey)(&n[0]) }
  if _tmt616 := MSK_getskc(self.ptr(),whichsol,_tmt615); _tmt616 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt616)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkcSlice(whichsol Soltype,first int32,last int32) (skc []Stakey,err error) {
  var _tmt617 *Stakey
  skc := make([]Stakey,(last - first))
  if len(skc) > 0 { _tmt617 = (*Stakey)(&n[0]) }
  if _tmt618 := MSK_getskcslice(self.ptr(),whichsol,first,last,_tmt617); _tmt618 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt618)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkn(whichsol Soltype) (skn []Stakey,err error) {
  var _tmt621 *Stakey
  var _tmt619 int32
  if _tmt620 := MSK_getnumcone(task.nativep,addr(_tmt619)); _tmt620 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt620)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt619)
  if len(skn) > 0 { _tmt621 = (*Stakey)(&n[0]) }
  if _tmt622 := MSK_getskn(self.ptr(),whichsol,_tmt621); _tmt622 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt622)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkx(whichsol Soltype) (skx []Stakey,err error) {
  var _tmt625 *Stakey
  var _tmt623 int32
  if _tmt624 := MSK_getnumvar(task.nativep,addr(_tmt623)); _tmt624 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt624)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt623)
  if len(skx) > 0 { _tmt625 = (*Stakey)(&n[0]) }
  if _tmt626 := MSK_getskx(self.ptr(),whichsol,_tmt625); _tmt626 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt626)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSkxSlice(whichsol Soltype,first int32,last int32) (skx []Stakey,err error) {
  var _tmt627 *Stakey
  skx := make([]Stakey,(last - first))
  if len(skx) > 0 { _tmt627 = (*Stakey)(&n[0]) }
  if _tmt628 := MSK_getskxslice(self.ptr(),whichsol,first,last,_tmt627); _tmt628 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt628)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlc(whichsol Soltype) (slc []float64,err error) {
  var _tmt631 *float64
  var _tmt629 int32
  if _tmt630 := MSK_getnumcon(task.nativep,addr(_tmt629)); _tmt630 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt630)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt629)
  if len(slc) > 0 { _tmt631 = (*float64)(&n[0]) }
  if _tmt632 := MSK_getslc(self.ptr(),whichsol,_tmt631); _tmt632 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt632)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlcSlice(whichsol Soltype,first int32,last int32) (slc []float64,err error) {
  var _tmt633 *float64
  slc := make([]float64,(last - first))
  if len(slc) > 0 { _tmt633 = (*float64)(&n[0]) }
  if _tmt634 := MSK_getslcslice(self.ptr(),whichsol,first,last,_tmt633); _tmt634 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt634)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlx(whichsol Soltype) (slx []float64,err error) {
  var _tmt637 *float64
  var _tmt635 int32
  if _tmt636 := MSK_getnumvar(task.nativep,addr(_tmt635)); _tmt636 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt636)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt635)
  if len(slx) > 0 { _tmt637 = (*float64)(&n[0]) }
  if _tmt638 := MSK_getslx(self.ptr(),whichsol,_tmt637); _tmt638 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt638)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSlxSlice(whichsol Soltype,first int32,last int32) (slx []float64,err error) {
  var _tmt639 *float64
  slx := make([]float64,(last - first))
  if len(slx) > 0 { _tmt639 = (*float64)(&n[0]) }
  if _tmt640 := MSK_getslxslice(self.ptr(),whichsol,first,last,_tmt639); _tmt640 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt640)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSnx(whichsol Soltype) (snx []float64,err error) {
  var _tmt643 *float64
  var _tmt641 int32
  if _tmt642 := MSK_getnumvar(task.nativep,addr(_tmt641)); _tmt642 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt642)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt641)
  if len(snx) > 0 { _tmt643 = (*float64)(&n[0]) }
  if _tmt644 := MSK_getsnx(self.ptr(),whichsol,_tmt643); _tmt644 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt644)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSnxSlice(whichsol Soltype,first int32,last int32) (snx []float64,err error) {
  var _tmt645 *float64
  snx := make([]float64,(last - first))
  if len(snx) > 0 { _tmt645 = (*float64)(&n[0]) }
  if _tmt646 := MSK_getsnxslice(self.ptr(),whichsol,first,last,_tmt645); _tmt646 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt646)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolSta(whichsol Soltype) (solutionsta Solsta,err error) {
  if _tmt647 := MSK_getsolsta(self.ptr(),whichsol,&solutionsta); _tmt647 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt647)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolution(whichsol Soltype) (problemsta Prosta,solutionsta Solsta,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,err error) {
  var _tmt650 *Stakey
  var _tmt648 int32
  if _tmt649 := MSK_getnumcon(task.nativep,addr(_tmt648)); _tmt649 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt649)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt648)
  if len(skc) > 0 { _tmt650 = (*Stakey)(&n[0]) }
  var _tmt653 *Stakey
  var _tmt651 int32
  if _tmt652 := MSK_getnumvar(task.nativep,addr(_tmt651)); _tmt652 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt652)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt651)
  if len(skx) > 0 { _tmt653 = (*Stakey)(&n[0]) }
  var _tmt656 *Stakey
  var _tmt654 int32
  if _tmt655 := MSK_getnumcone(task.nativep,addr(_tmt654)); _tmt655 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt655)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt654)
  if len(skn) > 0 { _tmt656 = (*Stakey)(&n[0]) }
  var _tmt659 *float64
  var _tmt657 int32
  if _tmt658 := MSK_getnumcon(task.nativep,addr(_tmt657)); _tmt658 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt658)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt657)
  if len(xc) > 0 { _tmt659 = (*float64)(&n[0]) }
  var _tmt662 *float64
  var _tmt660 int32
  if _tmt661 := MSK_getnumvar(task.nativep,addr(_tmt660)); _tmt661 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt661)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt660)
  if len(xx) > 0 { _tmt662 = (*float64)(&n[0]) }
  var _tmt665 *float64
  var _tmt663 int32
  if _tmt664 := MSK_getnumcon(task.nativep,addr(_tmt663)); _tmt664 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt664)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt663)
  if len(y) > 0 { _tmt665 = (*float64)(&n[0]) }
  var _tmt668 *float64
  var _tmt666 int32
  if _tmt667 := MSK_getnumcon(task.nativep,addr(_tmt666)); _tmt667 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt667)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt666)
  if len(slc) > 0 { _tmt668 = (*float64)(&n[0]) }
  var _tmt671 *float64
  var _tmt669 int32
  if _tmt670 := MSK_getnumcon(task.nativep,addr(_tmt669)); _tmt670 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt670)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt669)
  if len(suc) > 0 { _tmt671 = (*float64)(&n[0]) }
  var _tmt674 *float64
  var _tmt672 int32
  if _tmt673 := MSK_getnumvar(task.nativep,addr(_tmt672)); _tmt673 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt673)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt672)
  if len(slx) > 0 { _tmt674 = (*float64)(&n[0]) }
  var _tmt677 *float64
  var _tmt675 int32
  if _tmt676 := MSK_getnumvar(task.nativep,addr(_tmt675)); _tmt676 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt676)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt675)
  if len(sux) > 0 { _tmt677 = (*float64)(&n[0]) }
  var _tmt680 *float64
  var _tmt678 int32
  if _tmt679 := MSK_getnumvar(task.nativep,addr(_tmt678)); _tmt679 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt679)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt678)
  if len(snx) > 0 { _tmt680 = (*float64)(&n[0]) }
  if _tmt681 := MSK_getsolution(self.ptr(),whichsol,&problemsta,&solutionsta,_tmt650,_tmt653,_tmt656,_tmt659,_tmt662,_tmt665,_tmt668,_tmt671,_tmt674,_tmt677,_tmt680); _tmt681 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt681)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionInfo(whichsol Soltype) (pobj float64,pviolcon float64,pviolvar float64,pviolbarvar float64,pviolcone float64,pviolitg float64,dobj float64,dviolcon float64,dviolvar float64,dviolbarvar float64,dviolcone float64,err error) {
  if _tmt682 := MSK_getsolutioninfo(self.ptr(),whichsol,&pobj,&pviolcon,&pviolvar,&pviolbarvar,&pviolcone,&pviolitg,&dobj,&dviolcon,&dviolvar,&dviolbarvar,&dviolcone); _tmt682 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt682)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionInfoNew(whichsol Soltype) (pobj float64,pviolcon float64,pviolvar float64,pviolbarvar float64,pviolcone float64,pviolacc float64,pvioldjc float64,pviolitg float64,dobj float64,dviolcon float64,dviolvar float64,dviolbarvar float64,dviolcone float64,dviolacc float64,err error) {
  if _tmt683 := MSK_getsolutioninfonew(self.ptr(),whichsol,&pobj,&pviolcon,&pviolvar,&pviolbarvar,&pviolcone,&pviolacc,&pvioldjc,&pviolitg,&dobj,&dviolcon,&dviolvar,&dviolbarvar,&dviolcone,&dviolacc); _tmt683 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt683)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionNew(whichsol Soltype) (problemsta Prosta,solutionsta Solsta,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,doty []float64,err error) {
  var _tmt686 *Stakey
  var _tmt684 int32
  if _tmt685 := MSK_getnumcon(task.nativep,addr(_tmt684)); _tmt685 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt685)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skc := make([]Stakey,_tmt684)
  if len(skc) > 0 { _tmt686 = (*Stakey)(&n[0]) }
  var _tmt689 *Stakey
  var _tmt687 int32
  if _tmt688 := MSK_getnumvar(task.nativep,addr(_tmt687)); _tmt688 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt688)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skx := make([]Stakey,_tmt687)
  if len(skx) > 0 { _tmt689 = (*Stakey)(&n[0]) }
  var _tmt692 *Stakey
  var _tmt690 int32
  if _tmt691 := MSK_getnumcone(task.nativep,addr(_tmt690)); _tmt691 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt691)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  skn := make([]Stakey,_tmt690)
  if len(skn) > 0 { _tmt692 = (*Stakey)(&n[0]) }
  var _tmt695 *float64
  var _tmt693 int32
  if _tmt694 := MSK_getnumcon(task.nativep,addr(_tmt693)); _tmt694 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt694)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt693)
  if len(xc) > 0 { _tmt695 = (*float64)(&n[0]) }
  var _tmt698 *float64
  var _tmt696 int32
  if _tmt697 := MSK_getnumvar(task.nativep,addr(_tmt696)); _tmt697 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt697)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt696)
  if len(xx) > 0 { _tmt698 = (*float64)(&n[0]) }
  var _tmt701 *float64
  var _tmt699 int32
  if _tmt700 := MSK_getnumcon(task.nativep,addr(_tmt699)); _tmt700 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt700)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt699)
  if len(y) > 0 { _tmt701 = (*float64)(&n[0]) }
  var _tmt704 *float64
  var _tmt702 int32
  if _tmt703 := MSK_getnumcon(task.nativep,addr(_tmt702)); _tmt703 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt703)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slc := make([]float64,_tmt702)
  if len(slc) > 0 { _tmt704 = (*float64)(&n[0]) }
  var _tmt707 *float64
  var _tmt705 int32
  if _tmt706 := MSK_getnumcon(task.nativep,addr(_tmt705)); _tmt706 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt706)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt705)
  if len(suc) > 0 { _tmt707 = (*float64)(&n[0]) }
  var _tmt710 *float64
  var _tmt708 int32
  if _tmt709 := MSK_getnumvar(task.nativep,addr(_tmt708)); _tmt709 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt709)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  slx := make([]float64,_tmt708)
  if len(slx) > 0 { _tmt710 = (*float64)(&n[0]) }
  var _tmt713 *float64
  var _tmt711 int32
  if _tmt712 := MSK_getnumvar(task.nativep,addr(_tmt711)); _tmt712 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt712)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt711)
  if len(sux) > 0 { _tmt713 = (*float64)(&n[0]) }
  var _tmt716 *float64
  var _tmt714 int32
  if _tmt715 := MSK_getnumvar(task.nativep,addr(_tmt714)); _tmt715 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt715)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  snx := make([]float64,_tmt714)
  if len(snx) > 0 { _tmt716 = (*float64)(&n[0]) }
  var _tmt719 *float64
  var _tmt717 int64
  if _tmt718 := MSK_getaccntot(task.nativep,addr(_tmt717)); _tmt718 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt718)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt717)
  if len(doty) > 0 { _tmt719 = (*float64)(&n[0]) }
  if _tmt720 := MSK_getsolutionnew(self.ptr(),whichsol,&problemsta,&solutionsta,_tmt686,_tmt689,_tmt692,_tmt695,_tmt698,_tmt701,_tmt704,_tmt707,_tmt710,_tmt713,_tmt716,_tmt719); _tmt720 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt720)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSolutionSlice(whichsol Soltype,solitem Solitem,first int32,last int32) (values []float64,err error) {
  var _tmt721 *float64
  values := make([]float64,(last - first))
  if len(values) > 0 { _tmt721 = (*float64)(&n[0]) }
  if _tmt722 := MSK_getsolutionslice(self.ptr(),whichsol,solitem,first,last,_tmt721); _tmt722 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt722)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSparseSymMat(idx int64) (subi []int32,subj []int32,valij []float64,err error) {
  var _tmt723 int32
  var _tmt724 int64
  var _tmt725 symmattype
  if _tmt726 := MSK_getsymmatinfo(task.nativep,idx,addr(_tmt723),addr(_tmt724),addr(_tmt725)); _tmt726 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt726)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxlen int64 = _tmt724
  var _tmt727 *int32
  subi := make([]int32,maxlen)
  if len(subi) > 0 { _tmt727 = (*int32)(&n[0]) }
  var _tmt728 *int32
  subj := make([]int32,maxlen)
  if len(subj) > 0 { _tmt728 = (*int32)(&n[0]) }
  var _tmt729 *float64
  valij := make([]float64,maxlen)
  if len(valij) > 0 { _tmt729 = (*float64)(&n[0]) }
  if _tmt730 := MSK_getsparsesymmat(self.ptr(),idx,maxlen,_tmt727,_tmt728,_tmt729); _tmt730 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt730)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetStrParam(param Sparam) (len int32,parvalue string,err error) {
  var _tmt731 int32
  if _tmt732 := MSK_getstrparamlen(task.nativep,param,addr(_tmt731)); _tmt732 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt732)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var maxlen int32 = (1 + _tmt731)
  _tmt733 := make([]byte,maxlen)
  if _tmt734 := MSK_getstrparam(self.ptr(),param,maxlen,&len,C.CString(&tmpvar1[0])); _tmt734 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt734)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var parvalue string
  if p := strings.IndexByte(_tmt733,byte(0)); p < 0 {
    parvalue = string(_tmt733)
  } else {
    parvalue = string(_tmt733[:p])
  }
  return
}
func (self *Task) GetStrParamLen(param Sparam) (len int32,err error) {
  if _tmt735 := MSK_getstrparamlen(self.ptr(),param,&len); _tmt735 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt735)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSuc(whichsol Soltype) (suc []float64,err error) {
  var _tmt738 *float64
  var _tmt736 int32
  if _tmt737 := MSK_getnumcon(task.nativep,addr(_tmt736)); _tmt737 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt737)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  suc := make([]float64,_tmt736)
  if len(suc) > 0 { _tmt738 = (*float64)(&n[0]) }
  if _tmt739 := MSK_getsuc(self.ptr(),whichsol,_tmt738); _tmt739 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt739)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSucSlice(whichsol Soltype,first int32,last int32) (suc []float64,err error) {
  var _tmt740 *float64
  suc := make([]float64,(last - first))
  if len(suc) > 0 { _tmt740 = (*float64)(&n[0]) }
  if _tmt741 := MSK_getsucslice(self.ptr(),whichsol,first,last,_tmt740); _tmt741 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt741)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSux(whichsol Soltype) (sux []float64,err error) {
  var _tmt744 *float64
  var _tmt742 int32
  if _tmt743 := MSK_getnumvar(task.nativep,addr(_tmt742)); _tmt743 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt743)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  sux := make([]float64,_tmt742)
  if len(sux) > 0 { _tmt744 = (*float64)(&n[0]) }
  if _tmt745 := MSK_getsux(self.ptr(),whichsol,_tmt744); _tmt745 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt745)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSuxSlice(whichsol Soltype,first int32,last int32) (sux []float64,err error) {
  var _tmt746 *float64
  sux := make([]float64,(last - first))
  if len(sux) > 0 { _tmt746 = (*float64)(&n[0]) }
  if _tmt747 := MSK_getsuxslice(self.ptr(),whichsol,first,last,_tmt746); _tmt747 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt747)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetSymMatInfo(idx int64) (dim int32,nz int64,mattype Symmattype,err error) {
  if _tmt748 := MSK_getsymmatinfo(self.ptr(),idx,&dim,&nz,&mattype); _tmt748 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt748)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetTaskName() (taskname string,err error) {
  var _tmt749 int32
  if _tmt750 := MSK_gettasknamelen(task.nativep,addr(_tmt749)); _tmt750 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt750)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizetaskname int32 = (1 + _tmt749)
  _tmt751 := make([]byte,sizetaskname)
  if _tmt752 := MSK_gettaskname(self.ptr(),sizetaskname,C.CString(&tmpvar1[0])); _tmt752 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt752)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var taskname string
  if p := strings.IndexByte(_tmt751,byte(0)); p < 0 {
    taskname = string(_tmt751)
  } else {
    taskname = string(_tmt751[:p])
  }
  return
}
func (self *Task) GetTaskNameLen() (len int32,err error) {
  if _tmt753 := MSK_gettasknamelen(self.ptr(),&len); _tmt753 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt753)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarBound(i int32) (bk Boundkey,bl float64,bu float64,err error) {
  if _tmt754 := MSK_getvarbound(self.ptr(),i,&bk,&bl,&bu); _tmt754 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt754)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarBoundSlice(first int32,last int32) (bk []Boundkey,bl []float64,bu []float64,err error) {
  var _tmt755 *Boundkey
  bk := make([]Boundkey,(last - first))
  if len(bk) > 0 { _tmt755 = (*Boundkey)(&n[0]) }
  var _tmt756 *float64
  bl := make([]float64,(last - first))
  if len(bl) > 0 { _tmt756 = (*float64)(&n[0]) }
  var _tmt757 *float64
  bu := make([]float64,(last - first))
  if len(bu) > 0 { _tmt757 = (*float64)(&n[0]) }
  if _tmt758 := MSK_getvarboundslice(self.ptr(),first,last,_tmt755,_tmt756,_tmt757); _tmt758 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt758)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarName(j int32) (name string,err error) {
  var _tmt759 int32
  if _tmt760 := MSK_getvarnamelen(task.nativep,j,addr(_tmt759)); _tmt760 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt760)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  var sizename int32 = (1 + _tmt759)
  _tmt761 := make([]byte,sizename)
  if _tmt762 := MSK_getvarname(self.ptr(),j,sizename,C.CString(&tmpvar1[0])); _tmt762 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt762)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  var name string
  if p := strings.IndexByte(_tmt761,byte(0)); p < 0 {
    name = string(_tmt761)
  } else {
    name = string(_tmt761[:p])
  }
  return
}
func (self *Task) GetVarNameIndex(somename string) (asgn int32,index int32,err error) {
  _tmt763 := C.CString(somename)
  if _tmt764 := MSK_getvarnameindex(self.ptr(),_tmt763,&asgn,&index); _tmt764 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt764)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarNameLen(i int32) (len int32,err error) {
  if _tmt765 := MSK_getvarnamelen(self.ptr(),i,&len); _tmt765 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt765)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarType(j int32) (vartype Variabletype,err error) {
  if _tmt766 := MSK_getvartype(self.ptr(),j,&vartype); _tmt766 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt766)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetVarTypeList(subj []int32) (vartype []Variabletype,err error) {
  _tmt767 := len(subj)
  var num int32 = int32(_tmt767)
  var _tmt768 *int32
  if subj != nil { _tmt768 = (*C.MSKint32t)(&subj[0]) }
  var _tmt769 *Variabletype
  vartype := make([]Variabletype,num)
  if len(vartype) > 0 { _tmt769 = (*Variabletype)(&n[0]) }
  if _tmt770 := MSK_getvartypelist(self.ptr(),num,_tmt768,_tmt769); _tmt770 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt770)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXc(whichsol Soltype) (xc []float64,err error) {
  var _tmt773 *float64
  var _tmt771 int32
  if _tmt772 := MSK_getnumcon(task.nativep,addr(_tmt771)); _tmt772 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt772)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt771)
  if len(xc) > 0 { _tmt773 = (*float64)(&n[0]) }
  if _tmt774 := MSK_getxc(self.ptr(),whichsol,_tmt773); _tmt774 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt774)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXcSlice(whichsol Soltype,first int32,last int32) (xc []float64,err error) {
  var _tmt775 *float64
  xc := make([]float64,(last - first))
  if len(xc) > 0 { _tmt775 = (*float64)(&n[0]) }
  if _tmt776 := MSK_getxcslice(self.ptr(),whichsol,first,last,_tmt775); _tmt776 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt776)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXx(whichsol Soltype) (xx []float64,err error) {
  var _tmt779 *float64
  var _tmt777 int32
  if _tmt778 := MSK_getnumvar(task.nativep,addr(_tmt777)); _tmt778 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt778)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xx := make([]float64,_tmt777)
  if len(xx) > 0 { _tmt779 = (*float64)(&n[0]) }
  if _tmt780 := MSK_getxx(self.ptr(),whichsol,_tmt779); _tmt780 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt780)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetXxSlice(whichsol Soltype,first int32,last int32) (xx []float64,err error) {
  var _tmt781 *float64
  xx := make([]float64,(last - first))
  if len(xx) > 0 { _tmt781 = (*float64)(&n[0]) }
  if _tmt782 := MSK_getxxslice(self.ptr(),whichsol,first,last,_tmt781); _tmt782 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt782)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetY(whichsol Soltype) (y []float64,err error) {
  var _tmt785 *float64
  var _tmt783 int32
  if _tmt784 := MSK_getnumcon(task.nativep,addr(_tmt783)); _tmt784 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt784)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  y := make([]float64,_tmt783)
  if len(y) > 0 { _tmt785 = (*float64)(&n[0]) }
  if _tmt786 := MSK_gety(self.ptr(),whichsol,_tmt785); _tmt786 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt786)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) GetYSlice(whichsol Soltype,first int32,last int32) (y []float64,err error) {
  var _tmt787 *float64
  y := make([]float64,(last - first))
  if len(y) > 0 { _tmt787 = (*float64)(&n[0]) }
  if _tmt788 := MSK_getyslice(self.ptr(),whichsol,first,last,_tmt787); _tmt788 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt788)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InfeasibilityReport(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt789 := MSK_infeasibilityreport(self.ptr(),whichstream,whichsol); _tmt789 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt789)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InitBasisSolve() (basis []int32,err error) {
  var _tmt792 *int32
  var _tmt790 int32
  if _tmt791 := MSK_getnumcon(task.nativep,addr(_tmt790)); _tmt791 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt791)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  basis := make([]int32,_tmt790)
  if len(basis) > 0 { _tmt792 = (*int32)(&n[0]) }
  if _tmt793 := MSK_initbasissolve(self.ptr(),_tmt792); _tmt793 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt793)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InputData(maxnumcon int32,maxnumvar int32,c []float64,cfix float64,aptrb []int32,aptre []int32,asub []int32,aval []float64,bkc []Boundkey,blc []float64,buc []float64,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  _tmt794 := len(buc)
  if _tmt794 < bkc { _tmt794 = lof["name"] }
  if _tmt794 < blc { _tmt794 = lof["name"] }
  var numcon int32 = int32(_tmt794)
  _tmt795 := len(aptrb)
  if _tmt795 < blx { _tmt795 = lof["name"] }
  if _tmt795 < bux { _tmt795 = lof["name"] }
  if _tmt795 < bkx { _tmt795 = lof["name"] }
  if _tmt795 < aptre { _tmt795 = lof["name"] }
  if _tmt795 < c { _tmt795 = lof["name"] }
  var numvar int32 = int32(_tmt795)
  var _tmt796 *float64
  if c != nil { _tmt796 = (*C.MSKint32t)(&c[0]) }
  var _tmt797 *int32
  if aptrb != nil { _tmt797 = (*C.MSKint32t)(&aptrb[0]) }
  var _tmt798 *int32
  if aptre != nil { _tmt798 = (*C.MSKint32t)(&aptre[0]) }
  var _tmt799 *int32
  if asub != nil { _tmt799 = (*C.MSKint32t)(&asub[0]) }
  var _tmt800 *float64
  if aval != nil { _tmt800 = (*C.MSKint32t)(&aval[0]) }
  var _tmt801 *Boundkey
  if bkc != nil { _tmt801 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt802 *float64
  if blc != nil { _tmt802 = (*C.MSKint32t)(&blc[0]) }
  var _tmt803 *float64
  if buc != nil { _tmt803 = (*C.MSKint32t)(&buc[0]) }
  var _tmt804 *Boundkey
  if bkx != nil { _tmt804 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt805 *float64
  if blx != nil { _tmt805 = (*C.MSKint32t)(&blx[0]) }
  var _tmt806 *float64
  if bux != nil { _tmt806 = (*C.MSKint32t)(&bux[0]) }
  if _tmt807 := MSK_inputdata(self.ptr(),maxnumcon,maxnumvar,numcon,numvar,_tmt796,cfix,_tmt797,_tmt798,_tmt799,_tmt800,_tmt801,_tmt802,_tmt803,_tmt804,_tmt805,_tmt806); _tmt807 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt807)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) InputData(maxnumcon int32,maxnumvar int32,c []float64,cfix float64,aptrb []int64,aptre []int64,asub []int32,aval []float64,bkc []Boundkey,blc []float64,buc []float64,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  _tmt808 := len(buc)
  if _tmt808 < bkc { _tmt808 = lof["name"] }
  if _tmt808 < blc { _tmt808 = lof["name"] }
  var numcon int32 = int32(_tmt808)
  _tmt809 := len(aptrb)
  if _tmt809 < blx { _tmt809 = lof["name"] }
  if _tmt809 < bux { _tmt809 = lof["name"] }
  if _tmt809 < bkx { _tmt809 = lof["name"] }
  if _tmt809 < aptre { _tmt809 = lof["name"] }
  if _tmt809 < c { _tmt809 = lof["name"] }
  var numvar int32 = int32(_tmt809)
  var _tmt810 *float64
  if c != nil { _tmt810 = (*C.MSKint32t)(&c[0]) }
  var _tmt811 *int64
  if aptrb != nil { _tmt811 = (*C.MSKint32t)(&aptrb[0]) }
  var _tmt812 *int64
  if aptre != nil { _tmt812 = (*C.MSKint32t)(&aptre[0]) }
  var _tmt813 *int32
  if asub != nil { _tmt813 = (*C.MSKint32t)(&asub[0]) }
  var _tmt814 *float64
  if aval != nil { _tmt814 = (*C.MSKint32t)(&aval[0]) }
  var _tmt815 *Boundkey
  if bkc != nil { _tmt815 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt816 *float64
  if blc != nil { _tmt816 = (*C.MSKint32t)(&blc[0]) }
  var _tmt817 *float64
  if buc != nil { _tmt817 = (*C.MSKint32t)(&buc[0]) }
  var _tmt818 *Boundkey
  if bkx != nil { _tmt818 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt819 *float64
  if blx != nil { _tmt819 = (*C.MSKint32t)(&blx[0]) }
  var _tmt820 *float64
  if bux != nil { _tmt820 = (*C.MSKint32t)(&bux[0]) }
  if _tmt821 := MSK_inputdata64(self.ptr(),maxnumcon,maxnumvar,numcon,numvar,_tmt810,cfix,_tmt811,_tmt812,_tmt813,_tmt814,_tmt815,_tmt816,_tmt817,_tmt818,_tmt819,_tmt820); _tmt821 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt821)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsDouParName(parname string) (param Dparam,err error) {
  _tmt822 := C.CString(parname)
  if _tmt823 := MSK_isdouparname(self.ptr(),_tmt822,&param); _tmt823 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt823)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsIntParName(parname string) (param Iparam,err error) {
  _tmt824 := C.CString(parname)
  if _tmt825 := MSK_isintparname(self.ptr(),_tmt824,&param); _tmt825 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt825)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) IsStrParName(parname string) (param Sparam,err error) {
  _tmt826 := C.CString(parname)
  if _tmt827 := MSK_isstrparname(self.ptr(),_tmt826,&param); _tmt827 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt827)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) LinkFileToStream(whichstream Streamtype,filename string,append int32) (err error) {
  _tmt828 := C.CString(filename)
  if _tmt829 := MSK_linkfiletotaskstream(self.ptr(),whichstream,_tmt828,append); _tmt829 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt829)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) OneSolutionSummary(whichstream Streamtype,whichsol Soltype) (err error) {
  if _tmt830 := MSK_onesolutionsummary(self.ptr(),whichstream,whichsol); _tmt830 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt830)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) OptimizeRmt(address string,accesstoken string) (trmcode Rescode,err error) {
  _tmt831 := C.CString(address)
  _tmt832 := C.CString(accesstoken)
  if _tmt833 := MSK_optimizermt(self.ptr(),_tmt831,_tmt832,&trmcode); _tmt833 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt833)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) OptimizerSummary(whichstream Streamtype) (err error) {
  if _tmt834 := MSK_optimizersummary(self.ptr(),whichstream); _tmt834 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt834)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) Optimize() (trmcode Rescode,err error) {
  if _tmt835 := MSK_optimizetrm(self.ptr(),&trmcode); _tmt835 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt835)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PrimalRepair(wlc []float64,wuc []float64,wlx []float64,wux []float64) (err error) {
  var _tmt838 *float64
  var _tmt836 int32
  if _tmt837 := MSK_getnumcon(task.nativep,addr(_tmt836)); _tmt837 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt837)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wlc) < _tmt836 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wlc"}
    return
  }
  if wlc != nil { _tmt838 = (*C.MSKint32t)(&wlc[0]) }
  var _tmt841 *float64
  var _tmt839 int32
  if _tmt840 := MSK_getnumcon(task.nativep,addr(_tmt839)); _tmt840 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt840)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wuc) < _tmt839 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wuc"}
    return
  }
  if wuc != nil { _tmt841 = (*C.MSKint32t)(&wuc[0]) }
  var _tmt844 *float64
  var _tmt842 int32
  if _tmt843 := MSK_getnumvar(task.nativep,addr(_tmt842)); _tmt843 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt843)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wlx) < _tmt842 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wlx"}
    return
  }
  if wlx != nil { _tmt844 = (*C.MSKint32t)(&wlx[0]) }
  var _tmt847 *float64
  var _tmt845 int32
  if _tmt846 := MSK_getnumvar(task.nativep,addr(_tmt845)); _tmt846 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt846)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(wux) < _tmt845 {
    err = &ArrayLengthError{fun:"PrimalRepair",arg:"wux"}
    return
  }
  if wux != nil { _tmt847 = (*C.MSKint32t)(&wux[0]) }
  if _tmt848 := MSK_primalrepair(self.ptr(),_tmt838,_tmt841,_tmt844,_tmt847); _tmt848 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt848)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PrimalSensitivity(subi []int32,marki []Mark,subj []int32,markj []Mark) (leftpricei []float64,rightpricei []float64,leftrangei []float64,rightrangei []float64,leftpricej []float64,rightpricej []float64,leftrangej []float64,rightrangej []float64,err error) {
  _tmt849 := len(subi)
  if _tmt849 < marki { _tmt849 = lof["name"] }
  var numi int32 = int32(_tmt849)
  var _tmt850 *int32
  if subi != nil { _tmt850 = (*C.MSKint32t)(&subi[0]) }
  var _tmt851 *Mark
  if marki != nil { _tmt851 = (*C.MSKint32t)(&marki[0]) }
  _tmt852 := len(markj)
  if _tmt852 < subj { _tmt852 = lof["name"] }
  var numj int32 = int32(_tmt852)
  var _tmt853 *int32
  if subj != nil { _tmt853 = (*C.MSKint32t)(&subj[0]) }
  var _tmt854 *Mark
  if markj != nil { _tmt854 = (*C.MSKint32t)(&markj[0]) }
  var _tmt855 *float64
  leftpricei := make([]float64,numi)
  if len(leftpricei) > 0 { _tmt855 = (*float64)(&n[0]) }
  var _tmt856 *float64
  rightpricei := make([]float64,numi)
  if len(rightpricei) > 0 { _tmt856 = (*float64)(&n[0]) }
  var _tmt857 *float64
  leftrangei := make([]float64,numi)
  if len(leftrangei) > 0 { _tmt857 = (*float64)(&n[0]) }
  var _tmt858 *float64
  rightrangei := make([]float64,numi)
  if len(rightrangei) > 0 { _tmt858 = (*float64)(&n[0]) }
  var _tmt859 *float64
  leftpricej := make([]float64,numj)
  if len(leftpricej) > 0 { _tmt859 = (*float64)(&n[0]) }
  var _tmt860 *float64
  rightpricej := make([]float64,numj)
  if len(rightpricej) > 0 { _tmt860 = (*float64)(&n[0]) }
  var _tmt861 *float64
  leftrangej := make([]float64,numj)
  if len(leftrangej) > 0 { _tmt861 = (*float64)(&n[0]) }
  var _tmt862 *float64
  rightrangej := make([]float64,numj)
  if len(rightrangej) > 0 { _tmt862 = (*float64)(&n[0]) }
  if _tmt863 := MSK_primalsensitivity(self.ptr(),numi,_tmt850,_tmt851,numj,_tmt853,_tmt854,_tmt855,_tmt856,_tmt857,_tmt858,_tmt859,_tmt860,_tmt861,_tmt862); _tmt863 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt863)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAcc(accidx int64,domidx int64,afeidxlist []int64,b []float64) (err error) {
  _tmt864 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt864)
  var _tmt865 *int64
  if afeidxlist != nil { _tmt865 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt866 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutAcc",arg:"b"}
    return
  }
  if b != nil { _tmt866 = (*C.MSKint32t)(&b[0]) }
  if _tmt867 := MSK_putacc(self.ptr(),accidx,domidx,numafeidx,_tmt865,_tmt866); _tmt867 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt867)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccB(accidx int64,b []float64) (err error) {
  _tmt868 := len(b)
  var lengthb int64 = int32(_tmt868)
  var _tmt869 *float64
  if b != nil { _tmt869 = (*C.MSKint32t)(&b[0]) }
  if _tmt870 := MSK_putaccb(self.ptr(),accidx,lengthb,_tmt869); _tmt870 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt870)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccBJ(accidx int64,j int64,bj float64) (err error) {
  if _tmt871 := MSK_putaccbj(self.ptr(),accidx,j,bj); _tmt871 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt871)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccDotY(whichsol Soltype,accidx int64) (doty []float64,err error) {
  var _tmt874 *float64
  var _tmt872 int64
  if _tmt873 := MSK_getaccn(task.nativep,accidx,addr(_tmt872)); _tmt873 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt873)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  doty := make([]float64,_tmt872)
  if len(doty) > 0 { _tmt874 = (*float64)(&n[0]) }
  if _tmt875 := MSK_putaccdoty(self.ptr(),whichsol,accidx,_tmt874); _tmt875 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt875)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccList(accidxs []int64,domidxs []int64,afeidxlist []int64,b []float64) (err error) {
  _tmt876 := len(accidxs)
  if _tmt876 < domidxs { _tmt876 = lof["name"] }
  var numaccs int64 = int32(_tmt876)
  var _tmt877 *int64
  if accidxs != nil { _tmt877 = (*C.MSKint32t)(&accidxs[0]) }
  var _tmt878 *int64
  if domidxs != nil { _tmt878 = (*C.MSKint32t)(&domidxs[0]) }
  _tmt879 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt879)
  var _tmt880 *int64
  if afeidxlist != nil { _tmt880 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt881 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutAccList",arg:"b"}
    return
  }
  if b != nil { _tmt881 = (*C.MSKint32t)(&b[0]) }
  if _tmt882 := MSK_putacclist(self.ptr(),numaccs,_tmt877,_tmt878,numafeidx,_tmt880,_tmt881); _tmt882 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt882)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAccName(accidx int64,name string) (err error) {
  _tmt883 := C.CString(name)
  if _tmt884 := MSK_putaccname(self.ptr(),accidx,_tmt883); _tmt884 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt884)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutACol(j int32,subj []int32,valj []float64) (err error) {
  _tmt885 := len(valj)
  if _tmt885 < subj { _tmt885 = lof["name"] }
  var nzj int32 = int32(_tmt885)
  var _tmt886 *int32
  if subj != nil { _tmt886 = (*C.MSKint32t)(&subj[0]) }
  var _tmt887 *float64
  if valj != nil { _tmt887 = (*C.MSKint32t)(&valj[0]) }
  if _tmt888 := MSK_putacol(self.ptr(),j,nzj,_tmt886,_tmt887); _tmt888 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt888)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAColList(sub []int32,ptrb []int64,ptre []int64,asub []int32,aval []float64) (err error) {
  _tmt889 := len(ptrb)
  if _tmt889 < ptre { _tmt889 = lof["name"] }
  if _tmt889 < sub { _tmt889 = lof["name"] }
  var num int32 = int32(_tmt889)
  var _tmt890 *int32
  if sub != nil { _tmt890 = (*C.MSKint32t)(&sub[0]) }
  var _tmt891 *int64
  if ptrb != nil { _tmt891 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt892 *int64
  if ptre != nil { _tmt892 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt893 *int32
  if asub != nil { _tmt893 = (*C.MSKint32t)(&asub[0]) }
  var _tmt894 *float64
  if aval != nil { _tmt894 = (*C.MSKint32t)(&aval[0]) }
  if _tmt895 := MSK_putacollist64(self.ptr(),num,_tmt890,_tmt891,_tmt892,_tmt893,_tmt894); _tmt895 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt895)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfBlockTriplet(afeidx []int64,barvaridx []int32,subk []int32,subl []int32,valkl []float64) (err error) {
  _tmt896 := len(subl)
  if _tmt896 < subk { _tmt896 = lof["name"] }
  if _tmt896 < barvaridx { _tmt896 = lof["name"] }
  if _tmt896 < valkl { _tmt896 = lof["name"] }
  if _tmt896 < afeidx { _tmt896 = lof["name"] }
  var numtrip int64 = int32(_tmt896)
  var _tmt897 *int64
  if len(afeidx) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"afeidx"}
    return
  }
  if afeidx != nil { _tmt897 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt898 *int32
  if len(barvaridx) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"barvaridx"}
    return
  }
  if barvaridx != nil { _tmt898 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt899 *int32
  if len(subk) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt899 = (*C.MSKint32t)(&subk[0]) }
  var _tmt900 *int32
  if len(subl) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt900 = (*C.MSKint32t)(&subl[0]) }
  var _tmt901 *float64
  if len(valkl) < numtrip {
    err = &ArrayLengthError{fun:"PutAfeBarfBlockTriplet",arg:"valkl"}
    return
  }
  if valkl != nil { _tmt901 = (*C.MSKint32t)(&valkl[0]) }
  if _tmt902 := MSK_putafebarfblocktriplet(self.ptr(),numtrip,_tmt897,_tmt898,_tmt899,_tmt900,_tmt901); _tmt902 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt902)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfEntry(afeidx int64,barvaridx int32,termidx []int64,termweight []float64) (err error) {
  _tmt903 := len(termidx)
  if _tmt903 < termweight { _tmt903 = lof["name"] }
  var numterm int64 = int32(_tmt903)
  var _tmt904 *int64
  if termidx != nil { _tmt904 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt905 *float64
  if termweight != nil { _tmt905 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt906 := MSK_putafebarfentry(self.ptr(),afeidx,barvaridx,numterm,_tmt904,_tmt905); _tmt906 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt906)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfEntryList(afeidx []int64,barvaridx []int32,numterm []int64,ptrterm []int64,termidx []int64,termweight []float64) (err error) {
  _tmt907 := len(barvaridx)
  if _tmt907 < ptrterm { _tmt907 = lof["name"] }
  if _tmt907 < numterm { _tmt907 = lof["name"] }
  if _tmt907 < afeidx { _tmt907 = lof["name"] }
  var numafeidx int64 = int32(_tmt907)
  var _tmt908 *int64
  if afeidx != nil { _tmt908 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt909 *int32
  if barvaridx != nil { _tmt909 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt910 *int64
  if numterm != nil { _tmt910 = (*C.MSKint32t)(&numterm[0]) }
  var _tmt911 *int64
  if ptrterm != nil { _tmt911 = (*C.MSKint32t)(&ptrterm[0]) }
  _tmt912 := len(termidx)
  if _tmt912 < termweight { _tmt912 = lof["name"] }
  var lenterm int64 = int32(_tmt912)
  var _tmt913 *int64
  if termidx != nil { _tmt913 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt914 *float64
  if termweight != nil { _tmt914 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt915 := MSK_putafebarfentrylist(self.ptr(),numafeidx,_tmt908,_tmt909,_tmt910,_tmt911,lenterm,_tmt913,_tmt914); _tmt915 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt915)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeBarfRow(afeidx int64,barvaridx []int32,numterm []int64,ptrterm []int64,termidx []int64,termweight []float64) (err error) {
  _tmt916 := len(barvaridx)
  if _tmt916 < ptrterm { _tmt916 = lof["name"] }
  if _tmt916 < numterm { _tmt916 = lof["name"] }
  var numentr int32 = int32(_tmt916)
  var _tmt917 *int32
  if barvaridx != nil { _tmt917 = (*C.MSKint32t)(&barvaridx[0]) }
  var _tmt918 *int64
  if numterm != nil { _tmt918 = (*C.MSKint32t)(&numterm[0]) }
  var _tmt919 *int64
  if ptrterm != nil { _tmt919 = (*C.MSKint32t)(&ptrterm[0]) }
  _tmt920 := len(termidx)
  if _tmt920 < termweight { _tmt920 = lof["name"] }
  var lenterm int64 = int32(_tmt920)
  var _tmt921 *int64
  if termidx != nil { _tmt921 = (*C.MSKint32t)(&termidx[0]) }
  var _tmt922 *float64
  if termweight != nil { _tmt922 = (*C.MSKint32t)(&termweight[0]) }
  if _tmt923 := MSK_putafebarfrow(self.ptr(),afeidx,numentr,_tmt917,_tmt918,_tmt919,lenterm,_tmt921,_tmt922); _tmt923 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt923)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFCol(varidx int32,afeidx []int64,val []float64) (err error) {
  _tmt924 := len(val)
  if _tmt924 < afeidx { _tmt924 = lof["name"] }
  var numnz int64 = int32(_tmt924)
  var _tmt925 *int64
  if afeidx != nil { _tmt925 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt926 *float64
  if val != nil { _tmt926 = (*C.MSKint32t)(&val[0]) }
  if _tmt927 := MSK_putafefcol(self.ptr(),varidx,numnz,_tmt925,_tmt926); _tmt927 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt927)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFEntry(afeidx int64,varidx int32,value float64) (err error) {
  if _tmt928 := MSK_putafefentry(self.ptr(),afeidx,varidx,value); _tmt928 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt928)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFEntryList(afeidx []int64,varidx []int32,val []float64) (err error) {
  _tmt929 := len(val)
  if _tmt929 < varidx { _tmt929 = lof["name"] }
  if _tmt929 < afeidx { _tmt929 = lof["name"] }
  var numentr int64 = int32(_tmt929)
  var _tmt930 *int64
  if afeidx != nil { _tmt930 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt931 *int32
  if varidx != nil { _tmt931 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt932 *float64
  if val != nil { _tmt932 = (*C.MSKint32t)(&val[0]) }
  if _tmt933 := MSK_putafefentrylist(self.ptr(),numentr,_tmt930,_tmt931,_tmt932); _tmt933 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt933)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFRow(afeidx int64,varidx []int32,val []float64) (err error) {
  _tmt934 := len(varidx)
  if _tmt934 < val { _tmt934 = lof["name"] }
  var numnz int32 = int32(_tmt934)
  var _tmt935 *int32
  if varidx != nil { _tmt935 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt936 *float64
  if val != nil { _tmt936 = (*C.MSKint32t)(&val[0]) }
  if _tmt937 := MSK_putafefrow(self.ptr(),afeidx,numnz,_tmt935,_tmt936); _tmt937 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt937)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeFRowList(afeidx []int64,numnzrow []int32,ptrrow []int64,varidx []int32,val []float64) (err error) {
  _tmt938 := len(ptrrow)
  if _tmt938 < numnzrow { _tmt938 = lof["name"] }
  if _tmt938 < afeidx { _tmt938 = lof["name"] }
  var numafeidx int64 = int32(_tmt938)
  var _tmt939 *int64
  if afeidx != nil { _tmt939 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt940 *int32
  if numnzrow != nil { _tmt940 = (*C.MSKint32t)(&numnzrow[0]) }
  var _tmt941 *int64
  if ptrrow != nil { _tmt941 = (*C.MSKint32t)(&ptrrow[0]) }
  _tmt942 := len(varidx)
  if _tmt942 < val { _tmt942 = lof["name"] }
  var lenidxval int64 = int32(_tmt942)
  var _tmt943 *int32
  if varidx != nil { _tmt943 = (*C.MSKint32t)(&varidx[0]) }
  var _tmt944 *float64
  if val != nil { _tmt944 = (*C.MSKint32t)(&val[0]) }
  if _tmt945 := MSK_putafefrowlist(self.ptr(),numafeidx,_tmt939,_tmt940,_tmt941,lenidxval,_tmt943,_tmt944); _tmt945 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt945)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeG(afeidx int64,g float64) (err error) {
  if _tmt946 := MSK_putafeg(self.ptr(),afeidx,g); _tmt946 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt946)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeGList(afeidx []int64,g []float64) (err error) {
  _tmt947 := len(g)
  if _tmt947 < afeidx { _tmt947 = lof["name"] }
  var numafeidx int64 = int32(_tmt947)
  var _tmt948 *int64
  if afeidx != nil { _tmt948 = (*C.MSKint32t)(&afeidx[0]) }
  var _tmt949 *float64
  if g != nil { _tmt949 = (*C.MSKint32t)(&g[0]) }
  if _tmt950 := MSK_putafeglist(self.ptr(),numafeidx,_tmt948,_tmt949); _tmt950 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt950)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAfeGSlice(first int64,last int64,slice []float64) (err error) {
  var _tmt951 *float64
  if len(slice) < (last - first) {
    err = &ArrayLengthError{fun:"PutAfeGSlice",arg:"slice"}
    return
  }
  if slice != nil { _tmt951 = (*C.MSKint32t)(&slice[0]) }
  if _tmt952 := MSK_putafegslice(self.ptr(),first,last,_tmt951); _tmt952 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt952)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAij(i int32,j int32,aij float64) (err error) {
  if _tmt953 := MSK_putaij(self.ptr(),i,j,aij); _tmt953 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt953)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutAijList(subi []int32,subj []int32,valij []float64) (err error) {
  _tmt954 := len(subi)
  if _tmt954 < valij { _tmt954 = lof["name"] }
  if _tmt954 < subj { _tmt954 = lof["name"] }
  var num int64 = int32(_tmt954)
  var _tmt955 *int32
  if subi != nil { _tmt955 = (*C.MSKint32t)(&subi[0]) }
  var _tmt956 *int32
  if subj != nil { _tmt956 = (*C.MSKint32t)(&subj[0]) }
  var _tmt957 *float64
  if valij != nil { _tmt957 = (*C.MSKint32t)(&valij[0]) }
  if _tmt958 := MSK_putaijlist64(self.ptr(),num,_tmt955,_tmt956,_tmt957); _tmt958 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt958)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutARow(i int32,subi []int32,vali []float64) (err error) {
  _tmt959 := len(vali)
  if _tmt959 < subi { _tmt959 = lof["name"] }
  var nzi int32 = int32(_tmt959)
  var _tmt960 *int32
  if subi != nil { _tmt960 = (*C.MSKint32t)(&subi[0]) }
  var _tmt961 *float64
  if vali != nil { _tmt961 = (*C.MSKint32t)(&vali[0]) }
  if _tmt962 := MSK_putarow(self.ptr(),i,nzi,_tmt960,_tmt961); _tmt962 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt962)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutARowList(sub []int32,ptrb []int64,ptre []int64,asub []int32,aval []float64) (err error) {
  _tmt963 := len(ptrb)
  if _tmt963 < ptre { _tmt963 = lof["name"] }
  if _tmt963 < sub { _tmt963 = lof["name"] }
  var num int32 = int32(_tmt963)
  var _tmt964 *int32
  if sub != nil { _tmt964 = (*C.MSKint32t)(&sub[0]) }
  var _tmt965 *int64
  if ptrb != nil { _tmt965 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt966 *int64
  if ptre != nil { _tmt966 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt967 *int32
  if asub != nil { _tmt967 = (*C.MSKint32t)(&asub[0]) }
  var _tmt968 *float64
  if aval != nil { _tmt968 = (*C.MSKint32t)(&aval[0]) }
  if _tmt969 := MSK_putarowlist64(self.ptr(),num,_tmt964,_tmt965,_tmt966,_tmt967,_tmt968); _tmt969 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt969)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutATruncateTol(tolzero float64) (err error) {
  if _tmt970 := MSK_putatruncatetol(self.ptr(),tolzero); _tmt970 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt970)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraBlockTriplet(subi []int32,subj []int32,subk []int32,subl []int32,valijkl []float64) (err error) {
  _tmt971 := len(subl)
  if _tmt971 < valijkl { _tmt971 = lof["name"] }
  if _tmt971 < subk { _tmt971 = lof["name"] }
  if _tmt971 < subj { _tmt971 = lof["name"] }
  var num int64 = int32(_tmt971)
  var _tmt972 *int32
  if len(subi) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subi"}
    return
  }
  if subi != nil { _tmt972 = (*C.MSKint32t)(&subi[0]) }
  var _tmt973 *int32
  if len(subj) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subj"}
    return
  }
  if subj != nil { _tmt973 = (*C.MSKint32t)(&subj[0]) }
  var _tmt974 *int32
  if len(subk) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt974 = (*C.MSKint32t)(&subk[0]) }
  var _tmt975 *int32
  if len(subl) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt975 = (*C.MSKint32t)(&subl[0]) }
  var _tmt976 *float64
  if len(valijkl) < num {
    err = &ArrayLengthError{fun:"PutBaraBlockTriplet",arg:"valijkl"}
    return
  }
  if valijkl != nil { _tmt976 = (*C.MSKint32t)(&valijkl[0]) }
  if _tmt977 := MSK_putbarablocktriplet(self.ptr(),num,_tmt972,_tmt973,_tmt974,_tmt975,_tmt976); _tmt977 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt977)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraIj(i int32,j int32,sub []int64,weights []float64) (err error) {
  _tmt978 := len(weights)
  if _tmt978 < sub { _tmt978 = lof["name"] }
  var num int64 = int32(_tmt978)
  var _tmt979 *int64
  if sub != nil { _tmt979 = (*C.MSKint32t)(&sub[0]) }
  var _tmt980 *float64
  if weights != nil { _tmt980 = (*C.MSKint32t)(&weights[0]) }
  if _tmt981 := MSK_putbaraij(self.ptr(),i,j,num,_tmt979,_tmt980); _tmt981 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt981)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraIjList(subi []int32,subj []int32,alphaptrb []int64,alphaptre []int64,matidx []int64,weights []float64) (err error) {
  _tmt982 := len(alphaptrb)
  if _tmt982 < subi { _tmt982 = lof["name"] }
  if _tmt982 < alphaptre { _tmt982 = lof["name"] }
  if _tmt982 < subj { _tmt982 = lof["name"] }
  var num int32 = int32(_tmt982)
  var _tmt983 *int32
  if subi != nil { _tmt983 = (*C.MSKint32t)(&subi[0]) }
  var _tmt984 *int32
  if subj != nil { _tmt984 = (*C.MSKint32t)(&subj[0]) }
  var _tmt985 *int64
  if alphaptrb != nil { _tmt985 = (*C.MSKint32t)(&alphaptrb[0]) }
  var _tmt986 *int64
  if alphaptre != nil { _tmt986 = (*C.MSKint32t)(&alphaptre[0]) }
  var _tmt987 *int64
  if matidx != nil { _tmt987 = (*C.MSKint32t)(&matidx[0]) }
  var _tmt988 *float64
  if weights != nil { _tmt988 = (*C.MSKint32t)(&weights[0]) }
  if _tmt989 := MSK_putbaraijlist(self.ptr(),num,_tmt983,_tmt984,_tmt985,_tmt986,_tmt987,_tmt988); _tmt989 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt989)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBaraRowList(subi []int32,ptrb []int64,ptre []int64,subj []int32,nummat []int64,matidx []int64,weights []float64) (err error) {
  _tmt990 := len(ptrb)
  if _tmt990 < ptre { _tmt990 = lof["name"] }
  if _tmt990 < subi { _tmt990 = lof["name"] }
  var num int32 = int32(_tmt990)
  var _tmt991 *int32
  if subi != nil { _tmt991 = (*C.MSKint32t)(&subi[0]) }
  var _tmt992 *int64
  if ptrb != nil { _tmt992 = (*C.MSKint32t)(&ptrb[0]) }
  var _tmt993 *int64
  if ptre != nil { _tmt993 = (*C.MSKint32t)(&ptre[0]) }
  var _tmt994 *int32
  if subj != nil { _tmt994 = (*C.MSKint32t)(&subj[0]) }
  var _tmt995 *int64
  if len(nummat) < cast[int32](subj.len) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"nummat"}
    return
  }
  if nummat != nil { _tmt995 = (*C.MSKint32t)(&nummat[0]) }
  var _tmt996 *int64
  if len(matidx) < nummat.foldl(a+b) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"matidx"}
    return
  }
  if matidx != nil { _tmt996 = (*C.MSKint32t)(&matidx[0]) }
  var _tmt997 *float64
  if len(weights) < nummat.foldl(a+b) {
    err = &ArrayLengthError{fun:"PutBaraRowList",arg:"weights"}
    return
  }
  if weights != nil { _tmt997 = (*C.MSKint32t)(&weights[0]) }
  if _tmt998 := MSK_putbararowlist(self.ptr(),num,_tmt991,_tmt992,_tmt993,_tmt994,_tmt995,_tmt996,_tmt997); _tmt998 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt998)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarcBlockTriplet(subj []int32,subk []int32,subl []int32,valjkl []float64) (err error) {
  _tmt999 := len(valjkl)
  if _tmt999 < subl { _tmt999 = lof["name"] }
  if _tmt999 < subk { _tmt999 = lof["name"] }
  if _tmt999 < subj { _tmt999 = lof["name"] }
  var num int64 = int32(_tmt999)
  var _tmt1000 *int32
  if len(subj) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subj"}
    return
  }
  if subj != nil { _tmt1000 = (*C.MSKint32t)(&subj[0]) }
  var _tmt1001 *int32
  if len(subk) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subk"}
    return
  }
  if subk != nil { _tmt1001 = (*C.MSKint32t)(&subk[0]) }
  var _tmt1002 *int32
  if len(subl) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"subl"}
    return
  }
  if subl != nil { _tmt1002 = (*C.MSKint32t)(&subl[0]) }
  var _tmt1003 *float64
  if len(valjkl) < num {
    err = &ArrayLengthError{fun:"PutBarcBlockTriplet",arg:"valjkl"}
    return
  }
  if valjkl != nil { _tmt1003 = (*C.MSKint32t)(&valjkl[0]) }
  if _tmt1004 := MSK_putbarcblocktriplet(self.ptr(),num,_tmt1000,_tmt1001,_tmt1002,_tmt1003); _tmt1004 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1004)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarcJ(j int32,sub []int64,weights []float64) (err error) {
  _tmt1005 := len(weights)
  if _tmt1005 < sub { _tmt1005 = lof["name"] }
  var num int64 = int32(_tmt1005)
  var _tmt1006 *int64
  if sub != nil { _tmt1006 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1007 *float64
  if weights != nil { _tmt1007 = (*C.MSKint32t)(&weights[0]) }
  if _tmt1008 := MSK_putbarcj(self.ptr(),j,num,_tmt1006,_tmt1007); _tmt1008 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1008)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarsJ(whichsol Soltype,j int32,barsj []float64) (err error) {
  var _tmt1011 *float64
  var _tmt1009 int64
  if _tmt1010 := MSK_getlenbarvarj(task.nativep,j,addr(_tmt1009)); _tmt1010 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1010)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(barsj) < _tmt1009 {
    err = &ArrayLengthError{fun:"PutBarsJ",arg:"barsj"}
    return
  }
  if barsj != nil { _tmt1011 = (*C.MSKint32t)(&barsj[0]) }
  if _tmt1012 := MSK_putbarsj(self.ptr(),whichsol,j,_tmt1011); _tmt1012 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1012)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarvarName(j int32,name string) (err error) {
  _tmt1013 := C.CString(name)
  if _tmt1014 := MSK_putbarvarname(self.ptr(),j,_tmt1013); _tmt1014 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1014)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutBarxJ(whichsol Soltype,j int32,barxj []float64) (err error) {
  var _tmt1017 *float64
  var _tmt1015 int64
  if _tmt1016 := MSK_getlenbarvarj(task.nativep,j,addr(_tmt1015)); _tmt1016 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1016)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(barxj) < _tmt1015 {
    err = &ArrayLengthError{fun:"PutBarxJ",arg:"barxj"}
    return
  }
  if barxj != nil { _tmt1017 = (*C.MSKint32t)(&barxj[0]) }
  if _tmt1018 := MSK_putbarxj(self.ptr(),whichsol,j,_tmt1017); _tmt1018 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1018)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCfix(cfix float64) (err error) {
  if _tmt1019 := MSK_putcfix(self.ptr(),cfix); _tmt1019 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1019)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCJ(j int32,cj float64) (err error) {
  if _tmt1020 := MSK_putcj(self.ptr(),j,cj); _tmt1020 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1020)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCList(subj []int32,val []float64) (err error) {
  _tmt1021 := len(val)
  if _tmt1021 < subj { _tmt1021 = lof["name"] }
  var num int32 = int32(_tmt1021)
  var _tmt1022 *int32
  if subj != nil { _tmt1022 = (*C.MSKint32t)(&subj[0]) }
  var _tmt1023 *float64
  if val != nil { _tmt1023 = (*C.MSKint32t)(&val[0]) }
  if _tmt1024 := MSK_putclist(self.ptr(),num,_tmt1022,_tmt1023); _tmt1024 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1024)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBound(i int32,bkc Boundkey,blc float64,buc float64) (err error) {
  if _tmt1025 := MSK_putconbound(self.ptr(),i,bkc,blc,buc); _tmt1025 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1025)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundList(sub []int32,bkc []Boundkey,blc []float64,buc []float64) (err error) {
  _tmt1026 := len(bkc)
  if _tmt1026 < blc { _tmt1026 = lof["name"] }
  if _tmt1026 < buc { _tmt1026 = lof["name"] }
  if _tmt1026 < sub { _tmt1026 = lof["name"] }
  var num int32 = int32(_tmt1026)
  var _tmt1027 *int32
  if sub != nil { _tmt1027 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1028 *Boundkey
  if bkc != nil { _tmt1028 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt1029 *float64
  if blc != nil { _tmt1029 = (*C.MSKint32t)(&blc[0]) }
  var _tmt1030 *float64
  if buc != nil { _tmt1030 = (*C.MSKint32t)(&buc[0]) }
  if _tmt1031 := MSK_putconboundlist(self.ptr(),num,_tmt1027,_tmt1028,_tmt1029,_tmt1030); _tmt1031 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1031)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundListConst(sub []int32,bkc Boundkey,blc float64,buc float64) (err error) {
  _tmt1032 := len(sub)
  var num int32 = int32(_tmt1032)
  var _tmt1033 *int32
  if sub != nil { _tmt1033 = (*C.MSKint32t)(&sub[0]) }
  if _tmt1034 := MSK_putconboundlistconst(self.ptr(),num,_tmt1033,bkc,blc,buc); _tmt1034 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1034)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundSlice(first int32,last int32,bkc []Boundkey,blc []float64,buc []float64) (err error) {
  var _tmt1035 *Boundkey
  if len(bkc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"bkc"}
    return
  }
  if bkc != nil { _tmt1035 = (*C.MSKint32t)(&bkc[0]) }
  var _tmt1036 *float64
  if len(blc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"blc"}
    return
  }
  if blc != nil { _tmt1036 = (*C.MSKint32t)(&blc[0]) }
  var _tmt1037 *float64
  if len(buc) < (last - first) {
    err = &ArrayLengthError{fun:"PutConBoundSlice",arg:"buc"}
    return
  }
  if buc != nil { _tmt1037 = (*C.MSKint32t)(&buc[0]) }
  if _tmt1038 := MSK_putconboundslice(self.ptr(),first,last,_tmt1035,_tmt1036,_tmt1037); _tmt1038 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1038)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConBoundSliceConst(first int32,last int32,bkc Boundkey,blc float64,buc float64) (err error) {
  if _tmt1039 := MSK_putconboundsliceconst(self.ptr(),first,last,bkc,blc,buc); _tmt1039 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1039)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCone(k int32,ct Conetype,conepar float64,submem []int32) (err error) {
  _tmt1040 := len(submem)
  var nummem int32 = int32(_tmt1040)
  var _tmt1041 *int32
  if submem != nil { _tmt1041 = (*C.MSKint32t)(&submem[0]) }
  if _tmt1042 := MSK_putcone(self.ptr(),k,ct,conepar,nummem,_tmt1041); _tmt1042 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1042)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConeName(j int32,name string) (err error) {
  _tmt1043 := C.CString(name)
  if _tmt1044 := MSK_putconename(self.ptr(),j,_tmt1043); _tmt1044 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1044)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConName(i int32,name string) (err error) {
  _tmt1045 := C.CString(name)
  if _tmt1046 := MSK_putconname(self.ptr(),i,_tmt1045); _tmt1046 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1046)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutConSolutionI(i int32,whichsol Soltype,sk Stakey,x float64,sl float64,su float64) (err error) {
  if _tmt1047 := MSK_putconsolutioni(self.ptr(),i,whichsol,sk,x,sl,su); _tmt1047 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1047)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutCSlice(first int32,last int32,slice []float64) (err error) {
  var _tmt1048 *float64
  if len(slice) < (last - first) {
    err = &ArrayLengthError{fun:"PutCSlice",arg:"slice"}
    return
  }
  if slice != nil { _tmt1048 = (*C.MSKint32t)(&slice[0]) }
  if _tmt1049 := MSK_putcslice(self.ptr(),first,last,_tmt1048); _tmt1049 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1049)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjc(djcidx int64,domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64) (err error) {
  _tmt1050 := len(domidxlist)
  var numdomidx int64 = int32(_tmt1050)
  var _tmt1051 *int64
  if domidxlist != nil { _tmt1051 = (*C.MSKint32t)(&domidxlist[0]) }
  _tmt1052 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt1052)
  var _tmt1053 *int64
  if afeidxlist != nil { _tmt1053 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt1054 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutDjc",arg:"b"}
    return
  }
  if b != nil { _tmt1054 = (*C.MSKint32t)(&b[0]) }
  _tmt1055 := len(termsizelist)
  var numterms int64 = int32(_tmt1055)
  var _tmt1056 *int64
  if termsizelist != nil { _tmt1056 = (*C.MSKint32t)(&termsizelist[0]) }
  if _tmt1057 := MSK_putdjc(self.ptr(),djcidx,numdomidx,_tmt1051,numafeidx,_tmt1053,_tmt1054,numterms,_tmt1056); _tmt1057 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1057)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjcName(djcidx int64,name string) (err error) {
  _tmt1058 := C.CString(name)
  if _tmt1059 := MSK_putdjcname(self.ptr(),djcidx,_tmt1058); _tmt1059 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1059)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDjcSlice(idxfirst int64,idxlast int64,domidxlist []int64,afeidxlist []int64,b []float64,termsizelist []int64,termsindjc []int64) (err error) {
  _tmt1060 := len(domidxlist)
  var numdomidx int64 = int32(_tmt1060)
  var _tmt1061 *int64
  if domidxlist != nil { _tmt1061 = (*C.MSKint32t)(&domidxlist[0]) }
  _tmt1062 := len(afeidxlist)
  var numafeidx int64 = int32(_tmt1062)
  var _tmt1063 *int64
  if afeidxlist != nil { _tmt1063 = (*C.MSKint32t)(&afeidxlist[0]) }
  var _tmt1064 *float64
  if len(b) < numafeidx {
    err = &ArrayLengthError{fun:"PutDjcSlice",arg:"b"}
    return
  }
  if b != nil { _tmt1064 = (*C.MSKint32t)(&b[0]) }
  _tmt1065 := len(termsizelist)
  var numterms int64 = int32(_tmt1065)
  var _tmt1066 *int64
  if termsizelist != nil { _tmt1066 = (*C.MSKint32t)(&termsizelist[0]) }
  var _tmt1067 *int64
  if len(termsindjc) < (idxlast - idxfirst) {
    err = &ArrayLengthError{fun:"PutDjcSlice",arg:"termsindjc"}
    return
  }
  if termsindjc != nil { _tmt1067 = (*C.MSKint32t)(&termsindjc[0]) }
  if _tmt1068 := MSK_putdjcslice(self.ptr(),idxfirst,idxlast,numdomidx,_tmt1061,numafeidx,_tmt1063,_tmt1064,numterms,_tmt1066,_tmt1067); _tmt1068 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1068)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDomainName(domidx int64,name string) (err error) {
  _tmt1069 := C.CString(name)
  if _tmt1070 := MSK_putdomainname(self.ptr(),domidx,_tmt1069); _tmt1070 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1070)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutDouParam(param Dparam,parvalue float64) (err error) {
  if _tmt1071 := MSK_putdouparam(self.ptr(),param,parvalue); _tmt1071 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1071)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutIntParam(param Iparam,parvalue int32) (err error) {
  if _tmt1072 := MSK_putintparam(self.ptr(),param,parvalue); _tmt1072 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1072)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumAcc(maxnumacc int64) (err error) {
  if _tmt1073 := MSK_putmaxnumacc(self.ptr(),maxnumacc); _tmt1073 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1073)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumAfe(maxnumafe int64) (err error) {
  if _tmt1074 := MSK_putmaxnumafe(self.ptr(),maxnumafe); _tmt1074 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1074)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumANz(maxnumanz int64) (err error) {
  if _tmt1075 := MSK_putmaxnumanz(self.ptr(),maxnumanz); _tmt1075 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1075)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumBarvar(maxnumbarvar int32) (err error) {
  if _tmt1076 := MSK_putmaxnumbarvar(self.ptr(),maxnumbarvar); _tmt1076 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1076)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumCon(maxnumcon int32) (err error) {
  if _tmt1077 := MSK_putmaxnumcon(self.ptr(),maxnumcon); _tmt1077 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1077)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumCone(maxnumcone int32) (err error) {
  if _tmt1078 := MSK_putmaxnumcone(self.ptr(),maxnumcone); _tmt1078 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1078)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumDjc(maxnumdjc int64) (err error) {
  if _tmt1079 := MSK_putmaxnumdjc(self.ptr(),maxnumdjc); _tmt1079 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1079)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumDomain(maxnumdomain int64) (err error) {
  if _tmt1080 := MSK_putmaxnumdomain(self.ptr(),maxnumdomain); _tmt1080 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1080)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumQNz(maxnumqnz int64) (err error) {
  if _tmt1081 := MSK_putmaxnumqnz(self.ptr(),maxnumqnz); _tmt1081 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1081)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutMaxNumVar(maxnumvar int32) (err error) {
  if _tmt1082 := MSK_putmaxnumvar(self.ptr(),maxnumvar); _tmt1082 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1082)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaDouParam(paramname string,parvalue float64) (err error) {
  _tmt1083 := C.CString(paramname)
  if _tmt1084 := MSK_putnadouparam(self.ptr(),_tmt1083,parvalue); _tmt1084 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1084)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaIntParam(paramname string,parvalue int32) (err error) {
  _tmt1085 := C.CString(paramname)
  if _tmt1086 := MSK_putnaintparam(self.ptr(),_tmt1085,parvalue); _tmt1086 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1086)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutNaStrParam(paramname string,parvalue string) (err error) {
  _tmt1087 := C.CString(paramname)
  _tmt1088 := C.CString(parvalue)
  if _tmt1089 := MSK_putnastrparam(self.ptr(),_tmt1087,_tmt1088); _tmt1089 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1089)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutObjName(objname string) (err error) {
  _tmt1090 := C.CString(objname)
  if _tmt1091 := MSK_putobjname(self.ptr(),_tmt1090); _tmt1091 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1091)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutObjSense(sense Objsense) (err error) {
  if _tmt1092 := MSK_putobjsense(self.ptr(),sense); _tmt1092 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1092)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutOptserverHost(host string) (err error) {
  _tmt1093 := C.CString(host)
  if _tmt1094 := MSK_putoptserverhost(self.ptr(),_tmt1093); _tmt1094 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1094)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutParam(parname string,parvalue string) (err error) {
  _tmt1095 := C.CString(parname)
  _tmt1096 := C.CString(parvalue)
  if _tmt1097 := MSK_putparam(self.ptr(),_tmt1095,_tmt1096); _tmt1097 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1097)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQCon(qcsubk []int32,qcsubi []int32,qcsubj []int32,qcval []float64) (err error) {
  _tmt1098 := len(qcval)
  if _tmt1098 < qcsubi { _tmt1098 = lof["name"] }
  if _tmt1098 < qcsubj { _tmt1098 = lof["name"] }
  var numqcnz int32 = int32(_tmt1098)
  var _tmt1099 *int32
  if qcsubk != nil { _tmt1099 = (*C.MSKint32t)(&qcsubk[0]) }
  var _tmt1100 *int32
  if qcsubi != nil { _tmt1100 = (*C.MSKint32t)(&qcsubi[0]) }
  var _tmt1101 *int32
  if qcsubj != nil { _tmt1101 = (*C.MSKint32t)(&qcsubj[0]) }
  var _tmt1102 *float64
  if qcval != nil { _tmt1102 = (*C.MSKint32t)(&qcval[0]) }
  if _tmt1103 := MSK_putqcon(self.ptr(),numqcnz,_tmt1099,_tmt1100,_tmt1101,_tmt1102); _tmt1103 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1103)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQConK(k int32,qcsubi []int32,qcsubj []int32,qcval []float64) (err error) {
  _tmt1104 := len(qcval)
  if _tmt1104 < qcsubi { _tmt1104 = lof["name"] }
  if _tmt1104 < qcsubj { _tmt1104 = lof["name"] }
  var numqcnz int32 = int32(_tmt1104)
  var _tmt1105 *int32
  if qcsubi != nil { _tmt1105 = (*C.MSKint32t)(&qcsubi[0]) }
  var _tmt1106 *int32
  if qcsubj != nil { _tmt1106 = (*C.MSKint32t)(&qcsubj[0]) }
  var _tmt1107 *float64
  if qcval != nil { _tmt1107 = (*C.MSKint32t)(&qcval[0]) }
  if _tmt1108 := MSK_putqconk(self.ptr(),k,numqcnz,_tmt1105,_tmt1106,_tmt1107); _tmt1108 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1108)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQObj(qosubi []int32,qosubj []int32,qoval []float64) (err error) {
  _tmt1109 := len(qosubi)
  if _tmt1109 < qoval { _tmt1109 = lof["name"] }
  if _tmt1109 < qosubj { _tmt1109 = lof["name"] }
  var numqonz int32 = int32(_tmt1109)
  var _tmt1110 *int32
  if qosubi != nil { _tmt1110 = (*C.MSKint32t)(&qosubi[0]) }
  var _tmt1111 *int32
  if qosubj != nil { _tmt1111 = (*C.MSKint32t)(&qosubj[0]) }
  var _tmt1112 *float64
  if qoval != nil { _tmt1112 = (*C.MSKint32t)(&qoval[0]) }
  if _tmt1113 := MSK_putqobj(self.ptr(),numqonz,_tmt1110,_tmt1111,_tmt1112); _tmt1113 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1113)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutQObjIJ(i int32,j int32,qoij float64) (err error) {
  if _tmt1114 := MSK_putqobjij(self.ptr(),i,j,qoij); _tmt1114 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1114)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkc(whichsol Soltype,skc []Stakey) (err error) {
  var _tmt1117 *Stakey
  var _tmt1115 int32
  if _tmt1116 := MSK_getnumcon(task.nativep,addr(_tmt1115)); _tmt1116 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1116)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(skc) < _tmt1115 {
    err = &ArrayLengthError{fun:"PutSkc",arg:"skc"}
    return
  }
  if skc != nil { _tmt1117 = (*C.MSKint32t)(&skc[0]) }
  if _tmt1118 := MSK_putskc(self.ptr(),whichsol,_tmt1117); _tmt1118 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1118)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkcSlice(whichsol Soltype,first int32,last int32,skc []Stakey) (err error) {
  var _tmt1119 *Stakey
  if len(skc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSkcSlice",arg:"skc"}
    return
  }
  if skc != nil { _tmt1119 = (*C.MSKint32t)(&skc[0]) }
  if _tmt1120 := MSK_putskcslice(self.ptr(),whichsol,first,last,_tmt1119); _tmt1120 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1120)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkx(whichsol Soltype,skx []Stakey) (err error) {
  var _tmt1123 *Stakey
  var _tmt1121 int32
  if _tmt1122 := MSK_getnumvar(task.nativep,addr(_tmt1121)); _tmt1122 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1122)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(skx) < _tmt1121 {
    err = &ArrayLengthError{fun:"PutSkx",arg:"skx"}
    return
  }
  if skx != nil { _tmt1123 = (*C.MSKint32t)(&skx[0]) }
  if _tmt1124 := MSK_putskx(self.ptr(),whichsol,_tmt1123); _tmt1124 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1124)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSkxSlice(whichsol Soltype,first int32,last int32,skx []Stakey) (err error) {
  var _tmt1125 *Stakey
  if len(skx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSkxSlice",arg:"skx"}
    return
  }
  if skx != nil { _tmt1125 = (*C.MSKint32t)(&skx[0]) }
  if _tmt1126 := MSK_putskxslice(self.ptr(),whichsol,first,last,_tmt1125); _tmt1126 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1126)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlc(whichsol Soltype,slc []float64) (err error) {
  var _tmt1129 *float64
  var _tmt1127 int32
  if _tmt1128 := MSK_getnumcon(task.nativep,addr(_tmt1127)); _tmt1128 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1128)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(slc) < _tmt1127 {
    err = &ArrayLengthError{fun:"PutSlc",arg:"slc"}
    return
  }
  if slc != nil { _tmt1129 = (*C.MSKint32t)(&slc[0]) }
  if _tmt1130 := MSK_putslc(self.ptr(),whichsol,_tmt1129); _tmt1130 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1130)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlcSlice(whichsol Soltype,first int32,last int32,slc []float64) (err error) {
  var _tmt1131 *float64
  if len(slc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSlcSlice",arg:"slc"}
    return
  }
  if slc != nil { _tmt1131 = (*C.MSKint32t)(&slc[0]) }
  if _tmt1132 := MSK_putslcslice(self.ptr(),whichsol,first,last,_tmt1131); _tmt1132 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1132)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlx(whichsol Soltype,slx []float64) (err error) {
  var _tmt1135 *float64
  var _tmt1133 int32
  if _tmt1134 := MSK_getnumvar(task.nativep,addr(_tmt1133)); _tmt1134 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1134)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(slx) < _tmt1133 {
    err = &ArrayLengthError{fun:"PutSlx",arg:"slx"}
    return
  }
  if slx != nil { _tmt1135 = (*C.MSKint32t)(&slx[0]) }
  if _tmt1136 := MSK_putslx(self.ptr(),whichsol,_tmt1135); _tmt1136 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1136)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSlxSlice(whichsol Soltype,first int32,last int32,slx []float64) (err error) {
  var _tmt1137 *float64
  if len(slx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSlxSlice",arg:"slx"}
    return
  }
  if slx != nil { _tmt1137 = (*C.MSKint32t)(&slx[0]) }
  if _tmt1138 := MSK_putslxslice(self.ptr(),whichsol,first,last,_tmt1137); _tmt1138 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1138)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSnx(whichsol Soltype,sux []float64) (err error) {
  var _tmt1141 *float64
  var _tmt1139 int32
  if _tmt1140 := MSK_getnumvar(task.nativep,addr(_tmt1139)); _tmt1140 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1140)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sux) < _tmt1139 {
    err = &ArrayLengthError{fun:"PutSnx",arg:"sux"}
    return
  }
  if sux != nil { _tmt1141 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1142 := MSK_putsnx(self.ptr(),whichsol,_tmt1141); _tmt1142 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1142)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSnxSlice(whichsol Soltype,first int32,last int32,snx []float64) (err error) {
  var _tmt1143 *float64
  if len(snx) < (last - first) {
    err = &ArrayLengthError{fun:"PutSnxSlice",arg:"snx"}
    return
  }
  if snx != nil { _tmt1143 = (*C.MSKint32t)(&snx[0]) }
  if _tmt1144 := MSK_putsnxslice(self.ptr(),whichsol,first,last,_tmt1143); _tmt1144 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1144)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolution(whichsol Soltype,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64) (err error) {
  var _tmt1145 *Stakey
  if skc != nil { _tmt1145 = (*C.MSKint32t)(&skc[0]) }
  var _tmt1146 *Stakey
  if skx != nil { _tmt1146 = (*C.MSKint32t)(&skx[0]) }
  var _tmt1147 *Stakey
  if skn != nil { _tmt1147 = (*C.MSKint32t)(&skn[0]) }
  var _tmt1148 *float64
  if xc != nil { _tmt1148 = (*C.MSKint32t)(&xc[0]) }
  var _tmt1149 *float64
  if xx != nil { _tmt1149 = (*C.MSKint32t)(&xx[0]) }
  var _tmt1150 *float64
  if y != nil { _tmt1150 = (*C.MSKint32t)(&y[0]) }
  var _tmt1151 *float64
  if slc != nil { _tmt1151 = (*C.MSKint32t)(&slc[0]) }
  var _tmt1152 *float64
  if suc != nil { _tmt1152 = (*C.MSKint32t)(&suc[0]) }
  var _tmt1153 *float64
  if slx != nil { _tmt1153 = (*C.MSKint32t)(&slx[0]) }
  var _tmt1154 *float64
  if sux != nil { _tmt1154 = (*C.MSKint32t)(&sux[0]) }
  var _tmt1155 *float64
  if snx != nil { _tmt1155 = (*C.MSKint32t)(&snx[0]) }
  if _tmt1156 := MSK_putsolution(self.ptr(),whichsol,_tmt1145,_tmt1146,_tmt1147,_tmt1148,_tmt1149,_tmt1150,_tmt1151,_tmt1152,_tmt1153,_tmt1154,_tmt1155); _tmt1156 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1156)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolutionNew(whichsol Soltype,skc []Stakey,skx []Stakey,skn []Stakey,xc []float64,xx []float64,y []float64,slc []float64,suc []float64,slx []float64,sux []float64,snx []float64,doty []float64) (err error) {
  var _tmt1157 *Stakey
  if skc != nil { _tmt1157 = (*C.MSKint32t)(&skc[0]) }
  var _tmt1158 *Stakey
  if skx != nil { _tmt1158 = (*C.MSKint32t)(&skx[0]) }
  var _tmt1159 *Stakey
  if skn != nil { _tmt1159 = (*C.MSKint32t)(&skn[0]) }
  var _tmt1160 *float64
  if xc != nil { _tmt1160 = (*C.MSKint32t)(&xc[0]) }
  var _tmt1161 *float64
  if xx != nil { _tmt1161 = (*C.MSKint32t)(&xx[0]) }
  var _tmt1162 *float64
  if y != nil { _tmt1162 = (*C.MSKint32t)(&y[0]) }
  var _tmt1163 *float64
  if slc != nil { _tmt1163 = (*C.MSKint32t)(&slc[0]) }
  var _tmt1164 *float64
  if suc != nil { _tmt1164 = (*C.MSKint32t)(&suc[0]) }
  var _tmt1165 *float64
  if slx != nil { _tmt1165 = (*C.MSKint32t)(&slx[0]) }
  var _tmt1166 *float64
  if sux != nil { _tmt1166 = (*C.MSKint32t)(&sux[0]) }
  var _tmt1167 *float64
  if snx != nil { _tmt1167 = (*C.MSKint32t)(&snx[0]) }
  var _tmt1168 *float64
  if doty != nil { _tmt1168 = (*C.MSKint32t)(&doty[0]) }
  if _tmt1169 := MSK_putsolutionnew(self.ptr(),whichsol,_tmt1157,_tmt1158,_tmt1159,_tmt1160,_tmt1161,_tmt1162,_tmt1163,_tmt1164,_tmt1165,_tmt1166,_tmt1167,_tmt1168); _tmt1169 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1169)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSolutionYI(i int32,whichsol Soltype,y float64) (err error) {
  if _tmt1170 := MSK_putsolutionyi(self.ptr(),i,whichsol,y); _tmt1170 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1170)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutStrParam(param Sparam,parvalue string) (err error) {
  _tmt1171 := C.CString(parvalue)
  if _tmt1172 := MSK_putstrparam(self.ptr(),param,_tmt1171); _tmt1172 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1172)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSuc(whichsol Soltype,suc []float64) (err error) {
  var _tmt1175 *float64
  var _tmt1173 int32
  if _tmt1174 := MSK_getnumcon(task.nativep,addr(_tmt1173)); _tmt1174 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1174)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(suc) < _tmt1173 {
    err = &ArrayLengthError{fun:"PutSuc",arg:"suc"}
    return
  }
  if suc != nil { _tmt1175 = (*C.MSKint32t)(&suc[0]) }
  if _tmt1176 := MSK_putsuc(self.ptr(),whichsol,_tmt1175); _tmt1176 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1176)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSucSlice(whichsol Soltype,first int32,last int32,suc []float64) (err error) {
  var _tmt1177 *float64
  if len(suc) < (last - first) {
    err = &ArrayLengthError{fun:"PutSucSlice",arg:"suc"}
    return
  }
  if suc != nil { _tmt1177 = (*C.MSKint32t)(&suc[0]) }
  if _tmt1178 := MSK_putsucslice(self.ptr(),whichsol,first,last,_tmt1177); _tmt1178 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1178)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSux(whichsol Soltype,sux []float64) (err error) {
  var _tmt1181 *float64
  var _tmt1179 int32
  if _tmt1180 := MSK_getnumvar(task.nativep,addr(_tmt1179)); _tmt1180 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1180)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sux) < _tmt1179 {
    err = &ArrayLengthError{fun:"PutSux",arg:"sux"}
    return
  }
  if sux != nil { _tmt1181 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1182 := MSK_putsux(self.ptr(),whichsol,_tmt1181); _tmt1182 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1182)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutSuxSlice(whichsol Soltype,first int32,last int32,sux []float64) (err error) {
  var _tmt1183 *float64
  if len(sux) < (last - first) {
    err = &ArrayLengthError{fun:"PutSuxSlice",arg:"sux"}
    return
  }
  if sux != nil { _tmt1183 = (*C.MSKint32t)(&sux[0]) }
  if _tmt1184 := MSK_putsuxslice(self.ptr(),whichsol,first,last,_tmt1183); _tmt1184 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1184)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutTaskName(taskname string) (err error) {
  _tmt1185 := C.CString(taskname)
  if _tmt1186 := MSK_puttaskname(self.ptr(),_tmt1185); _tmt1186 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1186)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBound(j int32,bkx Boundkey,blx float64,bux float64) (err error) {
  if _tmt1187 := MSK_putvarbound(self.ptr(),j,bkx,blx,bux); _tmt1187 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1187)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundList(sub []int32,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  _tmt1188 := len(bkx)
  if _tmt1188 < blx { _tmt1188 = lof["name"] }
  if _tmt1188 < bux { _tmt1188 = lof["name"] }
  if _tmt1188 < sub { _tmt1188 = lof["name"] }
  var num int32 = int32(_tmt1188)
  var _tmt1189 *int32
  if sub != nil { _tmt1189 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1190 *Boundkey
  if bkx != nil { _tmt1190 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt1191 *float64
  if blx != nil { _tmt1191 = (*C.MSKint32t)(&blx[0]) }
  var _tmt1192 *float64
  if bux != nil { _tmt1192 = (*C.MSKint32t)(&bux[0]) }
  if _tmt1193 := MSK_putvarboundlist(self.ptr(),num,_tmt1189,_tmt1190,_tmt1191,_tmt1192); _tmt1193 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1193)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundListConst(sub []int32,bkx Boundkey,blx float64,bux float64) (err error) {
  _tmt1194 := len(sub)
  var num int32 = int32(_tmt1194)
  var _tmt1195 *int32
  if sub != nil { _tmt1195 = (*C.MSKint32t)(&sub[0]) }
  if _tmt1196 := MSK_putvarboundlistconst(self.ptr(),num,_tmt1195,bkx,blx,bux); _tmt1196 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1196)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundSlice(first int32,last int32,bkx []Boundkey,blx []float64,bux []float64) (err error) {
  var _tmt1197 *Boundkey
  if len(bkx) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"bkx"}
    return
  }
  if bkx != nil { _tmt1197 = (*C.MSKint32t)(&bkx[0]) }
  var _tmt1198 *float64
  if len(blx) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"blx"}
    return
  }
  if blx != nil { _tmt1198 = (*C.MSKint32t)(&blx[0]) }
  var _tmt1199 *float64
  if len(bux) < (last - first) {
    err = &ArrayLengthError{fun:"PutVarBoundSlice",arg:"bux"}
    return
  }
  if bux != nil { _tmt1199 = (*C.MSKint32t)(&bux[0]) }
  if _tmt1200 := MSK_putvarboundslice(self.ptr(),first,last,_tmt1197,_tmt1198,_tmt1199); _tmt1200 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1200)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarBoundSliceConst(first int32,last int32,bkx Boundkey,blx float64,bux float64) (err error) {
  if _tmt1201 := MSK_putvarboundsliceconst(self.ptr(),first,last,bkx,blx,bux); _tmt1201 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1201)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarName(j int32,name string) (err error) {
  _tmt1202 := C.CString(name)
  if _tmt1203 := MSK_putvarname(self.ptr(),j,_tmt1202); _tmt1203 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1203)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarSolutionJ(j int32,whichsol Soltype,sk Stakey,x float64,sl float64,su float64,sn float64) (err error) {
  if _tmt1204 := MSK_putvarsolutionj(self.ptr(),j,whichsol,sk,x,sl,su,sn); _tmt1204 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1204)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarType(j int32,vartype Variabletype) (err error) {
  if _tmt1205 := MSK_putvartype(self.ptr(),j,vartype); _tmt1205 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1205)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutVarTypeList(subj []int32,vartype []Variabletype) (err error) {
  _tmt1206 := len(vartype)
  if _tmt1206 < subj { _tmt1206 = lof["name"] }
  var num int32 = int32(_tmt1206)
  var _tmt1207 *int32
  if subj != nil { _tmt1207 = (*C.MSKint32t)(&subj[0]) }
  var _tmt1208 *Variabletype
  if vartype != nil { _tmt1208 = (*C.MSKint32t)(&vartype[0]) }
  if _tmt1209 := MSK_putvartypelist(self.ptr(),num,_tmt1207,_tmt1208); _tmt1209 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1209)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXc(whichsol Soltype) (xc []float64,err error) {
  var _tmt1212 *float64
  var _tmt1210 int32
  if _tmt1211 := MSK_getnumcon(task.nativep,addr(_tmt1210)); _tmt1211 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1211)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  xc := make([]float64,_tmt1210)
  if len(xc) > 0 { _tmt1212 = (*float64)(&n[0]) }
  if _tmt1213 := MSK_putxc(self.ptr(),whichsol,_tmt1212); _tmt1213 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1213)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXcSlice(whichsol Soltype,first int32,last int32,xc []float64) (err error) {
  var _tmt1214 *float64
  if len(xc) < (last - first) {
    err = &ArrayLengthError{fun:"PutXcSlice",arg:"xc"}
    return
  }
  if xc != nil { _tmt1214 = (*C.MSKint32t)(&xc[0]) }
  if _tmt1215 := MSK_putxcslice(self.ptr(),whichsol,first,last,_tmt1214); _tmt1215 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1215)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXx(whichsol Soltype,xx []float64) (err error) {
  var _tmt1218 *float64
  var _tmt1216 int32
  if _tmt1217 := MSK_getnumvar(task.nativep,addr(_tmt1216)); _tmt1217 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1217)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(xx) < _tmt1216 {
    err = &ArrayLengthError{fun:"PutXx",arg:"xx"}
    return
  }
  if xx != nil { _tmt1218 = (*C.MSKint32t)(&xx[0]) }
  if _tmt1219 := MSK_putxx(self.ptr(),whichsol,_tmt1218); _tmt1219 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1219)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutXxSlice(whichsol Soltype,first int32,last int32,xx []float64) (err error) {
  var _tmt1220 *float64
  if len(xx) < (last - first) {
    err = &ArrayLengthError{fun:"PutXxSlice",arg:"xx"}
    return
  }
  if xx != nil { _tmt1220 = (*C.MSKint32t)(&xx[0]) }
  if _tmt1221 := MSK_putxxslice(self.ptr(),whichsol,first,last,_tmt1220); _tmt1221 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1221)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutY(whichsol Soltype,y []float64) (err error) {
  var _tmt1224 *float64
  var _tmt1222 int32
  if _tmt1223 := MSK_getnumcon(task.nativep,addr(_tmt1222)); _tmt1223 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1223)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(y) < _tmt1222 {
    err = &ArrayLengthError{fun:"PutY",arg:"y"}
    return
  }
  if y != nil { _tmt1224 = (*C.MSKint32t)(&y[0]) }
  if _tmt1225 := MSK_puty(self.ptr(),whichsol,_tmt1224); _tmt1225 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1225)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) PutYSlice(whichsol Soltype,first int32,last int32,y []float64) (err error) {
  var _tmt1226 *float64
  if len(y) < (last - first) {
    err = &ArrayLengthError{fun:"PutYSlice",arg:"y"}
    return
  }
  if y != nil { _tmt1226 = (*C.MSKint32t)(&y[0]) }
  if _tmt1227 := MSK_putyslice(self.ptr(),whichsol,first,last,_tmt1226); _tmt1227 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1227)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadBSolution(filename string,compress Compresstype) (err error) {
  _tmt1228 := C.CString(filename)
  if _tmt1229 := MSK_readbsolution(self.ptr(),_tmt1228,compress); _tmt1229 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1229)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadData(filename string) (err error) {
  _tmt1230 := C.CString(filename)
  if _tmt1231 := MSK_readdataautoformat(self.ptr(),_tmt1230); _tmt1231 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1231)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadDataFormat(filename string,format Dataformat,compress Compresstype) (err error) {
  _tmt1232 := C.CString(filename)
  if _tmt1233 := MSK_readdataformat(self.ptr(),_tmt1232,format,compress); _tmt1233 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1233)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadJsonSol(filename string) (err error) {
  _tmt1234 := C.CString(filename)
  if _tmt1235 := MSK_readjsonsol(self.ptr(),_tmt1234); _tmt1235 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1235)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadJsonString(data string) (err error) {
  _tmt1236 := C.CString(data)
  if _tmt1237 := MSK_readjsonstring(self.ptr(),_tmt1236); _tmt1237 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1237)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadLpString(data string) (err error) {
  _tmt1238 := C.CString(data)
  if _tmt1239 := MSK_readlpstring(self.ptr(),_tmt1238); _tmt1239 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1239)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadOpfString(data string) (err error) {
  _tmt1240 := C.CString(data)
  if _tmt1241 := MSK_readopfstring(self.ptr(),_tmt1240); _tmt1241 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1241)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadParamFile(filename string) (err error) {
  _tmt1242 := C.CString(filename)
  if _tmt1243 := MSK_readparamfile(self.ptr(),_tmt1242); _tmt1243 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1243)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadPtfString(data string) (err error) {
  _tmt1244 := C.CString(data)
  if _tmt1245 := MSK_readptfstring(self.ptr(),_tmt1244); _tmt1245 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1245)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSolution(whichsol Soltype,filename string) (err error) {
  _tmt1246 := C.CString(filename)
  if _tmt1247 := MSK_readsolution(self.ptr(),whichsol,_tmt1246); _tmt1247 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1247)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSolutionFile(filename string) (err error) {
  _tmt1248 := C.CString(filename)
  if _tmt1249 := MSK_readsolutionfile(self.ptr(),_tmt1248); _tmt1249 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1249)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadSummary(whichstream Streamtype) (err error) {
  if _tmt1250 := MSK_readsummary(self.ptr(),whichstream); _tmt1250 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1250)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ReadTask(filename string) (err error) {
  _tmt1251 := C.CString(filename)
  if _tmt1252 := MSK_readtask(self.ptr(),_tmt1251); _tmt1252 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1252)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveBarvars(subset []int32) (err error) {
  _tmt1253 := len(subset)
  var num int32 = int32(_tmt1253)
  var _tmt1254 *int32
  if subset != nil { _tmt1254 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1255 := MSK_removebarvars(self.ptr(),num,_tmt1254); _tmt1255 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1255)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveCones(subset []int32) (err error) {
  _tmt1256 := len(subset)
  var num int32 = int32(_tmt1256)
  var _tmt1257 *int32
  if subset != nil { _tmt1257 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1258 := MSK_removecones(self.ptr(),num,_tmt1257); _tmt1258 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1258)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveCons(subset []int32) (err error) {
  _tmt1259 := len(subset)
  var num int32 = int32(_tmt1259)
  var _tmt1260 *int32
  if subset != nil { _tmt1260 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1261 := MSK_removecons(self.ptr(),num,_tmt1260); _tmt1261 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1261)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) RemoveVars(subset []int32) (err error) {
  _tmt1262 := len(subset)
  var num int32 = int32(_tmt1262)
  var _tmt1263 *int32
  if subset != nil { _tmt1263 = (*C.MSKint32t)(&subset[0]) }
  if _tmt1264 := MSK_removevars(self.ptr(),num,_tmt1263); _tmt1264 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1264)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) ResizeTask(maxnumcon int32,maxnumvar int32,maxnumcone int32,maxnumanz int64,maxnumqnz int64) (err error) {
  if _tmt1265 := MSK_resizetask(self.ptr(),maxnumcon,maxnumvar,maxnumcone,maxnumanz,maxnumqnz); _tmt1265 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1265)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SensitivityReport(whichstream Streamtype) (err error) {
  if _tmt1266 := MSK_sensitivityreport(self.ptr(),whichstream); _tmt1266 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1266)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SetDefaults() (err error) {
  if _tmt1267 := MSK_setdefaults(self.ptr()); _tmt1267 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1267)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SolutionDef(whichsol Soltype) (isdef bool,err error) {
  if _tmt1268 := MSK_solutiondef(self.ptr(),whichsol,&isdef); _tmt1268 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1268)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SolutionSummary(whichstream Streamtype) (err error) {
  if _tmt1269 := MSK_solutionsummary(self.ptr(),whichstream); _tmt1269 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1269)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) SolveWithBasis(transp bool,numnz int32,sub []int32,val []float64) (numnzout int32,err error) {
  var _tmt1272 *int32
  var _tmt1270 int32
  if _tmt1271 := MSK_getnumcon(task.nativep,addr(_tmt1270)); _tmt1271 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1271)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(sub) < _tmt1270 {
    err = &ArrayLengthError{fun:"SolveWithBasis",arg:"sub"}
    return
  }
  if sub != nil { _tmt1272 = (*C.MSKint32t)(&sub[0]) }
  var _tmt1275 *float64
  var _tmt1273 int32
  if _tmt1274 := MSK_getnumcon(task.nativep,addr(_tmt1273)); _tmt1274 != 0 {
    lastcode,lastmsg = self.getlasterror(_tmt1274)
     err = MosekError{ code:lastcode,msg:lastmsg}
    return
  }
  if len(val) < _tmt1273 {
    err = &ArrayLengthError{fun:"SolveWithBasis",arg:"val"}
    return
  }
  if val != nil { _tmt1275 = (*C.MSKint32t)(&val[0]) }
  if _tmt1276 := MSK_solvewithbasis(self.ptr(),transp,numnz,_tmt1272,_tmt1275,&numnzout); _tmt1276 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1276)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) StrToConeType(str string) (conetype Conetype,err error) {
  _tmt1277 := C.CString(str)
  if _tmt1278 := MSK_strtoconetype(self.ptr(),_tmt1277,&conetype); _tmt1278 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1278)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) StrToSk(str string) (sk Stakey,err error) {
  _tmt1279 := C.CString(str)
  if _tmt1280 := MSK_strtosk(self.ptr(),_tmt1279,&sk); _tmt1280 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1280)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) Toconic() (err error) {
  if _tmt1281 := MSK_toconic(self.ptr()); _tmt1281 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1281)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) UpdateSolutionInfo(whichsol Soltype) (err error) {
  if _tmt1282 := MSK_updatesolutioninfo(self.ptr(),whichsol); _tmt1282 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1282)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteBSolution(filename string,compress Compresstype) (err error) {
  _tmt1283 := C.CString(filename)
  if _tmt1284 := MSK_writebsolution(self.ptr(),_tmt1283,compress); _tmt1284 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1284)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteData(filename string) (err error) {
  _tmt1285 := C.CString(filename)
  if _tmt1286 := MSK_writedata(self.ptr(),_tmt1285); _tmt1286 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1286)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteJsonSol(filename string) (err error) {
  _tmt1287 := C.CString(filename)
  if _tmt1288 := MSK_writejsonsol(self.ptr(),_tmt1287); _tmt1288 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1288)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteParamFile(filename string) (err error) {
  _tmt1289 := C.CString(filename)
  if _tmt1290 := MSK_writeparamfile(self.ptr(),_tmt1289); _tmt1290 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1290)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteSolution(whichsol Soltype,filename string) (err error) {
  _tmt1291 := C.CString(filename)
  if _tmt1292 := MSK_writesolution(self.ptr(),whichsol,_tmt1291); _tmt1292 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1292)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteSolutionFile(filename string) (err error) {
  _tmt1293 := C.CString(filename)
  if _tmt1294 := MSK_writesolutionfile(self.ptr(),_tmt1293); _tmt1294 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1294)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteStat(filename string) (err error) {
  _tmt1295 := C.CString(filename)
  if _tmt1296 := MSK_writestat(self.ptr(),_tmt1295); _tmt1296 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1296)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Task) WriteTask(filename string) (err error) {
  _tmt1297 := C.CString(filename)
  if _tmt1298 := MSK_writetask(self.ptr(),_tmt1297); _tmt1298 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1298)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Axpy(n int32,alpha float64,x []float64,y []float64) (err error) {
  var _tmt1299 *float64
  if len(x) < n {
    err = &ArrayLengthError{fun:"Axpy",arg:"x"}
    return
  }
  if x != nil { _tmt1299 = (*C.MSKint32t)(&x[0]) }
  var _tmt1300 *float64
  if len(y) < n {
    err = &ArrayLengthError{fun:"Axpy",arg:"y"}
    return
  }
  if y != nil { _tmt1300 = (*C.MSKint32t)(&y[0]) }
  if _tmt1301 := MSK_axpy(self.ptr(),n,alpha,_tmt1299,_tmt1300); _tmt1301 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1301)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckInAll() (err error) {
  if _tmt1302 := MSK_checkinall(self.ptr()); _tmt1302 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1302)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckInLicense(feature Feature) (err error) {
  if _tmt1303 := MSK_checkinlicense(self.ptr(),feature); _tmt1303 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1303)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) CheckOutLicense(feature Feature) (err error) {
  if _tmt1304 := MSK_checkoutlicense(self.ptr(),feature); _tmt1304 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1304)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Dot(n int32,x []float64,y []float64) (xty float64,err error) {
  var _tmt1310 *float64
  if len(x) < n {
    err = &ArrayLengthError{fun:"Dot",arg:"x"}
    return
  }
  if x != nil { _tmt1310 = (*C.MSKint32t)(&x[0]) }
  var _tmt1311 *float64
  if len(y) < n {
    err = &ArrayLengthError{fun:"Dot",arg:"y"}
    return
  }
  if y != nil { _tmt1311 = (*C.MSKint32t)(&y[0]) }
  if _tmt1312 := MSK_dot(self.ptr(),n,_tmt1310,_tmt1311,&xty); _tmt1312 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1312)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) EchoIntro(longver int32) (err error) {
  if _tmt1313 := MSK_echointro(self.ptr(),longver); _tmt1313 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1313)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Expirylicenses() (expiry int64,err error) {
  if _tmt1314 := MSK_expirylicenses(self.ptr(),&expiry); _tmt1314 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1314)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Gemm(transa Transpose,transb Transpose,m int32,n int32,k int32,alpha float64,a []float64,b []float64,beta float64,c []float64) (err error) {
  var _tmt1315 *float64
  if len(a) < (m * k) {
    err = &ArrayLengthError{fun:"Gemm",arg:"a"}
    return
  }
  if a != nil { _tmt1315 = (*C.MSKint32t)(&a[0]) }
  var _tmt1316 *float64
  if len(b) < (k * n) {
    err = &ArrayLengthError{fun:"Gemm",arg:"b"}
    return
  }
  if b != nil { _tmt1316 = (*C.MSKint32t)(&b[0]) }
  var _tmt1317 *float64
  if len(c) < (m * n) {
    err = &ArrayLengthError{fun:"Gemm",arg:"c"}
    return
  }
  if c != nil { _tmt1317 = (*C.MSKint32t)(&c[0]) }
  if _tmt1318 := MSK_gemm(self.ptr(),transa,transb,m,n,k,alpha,_tmt1315,_tmt1316,beta,_tmt1317); _tmt1318 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1318)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Gemv(transa Transpose,m int32,n int32,alpha float64,a []float64,x []float64,beta float64,y []float64) (err error) {
  var _tmt1319 *float64
  if len(a) < (n * m) {
    err = &ArrayLengthError{fun:"Gemv",arg:"a"}
    return
  }
  if a != nil { _tmt1319 = (*C.MSKint32t)(&a[0]) }
  var _tmt1321 *float64
  var _tmt1320 int32
  if (transa == transpose_no) {
    _tmt1320 = n
  } else {
    _tmt1320 = m
  }
  if len(x) < _tmt1320 {
    err = &ArrayLengthError{fun:"Gemv",arg:"x"}
    return
  }
  if x != nil { _tmt1321 = (*C.MSKint32t)(&x[0]) }
  var _tmt1323 *float64
  var _tmt1322 int32
  if (transa == transpose_no) {
    _tmt1322 = m
  } else {
    _tmt1322 = n
  }
  if len(y) < _tmt1322 {
    err = &ArrayLengthError{fun:"Gemv",arg:"y"}
    return
  }
  if y != nil { _tmt1323 = (*C.MSKint32t)(&y[0]) }
  if _tmt1324 := MSK_gemv(self.ptr(),transa,m,n,alpha,_tmt1319,_tmt1321,beta,_tmt1323); _tmt1324 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1324)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func GetBuildInfo() (buildstate string,builddate string,err error) {
  _tmt1325 := make([]byte,max_str_len)
  _tmt1326 := make([]byte,max_str_len)
  if _tmt1327 := MSK_getbuildinfo(C.CString(&tmpvar1[0]),C.CString(&tmpvar1[0])); _tmt1327 != 0 {
    err = &MosekError{ code:_tmt1327 }
    return
  }
  var buildstate string
  if p := strings.IndexByte(_tmt1325,byte(0)); p < 0 {
    buildstate = string(_tmt1325)
  } else {
    buildstate = string(_tmt1325[:p])
  }
  var builddate string
  if p := strings.IndexByte(_tmt1326,byte(0)); p < 0 {
    builddate = string(_tmt1326)
  } else {
    builddate = string(_tmt1326[:p])
  }
  return
}
func GetCodeDesc(code Rescode) (symname string,str string,err error) {
  _tmt1328 := make([]byte,max_str_len)
  _tmt1329 := make([]byte,max_str_len)
  if _tmt1330 := MSK_getcodedesc(code,C.CString(&tmpvar1[0]),C.CString(&tmpvar1[0])); _tmt1330 != 0 {
    err = &MosekError{ code:_tmt1330 }
    return
  }
  var symname string
  if p := strings.IndexByte(_tmt1328,byte(0)); p < 0 {
    symname = string(_tmt1328)
  } else {
    symname = string(_tmt1328[:p])
  }
  var str string
  if p := strings.IndexByte(_tmt1329,byte(0)); p < 0 {
    str = string(_tmt1329)
  } else {
    str = string(_tmt1329[:p])
  }
  return
}
func GetVersion() (major int32,minor int32,revision int32,err error) {
  if _tmt1331 := MSK_getversion(&major,&minor,&revision); _tmt1331 != 0 {
    err = &MosekError{ code:_tmt1331 }
    return
  }
  return
}
func LicenseCleanup() (err error) {
  if _tmt1332 := MSK_licensecleanup(); _tmt1332 != 0 {
    err = &MosekError{ code:_tmt1332 }
    return
  }
  return
}
func (self *Env) Linkfiletostream(whichstream Streamtype,filename string,append int32) (err error) {
  _tmt1333 := C.CString(filename)
  if _tmt1334 := MSK_linkfiletoenvstream(self.ptr(),whichstream,_tmt1333,append); _tmt1334 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1334)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Potrf(uplo Uplo,n int32,a []float64) (err error) {
  var _tmt1336 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Potrf",arg:"a"}
    return
  }
  if a != nil { _tmt1336 = (*C.MSKint32t)(&a[0]) }
  if _tmt1337 := MSK_potrf(self.ptr(),uplo,n,_tmt1336); _tmt1337 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1337)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseCode(code []int32) (err error) {
  var _tmt1338 *int32
  if len(code) < license_buffer_length {
    err = &ArrayLengthError{fun:"PutLicenseCode",arg:"code"}
    return
  }
  if code != nil { _tmt1338 = (*C.MSKint32t)(&code[0]) }
  if _tmt1339 := MSK_putlicensecode(self.ptr(),_tmt1338); _tmt1339 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1339)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseDebug(licdebug int32) (err error) {
  if _tmt1340 := MSK_putlicensedebug(self.ptr(),licdebug); _tmt1340 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1340)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicensePath(licensepath string) (err error) {
  _tmt1341 := C.CString(licensepath)
  if _tmt1342 := MSK_putlicensepath(self.ptr(),_tmt1341); _tmt1342 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1342)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) PutLicenseWait(licwait int32) (err error) {
  if _tmt1343 := MSK_putlicensewait(self.ptr(),licwait); _tmt1343 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1343)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) ResetExpiryLicenses() (err error) {
  if _tmt1344 := MSK_resetexpirylicenses(self.ptr()); _tmt1344 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1344)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) SparseTriangularSolveDense(transposed Transpose,lnzc []int32,lptrc []int64,lsubc []int32,lvalc []float64,b []float64) (err error) {
  _tmt1345 := len(lnzc)
  if _tmt1345 < b { _tmt1345 = lof["name"] }
  if _tmt1345 < lptrc { _tmt1345 = lof["name"] }
  var n int32 = int32(_tmt1345)
  var _tmt1346 *int32
  if len(lnzc) < n {
    err = &ArrayLengthError{fun:"SparseTriangularSolveDense",arg:"lnzc"}
    return
  }
  if lnzc != nil { _tmt1346 = (*C.MSKint32t)(&lnzc[0]) }
  var _tmt1347 *int64
  if len(lptrc) < n {
    err = &ArrayLengthError{fun:"SparseTriangularSolveDense",arg:"lptrc"}
    return
  }
  if lptrc != nil { _tmt1347 = (*C.MSKint32t)(&lptrc[0]) }
  _tmt1348 := len(lsubc)
  if _tmt1348 < lvalc { _tmt1348 = lof["name"] }
  var lensubnval int64 = int32(_tmt1348)
  var _tmt1349 *int32
  if len(lsubc) < lensubnval {
    err = &ArrayLengthError{fun:"SparseTriangularSolveDense",arg:"lsubc"}
    return
  }
  if lsubc != nil { _tmt1349 = (*C.MSKint32t)(&lsubc[0]) }
  var _tmt1350 *float64
  if len(lvalc) < lensubnval {
    err = &ArrayLengthError{fun:"SparseTriangularSolveDense",arg:"lvalc"}
    return
  }
  if lvalc != nil { _tmt1350 = (*C.MSKint32t)(&lvalc[0]) }
  var _tmt1351 *float64
  if len(b) < n {
    err = &ArrayLengthError{fun:"SparseTriangularSolveDense",arg:"b"}
    return
  }
  if b != nil { _tmt1351 = (*C.MSKint32t)(&b[0]) }
  if _tmt1352 := MSK_sparsetriangularsolvedense(self.ptr(),transposed,n,_tmt1346,_tmt1347,lensubnval,_tmt1349,_tmt1350,_tmt1351); _tmt1352 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1352)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syeig(uplo Uplo,n int32,a []float64) (w []float64,err error) {
  var _tmt1353 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Syeig",arg:"a"}
    return
  }
  if a != nil { _tmt1353 = (*C.MSKint32t)(&a[0]) }
  var _tmt1354 *float64
  w := make([]float64,n)
  if len(w) > 0 { _tmt1354 = (*float64)(&n[0]) }
  if _tmt1355 := MSK_syeig(self.ptr(),uplo,n,_tmt1353,_tmt1354); _tmt1355 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1355)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syevd(uplo Uplo,n int32,a []float64) (w []float64,err error) {
  var _tmt1356 *float64
  if len(a) < (n * n) {
    err = &ArrayLengthError{fun:"Syevd",arg:"a"}
    return
  }
  if a != nil { _tmt1356 = (*C.MSKint32t)(&a[0]) }
  var _tmt1357 *float64
  w := make([]float64,n)
  if len(w) > 0 { _tmt1357 = (*float64)(&n[0]) }
  if _tmt1358 := MSK_syevd(self.ptr(),uplo,n,_tmt1356,_tmt1357); _tmt1358 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1358)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}
func (self *Env) Syrk(uplo Uplo,trans Transpose,n int32,k int32,alpha float64,a []float64,beta float64,c []float64) (err error) {
  var _tmt1359 *float64
  if len(a) < (n * k) {
    err = &ArrayLengthError{fun:"Syrk",arg:"a"}
    return
  }
  if a != nil { _tmt1359 = (*C.MSKint32t)(&a[0]) }
  var _tmt1360 *float64
  if len(c) < (n * n) {
    err = &ArrayLengthError{fun:"Syrk",arg:"c"}
    return
  }
  if c != nil { _tmt1360 = (*C.MSKint32t)(&c[0]) }
  if _tmt1361 := MSK_syrk(self.ptr(),uplo,trans,n,k,alpha,_tmt1359,beta,_tmt1360); _tmt1361 != 0 {
    lastcode,lastmsg := self.getlasterror(_tmt1361)
    err = &MosekError{code:lastcode,msg:lastmsg}
    return
  }
  return
}


