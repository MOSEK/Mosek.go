{"groups": {"method": [{"name": "task-nonlinear", "brief": "Data associated with nonlinear optimization.", "desc": "Data associated with nonlinear optimization.", "index-title": "Problem data - nonlinear"}, {"name": "task-variable", "brief": "Data associated with scalar variables.", "desc": "Data associated with scalar variables.", "index-title": "Problem data - variables"}, {"name": "task-linear", "brief": "Data associated with linear variables and constraints.", "desc": "Data associated with linear variables and constraints.", "index-title": "Problem data - linear part"}, {"name": "task-conic", "brief": "Data associated with cones (deprecated).", "desc": "Data associated with cones (deprecated).", "index-title": "Problem data - cones (deprecated)"}, {"name": "task-domain", "brief": "Data associated with domains.", "desc": "Data associated with domains.", "index-title": "Problem data - domain"}, {"name": "task-afe", "brief": "Data associated with affine expressions.", "desc": "Data associated with affine expressions.", "index-title": "Problem data - affine expressions"}, {"name": "task-acc", "brief": "Data associated with affine conic constraints.", "desc": "Data associated with affine conic constraints.", "index-title": "Problem data - affine conic constraints"}, {"name": "task-djc", "brief": "Data associated with disjunctive constraints.", "desc": "Data associated with disjunctive constraints.", "index-title": "Problem data - disjunctive constraints"}, {"name": "task-quadratic", "brief": "Data associated with quadratic objective and constraints.", "desc": "Data associated with quadratic objective and constraints.", "index-title": "Problem data - quadratic part"}, {"name": "task-bound", "brief": "Data associated with bounds.", "desc": "Data associated with bounds.", "index-title": "Problem data - bounds"}, {"name": "task-constraint", "brief": "Data associated with constraints.", "desc": "Data associated with constraints.", "index-title": "Problem data - constraints"}, {"name": "task-objective", "brief": "Data associated with objective.", "desc": "Data associated with objective.", "index-title": "Problem data - objective"}, {"name": "task-barvars", "brief": "Data associated with symmetric matrices and semidefinite optimization.", "desc": "Data associated with symmetric matrices and semidefinite optimization.", "index-title": "Problem data - semidefinite"}, {"name": "logging", "brief": "Functions related to logging.", "desc": "Functions related to logging.", "index-title": "Logging"}, {"name": "parameters", "brief": "Setting optimizer parameters.", "desc": "Setting optimizer parameters.", "index-title": "Parameters"}, {"name": "information-items", "brief": "Retrieving information items from the solver.", "desc": "Retrieving information items from the solver.", "index-title": "Information items and statistics"}, {"name": "naming", "brief": "Functions related to names.", "desc": "Functions related to names.", "index-title": "Names"}, {"name": "version", "brief": "Retrieving information about MOSEK version.", "desc": "Retrieving information about MOSEK version.", "index-title": "Versions"}, {"name": "callback", "brief": "Setting up callback functions.", "desc": "Setting up callback functions.", "index-title": "Callback"}, {"name": "input-output", "brief": "Input/output mechanisms.", "desc": "Input/output mechanisms.", "index-title": "Input/Output"}, {"name": "system", "brief": "System calls and memory allocation.", "desc": "System calls and memory allocation.", "index-title": "System, memory and debugging"}, {"name": "license", "brief": "Functions for interacting with the license system.", "desc": "Functions for interacting with the license system.", "index-title": "License system"}, {"name": "basis-matrix", "brief": "Solving linear systems with the basis matrix.", "desc": "Solving linear systems with the basis matrix.", "index-title": "Solving systems with basis matrix"}, {"name": "task-inspect", "brief": "Functions for inspecting the data of the problem.", "desc": "Functions for inspecting the data of the problem.", "index-title": "Inspecting the task"}, {"name": "management", "brief": "Functions for handling task objects.", "desc": "Functions for handling task objects.", "index-title": "Environment and task management"}, {"name": "linear-algebra", "brief": "Linear algebra routines.", "desc": "Linear algebra routines.", "index-title": "Linear algebra"}, {"name": "infeasibility-diagnostic", "brief": "Functions for performing infeasibility diagnostic.", "desc": "Functions for performing infeasibility diagnostic.", "index-title": "Infeasibility diagnostic"}, {"name": "sensitivity-analysis", "brief": "Functions for performing sensitivity analysis.", "desc": "Functions for performing sensitivity analysis.", "index-title": "Sensitivity analysis"}, {"name": "solution-primal", "brief": "Accessing primal solution values.", "desc": "Accessing primal solution values.", "index-title": "Solution - primal"}, {"name": "solution-dual", "brief": "Accessing dual solution values.", "desc": "Accessing dual solution values.", "index-title": "Solution - dual"}, {"name": "solution-barvar", "brief": "Accessing solution values for symmetric matrix variables.", "desc": "Accessing solution values for symmetric matrix variables.", "index-title": "Solution - semidefinite"}, {"name": "solution-information", "brief": "Accessing information about the solution.", "desc": "Accessing information about the solution.", "index-title": "Solution information"}, {"name": "remote", "brief": "Remote optimization using the OptServer.", "desc": "Remote optimization using the OptServer.", "index-title": "Remote optimization"}, {"name": "optimize", "brief": "Optimization.", "desc": "Optimization.", "index-title": "Optimization"}, {"name": "errors", "brief": "Response codes, errors and warnings.", "desc": "Response codes, errors and warnings.", "index-title": "Responses, errors and warnings"}], "param": [{"name": "log-param", "brief": "Logging parameters.", "desc": "Logging parameters.", "index-title": "Logging"}, {"name": "bi-param", "brief": "Basis identification parameters.", "desc": "Basis identification parameters.", "index-title": "Basis identification"}, {"name": "intpnt-param", "brief": "Interior-point method parameters.", "desc": "Parameters defining the behavior of the interior-point\nmethod for linear, conic and quadratic problems.", "index-title": "Interior-point method"}, {"name": "simplex-param", "brief": "Simplex optimizer parameters.", "desc": "Parameters defining the behavior of the simplex optimizer\nfor linear problems.", "index-title": "Simplex optimizer"}, {"name": "psimplex-param", "brief": "Primal simplex optimizer parameters.", "desc": "Parameters defining the behavior of the primal simplex\noptimizer for linear problems.", "index-title": "Primal simplex"}, {"name": "dsimplex-param", "brief": "Dual simplex optimizer parameters.", "desc": "Parameters defining the behavior of the dual simplex\noptimizer for linear problems.", "index-title": "Dual simplex"}, {"name": "conic-param", "brief": "Conic interior-point method parameters.", "desc": "Parameters defining the behavior of the interior-point\nmethod for conic problems.", "index-title": "Conic interior-point method"}, {"name": "mio-param", "brief": "Mixed-integer optimization parameters.", "desc": "Mixed-integer optimization parameters.", "index-title": "Mixed-integer optimization"}, {"name": "presolve-param", "brief": "Presolve parameters.", "desc": "Presolve parameters.", "index-title": "Presolve"}, {"name": "termination-param", "brief": "Termination parameters.", "desc": "Termination parameters.", "index-title": "Termination criteria"}, {"name": "callback-param", "brief": "Progress callback parameters.", "desc": "Progress callback parameters.", "index-title": "Progress callback"}, {"name": "feasrepair-param", "brief": "Feasibility repair parameters.", "desc": "Feasibility repair parameters.", "index-title": "Feasibility repair"}, {"name": "system-param", "brief": "Overall system parameters.", "desc": "Parameters defining the overall solver system.\nThis includes system and platform related information and behavior.", "index-title": "Overall system"}, {"name": "info-param", "brief": "Output information parameters.", "desc": "Output information parameters.", "index-title": "Output information"}, {"name": "solver-param", "brief": "Overall solver parameters.", "desc": "Overall solver parameters.", "index-title": "Overall solver"}, {"name": "dataio-param", "brief": "Data input/output parameters.", "desc": "Parameters defining the behavior of data readers and\nwriters.", "index-title": "Data input/output"}, {"name": "ana-param", "brief": "Analysis parameters.", "desc": "Parameters controlling the behavior of the problem and solution analyzers.", "index-title": "Analysis"}, {"name": "solio-param", "brief": "Solution input/output parameters.", "desc": "Parameters defining the behavior of solution reader and\nwriter.", "index-title": "Solution input/output"}, {"name": "infeas-param", "brief": "Infeasibility report parameters.", "desc": "Infeasibility report parameters.", "index-title": "Infeasibility report"}, {"name": "lic-param", "brief": "License manager parameters.", "desc": "License manager parameters.", "index-title": "License manager"}, {"name": "datacheck-param", "brief": "Data check parameters.", "desc": "These parameters defines data checking settings and problem\ndata tolerances, i.e. which values are rounded to 0 or\ninfinity, and which values are large or small enough to\nproduce a warning.", "index-title": "Data check"}, {"name": "debug-param", "brief": "Debugging parameters.", "desc": "These parameters defines that can be used when debugging a problem.", "index-title": "Debugging"}], "dflt": [{"name": "utils", "brief": "Utility type definitions.", "desc": "Utility type definitions.", "index-title": null}, {"name": "callback-typedef", "brief": "Progress callback function type definitions.", "desc": "Progress callback function type definitions.", "index-title": null}, {"name": "exit-typedef", "brief": "Exit callback function type definitions.", "desc": "Exit callback function type definitions.", "index-title": null}, {"name": "stream-typedef", "brief": "Stream printer function type definitions.", "desc": "Stream printer function type definitions.", "index-title": null}, {"name": "simple-typedef", "brief": "Simple type definitions.", "desc": "Simple type definitions.", "index-title": null}]}, "default-doc": {"ret": {"brief": "The function response code.", "desc": "The function response code."}, "usrptr": {"brief": "A pointer to a user-defined structure.", "desc": "A pointer to a user-defined structure."}, "y": {"brief": "Vector of dual variables corresponding to the constraints.", "desc": "Vector of dual variables corresponding to the constraints."}, "asub": {"brief": "Coefficient subscripts.", "desc": "Coefficient subscripts. See Section :ref:`doc.optimizer.cmo_rmo_matrix`."}, "maxnumcon": {"brief": "Number of preallocated constraints in the optimization task.", "desc": "Number of preallocated constraints in the optimization task."}, "task": {"brief": "An optimization task.", "desc": "An optimization task."}, "whichiinf": {"brief": "Specifies an integer information item.", "desc": "Specifies an integer information item."}, "whichliinf": {"brief": "Specifies a long information item.", "desc": "Specifies a long information item."}, "whichdinf": {"brief": "Specifies a double information item.", "desc": "Specifies a double information item."}, "snx": {"brief": "Dual variables corresponding to the conic constraints on the variables.", "desc": "Dual variables corresponding to the conic constraints on the variables (:math:`s_n^x`\\ )."}, "doty": {"brief": "Dual variables corresponding to affine conic constraints.", "desc": "Dual variables corresponding to affine conic constraints (:math:`\\dot{y}`\\ )."}, "bkx": {"brief": "Bound keys for the variables.", "desc": "Bound keys for the variables."}, "bkc": {"brief": "Bound keys for the constraints.", "desc": "Bound keys for the constraints."}, "prosta": {"brief": "Problem status.", "desc": "Problem status."}, "problemsta": {"brief": "Problem status.", "desc": "Problem status."}, "env": {"brief": "The MOSEK environment.", "desc": "The |mosek| environment."}, "partype": {"brief": "Parameter type.", "desc": "Parameter type."}, "maxpeqi": {"brief": "Maximum infeasibility in the primal equality constraints.", "desc": "Maximum infeasibility in the primal equality constraints."}, "solitem": {"brief": "Which part of the solution is required.", "desc": "Which part of the solution is required."}, "solsta": {"brief": "Solution status.", "desc": "Solution status."}, "solutionsta": {"brief": "Solution status.", "desc": "Solution status."}, "file": {"brief": "A handle to an open file.", "desc": "A handle to an open file."}, "objname": {"brief": "Name of the objective.", "desc": "Name of the objective."}, "whichinf": {"brief": "An information item.", "desc": "An information item."}, "numqcnz": {"brief": "Number of quadratic terms.", "desc": "Number of quadratic terms."}, "slc": {"brief": "Dual variables corresponding to the lower bounds on the constraints.", "desc": "Dual variables corresponding to the lower bounds on the constraints (:math:`s_l^c`\\ )."}, "r": {"brief": "A response code indicating the result of function call.", "desc": "A response code indicating the result of function call."}, "parvalue": {"brief": "Parameter value.", "desc": "Parameter value."}, "slx": {"brief": "Dual variables corresponding to the lower bounds on the variables.", "desc": "Dual variables corresponding to the lower bounds on the variables (:math:`s_l^x`)."}, "buc": {"brief": "Upper bounds for the constraints.", "desc": "Upper bounds for the constraints."}, "bux": {"brief": "Upper bounds for the variables.", "desc": "Upper bounds for the variables."}, "basic": {"brief": "If this is non-zero the basic solution is used. Otherwise the interior-point solution is used.", "desc": "If this is non-zero the basic solution is used. Otherwise the interior-point solution is used."}, "maxnumvar": {"brief": "Number of preallocated variables in the optimization task.", "desc": "Number of preallocated variables in the optimization task."}, "maxnumcone": {"brief": "Number of preallocated conic constraints in the optimization task.", "desc": "Number of preallocated conic constraints in the optimization task."}, "whichstream": {"brief": "Index of the stream.", "desc": "Index of the stream."}, "aptre": {"brief": "Row or column end pointers.", "desc": "Pointers to the last element plus 1 in the rows or the columns of :math:`A`."}, "aptrb": {"brief": "Row or column start pointers.", "desc": "Pointer to the first element in the rows or the columns of :math:`A`."}, "whichsol": {"brief": "Selects a solution.", "desc": "Selects a solution."}, "xx": {"brief": "Primal variable solution.", "desc": "Primal variable solution (:math:`x`)."}, "maxinti": {"brief": "Maximum infeasibility in integer constraints.", "desc": "Maximum infeasibility in integer constraints."}, "ivalue": {"brief": "The value of the required information item.", "desc": "The value of the required information item."}, "xc": {"brief": "Primal constraint solution.", "desc": "Primal constraint solution."}, "firstj": {"brief": "Index of the first variable for which information should be obtained.", "desc": "Index of the first variable for which information should be obtained."}, "first": {"brief": "First index in the sequence.", "desc": "First index in the sequence."}, "maxdcni": {"brief": "Maximum infeasibility in the dual conic constraints.", "desc": "Maximum infeasibility in the dual conic constraints."}, "cfix": {"brief": "Fixed term in the objective.", "desc": "Fixed term in the objective."}, "numcon": {"brief": "Number of constraints.", "desc": "Number of constraints."}, "varname": {"brief": "Name of the variable.", "desc": "Name of the variable."}, "slvinf": {"brief": "Contains information about the last optimization etc.", "desc": "Contains information about the last optimization etc."}, "last": {"brief": "Last index plus 1 in the sequence.", "desc": "Last index plus 1 in the sequence."}, "c": {"brief": "Linear terms of the objective as a dense vector. The length is the number of variables.", "desc": "Linear terms of the objective as a dense vector. The length is the number of variables."}, "bk": {"brief": "Bound keys.", "desc": "Bound keys."}, "maxpbi": {"brief": "Maximum primal bound infeasibility.", "desc": "Maximum primal bound infeasibility."}, "dualobj": {"brief": "Objective value corresponding to the dual solution.", "desc": "Objective value corresponding to the dual solution."}, "bu": {"brief": "Values for upper bounds.", "desc": "Values for upper bounds."}, "lastj": {"brief": "Index of the last variable on which information is requested.", "desc": "Index of the last variable on which information is requested."}, "bl": {"brief": "Values for lower bounds.", "desc": "Values for lower bounds."}, "sux": {"brief": "Dual variables corresponding to the upper bounds on the variables.", "desc": "Dual variables corresponding to the upper bounds on the variables (appears as :math:`s_u^x`)."}, "blc": {"brief": "Lower bounds for the constraints.", "desc": "Lower bounds for the constraints."}, "parname": {"brief": "Parameter name.", "desc": "Parameter name."}, "filename": {"brief": "A valid file name.", "desc": "A valid file name."}, "numvar": {"brief": "Number of variables.", "desc": "Number of variables."}, "numanz": {"brief": "Number of non-zero elements in the linear constraint matrix.", "desc": "Number of non-zero elements in :math:`A`."}, "blx": {"brief": "Lower bounds for the variables.", "desc": "Lower bounds for the variables."}, "suc": {"brief": "Dual variables corresponding to the upper bounds on the constraints.", "desc": "Dual variables corresponding to the upper bounds on the constraints (:math:`s_u^c`)."}, "maxdeqi": {"brief": "Maximum infeasibility in the dual equality constraints.", "desc": "Maximum infeasibility in the dual equality constraints."}, "taskname": {"brief": "Name assigned to the task.", "desc": "Name assigned to the task."}, "paramname": {"brief": "Name of a parameter.", "desc": "Name of a parameter."}, "maxpcni": {"brief": "Maximum infeasibility in the primal conic constraints.", "desc": "Maximum infeasibility in the primal conic constraints."}, "qcsubk": {"brief": "Constraint subscripts for quadratic coefficients.", "desc": "``k`` subscripts for :math:`q_{ij}^k`."}, "qcsubj": {"brief": "Column subscripts for quadratic constraint matrix.", "desc": "``j`` subscripts for :math:`q_{ij}^k`."}, "qcsubi": {"brief": "Row subscripts for quadratic constraint matrix.", "desc": "``i`` subscripts for :math:`q_{ij}^k`."}, "whichitem": {"brief": "Problem item, i.e. a cone, a variable or a constraint name.", "desc": "Problem item, i.e. a cone, a variable or a constraint name."}, "probtype": {"brief": "Problem type.", "desc": "Problem type."}, "infname": {"brief": "Name of the information item.", "desc": "Name of the information item."}, "qosubj": {"brief": "Column subscripts for quadratic objective coefficients.", "desc": ":math:`j` subscript for :math:`q_{ij}^o`."}, "qosubi": {"brief": "Row subscripts for quadratic objective coefficients.", "desc": ":math:`i` subscript for :math:`q_{ij}^o`."}, "maxnumanz": {"brief": "Number of preallocated non-zero linear matrix elements.", "desc": "Number of preallocated non-zero elements in :math:`A`."}, "inftype": {"brief": "Type of the information item.", "desc": "Type of the information item."}, "maxnumqnz": {"brief": "Number of non-zero elements preallocated in quadratic coefficient matrices.", "desc": "Number of non-zero elements preallocated in quadratic coefficient matrices."}, "primalobj": {"brief": "Objective value corresponding to the primal solution.", "desc": "Objective value corresponding to the primal solution."}, "skn": {"brief": "Status keys for the conic constraints.", "desc": "Status keys for the conic constraints."}, "skc": {"brief": "Status keys for the constraints.", "desc": "Status keys for the constraints."}, "aval": {"brief": "Coefficient values.", "desc": "Coefficient values."}, "param": {"brief": "Which parameter.", "desc": "Which parameter."}, "skx": {"brief": "Status keys for the variables.", "desc": "Status keys for the variables."}, "qoval": {"brief": "Quadratic objective coefficient values.", "desc": "Numerical value for :math:`q_{ij}^o`."}, "qcval": {"brief": "Quadratic constraint coefficient values.", "desc": "Numerical value for :math:`q_{ij}^k`."}, "conname": {"brief": "Name of the constraint.", "desc": "Name of the constraint."}, "maxdbi": {"brief": "Maximum dual bound infeasibility.", "desc": "Maximum dual bound infeasibility."}, "numqonz": {"brief": "Number of non-zero elements in the quadratic objective terms.", "desc": "Number of non-zero elements in :math:`Q^o`."}, "conepar": {"brief": "For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0.", "desc": "For the power cone it denotes the exponent alpha. For other cone types it is unused and can be set to 0."}, "nummem": {"brief": "Number of member variables in the cone.", "desc": "Number of member variables in the cone."}, "submem": {"brief": "Variable subscripts of the members in the cone.", "desc": "Variable subscripts of the members in the cone."}, "conetype": {"brief": "Specifies the type of the cone.", "desc": "Specifies the type of the cone."}, "ct": {"brief": "Specifies the type of the cone.", "desc": "Specifies the type of the cone."}, "data": {"brief": "Problem data in text format.", "desc": "Problem data in text format."}, "barvaridx": {"brief": "Semidefinite variable index.", "desc": "Semidefinite variable index."}, "afeidx": {"brief": "Affine expression index.", "desc": "Affine expression index (row number in the affine expression store :math:`F`)."}, "compress": {"brief": "Data compression type.", "desc": "Data compression type."}, "format": {"brief": "File data dormat.", "desc": "File data dormat."}}, "namespaces": {"mosek": {"name": "mosek", "prefix": "MSK", "typedefs": {"env_t": {"name": "env_t", "brief": "The MOSEK Environment type.", "desc": "The |mosek| Environment type.", "type": ["ptr", ["ctype", "MSKenv"]], "references": [], "member-of": []}, "task_t": {"name": "task_t", "brief": "The MOSEK Task type.", "desc": "The |mosek| Task type.", "type": ["ptr", ["ctype", "MSKtask"]], "references": [], "member-of": []}, "userhandle_t": {"name": "userhandle_t", "brief": "A pointer to a user-defined structure.", "type": ["ptr", ["ctype", "void"]], "references": [], "member-of": []}, "booleant": {"name": "booleant", "brief": "A signed integer interpreted as a boolean value.", "type": ["ctype", "int"], "references": [], "member-of": ["simple-typedef"]}, "int32t": {"name": "int32t", "brief": "Signed 32bit integer.", "type": ["ctype", "int32_t"], "references": [], "member-of": ["simple-typedef"]}, "int64t": {"name": "int64t", "brief": "Signed 64bit integer.", "type": ["ctype", "int64_t"], "references": [], "member-of": ["simple-typedef"]}, "wchart": {"name": "wchart", "brief": "Wide char type.", "desc": "Wide char type. The actual type may differ depending on the platform; it is either a 16 or 32 bits signed or unsigned integer.", "type": ["ctype", "wchar_t"], "references": [], "member-of": ["simple-typedef"]}, "realt": {"name": "realt", "brief": "The floating point type used by MOSEK.", "desc": "The floating point type used by |mosek|.", "type": ["ctype", "double"], "references": [], "member-of": ["simple-typedef"]}, "string_t": {"name": "string_t", "brief": "The string type used by MOSEK.", "desc": "The string type used by |mosek|. This is an UTF-8 encoded zero-terminated char string.", "type": ["ptr", ["ctype", "char"]], "references": [], "member-of": ["simple-typedef"]}, "callbackfunc": {"name": "callbackfunc", "brief": "Definition of the progress callback function.", "desc": "The progress callback function is a user-defined function which will be called by |mosek| occasionally during the optimization process.  In particular, the callback function is called at the beginning of each iteration in the interior-point optimizer. For the simplex optimizers :msk:iparam:`log_sim_freq` controls how frequently the callback is called. The callback provides an code denoting the point in the solver from which the call happened, and a set of arrays containing information items related to the current state of the solver.  Typically the user-defined callback function displays information about the solution process. The callback function can also be used to terminate the optimization process by returning a non-zero value.\n\nThe user *must not* call any |mosek| function directly or indirectly from the callback function. The only exception is the possibility to retrieve a current best integer solution from the mixed-integer optimizer, see Section :ref:`doc.callback`.", "type": ["func", {"status": "api", "returns": {"type": ["defined", "mosek", "int32t"], "name": null, "brief": "Return a non-zero value to indicate that an error occurred.", "desc": "If the return value is non-zero, |mosek| terminates whatever it is doing and returns control to the calling application."}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true}, {"name": "usrptr", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true, "classarg": true}, {"name": "caller", "brief": "The caller key indicating the current progress of the solver.", "mode": "i", "type": ["const-class", "mosek", "callbackcode"], "null?": false, "api?": true}, {"name": "douinf", "brief": "An array of doubles corresponding to the task information items.", "desc": "An array of double information items. The elements correspond to the definitions in :msk:const:`dinfitem`\\ .", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "intinf", "brief": "An array of integers corresponding to the task information items.", "desc": "An array of integer information items. The elements correspond to the definitions in :msk:const:`iinfitem`\\ .", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "lintinf", "brief": "An array of longs corresponding to the task information items.", "desc": "An array of long information items. The elements correspond to the definitions in :msk:const:`liinfitem`\\ .", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}]}], "references": [], "member-of": ["callback-typedef"]}, "exitfunc": {"name": "exitfunc", "brief": "A user-defined exit function which is called if a fatal error occurs.", "desc": "A user-defined exit function which is called in case\nof fatal errors to handle an error message and\nterminate the program. The function should never return.", "type": ["func", {"status": "api", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "usrptr", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": true, "api?": true, "classarg": true}, {"name": "file", "brief": "The name of the file where the fatal error occurred.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "The line number in the file where the fatal error occurred.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "msg", "brief": "A message about the error.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}]}], "references": [], "member-of": ["exit-typedef"]}, "streamfunc": {"name": "streamfunc", "brief": "Message-stream callback function type.", "desc": "The message-stream callback function is a user-defined function which can be linked to any\nof the |mosek| streams. Doing so, the function is called whenever |mosek| sends a message\nto the stream.\n\nThe user *must not* call any |mosek| function\ndirectly or indirectly from the callback function.", "type": ["func", {"status": "api", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "handle", "brief": "A pointer to a user-defined data structure (or a null pointer).", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": true, "api?": true, "classarg": true}, {"name": "str", "brief": "A string containing a message to a stream.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}]}], "references": [], "member-of": ["stream-typedef"]}, "responsefunc": {"name": "responsefunc", "brief": "A user-defined function which handles exceptions.", "desc": "Whenever |mosek| generates a warning or an error this function is called.  The\nargument ``r`` contains the code of the error/warning and the argument ``msg``\ncontains the corresponding error/warning message. This function should always\nreturn :msk:res:`ok`.", "type": ["func", {"status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "handle", "brief": "A pointer to a user-defined data structure (or a null pointer).", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": true, "api?": true, "classarg": true}, {"name": "r", "brief": "The response code corresponding to the exception.", "mode": "i", "type": ["const-class", "mosek", "rescode"], "null?": false, "api?": true}, {"name": "msg", "brief": "A string containing the exception message.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}]}], "references": [], "member-of": ["utils"]}, "hreadfunc": {"name": "hreadfunc", "brief": "A user-defined function which reads from a handle.", "desc": "Behaves similarly to system read function. Returns the number of bytes read.", "type": ["func", {"status": "api", "returns": {"type": ["ctype", "size_t"], "name": "ret"}, "args": [{"name": "handle", "brief": "A pointer to a user-defined data structure (or a null pointer).", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": true, "api?": true, "classarg": true}, {"name": "dest", "brief": "Read into this destination", "mode": "o", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true}, {"name": "count", "brief": "Number of bytes to read.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}]}], "references": [], "member-of": ["utils"]}, "hwritefunc": {"name": "hwritefunc", "brief": "A user-defined function which writes to a handle.", "desc": "Behaves similarly to system write function. Returns the number of bytes written.", "type": ["func", {"status": "api", "returns": {"type": ["ctype", "size_t"], "name": "ret"}, "args": [{"name": "handle", "brief": "A pointer to a user-defined data structure (or a null pointer).", "mode": "io", "type": ["defined", "mosek", "userhandle_t"], "null?": true, "api?": true, "classarg": true}, {"name": "src", "brief": "Write from this location", "mode": "i", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true}, {"name": "count", "brief": "Number of bytes to write.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}]}], "references": [], "member-of": ["utils"]}}, "classes": {"task": {"name": "task", "prefix": "_", "functions": {"analyzeproblem": {"caml-name": "analyze-problem", "name": "analyzeproblem", "brief": "Analyze the data of a task.", "desc": "The function analyzes the data of a task and writes out a report.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "analyze-problem", "api-name": "analyzeproblem", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect"], "locked": true, "breakable": false, "log": true, "const": "const"}, "analyzenames": {"caml-name": "analyze-names", "name": "analyzenames", "brief": "Analyze the names and issue an error for the first invalid name.", "desc": "The function analyzes the names and issues an error if a name is invalid.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "nametype", "brief": "The type of names e.g. valid in MPS or LP files.", "mode": "i", "type": ["const-class", "mosek", "nametype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "analyze-names", "api-name": "analyzenames", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "analyzesolution": {"caml-name": "analyze-solution", "name": "analyzesolution", "brief": "Print information related to the quality of the solution.", "desc": "Print information related to the quality of the solution and\nother solution statistics.\n\nBy default this function prints information about the\nlargest infeasibilites in the solution, the primal (and\npossibly dual) objective value and the solution status.\n\nFollowing parameters can be used to configure the printed statistics:\n\n* :msk:iparam:`ana_sol_basis` enables or disables printing of statistics specific to the basis solution (condition number, number of basic variables etc.). Default is on.\n* :msk:iparam:`ana_sol_print_violated` enables or disables listing names of all constraints (both primal and dual) which are violated by the solution. Default is off.\n* :msk:dparam:`ana_sol_infeas_tol` is the tolerance defining when a constraint is considered violated. If a constraint is violated more than this, it will be listed in the summary.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "analyze-solution", "api-name": "analyzesolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getpviolcon"]}, {"type": "function", "item": ["mosek", "task", "getpviolvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolcones"]}, {"type": "function", "item": ["mosek", "task", "getdviolcon"]}, {"type": "function", "item": ["mosek", "task", "getdviolvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolcones"]}, {"type": "constant", "item": ["mosek", "iparam", "ana_sol_basis"]}], "member-of": ["solution-information", "task-inspect"], "locked": true, "breakable": false, "log": true, "const": "const"}, "initbasissolve": {"caml-name": "init-basis-solve", "name": "initbasissolve", "brief": "Prepare a task for basis solver.", "desc": "Prepare a task for use with the :msk:func:`task.solvewithbasis` function.\n\nThis function should be called\n\n* immediately before the first call to :msk:func:`task.solvewithbasis`, and\n* immediately before any subsequent call to :msk:func:`task.solvewithbasis` if the task has been modified.\n\nIf the basis is singular i.e. not invertible, then the error :msk:res:`err_basis_singular` is reported.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "basis", "brief": "The array of basis indexes to use.", "desc": "The array of basis indexes to use. The array is interpreted as follows: If :math:`\\mathtt{basis}[i] \\leq\n\\idxend{numcon}`, then :math:`x_{\\mathtt{basis}[i]}^c` is in the basis\nat position :math:`i`, otherwise\n:math:`x_{\\mathtt{basis}[i]-\\mathtt{numcon}}` is in the basis at\nposition :math:`i`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "init-basis-solve", "api-name": "initbasissolve", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["basis-matrix"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "solvewithbasis": {"caml-name": "solve-with-basis", "name": "solvewithbasis", "brief": "Solve a linear equation system involving a basis matrix.", "desc": "If a basic solution is available, then exactly :math:`numcon`\nbasis variables are defined.  These :math:`numcon` basis\nvariables are denoted the basis.  Associated with the basis is a basis\nmatrix denoted :math:`B`.  This function solves either the linear\nequation system\n\n.. math::\n   :label: ais-eq-Bxb\n\n   B \\barX = b\n\nor the system\n\n.. math::\n   :label: ais-eq-Btxb\n\n   B^T \\barX = b\n\nfor the unknowns :math:`\\barX`, with :math:`b` being a user-defined  vector.\nIn order to make sense of the solution :math:`\\barX` it is important\nto know the ordering of the variables in the basis because the\nordering specifies how :math:`B` is constructed. When calling\n:msk:func:`task.initbasissolve` an ordering of the basis variables is\nobtained, which can be used to deduce how |mosek| has constructed\n:math:`B`. Indeed if the :math:`k`-th basis variable is variable\n:math:`x_j` it implies that\n\n\n.. math:: B_{i,k} = A_{i,j}, ~i=\\idxbeg,\\ldots,\\idxend{\\mathtt{numcon}}.\n\n\nOtherwise if the :math:`k`-th basis variable is variable :math:`x_j^c` it implies that\n\n.. math::\n\n  B_{i,k} = \\left\\{ \\begin{array}{ll}\n                          -1, & i = j, \\\\\n                          0 , & i \\neq j. \\\\\n                      \\end{array}\n              \\right.\n\nThe function :msk:func:`task.initbasissolve` must be called before a call to this function.\nPlease note that this function exploits the\nsparsity in the vector :math:`b` to speed up the computations.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "transp", "brief": "Controls which problem formulation is solved.", "desc": "If this argument is zero, then :eq:`ais-eq-Bxb` is solved, if non-zero then :eq:`ais-eq-Btxb` is solved.", "mode": "i", "type": ["defined", "mosek", "booleant"], "null?": false, "api?": true}, {"name": "numnz", "brief": "Input (number of non-zeros in right-hand side).", "desc": "The number of non-zeros in :math:`b`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "sub", "brief": "Input (indexes of non-zeros in right-hand side) and output (indexes of non-zeros in solution vector).", "desc": "As input it contains the positions of non-zeros in :math:`b`. As output it contains the positions of the non-zeros in\n:math:`\\barX`. It must have room for :math:`numcon` elements.", "mode": "io", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "val", "brief": "Input (right-hand side values) and output (solution vector values).", "desc": "As input it is the vector :math:`b` as a dense vector (although the positions of\nnon-zeros are specified in ``sub`` it is required that\n:math:`\\mathtt{val}[i] = 0` when :math:`b[i] = 0`).  As output ``val`` is\nthe vector :math:`\\barX` as a dense vector. It must have length :math:`numcon`.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "numnzout", "brief": "Output (number of non-zeros in solution vector).", "desc": "The number of non-zeros in :math:`\\barX`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "solve-with-basis", "api-name": "solvewithbasis", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "initbasissolve"]}, {"type": "constant", "item": ["mosek", "iparam", "basis_solve_use_plus_one"]}], "member-of": ["basis-matrix"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "basiscond": {"caml-name": "basis-cond", "name": "basiscond", "brief": "Computes conditioning information for the basis matrix.", "desc": "If a basic solution is available and it defines a nonsingular basis, then\nthis function computes the 1-norm estimate of the basis matrix and a 1-norm estimate\nfor the inverse of the basis matrix. The 1-norm estimates are computed using the method\noutlined in :cite:`STEWART:98:A`, pp. 388-391.\n\nBy definition the 1-norm condition number of a matrix :math:`B` is defined as\n\n.. math:: \\kappa_1(B) := \\|B\\|_1 \\|B^{-1}\\|_1.\n\nMoreover, the larger the condition number is the harder it is to solve\nlinear equation systems involving :math:`B`.  Given estimates for\n:math:`\\|B\\|_1` and :math:`\\|B^{-1}\\|_1` it is also possible to\nestimate :math:`\\kappa_1(B)`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "nrmbasis", "brief": "An estimate for the 1-norm of the basis.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "nrminvbasis", "brief": "An estimate for the 1-norm of the inverse of the basis.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "basis-cond", "api-name": "basiscond", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["basis-matrix"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendcons": {"caml-name": "append-cons", "name": "appendcons", "brief": "Appends a number of constraints to the optimization task.", "desc": "Appends a number of constraints to the\nmodel. Appended constraints will be declared\nfree. Please note that |mosek| will automatically\nexpand the problem dimension to accommodate the\nadditional constraints.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of constraints which should be appended.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "append-cons", "api-name": "appendcons", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "removecons"]}], "member-of": ["task-linear", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendvars": {"caml-name": "append-vars", "name": "appendvars", "brief": "Appends a number of variables to the optimization task.", "desc": "Appends a number of variables to the model. Appended\nvariables will be fixed at zero. Please note that\n|mosek| will automatically expand the problem\ndimension to accommodate the additional variables.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variables which should be appended.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "append-vars", "api-name": "appendvars", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "removevars"]}], "member-of": ["task-linear", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "removecons": {"caml-name": "remove-cons", "name": "removecons", "brief": "Removes a number of constraints.", "desc": "The function removes a subset of the constraints\nfrom the optimization task. This implies that the remaining\nconstraints are renumbered.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of constraints which should be removed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subset"]}]}, {"name": "subset", "brief": "Indexes of constraints which should be removed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "remove-cons", "api-name": "removecons", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendcons"]}], "member-of": ["task-constraint", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "removevars": {"caml-name": "remove-vars", "name": "removevars", "brief": "Removes a number of variables.", "desc": "The function removes a subset of the variables\nfrom the optimization task. This implies that the remaining\nvariables are renumbered.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variables which should be removed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subset"]}]}, {"name": "subset", "brief": "Indexes of variables which should be removed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "remove-vars", "api-name": "removevars", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendvars"]}], "member-of": ["task-variable", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "removebarvars": {"caml-name": "remove-barvars", "name": "removebarvars", "brief": "Removes a number of symmetric matrices.", "desc": "The function removes a subset of the symmetric matrices\nfrom the optimization task. This implies that the remaining\nsymmetric matrices are renumbered.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of symmetric matrices which should be removed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subset"]}]}, {"name": "subset", "brief": "Indexes of symmetric matrices which should be removed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "remove-barvars", "api-name": "removebarvars", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendbarvars"]}], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "removecones": {"caml-name": "remove-cones", "name": "removecones", "brief": "Removes a number of conic constraints from the problem.", "desc": "|deprecate-cones-v10|\n\nRemoves a number of conic constraints from the problem. This implies that the remaining conic constraints are renumbered.\nIn general, it is much more efficient to remove a cone with a high index than a low index.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of cones which should be removed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subset"]}]}, {"name": "subset", "brief": "Indexes of cones which should be removed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "remove-cones", "api-name": "removecones", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendbarvars": {"caml-name": "append-barvars", "name": "appendbarvars", "brief": "Appends semidefinite variables to the problem.", "desc": "Appends positive semidefinite matrix variables of dimensions given by ``dim`` to the problem.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of symmetric matrix variables to be appended.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dim"]}]}, {"name": "dim", "brief": "Dimensions of symmetric matrix variables to be added.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "append-barvars", "api-name": "appendbarvars", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendcone": {"caml-name": "append-cone", "name": "appendcone", "brief": "Appends a new conic constraint to the problem.", "desc": "|deprecate-cones-v10|\n\nAppends a new conic constraint to the problem. Hence, add a constraint\n\n.. math:: \\hat{x} \\in \\K\n\nto the problem, where :math:`\\K` is a convex cone. :math:`\\hat{x}` is a\nsubset of the variables which will be specified by the argument\n``submem``. Cone type is specified by ``ct``.\n\nDefine\n\n.. math:: \\hat{x} = x_{\\mathtt{submem}[1]},\\ldots,x_{\\mathtt{submem}[\\mathtt{nummem}]}.\n\nDepending on the value of ``ct`` this function appends one of the constraints:\n\n* Quadratic cone (:msk:const:`conetype.quad`, requires :math:`\\mathtt{nummem}\\geq 1`):\n\n  .. math:: \\hat{x}_0 \\geq \\sqrt{\\sum_{i=1}^{i<\\mathtt{nummem}} \\hat{x}_i^2}\n\n* Rotated quadratic cone (:msk:const:`conetype.rquad`, requires :math:`\\mathtt{nummem}\\geq 2`):\n\n  .. math:: 2 \\hat{x}_0 \\hat{x}_1 \\geq \\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i, \\quad \\hat{x}_{0}, \\hat{x}_1 \\geq 0\n\n* Primal exponential cone (:msk:const:`conetype.pexp`, requires :math:`\\mathtt{nummem}=3`):\n\n  .. math:: \\hat{x}_0 \\geq \\hat{x}_1\\exp(\\hat{x}_2/\\hat{x}_1), \\quad \\hat{x}_0,\\hat{x}_1 \\geq 0\n\n* Primal power cone (:msk:const:`conetype.ppow`, requires :math:`\\mathtt{nummem}\\geq 2`):\n\n  .. math:: \\hat{x}_0^\\alpha \\hat{x}_1^{1-\\alpha} \\geq \\sqrt{\\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i}, \\quad \\hat{x}_{0}, \\hat{x}_1 \\geq 0\n\n  where :math:`\\alpha` is the cone parameter specified by ``conepar``.\n\n* Dual exponential cone (:msk:const:`conetype.dexp`, requires :math:`\\mathtt{nummem}=3`):\n\n  .. math:: \\hat{x}_0 \\geq -\\hat{x}_2 e^{-1}\\exp(\\hat{x}_1/\\hat{x}_2), \\quad \\hat{x}_2\\leq 0,\\hat{x}_0 \\geq 0\n\n* Dual power cone (:msk:const:`conetype.dpow`, requires :math:`\\mathtt{nummem}\\geq 2`):\n\n  .. math:: \\left(\\frac{\\hat{x}_0}{\\alpha}\\right)^\\alpha \\left(\\frac{\\hat{x}_1}{1-\\alpha}\\right)^{1-\\alpha} \\geq \\sqrt{\\sum_{i=2}^{i<\\mathtt{nummem}} \\hat{x}^2_i}, \\quad \\hat{x}_{0}, \\hat{x}_1 \\geq 0\n\n  where :math:`\\alpha` is the cone parameter specified by ``conepar``.\n\n* Zero cone (:msk:const:`conetype.zero`):\n\n  .. math:: \\hat{x}_i = 0 \\ \\textrm{for all}\\ i\n\nPlease note that the sets of variables appearing in different conic constraints must be disjoint.\n\nFor an explained code example see :numref:`doc.tutorial_cqo`, :numref:`doc.tutorial_ceo` or :numref:`doc.tutorial_pow`.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "ct", "mode": "i", "type": ["const-class", "mosek", "conetype"], "null?": false, "api?": true}, {"name": "conepar", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "nummem", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["submem"]}]}, {"name": "submem", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "explicit-lengths": true, "ais": "function", "api-caml-name": "append-cone", "api-name": "appendcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendconeseq"]}, {"type": "function", "item": ["mosek", "task", "appendconesseq"]}], "member-of": ["task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendconeseq": {"caml-name": "append-cone-seq", "name": "appendconeseq", "brief": "Appends a new conic constraint to the problem.", "desc": "|deprecate-cones-v10|\n\nAppends a new conic constraint to the problem, as in :msk:func:`?task.appendcone`. The\nfunction assumes the members of cone are sequential\nwhere the first member has index ``j`` and the last\n``j+nummem-1``.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "ct", "mode": "i", "type": ["const-class", "mosek", "conetype"], "null?": false, "api?": true}, {"name": "conepar", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "nummem", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the first variable in the conic constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "append-cone-seq", "api-name": "appendconeseq", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendcone"]}, {"type": "function", "item": ["mosek", "task", "appendconesseq"]}], "member-of": ["task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendconesseq": {"caml-name": "append-cones-seq", "name": "appendconesseq", "brief": "Appends multiple conic constraints to the problem.", "desc": "|deprecate-cones-v10|\n\nAppends a number of conic constraints to the problem, as in :msk:func:`?task.appendcone`.\nThe :math:`k`\\ th cone is assumed to be of dimension ``nummem[k]``. Moreover, it is assumed\nthat the first variable of the first cone has index :math:`j` and starting from there the\nsequentially following variables belong to the first cone, then to the second cone and so on.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of cones to be added.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["conepar", "ct", "nummem"]}]}, {"name": "ct", "mode": "i", "type": ["ptr", ["const-class", "mosek", "conetype"]], "null?": false, "api?": true}, {"name": "conepar", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "nummem", "brief": "Numbers of member variables in the cones.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the first variable in the first cone to be appended.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "append-cones-seq", "api-name": "appendconesseq", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "appendcone"]}, {"type": "function", "item": ["mosek", "task", "appendconeseq"]}], "member-of": ["task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "bktostr": {"caml-name": "bk-to-str", "name": "bktostr", "brief": "Obtains a bound key string identifier.", "desc": "Obtains an identifier string corresponding to a bound key.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "bk", "brief": "Bound key.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the bound key.", "desc": "String corresponding to the bound key code ``bk``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "bk-to-str", "api-name": "bktostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "calloctask": {"caml-name": "calloc-task", "name": "calloctask", "brief": "A replacement for the system calloc function.", "desc": "Equivalent to ``calloc`` i.e. allocate space for an array of length\n``number`` where each element is of size ``size``.", "status": "obscure", "returns": {"type": ["ptr", ["ctype", "void"]], "name": null, "brief": "A pointer to the memory allocated through the task."}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "number", "brief": "Number of elements.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "size", "brief": "Size of each individual element.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "calloc", "api-name": "calloc", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "callocdbgtask": {"caml-name": "calloc-dbg-task", "name": "callocdbgtask", "brief": "Debug version of the task calloc function.", "desc": "Debug version of :msk:func:`task.calloctask`.", "status": "obscure", "returns": {"type": ["ptr", ["ctype", "void"]], "name": null, "brief": "A pointer to the memory allocated through the task."}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "number", "brief": "Number of elements.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "size", "brief": "Size of each individual element.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["ctype", "unsigned"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "calloc-dbg", "api-name": "callocdbg", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "chgconbound": {"caml-name": "chg-con-bound", "name": "chgconbound", "brief": "Changes the bounds for one constraint.", "desc": "Changes a bound for one constraint.\n\nIf ``lower`` is non-zero, then the lower bound is changed as follows:\n\n.. math::\n\n    \\mbox{new lower bound} =\n      \\left\\{\n        \\begin{array}{ll}\n          - \\infty,       & \\mathtt{finite}=0, \\\\\n          \\mathtt{value}  & \\mbox{otherwise}.\n        \\end{array}\n      \\right.\n\nOtherwise if ``lower`` is zero, then\n\n.. math::\n\n    \\mbox{new upper bound} =\n      \\left\\{\n        \\begin{array}{ll}\n          \\infty,        & \\mathtt{finite}=0, \\\\\n          \\mathtt{value} & \\mbox{otherwise}.\n        \\end{array}\n      \\right.\n\n\nPlease note that this function automatically updates the bound key for the\nbound, in particular, if the lower and upper bounds are identical, the\nbound key is changed to ``fixed``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint for which the bounds should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lower", "brief": "If non-zero, then the lower bound is changed, otherwise the upper bound is changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "finite", "brief": "If non-zero, then the given value is assumed to be finite.", "desc": "If non-zero, then ``value`` is assumed to be finite.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "value", "brief": "New value for the bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "chg-con-bound", "api-name": "chgconbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconbound"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-bound", "task-constraint", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "chgvarbound": {"caml-name": "chg-var-bound", "name": "chgvarbound", "brief": "Changes the bounds for one variable.", "desc": "Changes a bound for one variable.\n\nIf ``lower`` is non-zero, then the lower bound is changed as follows:\n\n.. math::\n\n    \\mbox{new lower bound} =\n      \\left\\{\n        \\begin{array}{ll}\n          - \\infty,     & \\mathtt{finite}=0, \\\\\n          \\mathtt{value} & \\mbox{otherwise}.\n        \\end{array}\n      \\right.\n\nOtherwise if ``lower`` is zero, then\n\n.. math::\n\n    \\mbox{new upper bound} =\n      \\left\\{\n        \\begin{array}{ll}\n          \\infty,     & \\mathtt{finite}=0, \\\\\n          \\mathtt{value} & \\mbox{otherwise}.\n        \\end{array}\n      \\right.\n\nPlease note that this function automatically updates the bound key for the bound,\nin particular, if the lower and upper bounds are identical, the bound key is\nchanged to ``fixed``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable for which the bounds should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lower", "brief": "If non-zero, then the lower bound is changed, otherwise the upper bound is changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "finite", "brief": "If non-zero, then the given value is assumed to be finite.", "desc": "If non-zero, then ``value`` is assumed to be finite.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "value", "brief": "New value for the bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "chg-var-bound", "api-name": "chgvarbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarbound"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-bound", "task-variable", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "conetypetostr": {"caml-name": "cone-type-to-str", "name": "conetypetostr", "brief": "Obtains a cone type string identifier.", "desc": "|deprecate-cones-v10|\n\nObtains the cone string identifier corresponding to a cone type.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "ct", "mode": "i", "type": ["const-class", "mosek", "conetype"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the cone type.", "desc": "String corresponding to the cone type code ``ct``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "1024", "ast": "1024"}]}], "ais": "function", "api-caml-name": "cone-type-to-str", "api-name": "conetypetostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "deletetask": {"caml-name": "delete-task", "name": "deletetask", "brief": "Deletes a task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "io", "type": ["ref", ["defined", "mosek", "task_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "delete-task", "api-name": "deletetask", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "echotask": {"caml-name": "echo-task", "name": "echotask", "brief": "Prints a formatted string to a task stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "format", "brief": "A valid printf-compatible format string", "desc": "Is a valid C format string which matches the arguments in ``...``.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "varnumarg", "brief": "Additional arguments", "mode": "i", "type": ["vararg"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "echo", "api-name": "echo", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "freetask": {"caml-name": "free-task", "name": "freetask", "brief": "Frees space allocated by MOSEK.", "desc": "Frees space allocated by a |mosek| function. Must not be applied\nto the |mosek| environment and task.", "status": "obscure", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "buffer", "brief": "A pointer.", "mode": "io", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "0", "ast": "0"}]}], "ais": "function", "api-caml-name": "free", "api-name": "free", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "freedbgtask": {"caml-name": "free-dbg-task", "name": "freedbgtask", "brief": "Frees space allocated by MOSEK.", "desc": "Frees space allocated by |mosek|. Debug version of :msk:func:`task.freetask`.", "status": "obscure", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "buffer", "brief": "A pointer.", "mode": "io", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "0", "ast": "0"}]}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["ctype", "unsigned"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "free-dbg", "api-name": "freedbg", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaij": {"caml-name": "get-aij", "name": "getaij", "brief": "Obtains a single coefficient in linear constraint matrix.", "desc": "Obtains a single coefficient in :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Row index of the coefficient to be returned.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index of the coefficient to be returned.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aij", "brief": "Returns the requested coefficient.", "desc": "The required coefficient :math:`a_{i,j}`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-aij", "api-name": "getaij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getapiecenumnz": {"caml-name": "get-a-piece-num-nz", "name": "getapiecenumnz", "brief": "Obtains the number non-zeros in a rectangular piece of the linear constraint matrix.", "desc": "Obtains the number non-zeros in a rectangular piece of :math:`A`, i.e. the number of elements in the set\n\n.. math:: \\{ (i,j)~:~ a_{i,j} \\neq 0,~ \\mathtt{firsti} \\leq i \\leq \\mathtt{lasti}-1, ~\\mathtt{firstj} \\leq j \\leq \\mathtt{lastj}-1\\}\n\nThis function is not an efficient way to obtain the number of non-zeros in one\nrow or column. In that case use the function :msk:func:`task.getarownumnz` or :msk:func:`task.getacolnumnz`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "firsti", "brief": "Index of the first row in the rectangular piece.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lasti", "brief": "Index of the last row plus one in the rectangular piece.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "firstj", "brief": "Index of the first column in the rectangular piece.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lastj", "brief": "Index of the last column plus one in the rectangular piece.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zero elements in the rectangular piece of the linear constraint matrix.", "desc": "Number of non-zero :math:`A` elements in the rectangular piece.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-piece-num-nz", "api-name": "getapiecenumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz"]}, {"type": "function", "item": ["mosek", "task", "getacolslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolnumnz": {"caml-name": "get-a-col-num-nz", "name": "getacolnumnz", "brief": "Obtains the number of non-zero elements in one column of the linear constraint matrix", "desc": "Obtains the number of non-zero elements in one column of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the column.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzj", "brief": "Number of non-zeros in the j'th column of (A).", "desc": "Number of non-zeros in the :math:`j`-th column of :math:`A`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-col-num-nz", "api-name": "getacolnumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacol": {"caml-name": "get-a-col", "name": "getacol", "brief": "Obtains one column of the linear constraint matrix.", "desc": "Obtains one column of :math:`A` in a sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the column.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzj", "brief": "Number of non-zeros in the column obtained.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": false}, {"name": "subj", "brief": "Row indices of the non-zeros in the column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getacolnumnz task (arg j) return-value)", "ast": ["call", "getacolnumnz", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}]}, {"name": "valj", "brief": "Numerical values in the column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getacolnumnz task (arg j) return-value)", "ast": ["call", "getacolnumnz", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}]}], "ais": "function", "api-caml-name": "get-a-col", "api-name": "getacol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolslice": {"caml-name": "get-a-col-slice", "name": "getacolslice", "brief": "Obtains a sequence of columns from the coefficient matrix.", "desc": "Obtains a sequence of columns from :math:`A` in sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first column in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last column in the sequence plus one.", "desc": "Index of the last column in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``sub`` and ``val``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getacolslicenumnz task (arg first) (arg last) return-value)", "ast": ["call", "getacolslicenumnz", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "ptrb", "brief": "Column start pointers.", "desc": "``ptrb[t]`` is an index pointing to the first element\nin the :math:`t`-th column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Column end pointers.", "desc": "``ptre[t]`` is an index pointing to the last element plus\none in the :math:`t`-th column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "sub", "brief": "Contains the row subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Contains the coefficient values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-col-slice", "api-name": "getacolslice", "targets": ["c", "cmdln"], "references": [{"type": "function", "item": ["mosek", "task", "getacolslicenumnz64"]}, {"type": "function", "item": ["mosek", "task", "getacolslicenumnz64"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolslice64": {"caml-name": "get-a-col-slice-64", "name": "getacolslice64", "brief": "Obtains a sequence of columns from the coefficient matrix.", "desc": "Obtains a sequence of columns from :math:`A` in sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first column in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last column in the sequence plus one.", "desc": "Index of the last column in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``sub`` and ``val``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getacolslicenumnz64 task (arg first) (arg last) return-value)", "ast": ["call", "getacolslicenumnz64", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "ptrb", "brief": "Column start pointers.", "desc": "``ptrb[t]`` is an index pointing to the first element\nin the :math:`t`-th column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Column end pointers.", "desc": "``ptre[t]`` is an index pointing to the last element plus\none in the :math:`t`-th column obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "sub", "brief": "Contains the row subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Contains the coefficient values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-col-slice", "api-name": "getacolslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarownumnz": {"caml-name": "get-a-row-num-nz", "name": "getarownumnz", "brief": "Obtains the number of non-zero elements in one row of the linear constraint matrix", "desc": "Obtains the number of non-zero elements in one row of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the row.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzi", "brief": "Number of non-zeros in the i'th row of `A`.", "desc": "Number of non-zeros in the :math:`i`-th row of :math:`A`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-row-num-nz", "api-name": "getarownumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarow": {"caml-name": "get-a-row", "name": "getarow", "brief": "Obtains one row of the linear constraint matrix.", "desc": "Obtains one row of :math:`A` in a sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the row.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzi", "brief": "Number of non-zeros in the row obtained.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": false}, {"name": "subi", "brief": "Column indices of the non-zeros in the row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getarownumnz task (arg i) return-value)", "ast": ["call", "getarownumnz", "task", ["arg", "i"], "return-value"], "arg-refs": ["i"]}]}, {"name": "vali", "brief": "Numerical values of the row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getarownumnz task (arg i) return-value)", "ast": ["call", "getarownumnz", "task", ["arg", "i"], "return-value"], "arg-refs": ["i"]}]}], "ais": "function", "api-caml-name": "get-a-row", "api-name": "getarow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolslicenumnz": {"caml-name": "get-a-col-slice-num-nz", "name": "getacolslicenumnz", "brief": "Obtains the number of non-zeros in a slice of columns of the coefficient matrix.", "desc": "Obtains the number of non-zeros in a slice of columns of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first column in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last column plus one in the sequence.", "desc": "Index of the last column **plus one** in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the slice.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-col-slice-num-nz", "api-name": "getacolslicenumnz", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolslicenumnz64": {"caml-name": "get-a-col-slice-num-nz-64", "name": "getacolslicenumnz64", "brief": "Obtains the number of non-zeros in a slice of columns of the coefficient matrix.", "desc": "Obtains the number of non-zeros in a slice of columns of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first column in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last column plus one in the sequence.", "desc": "Index of the last column **plus one** in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the slice.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-col-slice-num-nz", "api-name": "getacolslicenumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarowslicenumnz": {"caml-name": "get-a-row-slice-num-nz", "name": "getarowslicenumnz", "brief": "Obtains the number of non-zeros in a slice of rows of the coefficient matrix.", "desc": "Obtains the number of non-zeros in a slice of rows of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first row in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last row plus one in the sequence.", "desc": "Index of the last row **plus one** in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the slice.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-row-slice-num-nz", "api-name": "getarowslicenumnz", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarowslicenumnz64": {"caml-name": "get-a-row-slice-num-nz-64", "name": "getarowslicenumnz64", "brief": "Obtains the number of non-zeros in a slice of rows of the coefficient matrix.", "desc": "Obtains the number of non-zeros in a slice of rows of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first row in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last row plus one in the sequence.", "desc": "Index of the last row **plus one** in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the slice.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-a-row-slice-num-nz", "api-name": "getarowslicenumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarowslice": {"caml-name": "get-a-row-slice", "name": "getarowslice", "brief": "Obtains a sequence of rows from the coefficient matrix.", "desc": "Obtains a sequence of rows from :math:`A` in sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first row in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last row in the sequence plus one.", "desc": "Index of the last row in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``sub`` and ``val``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getarowslicenumnz task (arg first) (arg last) return-value)", "ast": ["call", "getarowslicenumnz", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "ptrb", "brief": "Row start pointers.", "desc": "``ptrb[t]`` is an index pointing to the first element\nin the :math:`t`-th row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Row end pointers.", "desc": "``ptre[t]`` is an index pointing to the last element plus\none in the :math:`t`-th row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "sub", "brief": "Contains the column subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Contains the coefficient values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-row-slice", "api-name": "getarowslice", "targets": ["c", "cmdln"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz64"]}, {"type": "function", "item": ["mosek", "task", "getacolslicenumnz64"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarowslice64": {"caml-name": "get-a-row-slice-64", "name": "getarowslice64", "brief": "Obtains a sequence of rows from the coefficient matrix.", "desc": "Obtains a sequence of rows from :math:`A` in sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first row in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last row in the sequence plus one.", "desc": "Index of the last row in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``sub`` and ``val``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getarowslicenumnz64 task (arg first) (arg last) return-value)", "ast": ["call", "getarowslicenumnz64", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "ptrb", "brief": "Row start pointers.", "desc": "``ptrb[t]`` is an index pointing to the first element\nin the :math:`t`-th row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Row end pointers.", "desc": "``ptre[t]`` is an index pointing to the last element plus\none in the :math:`t`-th row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "sub", "brief": "Contains the column subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Contains the coefficient values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-row-slice", "api-name": "getarowslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getatrip": {"caml-name": "get-a-trip", "name": "getatrip", "brief": "Obtains the A matrix in sparse triplet format.", "desc": "Obtains :math:`A` in sparse triplet format.\nThe triplets corresponding to nonzero entries are stored in the arrays ``subi``, ``subj`` and ``val``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``subi``, ``subj``, and ``val``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumanz64 task return-value)", "ast": ["call", "getnumanz64", "task", "return-value"]}]}, {"name": "subi", "brief": "Constraint subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "subj", "brief": "Column subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-trip", "api-name": "getatrip", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getarowslicetrip": {"caml-name": "get-a-row-slice-trip", "name": "getarowslicetrip", "brief": "Obtains a sequence of rows from the coefficient matrix in sparse triplet format.", "desc": "Obtains a sequence of rows from :math:`A` in sparse triplet format. The function returns the\ncontent of all rows whose index ``i`` satisfies ``first <= i < last``.\nThe triplets corresponding to nonzero entries are stored in the arrays ``subi``, ``subj`` and ``val``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first row in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last row in the sequence plus one.", "desc": "Index of the last row in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``subi``, ``subj``, and ``val``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getarowslicenumnz64 task (arg first) (arg last) return-value)", "ast": ["call", "getarowslicenumnz64", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "subi", "brief": "Constraint subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "subj", "brief": "Column subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-row-slice-trip", "api-name": "getarowslicetrip", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getarowslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getacolslicetrip": {"old-name": "getacolslicetrip", "caml-name": "get-a-col-slice-trip", "name": "getacolslicetrip", "brief": "Obtains a sequence of columns from the coefficient matrix in triplet format.", "desc": "Obtains a sequence of columns from :math:`A` in sparse triplet format. The function returns the content of all columns whose index ``j`` satisfies ``first <= j < last``. The triplets corresponding to nonzero entries are stored in the arrays ``subi``, ``subj`` and ``val``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "Index of the first column in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last column in the sequence plus one.", "desc": "Index of the last column in the sequence **plus one**.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumnz", "brief": "Denotes the length of the subscript and coefficient arrays.", "desc": "Denotes the length of the arrays ``subi``, ``subj``, and ``val``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getacolslicenumnz64 task (arg first) (arg last) return-value)", "ast": ["call", "getacolslicenumnz64", "task", ["arg", "first"], ["arg", "last"], "return-value"], "arg-refs": ["first", "last"]}]}, {"name": "subi", "brief": "Constraint subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "subj", "brief": "Column subscripts.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}, {"name": "val", "brief": "Values.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-a-col-slice-trip", "api-name": "getacolslicetrip", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getacolslicenumnz"]}], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconbound": {"old-name": "getconbound", "caml-name": "get-con-bound", "name": "getconbound", "brief": "Obtains bound information for one constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint for which the bound information should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bk", "mode": "o", "type": ["ref", ["const-class", "mosek", "boundkey"]], "null?": true, "api?": true}, {"name": "bl", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "bu", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-con-bound", "api-name": "getconbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect", "task-bound", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvarbound": {"old-name": "getvarbound", "caml-name": "get-var-bound", "name": "getvarbound", "brief": "Obtains bound information for one variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the variable for which the bound information should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bk", "mode": "o", "type": ["ref", ["const-class", "mosek", "boundkey"]], "null?": true, "api?": true}, {"name": "bl", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "bu", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-var-bound", "api-name": "getvarbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect", "task-bound", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconboundslice": {"old-name": "getconboundslice", "caml-name": "get-con-bound-slice", "name": "getconboundslice", "brief": "Obtains bounds information for a slice of the constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bk", "mode": "o", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "bl", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "bu", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-con-bound-slice", "api-name": "getconboundslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect", "task-bound", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvarboundslice": {"old-name": "getvarboundslice", "caml-name": "get-var-bound-slice", "name": "getvarboundslice", "brief": "Obtains bounds information for a slice of the variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bk", "mode": "o", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "bl", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "bu", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-var-bound-slice", "api-name": "getvarboundslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect", "task-bound", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getcj": {"caml-name": "get-c-j", "name": "getcj", "brief": "Obtains one objective coefficient.", "desc": "Obtains one coefficient of :math:`c`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable for which the c coefficient should be obtained.", "desc": "Index of the variable for which the :math:`c` coefficient should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "cj", "brief": "The c coefficient value.", "desc": "The value of :math:`c_j`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-c-j", "api-name": "getcj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getcslice"]}], "member-of": ["task-linear", "task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getc": {"old-name": "getc", "caml-name": "get-c", "name": "getc", "brief": "Obtains all objective coefficients.", "desc": "Obtains all objective coefficients :math:`c`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "c", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-c", "api-name": "getc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getcallbackfunc": {"old-name": "getcallbackfunc", "caml-name": "get-callbackfunc", "name": "getcallbackfunc", "brief": "Obtains the callback function and the associated user handle.", "desc": "Obtains the current user-defined callback function and associated user handle.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "func", "brief": "Returns the current user-defined callback function.", "desc": "Get the user-defined progress callback function :msk:type:`callbackfunc` associated with ``task``.\nIf ``func`` is identical to |null|, then no callback function is associated with the ``task``.", "mode": "o", "type": ["ref", ["defined", "mosek", "callbackfunc"]], "null?": true, "api?": true}, {"name": "handle", "brief": "The user-defined pointer associated with the user-defined callback function.", "mode": "o", "type": ["ref", ["defined", "mosek", "userhandle_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-callbackfunc", "api-name": "getcallbackfunc", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["callback"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getcfix": {"old-name": "getcfix", "caml-name": "get-cfix", "name": "getcfix", "brief": "Obtains the fixed term in the objective.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "cfix", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-cfix", "api-name": "getcfix", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getcone": {"old-name": "getcone", "caml-name": "get-cone", "name": "getcone", "brief": "Obtains a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ct", "mode": "o", "type": ["ref", ["const-class", "mosek", "conetype"]], "null?": true, "api?": true}, {"name": "conepar", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": false}, {"name": "nummem", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": false}, {"name": "submem", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getconeinfo task (arg k) dummy-value dummy-value return-value)", "ast": ["call", "getconeinfo", "task", ["arg", "k"], "dummy-value", "dummy-value", "return-value"], "arg-refs": ["k"]}]}], "ais": "function", "api-caml-name": "get-cone", "api-name": "getcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getconeinfo": {"old-name": "getconeinfo", "caml-name": "get-cone-info", "name": "getconeinfo", "brief": "Obtains information about a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ct", "mode": "o", "type": ["ref", ["const-class", "mosek", "conetype"]], "null?": true, "api?": true}, {"name": "conepar", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nummem", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-cone-info", "api-name": "getconeinfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getclist": {"caml-name": "get-c-list", "name": "getclist", "brief": "Obtains a sequence of coefficients from the objective.", "desc": "Obtains a sequence of elements in :math:`c`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variables for which the c values should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subj"]}]}, {"name": "subj", "brief": "A list of variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "c", "brief": "Linear terms of the requested list of the objective as a dense vector.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "( arg num )", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-c-list", "api-name": "getclist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getcslice": {"old-name": "getcslice", "caml-name": "get-c-slice", "name": "getcslice", "brief": "Obtains a sequence of coefficients from the objective.", "desc": "Obtains a sequence of elements in :math:`c`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "c", "brief": "Linear terms of the requested slice of the objective as a dense vector.", "desc": "Linear terms of the requested slice of the objective as a dense vector. The length is ``last-first``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-c-slice", "api-name": "getcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdouinf": {"caml-name": "get-dou-inf", "name": "getdouinf", "brief": "Obtains a double information item.", "desc": "Obtains a double information item from the task information database.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichdinf", "mode": "i", "type": ["const-class", "mosek", "dinfitem"], "null?": false, "api?": true}, {"name": "dvalue", "brief": "The value of the required double information item.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-dou-inf", "api-name": "getdouinf", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["information-items"], "locked": false, "breakable": false, "log": false, "const": "const"}, "getdouparam": {"old-name": "getdouparam", "caml-name": "get-dou-param", "name": "getdouparam", "brief": "Obtains a double parameter.", "desc": "Obtains the value of a double parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "dparam"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-dou-param", "api-name": "getdouparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdualobj": {"old-name": "getdualobj", "caml-name": "get-dual-obj", "name": "getdualobj", "brief": "Computes the dual objective value associated with the solution.", "desc": "Computes the dual objective value associated with the solution. Note that if the solution is a primal infeasibility certificate, then the fixed term in the objective value is not included.\n\nMoreover, since there is no dual solution associated with an integer solution, an error will be reported if the dual objective value is requested for the integer solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "dualobj", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-dual-obj", "api-name": "getdualobj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getenv": {"old-name": "getenv", "caml-name": "get-env", "name": "getenv", "brief": "Obtains the environment used to create the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "env", "mode": "o", "type": ["ref", ["defined", "mosek", "env_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-env", "api-name": "getenv", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getinfindex": {"old-name": "getinfindex", "caml-name": "get-inf-index", "name": "getinfindex", "brief": "Obtains the index of a named information item.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "inftype", "mode": "i", "type": ["const-class", "mosek", "inftype"], "null?": false, "api?": true}, {"name": "infname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "infindex", "brief": "The item index.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-inf-index", "api-name": "getinfindex", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "rust"], "references": [], "member-of": ["information-items"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getinfmax": {"old-name": "getinfmax", "caml-name": "get-inf-max", "name": "getinfmax", "brief": "Obtains the maximum index of an information item of a given type.", "desc": "Obtains the maximum index of an information item of a given type ``inftype`` plus 1.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "inftype", "mode": "i", "type": ["const-class", "mosek", "inftype"], "null?": false, "api?": true}, {"name": "infmax", "brief": "The maximum index (plus 1) requested.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "get-inf-max", "api-name": "getinfmax", "targets": ["c", "cmdln", "go", "java", "no-overload", "rust"], "references": [], "member-of": ["information-items"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getinfname": {"old-name": "getinfname", "caml-name": "get-inf-name", "name": "getinfname", "brief": "Obtains the name of an information item.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "inftype", "mode": "i", "type": ["const-class", "mosek", "inftype"], "null?": false, "api?": true}, {"name": "whichinf", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "infname", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "get-inf-name", "api-name": "getinfname", "targets": ["c", "cmdln", "go", "java", "julia", "no-overload", "rust"], "references": [], "member-of": ["information-items", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getintinf": {"old-name": "getintinf", "caml-name": "get-int-inf", "name": "getintinf", "brief": "Obtains an integer information item.", "desc": "Obtains an integer information item from the task information database.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichiinf", "mode": "i", "type": ["const-class", "mosek", "iinfitem"], "null?": false, "api?": true}, {"name": "ivalue", "brief": "The value of the required integer information item.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-int-inf", "api-name": "getintinf", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["information-items"], "locked": false, "breakable": false, "log": false, "const": "const"}, "getlintinf": {"old-name": "getlintinf", "caml-name": "get-lint-inf", "name": "getlintinf", "brief": "Obtains a long integer information item.", "desc": "Obtains a long integer information item from the task information database.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichliinf", "mode": "i", "type": ["const-class", "mosek", "liinfitem"], "null?": false, "api?": true}, {"name": "ivalue", "brief": "The value of the required long integer information item.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-lint-inf", "api-name": "getlintinf", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["information-items"], "locked": false, "breakable": false, "log": false, "const": "const"}, "getintparam": {"old-name": "getintparam", "caml-name": "get-int-param", "name": "getintparam", "brief": "Obtains an integer parameter.", "desc": "Obtains the value of an integer parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "iparam"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-int-param", "api-name": "getintparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnamelen": {"old-name": "getmaxnamelen", "caml-name": "get-max-name-len", "name": "getmaxnamelen", "brief": "Obtains the maximum length (not including terminating zero character) of any objective, constraint, variable, domain or cone name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxlen", "brief": "The maximum length of any name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-max-name-len", "api-name": "getmaxnamelen", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["task-inspect", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumanz": {"old-name": "getmaxnumanz", "caml-name": "get-max-num-a-nz", "name": "getmaxnumanz", "brief": "Obtains number of preallocated non-zeros in the linear constraint matrix.", "desc": "Obtains number of preallocated non-zeros in :math:`A`. When this number of non-zeros is reached |mosek| will automatically allocate more space for :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumanz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-max-num-a-nz", "api-name": "getmaxnumanz", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumanz64": {"old-name": "getmaxnumanz64", "caml-name": "get-max-num-a-nz-64", "name": "getmaxnumanz64", "brief": "Obtains number of preallocated non-zeros in the linear constraint matrix.", "desc": "Obtains number of preallocated non-zeros in :math:`A`. When this number of non-zeros is reached |mosek| will automatically allocate more space for :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumanz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-max-num-a-nz", "api-name": "getmaxnumanz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumcon": {"old-name": "getmaxnumcon", "caml-name": "get-max-num-con", "name": "getmaxnumcon", "brief": "Obtains the number of preallocated constraints in the optimization task.", "desc": "Obtains the number of preallocated constraints in the optimization task. When this number of constraints is reached |mosek| will automatically allocate more space for constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-max-num-con", "api-name": "getmaxnumcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-linear", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumvar": {"old-name": "getmaxnumvar", "caml-name": "get-max-num-var", "name": "getmaxnumvar", "brief": "Obtains the maximum number variables allowed.", "desc": "Obtains the number of preallocated variables in the optimization task. When this number of variables is reached |mosek| will automatically allocate more space for variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumvar", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-max-num-var", "api-name": "getmaxnumvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-linear", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnadouinf": {"caml-name": "get-na-dou-inf", "name": "getnadouinf", "brief": "Obtains a named double information item.", "desc": "Obtains a named double information item from task information database.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "infitemname", "brief": "The name of a double information item.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "dvalue", "brief": "The value of the required double information item.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-na-dou-inf", "api-name": "getnadouinf", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["information-items"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnadouparam": {"caml-name": "get-na-dou-param", "name": "getnadouparam", "brief": "Obtains a double parameter.", "desc": "Obtains the value of a named double parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-na-dou-param", "api-name": "getnadouparam", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnaintinf": {"caml-name": "get-na-int-inf", "name": "getnaintinf", "brief": "Obtains a named integer information item.", "desc": "Obtains a named integer information item from the task information database.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "infitemname", "brief": "The name of an integer information item.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "ivalue", "brief": "The value of the required integer information item.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-na-int-inf", "api-name": "getnaintinf", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["information-items"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnaintparam": {"old-name": "getnaintparam", "caml-name": "get-na-int-param", "name": "getnaintparam", "brief": "Obtains an integer parameter.", "desc": "Obtains the value of a named integer parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-na-int-param", "api-name": "getnaintparam", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarvarnamelen": {"old-name": "getbarvarnamelen", "caml-name": "get-barvar-name-len", "name": "getbarvarnamelen", "brief": "Obtains the length of the name of a semidefinite variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-barvar-name-len", "api-name": "getbarvarnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarvarname": {"old-name": "getbarvarname", "caml-name": "get-barvar-name", "name": "getbarvarname", "brief": "Obtains the name of a semidefinite variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "Length of the name buffer.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getbarvarnamelen task (arg i) return-value))", "ast": ["+", "1", ["call", "getbarvarnamelen", "task", ["arg", "i"], "return-value"]], "arg-refs": ["i"]}]}, {"name": "name", "brief": "The requested name is copied to this buffer.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-barvar-name", "api-name": "getbarvarname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarnamelen"]}], "member-of": ["naming", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarvarnameindex": {"old-name": "getbarvarnameindex", "caml-name": "get-barvar-name-index", "name": "getbarvarnameindex", "brief": "Obtains the index of semidefinite variable from its name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "somename", "brief": "The name of the variable.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "asgn", "brief": "Non-zero if the name somename is assigned to some semidefinite variable.", "desc": "Non-zero if the name ``somename`` is assigned to some semidefinite variable.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "index", "brief": "The index of a semidefinite variable with the name somename (if one exists).", "desc": "The index of a semidefinite variable with the name ``somename`` (if one exists).", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-barvar-name-index", "api-name": "getbarvarnameindex", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "generatebarvarnames": {"old-name": "generatebarvarnames", "caml-name": "generate-barvar-names", "name": "generatebarvarnames", "brief": "Generates systematic names for variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variable indexes.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subj"]}]}, {"name": "subj", "brief": "Indexes of the variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The variable name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-barvar-names", "api-name": "generatebarvarnames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-variable", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "generatevarnames": {"old-name": "generatevarnames", "caml-name": "generate-var-names", "name": "generatevarnames", "brief": "Generates systematic names for variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variable indexes.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subj"]}]}, {"name": "subj", "brief": "Indexes of the variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The variable name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-var-names", "api-name": "generatevarnames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-variable", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "generateconnames": {"old-name": "generateconnames", "caml-name": "generate-con-names", "name": "generateconnames", "brief": "Generates systematic names for constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of constraint indexes.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subi"]}]}, {"name": "subi", "brief": "Indexes of the constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The constraint name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-con-names", "api-name": "generateconnames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-constraint", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "generateconenames": {"old-name": "generateconenames", "caml-name": "generate-cone-names", "name": "generateconenames", "brief": "Generates systematic names for cone.", "desc": "Internal, deprecated.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of cone indexes.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subk"]}]}, {"name": "subk", "brief": "Indexes of the cone.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The cone name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-cone-names", "api-name": "generateconenames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "generateaccnames": {"old-name": "generateaccnames", "caml-name": "generate-acc-names", "name": "generateaccnames", "brief": "Generates systematic names for affine conic constraints.", "desc": "Internal.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variable indexes.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "Indexes of the affine conic constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The variable name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-acc-names", "api-name": "generateaccnames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "generatedjcnames": {"old-name": "generatedjcnames", "caml-name": "generate-djc-names", "name": "generatedjcnames", "brief": "Generates systematic names for affine conic constraints.", "desc": "Internal.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variable indexes.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "Indexes of the disjunctive constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "fmt", "brief": "The variable name formatting string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "ndims", "brief": "Number of dimensions in the shape.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["dims"]}]}, {"name": "dims", "brief": "Dimensions in the shape.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "sp", "brief": "Items that should be named.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "numnamedaxis", "brief": "Number of named axes", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["namedaxisidxs"]}]}, {"name": "namedaxisidxs", "brief": "List if named index axes", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"]}, {"name": "numnames", "brief": "Total number of names.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["names"]}]}, {"name": "names", "brief": "All axis names.", "mode": "i", "type": ["ptr", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "generate-djc-names", "api-name": "generatedjcnames", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconname": {"old-name": "putconname", "caml-name": "put-con-name", "name": "putconname", "brief": "Sets the name of a constraint.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The name of the constraint.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-con-name", "api-name": "putconname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-constraint", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarname": {"old-name": "putvarname", "caml-name": "put-var-name", "name": "putvarname", "brief": "Sets the name of a variable.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The variable name.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-var-name", "api-name": "putvarname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-variable", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconename": {"caml-name": "put-cone-name", "name": "putconename", "brief": "Sets the name of a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The name of the cone.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-cone-name", "api-name": "putconename", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbarvarname": {"caml-name": "put-barvar-name", "name": "putbarvarname", "brief": "Sets the name of a semidefinite variable.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The variable name.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-barvar-name", "api-name": "putbarvarname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarnamelen"]}], "member-of": ["naming", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putdomainname": {"caml-name": "put-domain-name", "name": "putdomainname", "brief": "Sets the name of a domain.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The name of the domain.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-domain-name", "api-name": "putdomainname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putdjcname": {"caml-name": "put-djc-name", "name": "putdjcname", "brief": "Sets the name of a disjunctive constraint.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The name of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-djc-name", "api-name": "putdjcname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-djc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaccname": {"caml-name": "put-acc-name", "name": "putaccname", "brief": "Sets the name of an affine conic constraint.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "name", "brief": "The name of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-acc-name", "api-name": "putaccname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getvarnamelen": {"old-name": "getvarnamelen", "caml-name": "get-var-name-len", "name": "getvarnamelen", "brief": "Obtains the length of the name of a variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of a variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-var-name-len", "api-name": "getvarnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-linear", "task-variable", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvarname": {"caml-name": "get-var-name", "name": "getvarname", "brief": "Obtains the name of a variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of a variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "The length of the name buffer.", "desc": "The length of the buffer pointed to by the ``name`` argument.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getvarnamelen task (arg j) return-value))", "ast": ["+", "1", ["call", "getvarnamelen", "task", ["arg", "j"], "return-value"]], "arg-refs": ["j"]}]}, {"name": "name", "brief": "Returns the required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-var-name", "api-name": "getvarname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getmaxnamelen"]}], "member-of": ["naming", "task-linear", "task-variable", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconnamelen": {"old-name": "getconnamelen", "caml-name": "get-con-name-len", "name": "getconnamelen", "brief": "Obtains the length of the name of a constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-con-name-len", "api-name": "getconnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-linear", "task-constraint", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconname": {"old-name": "getconname", "caml-name": "get-con-name", "name": "getconname", "brief": "Obtains the name of a constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "Length of the name buffer.", "desc": "Maximum length of name that can be stored in ``name``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getconnamelen task (arg i) return-value))", "ast": ["+", "1", ["call", "getconnamelen", "task", ["arg", "i"], "return-value"]], "arg-refs": ["i"]}]}, {"name": "name", "brief": "The required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-con-name", "api-name": "getconname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getconnamelen"]}], "member-of": ["naming", "task-linear", "task-constraint", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconnameindex": {"old-name": "getconnameindex", "caml-name": "get-con-name-index", "name": "getconnameindex", "brief": "Checks whether the name has been assigned to any constraint.", "desc": "Checks whether the name ``somename`` has been assigned to any constraint. If so, the index of the constraint is reported.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "somename", "brief": "The name which should be checked.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "asgn", "brief": "Is non-zero if the name somename is assigned to some constraint.", "desc": "Is non-zero if the name ``somename`` is assigned to some constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "index", "brief": "If the name somename is assigned to a constraint, then return the index of the constraint.", "desc": "If the name ``somename`` is assigned to a constraint, then ``index`` is the index of the constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "get-con-name-index", "api-name": "getconnameindex", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-linear", "task-constraint", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvarnameindex": {"old-name": "getvarnameindex", "caml-name": "get-var-name-index", "name": "getvarnameindex", "brief": "Checks whether the name has been assigned to any variable.", "desc": "Checks whether the name ``somename`` has been assigned to any variable. If so, the index of the variable is reported.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "somename", "brief": "The name which should be checked.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "asgn", "brief": "Is non-zero if the name somename is assigned to a variable.", "desc": "Is non-zero if the name ``somename`` is assigned to a variable.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "index", "brief": "If the name somename is assigned to a variable, then return the index of the variable.", "desc": "If the name ``somename`` is assigned to a variable, then ``index`` is the index of the variable.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "get-var-name-index", "api-name": "getvarnameindex", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-linear", "task-variable", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconenamelen": {"old-name": "getconenamelen", "caml-name": "get-cone-name-len", "name": "getconenamelen", "brief": "Obtains the length of the name of a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-cone-name-len", "api-name": "getconenamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-conic", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconename": {"old-name": "getconename", "caml-name": "get-cone-name", "name": "getconename", "brief": "Obtains the name of a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "Length of the name buffer.", "desc": "Maximum length of a name that can be stored in ``name``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getconenamelen task (arg i) return-value))", "ast": ["+", "1", ["call", "getconenamelen", "task", ["arg", "i"], "return-value"]], "arg-refs": ["i"]}]}, {"name": "name", "brief": "The required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-cone-name", "api-name": "getconename", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getconnamelen"]}], "member-of": ["naming", "task-conic", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getconenameindex": {"old-name": "getconenameindex", "caml-name": "get-cone-name-index", "name": "getconenameindex", "brief": "Checks whether the name has been assigned to any cone.", "desc": "|deprecate-cones-v10|\n\nChecks whether the name ``somename`` has been assigned to any cone. If it has been assigned to a cone, then the index of the cone is reported.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "somename", "brief": "The name which should be checked.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "asgn", "brief": "Is non-zero if the name somename is assigned to some cone.", "desc": "Is non-zero if the name ``somename`` is assigned to some cone.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "index", "brief": "If the name somename is assigned to some cone, this is the index of the cone.", "desc": "If the name ``somename`` is assigned to some cone, then ``index`` is the index of the cone.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-cone-name-index", "api-name": "getconenameindex", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-conic", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdomainnamelen": {"caml-name": "get-domain-name-len", "name": "getdomainnamelen", "brief": "Obtains the length of the name of a domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of a domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-domain-name-len", "api-name": "getdomainnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming", "task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdomainname": {"caml-name": "get-domain-name", "name": "getdomainname", "brief": "Obtains the name of a domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of a domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "The length of the name buffer.", "desc": "The length of the buffer pointed to by the ``name`` argument.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getdomainnamelen task (arg domidx) return-value))", "ast": ["+", "1", ["call", "getdomainnamelen", "task", ["arg", "domidx"], "return-value"]], "arg-refs": ["domidx"]}]}, {"name": "name", "brief": "Returns the required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-domain-name", "api-name": "getdomainname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjcnamelen": {"caml-name": "get-djc-name-len", "name": "getdjcnamelen", "brief": "Obtains the length of the name of a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of a disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-name-len", "api-name": "getdjcnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming", "task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjcname": {"caml-name": "get-djc-name", "name": "getdjcname", "brief": "Obtains the name of a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of a disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "The length of the name buffer.", "desc": "The length of the buffer pointed to by the ``name`` argument.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getdjcnamelen task (arg djcidx) return-value))", "ast": ["+", "1", ["call", "getdjcnamelen", "task", ["arg", "djcidx"], "return-value"]], "arg-refs": ["djcidx"]}]}, {"name": "name", "brief": "Returns the required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-name", "api-name": "getdjcname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccnamelen": {"caml-name": "get-acc-name-len", "name": "getaccnamelen", "brief": "Obtains the length of the name of an affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Index of an affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "len", "brief": "Returns the length of the indicated name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-name-len", "api-name": "getaccnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming", "task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccname": {"caml-name": "get-acc-name", "name": "getaccname", "brief": "Obtains the name of an affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Index of an affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizename", "brief": "The length of the name buffer.", "desc": "The length of the buffer pointed to by the ``name`` argument.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getaccnamelen task (arg accidx) return-value))", "ast": ["+", "1", ["call", "getaccnamelen", "task", ["arg", "accidx"], "return-value"]], "arg-refs": ["accidx"]}]}, {"name": "name", "brief": "Returns the required name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizename)", "ast": ["arg", "sizename"], "arg-refs": ["sizename"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-name", "api-name": "getaccname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnastrparam": {"old-name": "getnastrparam", "caml-name": "get-na-str-param", "name": "getnastrparam", "brief": "Obtains a string parameter.", "desc": "Obtains the value of a named string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "sizeparamname", "brief": "Size of the name buffer.", "desc": "Size of the name buffer ``parvalue``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE"}]}, {"name": "len", "brief": "Returns the length of the parameter value.", "desc": "Length of the string in ``parvalue``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "parvalue", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizeparamname)", "ast": ["arg", "sizeparamname"], "arg-refs": ["sizeparamname"]}]}], "ais": "function", "api-caml-name": "get-na-str-param", "api-name": "getnastrparam", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumanz": {"old-name": "getnumanz", "caml-name": "get-num-a-nz", "name": "getnumanz", "brief": "Obtains the number of non-zeros in the coefficient matrix.", "desc": "Obtains the number of non-zeros in :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numanz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-a-nz", "api-name": "getnumanz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumanz64": {"old-name": "getnumanz64", "caml-name": "get-num-a-nz-64", "name": "getnumanz64", "brief": "Obtains the number of non-zeros in the coefficient matrix.", "desc": "Obtains the number of non-zeros in :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numanz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-a-nz-64", "api-name": "getnumanz64", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumcon": {"old-name": "getnumcon", "caml-name": "get-num-con", "name": "getnumcon", "brief": "Obtains the number of constraints.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numcon", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-con", "api-name": "getnumcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-linear", "task-constraint", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumcone": {"old-name": "getnumcone", "caml-name": "get-num-cone", "name": "getnumcone", "brief": "Obtains the number of cones.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numcone", "brief": "Number of conic constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-cone", "api-name": "getnumcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-conic", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumconemem": {"old-name": "getnumconemem", "caml-name": "get-num-cone-mem", "name": "getnumconemem", "brief": "Obtains the number of members in a cone.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nummem", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-num-cone-mem", "api-name": "getnumconemem", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-conic", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumintvar": {"old-name": "getnumintvar", "caml-name": "get-num-int-var", "name": "getnumintvar", "brief": "Obtains the number of integer-constrained variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numintvar", "brief": "Number of integer variables.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-int-var", "api-name": "getnumintvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumparam": {"old-name": "getnumparam", "caml-name": "get-num-param", "name": "getnumparam", "brief": "Obtains the number of parameters of a given type.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "partype", "mode": "i", "type": ["const-class", "mosek", "parametertype"], "null?": false, "api?": true}, {"name": "numparam", "brief": "Returns the number of parameters of the requested type.", "desc": "The number of parameters of type ``partype``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-num-param", "api-name": "getnumparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumqconknz": {"caml-name": "get-num-q-con-k-nz", "name": "getnumqconknz", "brief": "Obtains the number of non-zero quadratic terms in a constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the constraint for which the number of non-zero quadratic terms should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numqcnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-q-con-k-nz", "api-name": "getnumqconknz", "targets": ["c", "cmdln", "rpc"], "references": [], "member-of": ["task-inspect", "task-constraint", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumqconknz64": {"old-name": "getnumqconknz64", "caml-name": "get-num-q-con-k-nz-64", "name": "getnumqconknz64", "brief": "Obtains the number of non-zero quadratic terms in a constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the constraint for which the number quadratic terms should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numqcnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-q-con-k-nz", "api-name": "getnumqconknz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-constraint", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumqobjnz": {"old-name": "getnumqobjnz", "caml-name": "get-num-q-obj-nz", "name": "getnumqobjnz", "brief": "Obtains the number of non-zero quadratic terms in the objective.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numqonz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-q-obj-nz", "api-name": "getnumqobjnz", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumqobjnz64": {"old-name": "getnumqobjnz64", "caml-name": "get-num-q-obj-nz-64", "name": "getnumqobjnz64", "brief": "Obtains the number of non-zero quadratic terms in the objective.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numqonz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-q-obj-nz", "api-name": "getnumqobjnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumvar": {"old-name": "getnumvar", "caml-name": "get-num-var", "name": "getnumvar", "brief": "Obtains the number of variables.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numvar", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-var", "api-name": "getnumvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumbarvar": {"old-name": "getnumbarvar", "caml-name": "get-num-barvar", "name": "getnumbarvar", "brief": "Obtains the number of semidefinite variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numbarvar", "brief": "Number of semidefinite variables in the problem.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-barvar", "api-name": "getnumbarvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumbarvar": {"caml-name": "get-max-num-barvar", "name": "getmaxnumbarvar", "brief": "Obtains maximum number of symmetric matrix variables for which space is currently preallocated.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumbarvar", "brief": "Maximum number of symmetric matrix variables for which space is currently preallocated.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-max-num-barvar", "api-name": "getmaxnumbarvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdimbarvarj": {"old-name": "getdimbarvarj", "caml-name": "get-dim-barvar-j", "name": "getdimbarvarj", "brief": "Obtains the dimension of a symmetric matrix variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the semidefinite variable whose dimension is requested.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "dimbarvarj", "brief": "The dimension of the j'th semidefinite variable.", "desc": "The dimension of the :math:`j`-th semidefinite variable.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-dim-barvar-j", "api-name": "getdimbarvarj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getlenbarvarj": {"old-name": "getlenbarvarj", "caml-name": "get-len-barvar-j", "name": "getlenbarvarj", "brief": "Obtains the length of one semidefinite variable.", "desc": "Obtains the length of the :math:`j`-th semidefinite variable i.e. the number of elements in the lower triangular part.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the semidefinite variable whose length if requested.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lenbarvarj", "brief": "Number of scalar elements in the lower triangular part of the semidefinite variable.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-len-barvar-j", "api-name": "getlenbarvarj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getobjname": {"old-name": "getobjname", "caml-name": "get-obj-name", "name": "getobjname", "brief": "Obtains the name assigned to the objective function.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "sizeobjname", "brief": "Length of the objname buffer.", "desc": "Length of ``objname``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getobjnamelen task return-value))", "ast": ["+", "1", ["call", "getobjnamelen", "task", "return-value"]]}]}, {"name": "objname", "brief": "Assigned the objective name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizeobjname)", "ast": ["arg", "sizeobjname"], "arg-refs": ["sizeobjname"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-obj-name", "api-name": "getobjname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getobjnamelen": {"old-name": "getobjnamelen", "caml-name": "get-obj-name-len", "name": "getobjnamelen", "brief": "Obtains the length of the name assigned to the objective function.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "len", "brief": "Assigned the length of the objective name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-obj-name-len", "api-name": "getobjnamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getparamname": {"old-name": "getparamname", "caml-name": "get-param-name", "name": "getparamname", "brief": "Obtains the name of a parameter.", "desc": "Obtains the name for a parameter ``param`` of type ``partype``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "partype", "mode": "i", "type": ["const-class", "mosek", "parametertype"], "null?": false, "api?": true}, {"name": "param", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "parname", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "get-param-name", "api-name": "getparamname", "targets": ["c", "cmdln", "go", "java", "julia", "no-overload", "rust"], "references": [], "member-of": ["naming", "parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getparammax": {"old-name": "getparammax", "caml-name": "get-param-max", "name": "getparammax", "brief": "Obtains the maximum index of a parameter of a given type.", "desc": "Obtains the maximum index of a parameter of type ``partype`` plus 1.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "partype", "mode": "i", "type": ["const-class", "mosek", "parametertype"], "null?": false, "api?": true}, {"name": "parammax", "brief": "The maximum index (plus 1) of the given parameter type.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-param-max", "api-name": "getparammax", "targets": ["c", "cmdln", "go", "java", "no-overload", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getprimalobj": {"caml-name": "get-primal-obj", "name": "getprimalobj", "brief": "Computes the primal objective value for the desired solution.", "desc": "Computes the primal objective value for the desired solution. Note that if the solution is an infeasibility certificate, then the fixed term in the objective is not included.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "primalobj", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-primal-obj", "api-name": "getprimalobj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-primal"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getprobtype": {"old-name": "getprobtype", "caml-name": "get-prob-type", "name": "getprobtype", "brief": "Obtains the problem type.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "probtype", "brief": "The problem type.", "mode": "o", "type": ["ref", ["const-class", "mosek", "problemtype"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-prob-type", "api-name": "getprobtype", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getqconk64": {"old-name": "getqconk64", "caml-name": "get-q-con-k-64", "name": "getqconk64", "brief": "Obtains all the quadratic terms in a constraint.", "desc": "Obtains all the quadratic terms in a constraint. The quadratic\nterms are stored sequentially in ``qcsubi``, ``qcsubj``, and ``qcval``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Which constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumqcnz", "brief": "Length of the subscript and coefficient buffers.", "desc": "Length of the arrays ``qcsubi``, ``qcsubj``, and ``qcval``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumqconknz64 task (arg k) return-value)", "ast": ["call", "getnumqconknz64", "task", ["arg", "k"], "return-value"], "arg-refs": ["k"]}]}, {"name": "numqcnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": false, "defaultout": true}, {"name": "qcsubi", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getnumqconknz64 task (arg k) return-value)", "ast": ["call", "getnumqconknz64", "task", ["arg", "k"], "return-value"], "arg-refs": ["k"]}]}, {"name": "qcsubj", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getnumqconknz64 task (arg k) return-value)", "ast": ["call", "getnumqconknz64", "task", ["arg", "k"], "return-value"], "arg-refs": ["k"]}]}, {"name": "qcval", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumqconknz64 task (arg k) return-value)", "ast": ["call", "getnumqconknz64", "task", ["arg", "k"], "return-value"], "arg-refs": ["k"]}]}], "ais": "function", "api-caml-name": "get-q-con-k", "api-name": "getqconk", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "task-quadratic", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getqconk": {"old-name": "getqconk", "caml-name": "get-q-con-k", "name": "getqconk", "brief": "Obtains all the quadratic terms in a constraint.", "desc": "Obtains all the quadratic terms in a constraint. The quadratic\nterms are stored sequentially in ``qcsubi``, ``qcsubj``, and ``qcval``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Which constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnumqcnz", "brief": "Length of the subscript and coefficient buffers.", "desc": "Length of the arrays ``qcsubi``, ``qcsubj``, and ``qcval``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumqconknz task (arg k) return-value)", "ast": ["call", "getnumqconknz", "task", ["arg", "k"], "return-value"], "arg-refs": ["k"]}]}, {"name": "numqcnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}, {"name": "qcsubi", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqcnz)", "ast": ["arg", "maxnumqcnz"], "arg-refs": ["maxnumqcnz"]}]}, {"name": "qcsubj", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqcnz)", "ast": ["arg", "maxnumqcnz"], "arg-refs": ["maxnumqcnz"]}]}, {"name": "qcval", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqcnz)", "ast": ["arg", "maxnumqcnz"], "arg-refs": ["maxnumqcnz"]}]}], "ais": "function", "api-caml-name": "get-q-con-k", "api-name": "getqconk", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-inspect", "task-quadratic", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getqobj": {"old-name": "getqobj", "caml-name": "get-q-obj", "name": "getqobj", "brief": "Obtains all the quadratic terms in the objective.", "desc": "Obtains the quadratic terms in the objective. The required quadratic terms\nare stored sequentially in ``qosubi``, ``qosubj``, and ``qoval``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumqonz", "brief": "Length of the subscript and coefficient arrays.", "desc": "The length of the arrays ``qosubi``, ``qosubj``, and ``qoval``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumqobjnz task return-value)", "ast": ["call", "getnumqobjnz", "task", "return-value"]}]}, {"name": "numqonz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": false}, {"name": "qosubi", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}, {"name": "qosubj", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}, {"name": "qoval", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}], "ais": "function", "api-caml-name": "get-q-obj", "api-name": "getqobj", "targets": ["c", "cmdln"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getqobj64": {"old-name": "getqobj64", "caml-name": "get-q-obj-64", "name": "getqobj64", "brief": "Obtains all the quadratic terms in the objective.", "desc": "Obtains the quadratic terms in the objective. The required quadratic terms\nare stored sequentially in ``qosubi``, ``qosubj``, and ``qoval``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumqonz", "brief": "Length of the subscript and coefficient arrays.", "desc": "The length of the arrays ``qosubi``, ``qosubj``, and ``qoval``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumqobjnz64 task return-value)", "ast": ["call", "getnumqobjnz64", "task", "return-value"]}]}, {"name": "numqonz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": false}, {"name": "qosubi", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}, {"name": "qosubj", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}, {"name": "qoval", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumqonz)", "ast": ["arg", "maxnumqonz"], "arg-refs": ["maxnumqonz"]}]}], "ais": "function", "api-caml-name": "get-q-obj", "api-name": "getqobj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getnumqobjnz64"]}], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getqobjij": {"old-name": "getqobjij", "caml-name": "get-q-obj-i-j", "name": "getqobjij", "brief": "Obtains one coefficient from the quadratic term of the objective", "desc": "Obtains one coefficient :math:`q_{ij}^o` in the quadratic term of the objective.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Row index of the coefficient.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index of coefficient.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qoij", "brief": "The required coefficient.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-q-obj-i-j", "api-name": "getqobjij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolution": {"old-name": "getsolution", "caml-name": "get-solution", "name": "getsolution", "brief": "Obtains the complete solution.", "desc": "Obtains the complete solution.\n\nConsider the case of linear programming. The primal problem is given by\n\n.. math::\n\n   \\begin{array}{lccccl}\n     \\mbox{minimize}              &      &      & c^T x+c^f &      &        \\\\\n     \\mbox{subject to} &  l^c & \\leq & A x       & \\leq & u^c,     \\\\\n     &  l^x & \\leq & x         & \\leq & u^x.   \\\\\n   \\end{array}\n\n\nand the corresponding dual problem is\n\n.. math::\n\n   \\begin{array}{lccl}\n     \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &  \\\\\n     & + (l^x)^T s_l^x - (u^x)^T s_u^x + c^f &  \\\\\n     \\mbox{subject to} & A^T y + s_l^x - s_u^x                 & = & c, \\\\\n     & -y    + s_l^c - s_u^c                 & = & 0, \\\\\n     & s_l^c,s_u^c,s_l^x,s_u^x \\geq 0.       &   &    \\\\\n   \\end{array}\n\n\nA conic optimization problem has the same primal variables as in the linear case. Recall that the dual of a conic optimization problem is given by:\n\n.. math::\n\n  \\begin{array}{lccccc}\n    \\mbox{maximize}   & (l^c)^T s_l^c - (u^c)^T s_u^c         &      &    \\\\\n    & +(l^x)^T s_l^x - (u^x)^T s_u^x + c^f  &      &    \\\\\n    \\mbox{subject to} & A^T y + s_l^x - s_u^x + s_n^x         & =    & c, \\\\\n    & -y + s_l^c - s_u^c                    & =    & 0, \\\\\n    & s_l^c,s_u^c,s_l^x,s_u^x               & \\geq & 0, \\\\\n    & s_n^x \\in \\K^*                        &      &    \\\\\n  \\end{array}\n\nThe mapping between variables and arguments to the function is as follows:\n\n* ``xx`` : Corresponds to variable :math:`x` (also denoted :math:`x^x`).\n* ``xc`` : Corresponds to :math:`x^c:=Ax`.\n* ``y``  : Corresponds to variable :math:`y`.\n* ``slc``: Corresponds to variable :math:`s_l^c`.\n* ``suc``: Corresponds to variable :math:`s_u^c`.\n* ``slx``: Corresponds to variable :math:`s_l^x`.\n* ``sux``: Corresponds to variable :math:`s_u^x`.\n* ``snx``: Corresponds to variable :math:`s_n^x`.\n\nThe meaning of the values returned by this function depend on the *solution status* returned in the argument ``solsta``. The most important possible values  of ``solsta`` are:\n\n* :msk:const:`solsta.optimal` : An optimal solution satisfying the optimality criteria for continuous problems is returned.\n\n* :msk:const:`solsta.integer_optimal` : An optimal solution satisfying the optimality criteria for integer problems is returned.\n\n* :msk:const:`solsta.prim_feas` : A solution satisfying the feasibility criteria.\n\n* :msk:const:`solsta.prim_infeas_cer` : A primal certificate of infeasibility is returned.\n\n* :msk:const:`solsta.dual_infeas_cer` : A dual certificate of infeasibility is returned.\n\nIn order to retrieve the primal and dual values of semidefinite variables see :msk:func:`task.getbarxj` and :msk:func:`task.getbarsj`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "problemsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "prosta"]], "null?": true, "api?": true}, {"name": "solutionsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "solsta"]], "null?": true, "api?": true}, {"name": "skc", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "skx", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "skn", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcone task return-value)", "ast": ["call", "getnumcone", "task", "return-value"]}]}, {"name": "xc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "xx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "y", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "slc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "suc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "slx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "sux", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "snx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-solution", "api-name": "getsolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsolutionslice"]}], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolutionnew": {"caml-name": "get-solution-new", "name": "getsolutionnew", "brief": "Obtains the complete solution.", "desc": "Obtains the complete solution. See :msk:func:`task.getsolution` for further information.\n\nIn order to retrieve the primal and dual values of semidefinite variables see :msk:func:`task.getbarxj` and :msk:func:`task.getbarsj`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "problemsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "prosta"]], "null?": true, "api?": true}, {"name": "solutionsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "solsta"]], "null?": true, "api?": true}, {"name": "skc", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "skx", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "skn", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcone task return-value)", "ast": ["call", "getnumcone", "task", "return-value"]}]}, {"name": "xc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "xx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "y", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "slc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "suc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "slx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "sux", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "snx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "doty", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-solution-new", "api-name": "getsolutionnew", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsolutionslice"]}], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolsta": {"old-name": "getsolsta", "caml-name": "get-sol-sta", "name": "getsolsta", "brief": "Obtains the solution status.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "solutionsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "solsta"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-sol-sta", "api-name": "getsolsta", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getprosta": {"old-name": "getprosta", "caml-name": "get-pro-sta", "name": "getprosta", "brief": "Obtains the problem status.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "problemsta", "mode": "o", "type": ["ref", ["const-class", "mosek", "prosta"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-pro-sta", "api-name": "getprosta", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getskc": {"old-name": "getskc", "caml-name": "get-skc", "name": "getskc", "brief": "Obtains the status keys for the constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skc", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-skc", "api-name": "getskc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getskcslice"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getskx": {"old-name": "getskx", "caml-name": "get-skx", "name": "getskx", "brief": "Obtains the status keys for the scalar variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skx", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-skx", "api-name": "getskx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getskxslice"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getskn": {"old-name": "getskn", "caml-name": "get-skn", "name": "getskn", "brief": "Obtains the status keys for the conic constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skn", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcone task return-value)", "ast": ["call", "getnumcone", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-skn", "api-name": "getskn", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getskxslice"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getxc": {"old-name": "getxc", "caml-name": "get-xc", "name": "getxc", "brief": "Obtains the xc vector for a solution.", "desc": "Obtains the :math:`x^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "xc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-xc", "api-name": "getxc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getxcslice"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getxx": {"old-name": "getxx", "caml-name": "get-xx", "name": "getxx", "brief": "Obtains the xx vector for a solution.", "desc": "Obtains the :math:`x^x` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "xx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-xx", "api-name": "getxx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getxxslice"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "const"}, "gety": {"old-name": "gety", "caml-name": "get-y", "name": "gety", "brief": "Obtains the y vector for a solution.", "desc": "Obtains the :math:`y` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "y", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-y", "api-name": "gety", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getyslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getslc": {"old-name": "getslc", "caml-name": "get-slc", "name": "getslc", "brief": "Obtains the slc vector for a solution.", "desc": "Obtains the :math:`s_l^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "slc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-slc", "api-name": "getslc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getslcslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccdoty": {"caml-name": "get-acc-dot-y", "name": "getaccdoty", "brief": "Obtains the doty vector for an affine conic constraint.", "desc": "Obtains the :math:`\\dot{y}` vector for a solution (the dual values of an affine conic constraint).", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "accidx", "brief": "The index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "doty", "brief": "The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccn task (arg accidx) return-value)", "ast": ["call", "getaccn", "task", ["arg", "accidx"], "return-value"], "arg-refs": ["accidx"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-dot-y", "api-name": "getaccdoty", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-dual", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccdotys": {"caml-name": "get-acc-dot-y-s", "name": "getaccdotys", "brief": "Obtains the doty vector for a solution.", "desc": "Obtains the :math:`\\dot{y}` vector for a solution (the dual values of all affine conic constraint).", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "doty", "brief": "The dual values of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-acc-dot-y-s", "api-name": "getaccdotys", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-dual", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "evaluateacc": {"caml-name": "evaluate-acc", "name": "evaluateacc", "brief": "Evaluates the activity of an affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "accidx", "brief": "The index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "activity", "brief": "The activity of the affine conic constraint. The array should have length equal to the dimension of the constraint.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccn task (arg accidx) return-value)", "ast": ["call", "getaccn", "task", ["arg", "accidx"], "return-value"], "arg-refs": ["accidx"]}]}], "ais": "function", "api-caml-name": "evaluate-acc", "api-name": "evaluateacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-primal", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "evaluateaccs": {"caml-name": "evaluate-accs", "name": "evaluateaccs", "brief": "Evaluates the activities of all affine conic constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "activity", "brief": "The activity of affine conic constraints. The array should have length equal to the sum of dimensions of all affine conic constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "evaluate-accs", "api-name": "evaluateaccs", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-primal", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsuc": {"old-name": "getsuc", "caml-name": "get-suc", "name": "getsuc", "brief": "Obtains the suc vector for a solution.", "desc": "Obtains the :math:`s_u^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "suc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-suc", "api-name": "getsuc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsucslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getslx": {"old-name": "getslx", "caml-name": "get-slx", "name": "getslx", "brief": "Obtains the slx vector for a solution.", "desc": "Obtains the :math:`s_l^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "slx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-slx", "api-name": "getslx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getslx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsux": {"old-name": "getsux", "caml-name": "get-sux", "name": "getsux", "brief": "Obtains the sux vector for a solution.", "desc": "Obtains the :math:`s_u^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "sux", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-sux", "api-name": "getsux", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsuxslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsnx": {"old-name": "getsnx", "caml-name": "get-snx", "name": "getsnx", "brief": "Obtains the snx vector for a solution.", "desc": "Obtains the :math:`s_n^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "snx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-snx", "api-name": "getsnx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsnxslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getskcslice": {"old-name": "getskcslice", "caml-name": "get-skc-slice", "name": "getskcslice", "brief": "Obtains the status keys for a slice of the constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "skc", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-skc-slice", "api-name": "getskcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getskc"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getskxslice": {"old-name": "getskxslice", "caml-name": "get-skx-slice", "name": "getskxslice", "brief": "Obtains the status keys for a slice of the scalar variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "skx", "mode": "o", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-skx-slice", "api-name": "getskxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getxcslice": {"old-name": "getxcslice", "caml-name": "get-xc-slice", "name": "getxcslice", "brief": "Obtains a slice of the xc vector for a solution.", "desc": "Obtains a slice of the :math:`x^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "xc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-xc-slice", "api-name": "getxcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getxc"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getxxslice": {"old-name": "getxxslice", "caml-name": "get-xx-slice", "name": "getxxslice", "brief": "Obtains a slice of the xx vector for a solution.", "desc": "Obtains a slice of the :math:`x^x` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "xx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-xx-slice", "api-name": "getxxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getxx"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getyslice": {"old-name": "getyslice", "caml-name": "get-y-slice", "name": "getyslice", "brief": "Obtains a slice of the y vector for a solution.", "desc": "Obtains a slice of the :math:`y` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "y", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-y-slice", "api-name": "getyslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "gety"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getslcslice": {"old-name": "getslcslice", "caml-name": "get-slc-slice", "name": "getslcslice", "brief": "Obtains a slice of the slc vector for a solution.", "desc": "Obtains a slice of the :math:`s_l^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-slc-slice", "api-name": "getslcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getslc"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsucslice": {"old-name": "getsucslice", "caml-name": "get-suc-slice", "name": "getsucslice", "brief": "Obtains a slice of the suc vector for a solution.", "desc": "Obtains a slice of the :math:`s_u^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "suc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-suc-slice", "api-name": "getsucslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsuc"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getslxslice": {"old-name": "getslxslice", "caml-name": "get-slx-slice", "name": "getslxslice", "brief": "Obtains a slice of the slx vector for a solution.", "desc": "Obtains a slice of the :math:`s_l^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-slx-slice", "api-name": "getslxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getslx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsuxslice": {"old-name": "getsuxslice", "caml-name": "get-sux-slice", "name": "getsuxslice", "brief": "Obtains a slice of the sux vector for a solution.", "desc": "Obtains a slice of the :math:`s_u^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sux", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-sux-slice", "api-name": "getsuxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsux"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsnxslice": {"old-name": "getsnxslice", "caml-name": "get-snx-slice", "name": "getsnxslice", "brief": "Obtains a slice of the snx vector for a solution.", "desc": "Obtains a slice of the :math:`s_n^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "snx", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-snx-slice", "api-name": "getsnxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsnx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarxj": {"caml-name": "get-barx-j", "name": "getbarxj", "brief": "Obtains the primal solution for a semidefinite variable.", "desc": "Obtains the primal solution for a semidefinite variable. Only the lower triangular part of :math:`\\barX_j` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the semidefinite variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barxj", "brief": "Value of the j'th variable of barx.", "desc": "Value of :math:`\\barX_j`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getlenbarvarj task (arg j) return-value)", "ast": ["call", "getlenbarvarj", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-barx-j", "api-name": "getbarxj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarxslice": {"caml-name": "get-barx-slice", "name": "getbarxslice", "brief": "Obtains the primal solution for a sequence of semidefinite variables.", "desc": "Obtains the primal solution for a sequence of semidefinite variables. The format is that matrices are stored sequentially, and in each matrix the columns are stored as in :msk:func:`task.getbarxj`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "brief": "Index of the first semidefinite variable in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last semidefinite variable in the slice plus one.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slicesize", "brief": "Denotes the length of the array barxslice.", "desc": "Denotes the length of the array ``barxslice``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "barxslice", "brief": "Solution values of symmetric matrix variables in the slice, stored sequentially.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg slicesize)", "ast": ["arg", "slicesize"], "arg-refs": ["slicesize"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-barx-slice", "api-name": "getbarxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarsj": {"old-name": "getbarsj", "caml-name": "get-bars-j", "name": "getbarsj", "brief": "Obtains the dual solution for a semidefinite variable.", "desc": "Obtains the dual solution for a semidefinite variable. Only the lower triangular part of :math:`\\barS_j` is returned because the matrix by construction is symmetric. The format is that the columns are stored sequentially in the natural order.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the semidefinite variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barsj", "brief": "Value of the j'th dual variable of barx.", "desc": "Value of :math:`\\barS_j`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getlenbarvarj task (arg j) return-value)", "ast": ["call", "getlenbarvarj", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-bars-j", "api-name": "getbarsj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarsslice": {"caml-name": "get-bars-slice", "name": "getbarsslice", "brief": "Obtains the dual solution for a sequence of semidefinite variables.", "desc": "Obtains the dual solution for a sequence of semidefinite variables. The format is that matrices are stored sequentially, and in each matrix the columns are stored as in :msk:func:`task.getbarsj`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "brief": "Index of the first semidefinite variable in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Index of the last semidefinite variable in the slice plus one.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slicesize", "brief": "Denotes the length of the array barsslice.", "desc": "Denotes the length of the array ``barsslice``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "barsslice", "brief": "Dual solution values of symmetric matrix variables in the slice, stored sequentially.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg slicesize)", "ast": ["arg", "slicesize"], "arg-refs": ["slicesize"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-bars-slice", "api-name": "getbarsslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putskc": {"old-name": "putskc", "caml-name": "put-skc", "name": "putskc", "brief": "Sets the status keys for the constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-skc", "api-name": "putskc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putskcslice"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putskx": {"old-name": "putskx", "caml-name": "put-skx", "name": "putskx", "brief": "Sets the status keys for the scalar variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-skx", "api-name": "putskx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putskxslice"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putxc": {"old-name": "putxc", "caml-name": "put-xc", "name": "putxc", "brief": "Sets the xc vector for a solution.", "desc": "Sets the :math:`x^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "xc", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-xc", "api-name": "putxc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putxcslice"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putxx": {"caml-name": "put-xx", "name": "putxx", "brief": "Sets the xx vector for a solution.", "desc": "Sets the :math:`x^x` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "xx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-xx", "api-name": "putxx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putxxslice"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "puty": {"old-name": "puty", "caml-name": "put-y", "name": "puty", "brief": "Sets the y vector for a solution.", "desc": "Sets the :math:`y` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "y", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-y", "api-name": "puty", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putyslice"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putslc": {"old-name": "putslc", "caml-name": "put-slc", "name": "putslc", "brief": "Sets the slc vector for a solution.", "desc": "Sets the :math:`s_l^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "slc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-slc", "api-name": "putslc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putslcslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsuc": {"old-name": "putsuc", "caml-name": "put-suc", "name": "putsuc", "brief": "Sets the suc vector for a solution.", "desc": "Sets the :math:`s_u^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "suc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-suc", "api-name": "putsuc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsucslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putslx": {"old-name": "putslx", "caml-name": "put-slx", "name": "putslx", "brief": "Sets the slx vector for a solution.", "desc": "Sets the :math:`s_l^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "slx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-slx", "api-name": "putslx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putslx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsux": {"old-name": "putsux", "caml-name": "put-sux", "name": "putsux", "brief": "Sets the sux vector for a solution.", "desc": "Sets the :math:`s_u^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "sux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-sux", "api-name": "putsux", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsuxslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsnx": {"old-name": "putsnx", "caml-name": "put-snx", "name": "putsnx", "brief": "Sets the snx vector for a solution.", "desc": "Sets the :math:`s_n^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "sux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "put-snx", "api-name": "putsnx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsnxslice"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaccdoty": {"caml-name": "put-acc-dot-y", "name": "putaccdoty", "brief": "Puts the doty vector for a solution.", "desc": "Puts the :math:`\\dot{y}` vector for a solution (the dual values of an affine conic constraint).", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "accidx", "brief": "The index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "doty", "brief": "The dual values for this affine conic constraint. The array should have length equal to the dimension of the constraint.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccn task (arg accidx) return-value)", "ast": ["call", "getaccn", "task", ["arg", "accidx"], "return-value"], "arg-refs": ["accidx"]}]}], "ais": "function", "api-caml-name": "put-acc-dot-y", "api-name": "putaccdoty", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-dual", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putskcslice": {"old-name": "putskcslice", "caml-name": "put-skc-slice", "name": "putskcslice", "brief": "Sets the status keys for a slice of the constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "skc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-skc-slice", "api-name": "putskcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putskc"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putskxslice": {"old-name": "putskxslice", "caml-name": "put-skx-slice", "name": "putskxslice", "brief": "Sets the status keys for a slice of the variables.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "skx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-skx-slice", "api-name": "putskxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putxcslice": {"old-name": "putxcslice", "caml-name": "put-xc-slice", "name": "putxcslice", "brief": "Sets a slice of the xc vector for a solution.", "desc": "Sets a slice of the :math:`x^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "xc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-xc-slice", "api-name": "putxcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putxc"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putxxslice": {"old-name": "putxxslice", "caml-name": "put-xx-slice", "name": "putxxslice", "brief": "Sets a slice of the xx vector for a solution.", "desc": "Sets a slice of the :math:`x^x` vector for a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "xx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-xx-slice", "api-name": "putxxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putxx"]}], "member-of": ["solution-primal"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putyslice": {"old-name": "putyslice", "caml-name": "put-y-slice", "name": "putyslice", "brief": "Sets a slice of the y vector for a solution.", "desc": "Sets a slice of the :math:`y` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "y", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-y-slice", "api-name": "putyslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "puty"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putslcslice": {"old-name": "putslcslice", "caml-name": "put-slc-slice", "name": "putslcslice", "brief": "Sets a slice of the slc vector for a solution.", "desc": "Sets a slice of the :math:`s_l^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-slc-slice", "api-name": "putslcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putslc"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsucslice": {"old-name": "putsucslice", "caml-name": "put-suc-slice", "name": "putsucslice", "brief": "Sets a slice of the suc vector for a solution.", "desc": "Sets a slice of the :math:`s_u^c` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "suc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-suc-slice", "api-name": "putsucslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsuc"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putslxslice": {"old-name": "putslxslice", "caml-name": "put-slx-slice", "name": "putslxslice", "brief": "Sets a slice of the slx vector for a solution.", "desc": "Sets a slice of the :math:`s_l^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-slx-slice", "api-name": "putslxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putslx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsuxslice": {"old-name": "putsuxslice", "caml-name": "put-sux-slice", "name": "putsuxslice", "brief": "Sets a slice of the sux vector for a solution.", "desc": "Sets a slice of the :math:`s_u^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-sux-slice", "api-name": "putsuxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsux"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsnxslice": {"old-name": "putsnxslice", "caml-name": "put-snx-slice", "name": "putsnxslice", "brief": "Sets a slice of the snx vector for a solution.", "desc": "Sets a slice of the :math:`s_n^x` vector for a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "snx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-snx-slice", "api-name": "putsnxslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putsnx"]}], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbarxj": {"old-name": "putbarxj", "caml-name": "put-barx-j", "name": "putbarxj", "brief": "Sets the primal solution for a semidefinite variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the semidefinite variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barxj", "brief": "Value of the j'th variable of barx.", "desc": "Value of :math:`\\barX_j`. Format as in :msk:func:`task.getbarxj`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getlenbarvarj task (arg j) return-value)", "ast": ["call", "getlenbarvarj", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}]}], "ais": "function", "api-caml-name": "put-barx-j", "api-name": "putbarxj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbarsj": {"old-name": "putbarsj", "caml-name": "put-bars-j", "name": "putbarsj", "brief": "Sets the dual solution for a semidefinite variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "j", "brief": "Index of the semidefinite variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barsj", "brief": "Value of the j'th variable of barx.", "desc": "Value of :math:`\\barS_j`. Format as in :msk:func:`task.getbarsj`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getlenbarvarj task (arg j) return-value\n                         )", "ast": ["call", "getlenbarvarj", "task", ["arg", "j"], "return-value"], "arg-refs": ["j"]}]}], "ais": "function", "api-caml-name": "put-bars-j", "api-name": "putbarsj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-barvar"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getpviolcon": {"caml-name": "get-pviol-con", "name": "getpviolcon", "brief": "Computes the violation of a primal solution associated to a constraint.", "desc": "Computes the primal solution violation for a set of constraints.\nThe primal violation of the solution associated with the :math:`i`-th constraint is given by\n\n.. math:: \\max(\\tau l_i^c - (x_i^c)^*,\\ (x_i^c)^* - \\tau u_i^c),\\ |\\sum_{j=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} a_{ij} x_j^* - x_i^c|)\n\n\nwhere :math:`\\tau=0` if the solution is a certificate of\ndual infeasibility and :math:`\\tau=1` otherwise. Both when\nthe solution is a certificate of dual infeasibility and when it is primal\nfeasible the violation should be small. The above formula applies for\nthe linear case but is appropriately generalized in other cases.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation associated with the solution for the constraint ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-pviol-con", "api-name": "getpviolcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpviolvar": {"caml-name": "get-pviol-var", "name": "getpviolvar", "brief": "Computes the violation of a primal solution for a list of scalar variables.", "desc": "Computes the primal solution violation associated to a set of variables.\nLet :math:`x_j^*` be the value of :math:`x_j` for the specified\nsolution.  Then the primal violation of the solution associated with variable\n:math:`x_j` is given by\n\n.. math:: \\max( \\tau l_j^x - x_j^*,\\ x_j^* - \\tau u_j^x,\\ 0).\n\nwhere :math:`\\tau=0` if the solution is a certificate of\ndual infeasibility and :math:`\\tau=1` otherwise. Both when\nthe solution is a certificate of dual infeasibility and when it is primal\nfeasible the violation should be small.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of x variables.", "desc": "An array of indexes of :math:`x` variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation associated with the solution for the variable :math:`x_\\mathtt{sub[k]}`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-pviol-var", "api-name": "getpviolvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpviolbarvar": {"caml-name": "get-pviol-barvar", "name": "getpviolbarvar", "brief": "Computes the violation of a primal solution for a list of semidefinite variables.", "desc": "Computes the primal solution violation for a set of semidefinite variables.\nLet :math:`(\\barX_j)^*` be the value of the variable :math:`\\barX_j` for the\nspecified solution.  Then the primal violation of the solution associated with\nvariable :math:`\\barX_j` is given by\n\n.. math:: \\max(-\\lambda_{\\min}(\\barX_j),\\ 0.0).\n\nBoth when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of barX variables.", "desc": "An array of indexes of :math:`\\barX` variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is how much the solution violates the constraint :math:`\\barX_{\\mathtt{sub}[k]} \\in \\PSD`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-pviol-barvar", "api-name": "getpviolbarvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpviolcones": {"caml-name": "get-pviol-cones", "name": "getpviolcones", "brief": "Computes the violation of a solution for set of conic constraints.", "desc": "|deprecate-cones-v10|\n\nComputes the primal solution violation for a set of conic constraints.\nLet :math:`x^*` be the value of the variable :math:`x` for the specified solution.\nFor simplicity let us assume that :math:`x` is a member of a quadratic cone, then\nthe violation is computed as follows\n\n.. math::\n\n  \\left\\{\n    \\begin{array}{ll}\n      \\max(0,\\|x_{2:n}\\|-x_1) / \\sqrt{2}, & x_1 \\geq -\\|x_{2:n}\\|, \\\\\n      \\|x\\|, & \\mbox{otherwise.}\n    \\end{array}\n  \\right.\n\nBoth when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of conic constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the solution associated with the conic constraint number ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-pviol-cones", "api-name": "getpviolcones", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpviolacc": {"caml-name": "get-pviol-acc", "name": "getpviolacc", "brief": "Computes the violation of a solution for set of affine conic constraints.", "desc": "Computes the primal solution violation for a set of affine conic constraints.\nLet :math:`x^*` be the value of the variable :math:`x` for the specified solution.\nFor simplicity let us assume that :math:`x` is a member of a quadratic cone, then\nthe violation is computed as follows\n\n.. math::\n\n  \\left\\{\n    \\begin{array}{ll}\n      \\max(0,\\|x_{2:n}\\|-x_1) / \\sqrt{2}, & x_1 \\geq -\\|x_{2:n}\\|, \\\\\n      \\|x\\|, & \\mbox{otherwise.}\n    \\end{array}\n  \\right.\n\nBoth when the solution is a certificate of dual infeasibility or when it is primal feasible the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "numaccidx", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["accidxlist"]}]}, {"name": "accidxlist", "brief": "An array of indexes of conic constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the solution associated with the affine conic constraint number ``accidxlist[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numaccidx)", "ast": ["arg", "numaccidx"], "arg-refs": ["numaccidx"]}]}], "ais": "function", "api-caml-name": "get-pviol-acc", "api-name": "getpviolacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpvioldjc": {"caml-name": "get-pviol-djc", "name": "getpvioldjc", "brief": "Computes the violation of a solution for set of disjunctive constraints.", "desc": "Computes the primal solution violation for a set of disjunctive constraints. For a single DJC the violation is defined as\n\n.. math:: \\mathrm{viol}\\left(\\bigvee_{i=1}^t \\bigwedge_{j=1}^{s_i} T_{i,j}\\right) = \\min_{i=1,\\ldots,t}\\left(\\max_{j=1,\\ldots,s_j}(\\mathrm{viol}(T_{i,j}))\\right)\n\nwhere the violation of each simple term :math:`T_{i,j}` is defined as for an ordinary linear constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "numdjcidx", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["djcidxlist"]}]}, {"name": "djcidxlist", "brief": "An array of indexes of disjunctive constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the solution associated with the disjunctive constraint number ``djcidxlist[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numdjcidx)", "ast": ["arg", "numdjcidx"], "arg-refs": ["numdjcidx"]}]}], "ais": "function", "api-caml-name": "get-pviol-djc", "api-name": "getpvioldjc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdviolcon": {"caml-name": "get-dviol-con", "name": "getdviolcon", "brief": "Computes the violation of a dual solution associated with a set of constraints.", "desc": "The violation of the dual solution associated with the :math:`i`-th constraint\nis computed as follows\n\n.. math:: \\max( \\rho( (s_l^c)_i^*,(b_l^c)_i ),\\ \\rho( (s_u^c)_i^*, -(b_u^c)_i ),\\ |-y_i+(s_l^c)_i^*-(s_u^c)_i^*| )\n\nwhere\n\n.. math::\n\n    \\rho(x,l) =\n      \\left\\{\n        \\begin{array}{ll}\n           -x,   & l > -\\infty , \\\\\n           |x|, &  \\mbox{otherwise}.\\\\\n        \\end{array}\n      \\right.\n\nBoth when the solution is a certificate of primal infeasibility or it is a dual feasible solution the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of dual solution associated with the constraint ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-dviol-con", "api-name": "getdviolcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdviolvar": {"caml-name": "get-dviol-var", "name": "getdviolvar", "brief": "Computes the violation of a dual solution associated with a set of scalar variables.", "desc": "The violation of the dual solution associated with the :math:`j`-th variable is\ncomputed as follows\n\n.. math:: \\max \\left(\\rho((s_l^x)_j^*,(b_l^x)_j),\\ \\rho((s_u^x)_j^*,-(b_u^x)_j),\\ |\\sum_{i=\\idxbeg}^{\\idxend{\\mathtt{numcon}}} a_{ij} y_i+(s_l^x)_j^*-(s_u^x)_j^* - \\tau c_j| \\right)\n\nwhere\n\n.. math::\n\n  \\rho(x,l) =\n    \\left\\{\n      \\begin{array}{ll}\n         -x,   & l > -\\infty , \\\\\n         |x|, &  \\mbox{otherwise}\n      \\end{array}\n    \\right.\n\n\nand :math:`\\tau=0` if the solution is a certificate of primal infeasibility and :math:`\\tau=1` otherwise. The formula for computing the violation is only shown\nfor the linear case but is generalized appropriately for the more general problems. Both when the solution is a certificate of primal infeasibility or when it is a dual feasible solution the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of x variables.", "desc": "An array of indexes of :math:`x` variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of dual solution associated with the variable ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-dviol-var", "api-name": "getdviolvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdviolbarvar": {"caml-name": "get-dviol-barvar", "name": "getdviolbarvar", "brief": "Computes the violation of dual solution for a set of semidefinite variables.", "desc": "Let :math:`(\\barS_j)^*` be the value of variable :math:`\\barS_j` for the\nspecified solution.  Then the dual violation of the solution associated with\nvariable :math:`\\barS_j` is given by\n\n.. math:: \\max(-\\lambda_{\\min}(\\barS_j),\\ 0.0).\n\nBoth when the solution is a certificate of primal infeasibility and when it is\ndual feasible solution the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of barx variables.", "desc": "An array of indexes of :math:`\\barX` variables.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the solution for the constraint :math:`\\barS_{\\mathtt{sub}[k]} \\in \\PSD`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-dviol-barvar", "api-name": "getdviolbarvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdviolcones": {"caml-name": "get-dviol-cones", "name": "getdviolcones", "brief": "Computes the violation of a solution for set of dual conic constraints.", "desc": "|deprecate-cones-v10|\n\nLet :math:`(s_n^x)^*` be the value of variable :math:`(s_n^x)` for the\nspecified solution. For simplicity let us assume that :math:`s_n^x` is a member\nof a quadratic cone, then the violation is computed as follows\n\n.. math::\n\n    \\left\\{\n      \\begin{array}{ll}\n        \\max(0,(\\|s_n^x\\|_{2:n}^*-(s_n^x)_1^*) / \\sqrt{2}, & (s_n^x)^* \\geq -\\|(s_n^x)_{2:n}^*\\|, \\\\\n        \\|(s_n^x)^*\\|, & \\mbox{otherwise.}\n      \\end{array}\n    \\right.\n\nBoth when the solution is a certificate of primal infeasibility or when it is a\ndual feasible solution the violation should be small.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "num", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "An array of indexes of conic constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the dual solution associated with the conic constraint ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-dviol-cones", "api-name": "getdviolcones", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdviolacc": {"caml-name": "get-dviol-acc", "name": "getdviolacc", "brief": "Computes the violation of the dual solution for set of affine conic constraints.", "desc": "Let :math:`(s_n^x)^*` be the value of variable :math:`(s_n^x)` for the\nspecified solution. For simplicity let us assume that :math:`s_n^x` is a member\nof a quadratic cone, then the violation is computed as follows\n\n.. math::\n\n    \\left\\{\n      \\begin{array}{ll}\n        \\max(0,(\\|s_n^x\\|_{2:n}^*-(s_n^x)_1^*) / \\sqrt{2}, & (s_n^x)^* \\geq -\\|(s_n^x)_{2:n}^*\\|, \\\\\n        \\|(s_n^x)^*\\|, & \\mbox{otherwise.}\n      \\end{array}\n    \\right.\n\nBoth when the solution is a certificate of primal infeasibility or when it is a\ndual feasible solution the violation should be small.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "numaccidx", "brief": "Length of sub and viol.", "desc": "Length of ``sub`` and ``viol``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["accidxlist"]}]}, {"name": "accidxlist", "brief": "An array of indexes of conic constraints.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "viol", "brief": "List of violations corresponding to sub.", "desc": "``viol[k]`` is the violation of the dual solution associated with the conic constraint ``sub[k]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numaccidx)", "ast": ["arg", "numaccidx"], "arg-refs": ["numaccidx"]}]}], "ais": "function", "api-caml-name": "get-dviol-acc", "api-name": "getdviolacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolutioninfo": {"caml-name": "get-solution-info", "name": "getsolutioninfo", "brief": "Obtains information about of a solution.", "desc": "Obtains information about a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "pobj", "brief": "The primal objective value.", "desc": "The primal objective value as computed by :msk:func:`task.getprimalobj`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolcon", "brief": "Maximal primal bound violation for a xc variable.", "desc": "Maximal primal violation of the solution associated with the :math:`x^c` variables where the violations are computed by :msk:func:`task.getpviolcon`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolvar", "brief": "Maximal primal bound violation for a xx variable.", "desc": "Maximal primal violation of the solution for the :math:`x` variables where the violations are computed by :msk:func:`task.getpviolvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolbarvar", "brief": "Maximal primal bound violation for a barx variable.", "desc": "Maximal primal violation of solution for the :math:`\\barX` variables where the violations are computed by :msk:func:`task.getpviolbarvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolcone", "brief": "Maximal primal violation of the solution with respect to the conic constraints.", "desc": "Maximal primal violation of solution for the conic constraints where the violations are computed by :msk:func:`?task.getpviolcones`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolitg", "brief": "Maximal violation in the integer constraints.", "desc": "Maximal violation in the integer constraints. The violation for an integer variable :math:`x_j` is given by :math:`\\min(x_j-\\lfloor x_j \\rfloor,\\lceil x_j \\rceil - x_j)`. This number is always zero for the interior-point and basic solutions.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dobj", "brief": "Dual objective value.", "desc": "Dual objective value as computed by :msk:func:`task.getdualobj`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolcon", "brief": "Maximal dual bound violation for a xc variable.", "desc": "Maximal violation of the dual solution associated with the :math:`x^c` variable as computed by :msk:func:`task.getdviolcon`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolvar", "brief": "Maximal dual bound violation for a xx variable.", "desc": "Maximal violation of the dual solution associated with the :math:`x` variable as computed by :msk:func:`task.getdviolvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolbarvar", "brief": "Maximal dual bound violation for a bars variable.", "desc": "Maximal violation of the dual solution associated with the :math:`\\barS` variable as computed by :msk:func:`task.getdviolbarvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolcone", "brief": "Maximum violation of the dual solution in the dual conic constraints.", "desc": "Maximal violation of the dual solution associated with the dual conic constraints as computed by :msk:func:`?task.getdviolcones`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-solution-info", "api-name": "getsolutioninfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsolsta"]}, {"type": "function", "item": ["mosek", "task", "getprimalobj"]}, {"type": "function", "item": ["mosek", "task", "getpviolcon"]}, {"type": "function", "item": ["mosek", "task", "getpviolvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolcones"]}, {"type": "function", "item": ["mosek", "task", "getdualobj"]}, {"type": "function", "item": ["mosek", "task", "getdviolcon"]}, {"type": "function", "item": ["mosek", "task", "getdviolvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolcones"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolutioninfonew": {"caml-name": "get-solution-info-new", "name": "getsolutioninfonew", "brief": "Obtains information about of a solution.", "desc": "Obtains information about a solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "pobj", "brief": "The primal objective value.", "desc": "The primal objective value as computed by :msk:func:`task.getprimalobj`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolcon", "brief": "Maximal primal bound violation for a xc variable.", "desc": "Maximal primal violation of the solution associated with the :math:`x^c` variables where the violations are computed by :msk:func:`task.getpviolcon`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolvar", "brief": "Maximal primal bound violation for a xx variable.", "desc": "Maximal primal violation of the solution for the :math:`x` variables where the violations are computed by :msk:func:`task.getpviolvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolbarvar", "brief": "Maximal primal bound violation for a barx variable.", "desc": "Maximal primal violation of solution for the :math:`\\barX` variables where the violations are computed by :msk:func:`task.getpviolbarvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolcone", "brief": "Maximal primal violation of the solution with respect to the conic constraints.", "desc": "Maximal primal violation of solution for the conic constraints where the violations are computed by :msk:func:`?task.getpviolcones`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolacc", "brief": "Maximal primal violation of the solution with respect to the affine conic constraints.", "desc": "Maximal primal violation of solution for the affine conic constraints where the violations are computed by :msk:func:`task.getpviolacc`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pvioldjc", "brief": "Maximal primal violation of the solution with respect to the disjunctive constraints.", "desc": "Maximal primal violation of solution for the disjunctive constraints where the violations are computed by :msk:func:`task.getpvioldjc`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "pviolitg", "brief": "Maximal violation in the integer constraints.", "desc": "Maximal violation in the integer constraints. The violation for an integer variable :math:`x_j` is given by :math:`\\min(x_j-\\lfloor x_j \\rfloor,\\lceil x_j \\rceil - x_j)`. This number is always zero for the interior-point and basic solutions.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dobj", "brief": "Dual objective value.", "desc": "Dual objective value as computed by :msk:func:`task.getdualobj`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolcon", "brief": "Maximal dual bound violation for a xc variable.", "desc": "Maximal violation of the dual solution associated with the :math:`x^c` variable as computed by :msk:func:`task.getdviolcon`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolvar", "brief": "Maximal dual bound violation for a xx variable.", "desc": "Maximal violation of the dual solution associated with the :math:`x` variable as computed by :msk:func:`task.getdviolvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolbarvar", "brief": "Maximal dual bound violation for a bars variable.", "desc": "Maximal violation of the dual solution associated with the :math:`\\barS` variable as computed by :msk:func:`task.getdviolbarvar`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolcone", "brief": "Maximum violation of the dual solution in the dual conic constraints.", "desc": "Maximal violation of the dual solution associated with the dual conic constraints as computed by :msk:func:`?task.getdviolcones`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "dviolacc", "brief": "Maximum violation of the dual solution in the dual affine conic constraints.", "desc": "Maximal violation of the dual solution associated with the affine conic constraints as computed by :msk:func:`task.getdviolacc`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-solution-info-new", "api-name": "getsolutioninfonew", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsolsta"]}, {"type": "function", "item": ["mosek", "task", "getprimalobj"]}, {"type": "function", "item": ["mosek", "task", "getpviolcon"]}, {"type": "function", "item": ["mosek", "task", "getpviolvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getpviolcones"]}, {"type": "function", "item": ["mosek", "task", "getdualobj"]}, {"type": "function", "item": ["mosek", "task", "getdviolcon"]}, {"type": "function", "item": ["mosek", "task", "getdviolvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolbarvar"]}, {"type": "function", "item": ["mosek", "task", "getdviolcones"]}], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdualsolutionnorms": {"caml-name": "get-dual-solution-norms", "name": "getdualsolutionnorms", "brief": "Compute norms of the dual solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "nrmy", "brief": "The norm of the y vector.", "desc": "The norm of the :math:`y` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmslc", "brief": "The norm of the slc vector.", "desc": "The norm of the :math:`s_l^c` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmsuc", "brief": "The norm of the suc vector.", "desc": "The norm of the :math:`s_u^c` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmslx", "brief": "The norm of the slx vector.", "desc": "The norm of the :math:`s_l^x` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmsux", "brief": "The norm of the sux vector.", "desc": "The norm of the :math:`s_u^x` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmsnx", "brief": "The norm of the snx vector.", "desc": "The norm of the :math:`s_n^x` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmbars", "brief": "The norm of the bars vector.", "desc": "The norm of the :math:`\\barS` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-dual-solution-norms", "api-name": "getdualsolutionnorms", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getprimalsolutionnorms": {"caml-name": "get-primal-solution-norms", "name": "getprimalsolutionnorms", "brief": "Compute norms of the primal solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "nrmxc", "brief": "The norm of the xc vector.", "desc": "The norm of the :math:`x^c` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmxx", "brief": "The norm of the xx vector.", "desc": "The norm of the :math:`x` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "nrmbarx", "brief": "The norm of the barX vector.", "desc": "The norm of the :math:`\\barX` vector.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-primal-solution-norms", "api-name": "getprimalsolutionnorms", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsolutionslice": {"old-name": "getsolutionslice", "caml-name": "get-solution-slice", "name": "getsolutionslice", "brief": "Obtains a slice of the solution.", "desc": "Obtains a slice of one item from the solution. The format of the solution is exactly as in :msk:func:`task.getsolution`. The parameter ``solitem`` determines which of the solution vectors should be returned.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "solitem", "mode": "i", "type": ["const-class", "mosek", "solitem"], "null?": false, "api?": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "values", "brief": "The values of the requested solution elements.", "desc": "The values in the required sequence are stored sequentially in ``values``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-solution-slice", "api-name": "getsolutionslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getsolution"]}], "member-of": ["solution-primal", "solution-dual", "solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getreducedcosts": {"old-name": "getreducedcosts", "caml-name": "get-reduced-costs", "name": "getreducedcosts", "brief": "Obtains the reduced costs for a sequence of variables.", "desc": "Computes the reduced costs for a slice of variables and returns them in the array ``redcosts`` i.e.\n\n.. math::\n    :label: ais-eq-redcost\n\n    \\mathtt{redcosts} = \\left[ (s_l^x)_j-(s_u^x)_j, ~j=\\mathtt{first},\\ldots,\\mathtt{last}-1 \\right]", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "first", "brief": "The index of the first variable in the sequence.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "The index of the last variable in the sequence plus 1.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "redcosts", "brief": "Returns the requested reduced costs.", "desc": "The reduced costs for the required slice of variables.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-reduced-costs", "api-name": "getreducedcosts", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-dual"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getstrparam": {"old-name": "getstrparam", "caml-name": "get-str-param", "name": "getstrparam", "brief": "Obtains the value of a string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "sparam"], "null?": false, "api?": true}, {"name": "maxlen", "brief": "Length of the parvalue buffer.", "desc": "Length of the ``parvalue`` buffer.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call getstrparamlen task (arg param) return-value))", "ast": ["+", "1", ["call", "getstrparamlen", "task", ["arg", "param"], "return-value"]], "arg-refs": ["param"]}]}, {"name": "len", "brief": "The length of the parameter value.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "parvalue", "brief": "If this is not a null pointer, the parameter value is stored here.", "desc": "Parameter value.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxlen)", "ast": ["arg", "maxlen"], "arg-refs": ["maxlen"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-str-param", "api-name": "getstrparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming", "parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getstrparamlen": {"old-name": "getstrparamlen", "caml-name": "get-str-param-len", "name": "getstrparamlen", "brief": "Obtains the length of a string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "sparam"], "null?": false, "api?": true}, {"name": "len", "brief": "The length of the parameter value.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-str-param-len", "api-name": "getstrparamlen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming", "parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getstrparamal": {"old-name": "getstrparamal", "caml-name": "get-str-param-al", "name": "getstrparamal", "brief": "Obtains the value of a string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "sparam"], "null?": false, "api?": true}, {"name": "numaddchr", "brief": "Extra capacity of the return string buffer.", "desc": "Number of additional characters for which room is left in ``value``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "value", "brief": "Parameter value.", "desc": "Parameter value. |mosek| will allocate this char buffer of size equal to the actual length of the string parameter plus ``numaddchr``. This memory must be freed by :msk:func:`task.freetask`.", "mode": "io", "type": ["ref", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-str-param-al", "api-name": "getstrparamal", "targets": ["c", "cmdln"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnastrparamal": {"old-name": "getnastrparamal", "caml-name": "get-na-str-param-al", "name": "getnastrparamal", "brief": "Obtains the value of a named string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "numaddchr", "brief": "Extra capacity of the return string buffer.", "desc": "Number of additional characters for which room is left in ``value``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "value", "brief": "Parameter value.", "desc": "Parameter value. |mosek| will allocate this char buffer of size equal to the actual length of the string parameter plus ``numaddchr``. This memory must be freed by :msk:func:`task.freetask`.", "mode": "o", "type": ["ref", ["defined", "mosek", "string_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-na-str-param-al", "api-name": "getnastrparamal", "targets": ["c", "cmdln"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsymbcon": {"old-name": "getsymbcon", "caml-name": "get-symb-con", "name": "getsymbcon", "brief": "Obtains a cone type string identifier.", "desc": "Obtains the name and corresponding value for the :math:`i`\\ th symbolic constant.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "sizevalue", "brief": "The length of the value buffer.", "desc": "The length of the buffer pointed to by the ``value`` argument.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}, {"name": "name", "brief": "Name of the i'th symbolic constant.", "desc": "Name of the :math:`i`\\ th symbolic constant.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}, {"name": "value", "brief": "The corresponding value.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-symb-con", "api-name": "getsymbcon", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "gettasknamelen": {"old-name": "gettasknamelen", "caml-name": "get-task-name-len", "name": "gettasknamelen", "brief": "Obtains the length the task name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "len", "brief": "Returns the length of the task name.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-task-name-len", "api-name": "gettasknamelen", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getbarvarname"]}], "member-of": ["naming", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "gettaskname": {"caml-name": "get-task-name", "name": "gettaskname", "brief": "Obtains the task name.", "desc": "Obtains the name assigned to the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "sizetaskname", "brief": "Length of the taskname buffer.", "desc": "Length of the ``taskname`` buffer.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ 1 (call gettasknamelen task return-value))", "ast": ["+", "1", ["call", "gettasknamelen", "task", "return-value"]]}]}, {"name": "taskname", "brief": "Returns the task name.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizetaskname)", "ast": ["arg", "sizetaskname"], "arg-refs": ["sizetaskname"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-task-name", "api-name": "gettaskname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmionumthreads": {"old-name": "getmionumthreads", "caml-name": "get-mio-num-threads", "name": "getmionumthreads", "brief": "Obtains the number of threads used by the mixed integer optimizer.", "desc": "Obtains the number of threads used by the mixed integer optimizer.  If\n:msk:iparam:`num_threads` is set to zero this function will return the number\nof cores on the system. Otherwise it return the value of\n:msk:iparam:`num_threads`.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numthreads", "brief": "The number of threads.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-mio-num-threads", "api-name": "getmionumthreads", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvartype": {"old-name": "getvartype", "caml-name": "get-var-type", "name": "getvartype", "brief": "Gets the variable type of one variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "vartype", "brief": "Variable type of variable index j.", "desc": "Variable type of the :math:`j`-th variable.", "mode": "o", "type": ["ref", ["const-class", "mosek", "variabletype"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-var-type", "api-name": "getvartype", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getvartypelist": {"old-name": "getvartypelist", "caml-name": "get-var-type-list", "name": "getvartypelist", "brief": "Obtains the variable type for one or more variables.", "desc": "Obtains the variable type of one or more variables. Upon return ``vartype[k]`` is the variable type of variable ``subj[k]``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variables for which the variable type should be obtained.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subj"]}]}, {"name": "subj", "brief": "A list of variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "vartype", "brief": "Returns the variables types corresponding the variable indexes requested.", "desc": "The variables types corresponding to the variables specified by ``subj``.", "mode": "o", "type": ["ptr", ["const-class", "mosek", "variabletype"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "get-var-type-list", "api-name": "getvartypelist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "const"}, "inputdata": {"old-name": "inputdata", "caml-name": "input-data", "name": "inputdata", "brief": "Input the linear part of an optimization task in one function call.", "desc": "Input the linear part of an optimization problem.\n\nThe non-zeros of :math:`A` are inputted column-wise in the format described in Section :ref:`doc.optimizer.cmo_rmo_matrix`.\n\nFor an explained code example see Section :ref:`doc.tutorial_lo` and Section :ref:`doc.optimizer.matrix_formats`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumvar", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "numcon", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["bkc", "buc", "blc"]}]}, {"name": "numvar", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["bux", "blx", "aptrb", "aptre", "c", "bkx"]}]}, {"name": "c", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "cfix", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "aptrb", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aptre", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bkc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "buc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bkx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["aptrb", "aptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "input-data", "api-name": "inputdata", "targets": ["c", "cmdln", "dotnet", "java", "rpc"], "references": [], "member-of": ["task-linear", "task-bound", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "inputdata64": {"old-name": "inputdata64", "caml-name": "input-data-64", "name": "inputdata64", "brief": "Input the linear part of an optimization task in one function call.", "desc": "Input the linear part of an optimization problem.\n\n\nThe non-zeros of :math:`A` are inputted column-wise in the format described in Section :ref:`doc.optimizer.cmo_rmo_matrix`.\n\nFor an explained code example see Section :ref:`doc.tutorial_lo` and Section :ref:`doc.optimizer.matrix_formats`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumvar", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "numcon", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["bkc", "buc", "blc"]}]}, {"name": "numvar", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["bux", "blx", "aptrb", "aptre", "c", "bkx"]}]}, {"name": "c", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "cfix", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "aptrb", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aptre", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bkc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "buc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bkx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["aptrb", "aptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "input-data", "api-name": "inputdata", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-bound", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "isdouparname": {"old-name": "isdouparname", "caml-name": "is-dou-par-name", "name": "isdouparname", "brief": "Checks a double parameter name.", "desc": "Checks whether ``parname`` is a valid double parameter name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "parname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "param", "brief": "Returns the parameter corresponding to the name, if one exists.", "mode": "o", "type": ["ref", ["const-class", "mosek", "dparam"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "is-dou-par-name", "api-name": "isdouparname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "isintparname": {"old-name": "isintparname", "caml-name": "is-int-par-name", "name": "isintparname", "brief": "Checks an integer parameter name.", "desc": "Checks whether ``parname`` is a valid integer parameter name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "parname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "param", "brief": "Returns the parameter corresponding to the name, if one exists.", "mode": "o", "type": ["ref", ["const-class", "mosek", "iparam"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "is-int-par-name", "api-name": "isintparname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "isstrparname": {"old-name": "isstrparname", "caml-name": "is-str-par-name", "name": "isstrparname", "brief": "Checks a string parameter name.", "desc": "Checks whether ``parname`` is a valid string parameter name.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "parname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "param", "brief": "Returns the parameter corresponding to the name, if one exists.", "mode": "o", "type": ["ref", ["const-class", "mosek", "sparam"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "is-str-par-name", "api-name": "isstrparname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "linkfiletotaskstream": {"old-name": "linkfiletotaskstream", "caml-name": "link-file-to-task-stream", "name": "linkfiletotaskstream", "brief": "Directs all output from a task stream to a file.", "desc": "Directs all output from a task stream ``whichstream`` to a file ``filename``.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "append", "brief": "If this argument is 0 the output file will be overwritten, otherwise it will be appended to.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "link-file-to-stream", "api-name": "linkfiletostream", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["logging"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "linkfunctotaskstream": {"old-name": "linkfunctotaskstream", "caml-name": "link-func-to-task-stream", "name": "linkfunctotaskstream", "brief": "Connects a user-defined function to a task stream.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "handle", "brief": "Pointer to a user-defined structure.", "desc": "A user-defined handle which is passed to the user-defined function ``func``.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "func", "brief": "Pointer to a user-defined function.", "desc": "All output to the stream ``whichstream`` is passed to ``func``.", "mode": "i", "type": ["defined", "mosek", "streamfunc"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "link-func-to-stream", "api-name": "linkfunctostream", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["logging", "callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "unlinkfuncfromtaskstream": {"caml-name": "unlink-func-from-task-stream", "name": "unlinkfuncfromtaskstream", "brief": "Disconnects a user-defined function from a task stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "unlink-func-from-stream", "api-name": "unlinkfuncfromstream", "targets": ["c", "cmdln", "rust"], "references": [], "member-of": ["logging", "callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "clonetask": {"caml-name": "clone-task", "name": "clonetask", "brief": "Creates a clone of an existing task.", "desc": "Creates a clone of an existing task copying all problem data and parameter settings to a new task. Callback functions are not copied.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "clonedtask", "brief": "The cloned task.", "mode": "o", "type": ["ref", ["defined", "mosek", "task_t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "clone-task", "api-name": "clonetask", "targets": ["c", "cmdln", "no-overload"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "const"}, "primalrepair": {"caml-name": "primal-repair", "name": "primalrepair", "brief": "Repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables.", "desc": "The function repairs a primal infeasible optimization problem by adjusting the bounds on the constraints and variables where the adjustment\nis computed as the minimal weighted sum of relaxations to the bounds on the constraints and variables. Observe the function only repairs the problem but does not\nsolve it. If an optimal solution is required the problem should be optimized after the repair.\n\nThe function is applicable to linear and conic problems possibly with integer variables.\n\nObserve that when computing the minimal weighted relaxation the termination tolerance specified by the parameters of the task is employed. For instance\nthe parameter :msk:iparam:`mio_mode` can be used to make |mosek| ignore the integer constraints during the repair which usually leads to a much faster repair.\nHowever, the drawback is of course that the repaired problem may not have an integer feasible solution.\n\nNote the function modifies the task in place. If this is not desired, then apply the function to a cloned task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "wlc", "brief": "Weights associated with relaxing lower bounds on the constraints.", "desc": ":math:`(w_l^c)_i` is the weight associated with relaxing the lower bound on\nconstraint :math:`i`. If the weight is negative, then the lower bound is not\nrelaxed. Moreover, if the argument is |null|, then all the weights are assumed\nto be :math:`1`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "wuc", "brief": "Weights associated with relaxing the upper bound on the constraints.", "desc": ":math:`(w_u^c)_i` is the weight associated with relaxing the upper bound on\nconstraint :math:`i`. If the weight is negative, then the upper bound is not\nrelaxed. Moreover, if the argument is |null|, then all the weights are assumed\nto be :math:`1`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumcon task return-value)", "ast": ["call", "getnumcon", "task", "return-value"]}]}, {"name": "wlx", "brief": "Weights associated with relaxing the lower bounds of the variables.", "desc": ":math:`(w_l^x)_j` is the weight associated with relaxing the lower bound on variable :math:`j`. If the weight is negative, then the lower bound is not relaxed. Moreover,\nif the argument is |null|, then all the weights are assumed to be :math:`1`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}, {"name": "wux", "brief": "Weights associated with relaxing the upper bounds of variables.", "desc": ":math:`(w_l^x)_i` is the weight associated with relaxing the upper bound on variable :math:`j`. If the weight is negative, then the upper bound is not relaxed. Moreover,\nif the argument is |null|, then all the weights are assumed to be :math:`1`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumvar task return-value)", "ast": ["call", "getnumvar", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "primal-repair", "api-name": "primalrepair", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "constant", "item": ["mosek", "iparam", "primal_repair_optimizer"]}, {"type": "constant", "item": ["mosek", "iparam", "log_feas_repair"]}, {"type": "constant", "item": ["mosek", "dinfitem", "primal_repair_penalty_obj"]}], "member-of": ["infeasibility-diagnostic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "infeasibilityreport": {"caml-name": "infeasibility-report", "name": "infeasibilityreport", "brief": "Prints the infeasibility report to an output stream.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "infeasibility-report", "api-name": "infeasibilityreport", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["infeasibility-diagnostic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "toconic": {"name": "toconic", "brief": "In-place reformulation of a QCQO to a conic quadratic problem.", "desc": "This function tries to reformulate a given Quadratically Constrained Quadratic\nOptimization problem (QCQO) as a Conic Quadratic Optimization problem (CQO).\nThe first step of the reformulation is to convert the quadratic term of the\nobjective function, if any, into a constraint. Then the following steps are\nrepeated for each quadratic constraint:\n\n* a conic constraint is added along with a suitable number of auxiliary variables and constraints;\n* the original quadratic constraint is not removed, but all its coefficients are zeroed out.\n\nNote that the reformulation preserves all the original variables.\n\nThe conversion is performed in-place, i.e. the task passed as argument is\nmodified on exit. That also means that if the reformulation fails, i.e. the\ngiven QCQP is not representable as a CQO, then the task has an undefined state.\nIn some cases, users may want to clone the task to ensure a clean copy is\npreserved.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "toconic", "api-name": "toconic", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "optimize": {"name": "optimize", "brief": "Optimizes the problem.", "desc": "Calls the optimizer. Depending on the problem type and the selected optimizer\nthis will call one of the optimizers in |mosek|. By default the interior point\noptimizer will be selected for continuous problems.  The optimizer may be\nselected manually by setting the parameter :msk:iparam:`optimizer`.\n\nResponse codes come in three categories:\n\n*  Errors: Indicate that an error has occurred during the optimization, e.g  the optimizer has run out of memory (:msk:const:`rescode.err_space`).\n*  Warnings: Less fatal than errors. E.g :msk:const:`rescode.wrn_large_cj` indicating possibly problematic problem data.\n*  Termination codes: Relaying information about the conditions under which the optimizer terminated. E.g :msk:const:`rescode.trm_max_iterations` indicates that\n   the optimizer finished because it reached the maximum number of iterations specified by the user.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "optimize", "api-name": "optimize", "targets": ["c", "cmdln", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "getsolution"]}, {"type": "function", "item": ["mosek", "task", "getsolutioninfo"]}, {"type": "constant", "item": ["mosek", "iparam", "optimizer"]}], "member-of": ["optimize"], "locked": true, "breakable": true, "log": true, "const": "mut"}, "optimizetrm": {"old-name": "optimizetrm", "caml-name": "optimize-trm", "name": "optimizetrm", "brief": "Optimizes the problem.", "desc": "Calls the optimizer. Depending on the problem type and the selected optimizer\nthis will call one of the optimizers in |mosek|. By default the interior point\noptimizer will be selected for continuous problems.  The optimizer may be\nselected manually by setting the parameter :msk:iparam:`optimizer`.\n\n.. msk_only:: c\n\n   This function is equivalent to :msk:func:`task.optimize` except for the handling of return values. This function returns errors on the left hand side. Warnings are not returned and termination codes are returned through the separate argument ``trmcode``.\n\n.. msk_only:: java and dotnet and python\n\n   This function throws an exception if an error has occurred during the optimization, e.g the optimizer has run out of memory. Moreover it provides a termination code, relaying information about the conditions under which the optimizer terminated. For example :msk:const:`rescode.trm_max_iterations` indicates that the optimizer finished because it reached the maximum number of iterations specified by the user.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "trmcode", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "optimize", "api-name": "optimize", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "optimize"]}, {"type": "function", "item": ["mosek", "task", "getsolution"]}, {"type": "function", "item": ["mosek", "task", "getsolutioninfo"]}, {"type": "constant", "item": ["mosek", "iparam", "optimizer"]}], "member-of": ["optimize"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "printparam": {"caml-name": "print-param", "name": "printparam", "brief": "Prints the current parameter settings.", "desc": "Prints the current parameter settings to the message stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "print-param", "api-name": "printparam", "targets": ["c", "cmdln", "julia", "no-overload", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "logging"], "locked": true, "breakable": false, "log": false, "const": "const"}, "probtypetostr": {"old-name": "probtypetostr", "caml-name": "prob-type-to-str", "name": "probtypetostr", "brief": "Obtains a string containing the name of a given problem type.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "probtype", "mode": "i", "type": ["const-class", "mosek", "problemtype"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the problem type key.", "desc": "String corresponding to the problem type key ``probtype``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "prob-type-to-str", "api-name": "probtypetostr", "targets": ["c", "cmdln", "go", "julia", "no-overload"], "references": [], "member-of": ["task-inspect", "naming"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "prostatostr": {"old-name": "prostatostr", "caml-name": "pro-sta-to-str", "name": "prostatostr", "brief": "Obtains a string containing the name of a given problem status.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "problemsta", "mode": "i", "type": ["const-class", "mosek", "prosta"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the status key.", "desc": "String corresponding to the status key ``prosta``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "pro-sta-to-str", "api-name": "prostatostr", "targets": ["c", "cmdln", "go", "julia", "no-overload"], "references": [], "member-of": ["solution-information", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putresponsefunc": {"old-name": "putresponsefunc", "caml-name": "put-response-func", "name": "putresponsefunc", "brief": "Inputs a user-defined error callback function.", "desc": "Inputs a user-defined error callback which is called when an error or warning occurs.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "responsefunc", "brief": "A user-defined response handling function.", "mode": "i", "type": ["defined", "mosek", "responsefunc"], "null?": false, "api?": true}, {"name": "handle", "brief": "Pointer to a user-defined data structure.", "desc": "A user-defined data structure that  is passed to the function ``responsefunc`` whenever it is called.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-response-func", "api-name": "putresponsefunc", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["callback", "logging"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "commitchanges": {"old-name": "commitchanges", "caml-name": "commit-changes", "name": "commitchanges", "brief": "Commits all cached problem changes.", "desc": "Commits all cached problem changes to the task. It is usually not necessary to call this function explicitly since changes will be committed automatically when required.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "commit-changes", "api-name": "commitchanges", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getatruncatetol": {"caml-name": "get-a-truncate-tol", "name": "getatruncatetol", "brief": "Gets the current A matrix truncation threshold.", "desc": "Obtains the tolerance value set with :msk:func:`task.putatruncatetol`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "tolzero", "brief": "Truncation tolerance.", "desc": "All elements  :math:`|a_{i,j}|` less than this tolerance is truncated to zero.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "1", "ast": "1"}]}], "ais": "function", "api-caml-name": "get-a-truncate-tol", "api-name": "getatruncatetol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putatruncatetol": {"caml-name": "put-a-truncate-tol", "name": "putatruncatetol", "brief": "Truncates all elements in A below a certain tolerance to zero.", "desc": "Truncates (sets to zero) all elements in :math:`A`  that satisfy\n\n.. math:: |a_{i,j}| \\leq \\mathtt{tolzero}.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "tolzero", "brief": "Truncation tolerance.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-a-truncate-tol", "api-name": "putatruncatetol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaij": {"old-name": "putaij", "caml-name": "put-aij", "name": "putaij", "brief": "Changes a single value in the linear coefficient matrix.", "desc": "Changes a coefficient in the linear coefficient matrix :math:`A` using the method\n\n.. math:: a_{i,j} = \\mathtt{aij}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Constraint (row) index.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Variable (column) index.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aij", "brief": "New coefficient.", "desc": "New coefficient for :math:`a_{i,j}`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-aij", "api-name": "putaij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putarow"]}, {"type": "function", "item": ["mosek", "task", "putacol"]}, {"type": "function", "item": ["mosek", "task", "putaijlist"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaijlist": {"old-name": "putaijlist", "caml-name": "put-aij-list", "name": "putaijlist", "brief": "Changes one or more coefficients in the linear constraint matrix.", "desc": "Changes one or more coefficients in :math:`A` using the method\n\n.. math:: a_{\\mathtt{subi[k]},\\mathtt{subj[k]}} = \\mathtt{valij[k]}, \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}}.\n\nDuplicates are not allowed.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of coefficients that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subi", "valij", "subj"]}]}, {"name": "subi", "brief": "Constraint (row) indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "subj", "brief": "Variable (column) indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "valij", "brief": "New coefficient values.", "desc": "New coefficient values for :math:`a_{i,j}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-aij-list", "api-name": "putaijlist", "targets": ["c", "cmdln", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "putarow"]}, {"type": "function", "item": ["mosek", "task", "putacol"]}, {"type": "function", "item": ["mosek", "task", "putaij"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaijlist64": {"caml-name": "put-aij-list64", "name": "putaijlist64", "brief": "Changes one or more coefficients in the linear constraint matrix.", "desc": "Changes one or more coefficients in :math:`A` using the method\n\n.. math:: a_{\\mathtt{subi[k]},\\mathtt{subj[k]}} = \\mathtt{valij[k]}, \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}}.\n\nDuplicates are not allowed.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of coefficients that should be changed.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subi", "valij", "subj"]}]}, {"name": "subi", "brief": "Constraint (row) indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "subj", "brief": "Variable (column) indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "valij", "brief": "New coefficient values.", "desc": "New coefficient values for :math:`a_{i,j}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-aij-list", "api-name": "putaijlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putarow"]}, {"type": "function", "item": ["mosek", "task", "putacol"]}, {"type": "function", "item": ["mosek", "task", "putaij"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacol": {"old-name": "putacol", "caml-name": "put-a-col", "name": "putacol", "brief": "Replaces all elements in one column of the linear constraint matrix.", "desc": "Change one column of the linear constraint matrix :math:`A`. Resets all the elements in column :math:`j` to zero and then sets\n\n.. math:: a_{\\mathtt{subj}[k],\\mathtt{j}} = \\mathtt{valj}[k], \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{nzj}}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Column index.", "desc": "Index of a column in :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzj", "brief": "Number of non-zeros in column.", "desc": "Number of non-zeros in column :math:`j` of :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["valj", "subj"]}]}, {"name": "subj", "brief": "Row indexes of non-zero values in column.", "desc": "Row indexes of non-zero values in column :math:`j` of :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "valj", "brief": "New non-zero values of column.", "desc": "New non-zero values of column :math:`j` in :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-a-col", "api-name": "putacol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putacolslice"]}, {"type": "function", "item": ["mosek", "task", "putacollist"]}, {"type": "function", "item": ["mosek", "task", "putarow"]}, {"type": "function", "item": ["mosek", "task", "putaij"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putarow": {"old-name": "putarow", "caml-name": "put-a-row", "name": "putarow", "brief": "Replaces all elements in one row of the linear constraint matrix.", "desc": "Change one row of the linear constraint matrix :math:`A`. Resets all the elements in row :math:`i` to zero and then sets\n\n.. math:: a_{\\mathtt{i},\\mathtt{subi}[k]} = \\mathtt{vali}[k], \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{nzi}}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Row index.", "desc": "Index of a row in :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nzi", "brief": "Number of non-zeros in row.", "desc": "Number of non-zeros in row :math:`i` of :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["vali", "subi"]}]}, {"name": "subi", "brief": "Column indexes of non-zero values in row.", "desc": "Column indexes of non-zero values in row :math:`i` of :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "vali", "brief": "New non-zero values of row.", "desc": "New non-zero values of row :math:`i` in :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-a-row", "api-name": "putarow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putarowslice"]}, {"type": "function", "item": ["mosek", "task", "putarowlist"]}, {"type": "function", "item": ["mosek", "task", "putacol"]}, {"type": "function", "item": ["mosek", "task", "putaij"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putarowslice": {"old-name": "putarowslice", "caml-name": "put-a-row-slice", "name": "putarowslice", "brief": "Replaces all elements in several rows the linear constraint matrix.", "desc": "Change a slice of rows in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested rows are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1 \\\\\n                   & a_{i,\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i-\\mathtt{first}\\idxorg],\\ldots,\\mathtt{ptre}[i-\\mathtt{first}\\idxorg]-1.\n    \\end{array}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "First row in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Last row plus one in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the rows.", "desc": "Array of pointers to the first element in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the rows.", "desc": "Array of pointers to the last element plus one in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "asub", "brief": "Column indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csr", "arg": "At", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-row-slice", "api-name": "putarowslice", "targets": ["c", "cmdln", "java", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "putarowslice64"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putarowslice64": {"old-name": "putarowslice64", "caml-name": "put-a-row-slice-64", "name": "putarowslice64", "brief": "Replaces all elements in several rows the linear constraint matrix.", "desc": "Change a slice of rows in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested rows are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1 \\\\\n                   & a_{i,\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i-\\mathtt{first}\\idxorg],\\ldots,\\mathtt{ptre}[i-\\mathtt{first}\\idxorg]-1.\n    \\end{array}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "First row in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Last row plus one in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the rows.", "desc": "Array of pointers to the first element in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the rows.", "desc": "Array of pointers to the last element plus one in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "asub", "brief": "Column indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csr", "arg": "At", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-row-slice", "api-name": "putarowslice", "targets": ["c", "cmdln", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putarowslice64"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putarowlist": {"old-name": "putarowlist", "caml-name": "put-a-row-list", "name": "putarowlist", "brief": "Replaces all elements in several rows of the linear constraint matrix.", "desc": "Change a set of rows in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested rows are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}} \\\\\n                   & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.\n    \\end{array}", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of rows of A matrix to replace.", "desc": "Number of rows of :math:`A` to replace.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["ptre", "ptrb", "sub"]}]}, {"name": "sub", "brief": "Indexes of rows or columns that should be replaced.", "desc": "Indexes of rows that should be replaced, no duplicates.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the rows.", "desc": "Array of pointers to the first element in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the rows.", "desc": "Array of pointers to the last element plus one in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Variable indexes.", "desc": "Column indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csr", "arg": "At", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-row-list", "api-name": "putarowlist", "targets": ["c", "cmdln", "java", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putarowlist64": {"old-name": "putarowlist64", "caml-name": "put-a-row-list-64", "name": "putarowlist64", "brief": "Replaces all elements in several rows of the linear constraint matrix.", "desc": "Change a set of rows in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested rows are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}} \\\\\n                   & a_{\\mathtt{sub}[i],\\mathtt{asub}[k]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.\n    \\end{array}", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of rows of A matrix to replace.", "desc": "Number of rows of :math:`A` to replace.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["ptre", "ptrb", "sub"]}]}, {"name": "sub", "brief": "Indexes of rows or columns that should be replaced.", "desc": "Indexes of rows that should be replaced, no duplicates.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the rows.", "desc": "Array of pointers to the first element in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the rows.", "desc": "Array of pointers to the last element plus one in each row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Variable indexes.", "desc": "Column indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csr", "arg": "At", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-row-list", "api-name": "putarowlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacolslice": {"old-name": "putacolslice", "caml-name": "put-a-col-slice", "name": "putacolslice", "brief": "Replaces all elements in a sequence of columns the linear constraint matrix.", "desc": "Change a slice of columns in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested columns are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1\\\\\n                  & a_{\\mathtt{asub}[k],i} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i-\\mathtt{first}\\idxorg],\\ldots,\\mathtt{ptre}[i-\\mathtt{first}\\idxorg]-1.\n    \\end{array}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "First column in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Last column plus one in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the columns.", "desc": "Array of pointers to the first element in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the columns.", "desc": "Array of pointers to the last element plus one in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Row indexes", "desc": "Row indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-col-slice", "api-name": "putacolslice", "targets": ["c", "cmdln", "java", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "putacolslice64"]}, {"type": "function", "item": ["mosek", "task", "putarowslice"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacolslice64": {"old-name": "putacolslice64", "caml-name": "put-a-col-slice-64", "name": "putacolslice64", "brief": "Replaces all elements in a sequence of columns the linear constraint matrix.", "desc": "Change a slice of columns in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested columns are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\mathtt{first},\\ldots,\\mathtt{last}-1\\\\\n                  & a_{\\mathtt{asub}[k],i} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i-\\mathtt{first}\\idxorg],\\ldots,\\mathtt{ptre}[i-\\mathtt{first}\\idxorg]-1.\n    \\end{array}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "First column in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Last column plus one in the slice.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the columns.", "desc": "Array of pointers to the first element in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the columns.", "desc": "Array of pointers to the last element plus one in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Row indexes", "desc": "Row indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-col-slice", "api-name": "putacolslice", "targets": ["c", "cmdln", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putacolslice"]}, {"type": "function", "item": ["mosek", "task", "putarowslice"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacollist": {"old-name": "putacollist", "caml-name": "put-a-col-list", "name": "putacollist", "brief": "Replaces all elements in several columns the linear constraint matrix.", "desc": "Change a set of columns in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested columns are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}}\\\\\n                  & a_{\\mathtt{asub}[k],\\mathtt{sub}[i]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.\n    \\end{array}", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of columns of A matrix to replace.", "desc": "Number of columns of :math:`A` to replace.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["ptre", "ptrb", "sub"]}]}, {"name": "sub", "brief": "Indexes of columns that should be replaced.", "desc": "Indexes of columns that should be replaced, no duplicates.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the columns.", "desc": "Array of pointers to the first element in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the columns.", "desc": "Array of pointers to the last element plus one in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Row indexes", "desc": "Row indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-col-list", "api-name": "putacollist", "targets": ["c", "cmdln", "go", "java", "rpc"], "references": [{"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}, {"type": "function", "item": ["mosek", "task", "putacollist64"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacollist64": {"old-name": "putacollist64", "caml-name": "put-a-col-list-64", "name": "putacollist64", "brief": "Replaces all elements in several columns the linear constraint matrix.", "desc": "Change a set of columns in the linear constraint matrix :math:`A` with data in sparse triplet format. The requested columns are set to zero and then updated with:\n\n.. math::\n\n    \\begin{array}{rl}\n      \\mathtt{for} & i=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}}\\\\\n                  & a_{\\mathtt{asub}[k],\\mathtt{sub}[i]} = \\mathtt{aval}[k],\\quad k=\\mathtt{ptrb}[i],\\ldots,\\mathtt{ptre}[i]-1.\n    \\end{array}", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of columns of A matrix to replace.", "desc": "Number of columns of :math:`A` to replace.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["ptre", "ptrb", "sub"]}]}, {"name": "sub", "brief": "Indexes of columns that should be replaced.", "desc": "Indexes of columns that should be replaced, no duplicates.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Array of pointers to the first element in the columns.", "desc": "Array of pointers to the first element in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "Array of pointers to the last element plus one in the columns.", "desc": "Array of pointers to the last element plus one in each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asub", "brief": "Row indexes", "desc": "Row indexes of new elements.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "aval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["ptrb", "ptre", "asub", "aval"]}, "ais": "function", "api-caml-name": "put-a-col-list", "api-name": "putacollist", "targets": ["c", "cmdln", "dotnet", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}, {"type": "function", "item": ["mosek", "task", "putacollist64"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbaraij": {"old-name": "putbaraij", "caml-name": "put-bara-ij", "name": "putbaraij", "brief": "Inputs an element of barA.", "desc": "This function sets one element in the :math:`\\barA` matrix.\n\nEach element in the :math:`\\barA` matrix is a weighted sum of\nsymmetric matrices from the symmetric matrix storage :math:`E`, so\n:math:`\\barA_{ij}` is a symmetric matrix. By default all elements in\n:math:`\\barA` are 0, so only non-zero elements need be added.\nSetting the same element again will overwrite the earlier entry.\n\nThe symmetric matrices from :math:`E` are defined separately\nusing the function :msk:func:`task.appendsparsesymmat`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Row index of barA.", "desc": "Row index of :math:`\\barA`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index of barA.", "desc": "Column index of :math:`\\barA`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "Number terms in the weighted sum.", "desc": "The number of terms in the weighted sum that forms :math:`\\barA_{ij}`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["weights", "sub"]}]}, {"name": "sub", "brief": "Element indexes in matrix storage.", "desc": "Indices in :math:`E` of the matrices appearing in the weighted sum for :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "weights", "brief": "Weights in the weighted sum.", "desc": "``weights[k]`` is the coefficient of the ``sub[k]``-th element of :math:`E` in the weighted sum forming  :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-bara-ij", "api-name": "putbaraij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbaraijlist": {"caml-name": "put-bara-ij-list", "name": "putbaraijlist", "brief": "Inputs list of elements of barA.", "desc": "This function sets a list of elements in the :math:`\\barA` matrix.\n\nEach element in the :math:`\\barA` matrix is a weighted sum of\nsymmetric matrices from the symmetric matrix storage :math:`E`, so\n:math:`\\barA_{ij}` is a symmetric matrix. By default all elements in\n:math:`\\barA` are 0, so only non-zero elements need be added.\nSetting the same element again will overwrite the earlier entry.\n\nThe symmetric matrices from :math:`E` are defined separately\nusing the function :msk:func:`task.appendsparsesymmat`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of barA entries to add.", "desc": "Number of :math:`\\barA` entries to add.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["alphaptrb", "subi", "alphaptre", "subj"]}]}, {"name": "subi", "brief": "Row index of barA.", "desc": "Row index of :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "subj", "brief": "Column index of barA.", "desc": "Column index of :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "alphaptrb", "brief": "Start entries for terms in the weighted sum.", "desc": "Start entries for terms in the weighted sum that forms :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "alphaptre", "brief": "End entries for terms in the weighted sum.", "desc": "End entries for terms in the weighted sum that forms :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "matidx", "brief": "Element indexes in matrix storage.", "desc": "Indices in :math:`E` of the matrices appearing in the weighted sum for :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "weights", "brief": "Weights in the weighted sum.", "desc": "``weights[k]`` is the coefficient of the ``sub[k]``-th element of :math:`E` in the weighted sum forming  :math:`\\barA_{ij}`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["alphaptrb", "alphaptre", "matidx", "weights"]}, "ais": "function", "api-caml-name": "put-bara-ij-list", "api-name": "putbaraijlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbararowlist": {"old-name": "putbararowlist", "caml-name": "put-bara-row-list", "name": "putbararowlist", "brief": "Replace a set of rows of barA", "desc": "This function replaces a list of rows in the :math:`\\barA` matrix.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of barA entries to add.", "desc": "Number of :math:`\\barA` entries to add.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTHOF", "arg-refs": ["ptre", "ptrb", "subi"]}]}, {"name": "subi", "brief": "Row indexes of barA.", "desc": "Row indexes of :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptrb", "brief": "Start of rows in barA.", "desc": "Start of rows in :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ptre", "brief": "End of rows in barA.", "desc": "End of rows in :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "subj", "brief": "Column index of barA.", "desc": "Column index of :math:`\\barA`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "nummat", "brief": "Number of entries in weighted sum of matrixes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(length (arg subj))", "ast": ["length", ["arg", "subj"]], "arg-refs": ["subj"]}]}, {"name": "matidx", "brief": "Matrix indexes for weighted sum of matrixes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(sum (arg nummat))", "ast": ["sum", ["arg", "nummat"]], "arg-refs": ["nummat"]}]}, {"name": "weights", "brief": "Weights for weighted sum of matrixes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(sum (arg nummat))", "ast": ["sum", ["arg", "nummat"]], "arg-refs": ["nummat"]}]}], "sparse-matrix": {"type": "csc", "arg": "A", "fmt": ["ptrb", "ptre", "subj", "nummat"]}, "ais": "function", "api-caml-name": "put-bara-row-list", "api-name": "putbararowlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumbarcnz": {"old-name": "getnumbarcnz", "caml-name": "get-num-barc-nz", "name": "getnumbarcnz", "brief": "Obtains the number of nonzero elements in barc.", "desc": "Obtains the number of nonzero elements in :math:`\\barC`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "nz", "brief": "The number of nonzero elements in barc.", "desc": "The number of nonzeros in :math:`\\barC` i.e. the number of elements :math:`\\barC_j` that are nonzero.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-barc-nz", "api-name": "getnumbarcnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumbaranz": {"old-name": "getnumbaranz", "caml-name": "get-num-bara-nz", "name": "getnumbaranz", "brief": "Get the number of nonzero elements in barA.", "desc": "Get the number of nonzero elements in :math:`\\barA`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "nz", "brief": "The number of nonzero block elements in barA.", "desc": "The number of nonzero block elements in :math:`\\barA` i.e. the number of :math:`\\barA_{ij}` elements that are nonzero.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-bara-nz", "api-name": "getnumbaranz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarcsparsity": {"old-name": "getbarcsparsity", "caml-name": "get-barc-sparsity", "name": "getbarcsparsity", "brief": "Get the positions of the nonzero elements in barc.", "desc": "Internally only the nonzero elements of :math:`\\barC` are stored\nin a vector. This function is used to obtain the nonzero elements of :math:`\\barC`\nand their indexes in the internal vector representation (in ``idx``). From the index\ndetailed information about each nonzero :math:`\\barC_j` can be\nobtained using :msk:func:`task.getbarcidxinfo` and :msk:func:`task.getbarcidx`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumnz", "brief": "idxj must be at least maxnumnz long.", "desc": "``idxj`` must be at least ``maxnumnz`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumbarcnz task return-value)", "ast": ["call", "getnumbarcnz", "task", "return-value"]}]}, {"name": "numnz", "brief": "Number of nonzero elements in barc.", "desc": "Number of nonzero elements in :math:`\\barC`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "idxj", "brief": "Internal positions of the nonzeros elements in barc.", "desc": "Internal positions of the nonzeros elements in :math:`\\barC`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-barc-sparsity", "api-name": "getbarcsparsity", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarasparsity": {"caml-name": "get-bara-sparsity", "name": "getbarasparsity", "brief": "Obtains the sparsity pattern of the barA matrix.", "desc": "The matrix :math:`\\barA` is assumed to be a sparse matrix of symmetric matrices.\nThis implies that many of the elements in :math:`\\barA` are likely to be zero matrices.\nTherefore, in order to save space, only nonzero elements in :math:`\\barA` are stored\non vectorized form. This function is used to obtain the sparsity pattern of\n:math:`\\barA` and the position of each nonzero element in the vectorized form of\n:math:`\\barA`. From the index detailed information about each nonzero :math:`\\barA_{i,j}` can be\nobtained using :msk:func:`task.getbaraidxinfo` and :msk:func:`task.getbaraidx`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumnz", "brief": "The array idxij must be at least maxnumnz long.", "desc": "The array ``idxij`` must be at least ``maxnumnz`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumbaranz task return-value)", "ast": ["call", "getnumbaranz", "task", "return-value"]}]}, {"name": "numnz", "brief": "Number of nonzero elements in barA.", "desc": "Number of nonzero elements in :math:`\\barA`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "idxij", "brief": "Position of each nonzero element in the vector representation of barA.", "desc": "Position of each nonzero element in the vectorized form of :math:`\\barA`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumnz)", "ast": ["arg", "maxnumnz"], "arg-refs": ["maxnumnz"]}]}], "ais": "function", "api-caml-name": "get-bara-sparsity", "api-name": "getbarasparsity", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarcidxinfo": {"old-name": "getbarcidxinfo", "caml-name": "get-barc-idx-info", "name": "getbarcidxinfo", "brief": "Obtains information about an element in barc.", "desc": "Obtains the number of terms in the weighted sum that forms a particular element in :math:`\\barC`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Index of the element for which information should be obtained. The value is an index of a symmetric sparse variable.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "Number of terms that appear in the weighted sum that forms the requested element.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-barc-idx-info", "api-name": "getbarcidxinfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarcidxj": {"caml-name": "get-barc-idx-j", "name": "getbarcidxj", "brief": "Obtains the row index of an element in barc.", "desc": "Obtains the row index of an element in :math:`\\barC`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Index of the element for which information should be obtained.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Row index in barc.", "desc": "Row index in :math:`\\barC`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "get-barc-idx-j", "api-name": "getbarcidxj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarcidx": {"old-name": "getbarcidx", "caml-name": "get-barc-idx", "name": "getbarcidx", "brief": "Obtains information about an element in barc.", "desc": "Obtains information about an element in :math:`\\barC`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Index of the element for which information should be obtained.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnum", "brief": "sub and weights must be at least maxnum long.", "desc": "``sub`` and ``weights`` must be at least ``maxnum`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getbarcidxinfo task (arg idx) return-value)", "ast": ["call", "getbarcidxinfo", "task", ["arg", "idx"], "return-value"], "arg-refs": ["idx"]}]}, {"name": "j", "brief": "Row index in barc.", "desc": "Row index in :math:`\\barC`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "Number of terms in the weighted sum.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true}, {"name": "sub", "brief": "Elements appearing the weighted sum.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "weights", "brief": "Weights of terms in the weighted sum.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}], "ais": "function", "api-caml-name": "get-barc-idx", "api-name": "getbarcidx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbaraidxinfo": {"old-name": "getbaraidxinfo", "caml-name": "get-bara-idx-info", "name": "getbaraidxinfo", "brief": "Obtains the number of terms in the weighted sum that form a particular element in barA.", "desc": "Each nonzero element in :math:`\\barA_{ij}` is formed as a weighted sum of\nsymmetric matrices. Using this function the number of terms in the weighted sum\ncan be obtained. See description of :msk:func:`task.appendsparsesymmat` for details\nabout the weighted sum.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "The internal position of the element for which information should be obtained.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "Number of terms in the weighted sum that form the specified element in barA.", "desc": "Number of terms in the weighted sum that form the specified element in :math:`\\barA`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-bara-idx-info", "api-name": "getbaraidxinfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbaraidxij": {"caml-name": "get-bara-idx-i-j", "name": "getbaraidxij", "brief": "Obtains information about an element in barA.", "desc": "Obtains information about an element in :math:`\\barA`. Since :math:`\\barA`\nis a sparse matrix of symmetric matrices, only the nonzero elements in\n:math:`\\barA` are stored in order to save space. Now :math:`\\barA` is\nstored vectorized i.e. as one long vector.  This function makes it\npossible to obtain information such as the row index and the column index of a\nparticular element of the vectorized form of :math:`\\barA`.\n\nPlease note that if one element of :math:`\\barA` is inputted multiple times\nthen it may be stored several times in vectorized form. In that case the\nelement with the highest index is the one that is used.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Position of the element in the vectorized form.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "i", "brief": "Row index of the element at position idx.", "desc": "Row index of the element at position ``idx``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index of the element at position idx.", "desc": "Column index of the element at position ``idx``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "get-bara-idx-i-j", "api-name": "getbaraidxij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbaraidx": {"old-name": "getbaraidx", "caml-name": "get-bara-idx", "name": "getbaraidx", "brief": "Obtains information about an element in barA.", "desc": "Obtains information about an element in :math:`\\barA`. Since :math:`\\barA`\nis a sparse matrix of symmetric matrices, only the nonzero elements in\n:math:`\\barA` are stored in order to save space. Now :math:`\\barA` is\nstored vectorized i.e. as one long vector. This function makes it\npossible to obtain information such as the row index and the column index of a\nparticular element of the vectorized form of :math:`\\barA`.\n\nPlease observe if one element of :math:`\\barA` is inputted multiple times\nthen it may be stored several times in vectorized form. In that case the\nelement with the highest index is the one that is used.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Position of the element in the vectorized form.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxnum", "brief": "sub and weights must be at least maxnum long.", "desc": "``sub`` and ``weights`` must be at least ``maxnum`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getbaraidxinfo task (arg idx) return-value)", "ast": ["call", "getbaraidxinfo", "task", ["arg", "idx"], "return-value"], "arg-refs": ["idx"]}]}, {"name": "i", "brief": "Row index of the element at position idx.", "desc": "Row index of the element at position ``idx``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index of the element at position idx.", "desc": "Column index of the element at position ``idx``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "Number of terms in weighted sum that forms the element.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true, "defaultout": true}, {"name": "sub", "brief": "A list indexes of the elements from symmetric matrix storage that appear in the weighted sum.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "weights", "brief": "The weights associated with each term in the weighted sum.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}], "ais": "function", "api-caml-name": "get-bara-idx", "api-name": "getbaraidx", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumbarcblocktriplets": {"caml-name": "get-num-barc-block-triplets", "name": "getnumbarcblocktriplets", "brief": "Obtains an upper bound on the number of elements in the block triplet form of barc.", "desc": "Obtains an upper bound on the number of elements in the block triplet form of :math:`\\barC`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "An upper bound on the number of elements in the block triplet form of barc.", "desc": "An upper bound on the number of elements in the block triplet form of :math:`\\barC.`", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-barc-block-triplets", "api-name": "getnumbarcblocktriplets", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putbarcblocktriplet": {"caml-name": "put-barc-block-triplet", "name": "putbarcblocktriplet", "brief": "Inputs barC in block triplet form.", "desc": "Inputs the :math:`\\barC` matrix in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of elements in the block triplet form.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["valjkl", "subl", "subk", "subj"]}]}, {"name": "subj", "brief": "Symmetric matrix variable index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "valjkl", "brief": "The numerical value associated with each block triplet.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "put-barc-block-triplet", "api-name": "putbarcblocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getbarcblocktriplet": {"old-name": "getbarcblocktriplet", "caml-name": "get-barc-block-triplet", "name": "getbarcblocktriplet", "brief": "Obtains barC in block triplet form.", "desc": "Obtains :math:`\\barC` in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnum", "brief": "subj, subk, subl and valjkl must be maxnum long.", "desc": "``subj``, ``subk``, ``subl`` and ``valjkl`` must be  ``maxnum`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumbarcblocktriplets task return-value)", "ast": ["call", "getnumbarcblocktriplets", "task", "return-value"]}]}, {"name": "num", "brief": "Number of elements in the block triplet form.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}, {"name": "subj", "brief": "Symmetric matrix variable index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "valjkl", "brief": "The numerical value associated with each block triplet.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}], "ais": "function", "api-caml-name": "get-barc-block-triplet", "api-name": "getbarcblocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putbarablocktriplet": {"caml-name": "put-bara-block-triplet", "name": "putbarablocktriplet", "brief": "Inputs barA in block triplet form.", "desc": "Inputs the :math:`\\barA` matrix in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of elements in the block triplet form.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["valijkl", "subl", "subk", "subj"]}]}, {"name": "subi", "brief": "Constraint index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "subj", "brief": "Symmetric matrix variable index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}, {"name": "valijkl", "brief": "The numerical value associated with each block triplet.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-bara-block-triplet", "api-name": "putbarablocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumbarablocktriplets": {"old-name": "getnumbarablocktriplets", "caml-name": "get-num-bara-block-triplets", "name": "getnumbarablocktriplets", "brief": "Obtains an upper bound on the number of scalar elements in the block triplet form of bara.", "desc": "Obtains an upper bound on the number of elements in the block triplet form of :math:`\\barA`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "An upper bound on the number of elements in the block triplet form of bara.", "desc": "An upper bound on the number of elements in the block triplet form of :math:`\\barA.`", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-bara-block-triplets", "api-name": "getnumbarablocktriplets", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getbarablocktriplet": {"old-name": "getbarablocktriplet", "caml-name": "get-bara-block-triplet", "name": "getbarablocktriplet", "brief": "Obtains barA in block triplet form.", "desc": "Obtains :math:`\\barA` in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnum", "brief": "subi, subj, subk, subl and valijkl must be maxnum long.", "desc": "``subi``, ``subj``, ``subk``, ``subl`` and ``valijkl`` must be  ``maxnum`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getnumbarablocktriplets task return-value)", "ast": ["call", "getnumbarablocktriplets", "task", "return-value"]}]}, {"name": "num", "brief": "Number of elements in the block triplet form.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}, {"name": "subi", "brief": "Constraint index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "subj", "brief": "Symmetric matrix variable index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}, {"name": "valijkl", "brief": "The numerical value associated with each block triplet.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnum)", "ast": ["arg", "maxnum"], "arg-refs": ["maxnum"]}]}], "ais": "function", "api-caml-name": "get-bara-block-triplet", "api-name": "getbarablocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putmaxnumafe": {"caml-name": "put-max-num-afe", "name": "putmaxnumafe", "brief": "Sets the number of preallocated affine expressions in the optimization task.", "desc": "Sets the number of preallocated affine expressions in the optimization task. When this\nnumber is reached |mosek| will automatically allocate more space for affine expressions.\nIt is never mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumafe", "brief": "Number of preallocated affine expressions.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-afe", "api-name": "putmaxnumafe", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumafe": {"caml-name": "get-num-afe", "name": "getnumafe", "brief": "Obtains the number of affine expressions.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafe", "brief": "Number of affine expressions.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-afe", "api-name": "getnumafe", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendafes": {"caml-name": "append-afes", "name": "appendafes", "brief": "Appends a number of empty affine expressions to the optimization task.", "desc": "Appends a number of empty affine expressions to the task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of empty affine expressions which should be appended.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "append-afes", "api-name": "appendafes", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafefentry": {"caml-name": "put-afe-f-entry", "name": "putafefentry", "brief": "Replaces one entry in F.", "desc": "Replaces one entry in the affine expression store :math:`F`, that is it sets:\n\n.. math:: F_{\\mathrm{afeidx}, \\mathrm{varidx}} = \\mathrm{value}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index in F.", "desc": "Row index in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "varidx", "brief": "Column index in F.", "desc": "Column index in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "value", "brief": "Value of the entry.", "desc": "Value of :math:`F_{\\mathrm{afeidx},\\mathrm{varidx}}`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-f-entry", "api-name": "putafefentry", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafefentrylist": {"caml-name": "put-afe-f-entry-list", "name": "putafefentrylist", "brief": "Replaces a list of entries in F.", "desc": "Replaces a number of entries in the affine expression store :math:`F`, that is it sets:\n\n.. math:: F_{\\mathrm{afeidxs}[k], \\mathrm{varidx}[k]} = \\mathrm{val}[k]\n\nfor all :math:`k`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numentr", "brief": "Number of entries.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["varidx", "afeidx", "val"]}]}, {"name": "afeidx", "brief": "Row indices in F.", "desc": "Row indices in :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "varidx", "brief": "Column indices in F.", "desc": "Column indices in :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "val", "brief": "Values of the entries in F.", "desc": "Values of the entries in :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-f-entry-list", "api-name": "putafefentrylist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafefrow": {"caml-name": "empty-afe-f-row", "name": "emptyafefrow", "brief": "Clears a row in F.", "desc": "Clears one row in the affine constraint matrix :math:`F`, that is sets :math:`F_{\\mathrm{afeidx},*}=0`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index.", "desc": "Index of a row in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-f-row", "api-name": "emptyafefrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafefcol": {"caml-name": "empty-afe-f-col", "name": "emptyafefcol", "brief": "Clears a column in F.", "desc": "Clears one column in the affine constraint matrix :math:`F`, that is sets :math:`F_{*,\\mathrm{varidx}}=0`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "varidx", "brief": "Variable index.", "desc": "Index of a variable (column in :math:`F`).", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-f-col", "api-name": "emptyafefcol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafefrowlist": {"caml-name": "empty-afe-f-row-list", "name": "emptyafefrowlist", "brief": "Clears rows in F.", "desc": "Clears a number of rows in :math:`F` i.e. sets :math:`F_{i,*} = 0` for all indices :math:`i` in ``afeidx``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafeidx", "brief": "The number of rows to zero.", "desc": "The number of rows to zero, length of ``afeidxlist``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidx"]}]}, {"name": "afeidx", "brief": "Indices of rows in F to clear.", "desc": "Indices of rows in :math:`F` to clear.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-f-row-list", "api-name": "emptyafefrowlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafefcollist": {"caml-name": "empty-afe-f-col-list", "name": "emptyafefcollist", "brief": "Clears columns in F.", "desc": "Clears a number of columns in :math:`F` i.e. sets :math:`F_{*,j} = 0` for all indices :math:`j` in ``varidx``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numvaridx", "brief": "The number of columns to zero.", "desc": "The number of columns to zero, length of ``varidx`` list.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["varidx"]}]}, {"name": "varidx", "brief": "Indices of variables in F to clear.", "desc": "Indices of variables (columns) in :math:`F` to clear.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-f-col-list", "api-name": "emptyafefcollist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafefrow": {"caml-name": "put-afe-f-row", "name": "putafefrow", "brief": "Replaces all elements in one row of the F matrix in the affine expressions.", "desc": "Change one row of the matrix :math:`F` of affine expressions. Resets all the elements in row ``afeidx`` to zero and then sets\n\n.. math:: F_{\\mathtt{afeidx},\\mathtt{varidx}[k]} = \\mathtt{val}[k], \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{numnz}}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index.", "desc": "Index of a row in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the row.", "desc": "Number of non-zeros in the row of :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["varidx", "val"]}]}, {"name": "varidx", "brief": "Column indexes of non-zero values in the row.", "desc": "Column indexes of non-zero values in the row of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "val", "brief": "New non-zero values in the row.", "desc": "New non-zero values in the row of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-afe-f-row", "api-name": "putafefrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafefrowlist": {"caml-name": "put-afe-f-row-list", "name": "putafefrowlist", "brief": "Replaces all elements in a number of rows of the F matrix in the affine expressions.", "desc": "Clears and then changes a number of rows of the matrix :math:`F` of affine expressions. The :math:`k`-th of the rows to be changed has index :math:`i = \\mathrm{afeidx}[k]`, contains :math:`\\mathrm{numnzrow}[k]` nonzeros and its description as in :msk:func:`task.putafefrow` starts in position :math:`\\mathrm{ptrrow}[k]` of the arrays ``varidx`` and ``val``. Formally, the row with index :math:`i` is cleared and then set as:\n\n.. math:: F_{i,\\mathrm{varidx}[\\mathrm{ptrrow}[k]+j]} = \\mathrm{val}[\\mathrm{ptrrow}[k] + j], \\quad j=0,\\ldots,\\mathrm{numnzrow}[k]-1.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafeidx", "brief": "The number of rows.", "desc": "The number of rows of :math:`F` to modify; length of ``afeidx``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["ptrrow", "numnzrow", "afeidx"]}]}, {"name": "afeidx", "brief": "Row indices.", "desc": "Indices of rows in :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnzrow", "brief": "Number of non-zeros in each row.", "desc": "Number of non-zeros in each of the modified rows of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "ptrrow", "brief": "Pointer to the first nonzero in each row.", "desc": "Pointer to the first nonzero in each row of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lenidxval", "brief": "Length of the arrays with nonzero indexes and values.", "desc": "Length of arrays ``varidx`` and ``val`` with indexes and values of nonzeros in the modified rows.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["varidx", "val"]}]}, {"name": "varidx", "brief": "Column indexes of non-zero values.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "val", "brief": "New non-zero values in the rows.", "desc": "New non-zero values in the rows of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "plr", "arg": "F", "fmt": ["ptrrow", "numnzrow", "varidx", "val"]}, "ais": "function", "api-caml-name": "put-afe-f-row-list", "api-name": "putafefrowlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafefcol": {"caml-name": "put-afe-f-col", "name": "putafefcol", "brief": "Replaces all elements in one column of the F matrix in the affine expressions.", "desc": "Change one column of the matrix :math:`F` of affine expressions. Resets all the elements in column ``varidx`` to zero and then sets\n\n.. math:: F_{\\mathtt{afeidx}[k],\\mathtt{varidx}} = \\mathtt{val}[k], \\quad k=\\idxbeg,\\ldots,\\idxend{\\mathtt{numnz}}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "varidx", "brief": "Column index.", "desc": "Index of a column in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the column.", "desc": "Number of non-zeros in the column of :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidx", "val"]}]}, {"name": "afeidx", "brief": "Row indexes of non-zero values in the column.", "desc": "Row indexes of non-zero values in the column of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "val", "brief": "New non-zero values in the column.", "desc": "New non-zero values in the column of :math:`F`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-afe-f-col", "api-name": "putafefcol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafefrownumnz": {"caml-name": "get-afe-f-row-num-nz", "name": "getafefrownumnz", "brief": "Obtains the number of nonzeros in a row of F.", "desc": "Obtains the number of nonzeros in one row of :math:`F`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index.", "desc": "Index of a row in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the row.", "desc": "Number of non-zeros in row ``afeidx`` of :math:`F`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-afe-f-row-num-nz", "api-name": "getafefrownumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafefnumnz": {"caml-name": "get-afe-f-num-nz", "name": "getafefnumnz", "brief": "Obtains the total number of nonzeros in F.", "desc": "Obtains the total number of nonzeros in :math:`F`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numnz", "brief": "Number of nonzeros in F.", "desc": "Number of non-zeros in :math:`F`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-afe-f-num-nz", "api-name": "getafefnumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafefrow": {"caml-name": "get-afe-f-row", "name": "getafefrow", "brief": "Obtains one row of F in sparse format.", "desc": "Obtains one row of :math:`F` in sparse format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index.", "desc": "Index of a row in :math:`F`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numnz", "brief": "Number of non-zeros in the row obtained.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": false}, {"name": "varidx", "brief": "Column indices of the non-zeros in the row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafefrownumnz task (arg afeidx) return-value)", "ast": ["call", "getafefrownumnz", "task", ["arg", "afeidx"], "return-value"], "arg-refs": ["afeidx"]}]}, {"name": "val", "brief": "Values of the non-zeros in the row obtained.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getafefrownumnz task (arg afeidx) return-value)", "ast": ["call", "getafefrownumnz", "task", ["arg", "afeidx"], "return-value"], "arg-refs": ["afeidx"]}]}], "ais": "function", "api-caml-name": "get-afe-f-row", "api-name": "getafefrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafeftrip": {"caml-name": "get-afe-f-trip", "name": "getafeftrip", "brief": "Obtains the F matrix in triplet format.", "desc": "Obtains the :math:`F` in triplet format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row indices of nonzeros.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafefnumnz task return-value)", "ast": ["call", "getafefnumnz", "task", "return-value"]}]}, {"name": "varidx", "brief": "Column indices of nonzeros.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafefnumnz task return-value)", "ast": ["call", "getafefnumnz", "task", "return-value"]}]}, {"name": "val", "brief": "Values of nonzero entries.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getafefnumnz task return-value)", "ast": ["call", "getafefnumnz", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-afe-f-trip", "api-name": "getafeftrip", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafebarfentry": {"caml-name": "put-afe-barf-entry", "name": "putafebarfentry", "brief": "Inputs one entry in barF.", "desc": "This function sets one entry :math:`\\barF_{ij}` where :math:`i=\\mathrm{afeidx}` is the row index in the store of\naffine expressions and :math:`j=\\mathrm{barvaridx}` is the index of a symmetric variable. That is, the expression\n\n.. math::\n   \\langle \\barF_{ij}, \\barX_j\\rangle\n\nwill be added to the :math:`i`-th affine expression.\n\nThe matrix :math:`\\barF_{ij}` is specified as a weighted sum of\nsymmetric matrices from the symmetric matrix storage :math:`E`, so\n:math:`\\barF_{ij}` is a symmetric matrix, precisely:\n\n.. math::\n   \\barF_{\\mathrm{afeidx},\\mathrm{barvaridx}} = \\sum_{k} \\mathrm{termweight}[k] \\cdot E_{\\mathrm{termidx}[k]}.\n\nBy default all elements in\n:math:`\\barF` are 0, so only non-zero elements need be added.\nSetting the same entry again will overwrite the earlier entry.\n\nThe symmetric matrices from :math:`E` are defined separately\nusing the function :msk:func:`task.appendsparsesymmat`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barvaridx", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numterm", "brief": "Number of terms in the weighted sum.", "desc": "The number of terms in the weighted sum that forms the :math:`\\barF` entry being specified.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["termweight", "termidx"]}]}, {"name": "termidx", "brief": "Element indices in matrix storage.", "desc": "Indices in :math:`E` of the matrices appearing in the weighted sum for the :math:`\\barF` entry being specified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "termweight", "brief": "Weights in the weighted sum.", "desc": "``termweight[k]`` is the coefficient of the ``termidx[k]``-th element of :math:`E` in the weighted sum the :math:`\\barF` entry being specified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-barf-entry", "api-name": "putafebarfentry", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafebarfentrylist": {"caml-name": "put-afe-barf-entry-list", "name": "putafebarfentrylist", "brief": "Inputs a list of entries in barF.", "desc": "This function sets a list of entries in :math:`\\barF`. Each entry should be described as in :msk:func:`task.putafebarfentry`\nand all those descriptions should be combined (for example concatenated) in the input to this method. That means the :math:`k`-th entry set will\nhave row index ``afeidx[k]``, symmetric variable index ``barvaridx[k]`` and the description of this term consists of\nindices in :math:`E` and weights appearing in positions\n\n.. math::\n   \\mathrm{ptrterm}[k],\\ldots,\\mathrm{ptrterm}[k] + (\\mathrm{lenterm}[k] - 1)\n\nin the corresponding arrays ``termidx`` and ``termweight``. See :msk:func:`task.putafebarfentry` for details.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafeidx", "brief": "Number of elements in the list.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["barvaridx", "ptrterm", "afeidx", "numterm"]}]}, {"name": "afeidx", "brief": "Row indexes of barF.", "desc": "Row indexes of :math:`\\barF`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barvaridx", "brief": "Semidefinite variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numterm", "brief": "Number of terms in the weighted sums.", "desc": "The number of terms in the weighted sums that form each entry.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "ptrterm", "brief": "Pointer to the terms forming each entry.", "desc": "The pointer to the beginning of the description of each entry.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lenterm", "brief": "Length of the index and weight lists.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTHOF", "arg-refs": ["termweight", "termidx"]}]}, {"name": "termidx", "brief": "Concatenated element indexes in matrix storage.", "desc": "Concatenated lists of indices in :math:`E` of the matrices appearing in the weighted sums for the :math:`\\barF` being specified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "termweight", "brief": "Concatenated weights in the weighted sum.", "desc": "Concatenated lists of weights appearing in the weighted sums forming the :math:`\\barF` elements being specified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-barf-entry-list", "api-name": "putafebarfentrylist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafebarfrow": {"caml-name": "put-afe-barf-row", "name": "putafebarfrow", "brief": "Inputs a row of barF.", "desc": "This function inputs one row in :math:`\\barF`. It first clears the row, i.e. sets :math:`\\barF_{\\mathrm{afeidx},*}=0` and then sets the new entries. Each entry should be described as in :msk:func:`task.putafebarfentry` and all those descriptions should be combined (for example concatenated) in the input to this method. That means the :math:`k`-th entry set will\nhave row index ``afeidx``, symmetric variable index ``barvaridx[k]`` and the description of this term consists of\nindices in :math:`E` and weights appearing in positions\n\n.. math::\n   \\mathrm{ptrterm}[k],\\ldots,\\mathrm{ptrterm}[k] + (\\mathrm{numterm}[k] - 1)\n\nin the corresponding arrays ``termidx`` and ``termweight``. See :msk:func:`task.putafebarfentry` for details.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numentr", "brief": "Number of entries in the row of F.", "desc": "Number of entries in the row of :math:`\\barF`; length of ``barvaridx``, ``numterm``, ``ptrterm``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["barvaridx", "ptrterm", "numterm"]}]}, {"name": "barvaridx", "brief": "Semidefinite variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numterm", "brief": "Number of terms in the weighted sums.", "desc": "The number of terms in the weighted sums that form each entry.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "ptrterm", "brief": "Pointer to the terms forming each entry.", "desc": "The pointer to the beginning of the description of each entry.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lenterm", "brief": "Length of the index and weight lists.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["termweight", "termidx"]}]}, {"name": "termidx", "brief": "Concatenated element indexes in matrix storage.", "desc": "Concatenated lists of indices in :math:`E` of the matrices appearing in the weighted sums for the :math:`\\barF` entries in the row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "termweight", "brief": "Concatenated weights in the weighted sum.", "desc": "Concatenated lists of weights appearing in the weighted sums forming the :math:`\\barF` entries in the row.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-barf-row", "api-name": "putafebarfrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafebarfrow": {"caml-name": "empty-afe-barf-row", "name": "emptyafebarfrow", "brief": "Clears a row in barF", "desc": "Clears a row in :math:`\\barF` i.e. sets :math:`\\barF_{\\mathrm{afeidx},*} = 0`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-barf-row", "api-name": "emptyafebarfrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "emptyafebarfrowlist": {"caml-name": "empty-afe-barf-row-list", "name": "emptyafebarfrowlist", "brief": "Clears rows in barF.", "desc": "Clears a number of rows in :math:`\\barF` i.e. sets :math:`\\barF_{i,*} = 0` for all indices :math:`i` in ``afeidxlist``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafeidx", "brief": "The number of rows to zero.", "desc": "The number of rows to zero, length of ``afeidxlist``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "Indices of rows in barF to clear.", "desc": "Indices of rows in :math:`\\barF` to clear.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}], "ais": "function", "api-caml-name": "empty-afe-barf-row-list", "api-name": "emptyafebarfrowlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafebarfblocktriplet": {"caml-name": "put-afe-barf-block-triplet", "name": "putafebarfblocktriplet", "brief": "Inputs barF in block triplet form.", "desc": "Inputs the :math:`\\barF` matrix data in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numtrip", "brief": "Number of elements in the block triplet form.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["valkl", "barvaridx", "subl", "afeidx", "subk"]}]}, {"name": "afeidx", "brief": "Constraint index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg numtrip)", "ast": ["arg", "numtrip"], "arg-refs": ["numtrip"]}]}, {"name": "barvaridx", "brief": "Symmetric matrix variable index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg numtrip)", "ast": ["arg", "numtrip"], "arg-refs": ["numtrip"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg numtrip)", "ast": ["arg", "numtrip"], "arg-refs": ["numtrip"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg numtrip)", "ast": ["arg", "numtrip"], "arg-refs": ["numtrip"]}]}, {"name": "valkl", "brief": "The numerical value associated with each block triplet.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numtrip)", "ast": ["arg", "numtrip"], "arg-refs": ["numtrip"]}]}], "ais": "function", "api-caml-name": "put-afe-barf-block-triplet", "api-name": "putafebarfblocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafebarfnumblocktriplets": {"caml-name": "get-afe-barf-num-block-triplets", "name": "getafebarfnumblocktriplets", "brief": "Obtains an upper bound on the number of elements in the block triplet form of barf.", "desc": "Obtains an upper bound on the number of elements in the block triplet form of :math:`\\barF`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numtrip", "brief": "An upper bound on the number of elements in the block triplet form of barf.", "desc": "An upper bound on the number of elements in the block triplet form of :math:`\\barF.`", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-afe-barf-num-block-triplets", "api-name": "getafebarfnumblocktriplets", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getafebarfblocktriplet": {"caml-name": "get-afe-barf-block-triplet", "name": "getafebarfblocktriplet", "brief": "Obtains barF in block triplet form.", "desc": "Obtains :math:`\\barF` in block triplet form.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumtrip", "brief": "afeidx, barvaridx, subk, subl and valijkl must be maxnumtrip long.", "desc": "``afeidx``, ``barvaridx``, ``subk``, ``subl`` and ``valkl`` must be  ``maxnumtrip`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getafebarfnumblocktriplets task return-value)", "ast": ["call", "getafebarfnumblocktriplets", "task", "return-value"]}]}, {"name": "numtrip", "brief": "Number of elements in the block triplet form.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}, {"name": "afeidx", "brief": "Constraint index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "barvaridx", "brief": "Symmetric matrix variable index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "subk", "brief": "Block row index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "subl", "brief": "Block column index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "valkl", "brief": "The numerical value associated with each block triplet.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}], "ais": "function", "api-caml-name": "get-afe-barf-block-triplet", "api-name": "getafebarfblocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getafebarfnumrowentries": {"caml-name": "get-afe-barf-num-row-entries", "name": "getafebarfnumrowentries", "brief": "Obtains the number of nonzero entries in a row of barF.", "desc": "Obtains the number of nonzero entries in one row of :math:`\\barF`, that is the number of :math:`j` such that :math:`\\barF_{\\mathrm{afeidx},j}` is not the zero matrix.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numentr", "brief": "Number of nonzero entries in a row of barF.", "desc": "Number of nonzero entries in a row of :math:`\\barF`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-afe-barf-num-row-entries", "api-name": "getafebarfnumrowentries", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafebarfrowinfo": {"caml-name": "get-afe-barf-row-info", "name": "getafebarfrowinfo", "brief": "Obtains information about one row of barF.", "desc": "Obtains information about one row of :math:`\\barF`: the number of nonzero entries, that is the number of :math:`j` such that :math:`\\barF_{\\mathrm{afeidx},j}` is not the zero matrix, as well as the total number of terms in the representations of all\nthese entries as weighted sums of matrices from :math:`E`. This information provides the data sizes required for a call to\n:msk:func:`task.getafebarfrow`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numentr", "brief": "Number of nonzero entries in a row of barF.", "desc": "Number of nonzero entries in a row of :math:`\\barF`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "numterm", "brief": "Number of terms in the weighted sums representation of the row of barF.", "desc": "Number of terms in the weighted sums representation of the row of :math:`\\barF`.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-afe-barf-row-info", "api-name": "getafebarfrowinfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafebarfrow": {"caml-name": "get-afe-barf-row", "name": "getafebarfrow", "brief": "Obtains nonzero entries in one row of barF.", "desc": "Obtains all nonzero entries in one row :math:`\\barF_{\\mathrm{afeidx},*}` of :math:`\\barF`. For every :math:`k` there is a nonzero entry :math:`\\barF_{\\mathrm{afeidx}, \\mathrm{barvaridx}[k]}`, which is represented as a weighted sum of :math:`\\mathrm{numterm}[k]` terms. The indices in the matrix store :math:`E` and their weights for the :math:`k`-th entry appear in the arrays ``termidx`` and ``termweight`` in positions\n\n.. math:: \\mathrm{ptrterm}[k],\\ldots,\\mathrm{ptrterm}[k]+(\\mathrm{numterm}[k]-1).\n\nThe arrays should be long enough to accommodate the data; their required lengths can be obtained with :msk:func:`task.getafebarfrowinfo`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index of barF.", "desc": "Row index of :math:`\\barF`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "barvaridx", "brief": "Semidefinite variable indices.", "desc": "Semidefinite variable indices of nonzero entries in the row of :math:`\\barF`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafebarfrowinfo task (arg afeidx) return-value dummy-value)", "ast": ["call", "getafebarfrowinfo", "task", ["arg", "afeidx"], "return-value", "dummy-value"], "arg-refs": ["afeidx"]}]}, {"name": "ptrterm", "brief": "Pointers to the description of entries.", "desc": "Pointers to the start of each entry's description.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafebarfrowinfo task (arg afeidx) return-value dummy-value)", "ast": ["call", "getafebarfrowinfo", "task", ["arg", "afeidx"], "return-value", "dummy-value"], "arg-refs": ["afeidx"]}]}, {"name": "numterm", "brief": "Number of terms in each entry.", "desc": "Number of terms in the weighted sum representation of each entry.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getafebarfrowinfo task (arg afeidx) return-value dummy-value)", "ast": ["call", "getafebarfrowinfo", "task", ["arg", "afeidx"], "return-value", "dummy-value"], "arg-refs": ["afeidx"]}]}, {"name": "termidx", "brief": "Indices of semidefinite matrices from E.", "desc": "Indices of semidefinite matrices from the matrix store :math:`E`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getafebarfrowinfo task (arg afeidx) dummy-value return-value)", "ast": ["call", "getafebarfrowinfo", "task", ["arg", "afeidx"], "dummy-value", "return-value"], "arg-refs": ["afeidx"]}]}, {"name": "termweight", "brief": "Weights appearing in the weighted sum representation.", "desc": "Weights appearing in the weighted sum representations of all entries.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getafebarfrowinfo task (arg afeidx) dummy-value return-value)", "ast": ["call", "getafebarfrowinfo", "task", ["arg", "afeidx"], "dummy-value", "return-value"], "arg-refs": ["afeidx"]}]}], "ais": "function", "api-caml-name": "get-afe-barf-row", "api-name": "getafebarfrow", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafeg": {"caml-name": "put-afe-g", "name": "putafeg", "brief": "Replaces one element in the g vector in the affine expressions.", "desc": "Change one element of the vector :math:`g` in affine expressions i.e.\n\n.. math:: g_{\\mathtt{afeidx}} = \\mathtt{gi}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Row index.", "desc": "Index of an entry in :math:`g`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "g", "brief": "New value for the element of g.", "desc": "New value for :math:`g_{\\mathrm{afeidx}}`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-g", "api-name": "putafeg", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putafeglist": {"caml-name": "put-afe-g-list", "name": "putafeglist", "brief": "Replaces a list of elements in the g vector in the affine expressions.", "desc": "Changes a list of elements of the vector :math:`g` in affine expressions i.e. for all :math:`k` it sets\n\n.. math:: g_{\\mathrm{afeidx}[k]} = \\mathrm{glist}[k].", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafeidx", "brief": "Number of entries.", "desc": "Number of entries to change; length of ``afeidxlist``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidx", "g"]}]}, {"name": "afeidx", "brief": "Indices of entries in g.", "desc": "Indices of entries in :math:`g`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "g", "brief": "New values for the elements of g.", "desc": "New values for :math:`g`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-afe-g-list", "api-name": "putafeglist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafeg": {"caml-name": "get-afe-g", "name": "getafeg", "brief": "Obtains a single coefficient in g.", "desc": "Obtains a single coefficient in :math:`g`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "afeidx", "brief": "Element index.", "desc": "Index of an element in :math:`g`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "g", "brief": "The entry in g.", "desc": "The value of :math:`g_{\\mathrm{afeidx}}`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-afe-g", "api-name": "getafeg", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getafegslice": {"caml-name": "get-afe-g-slice", "name": "getafegslice", "brief": "Obtains a sequence of coefficients from the vector g.", "desc": "Obtains a sequence of elements from the vector :math:`g` of constant terms in the affine expressions list.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "g", "brief": "The slice of g as a dense vector.", "desc": "The slice :math:`g` as a dense vector. The length is ``last-first``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "get-afe-g-slice", "api-name": "getafegslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-afe"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putafegslice": {"caml-name": "put-afe-g-slice", "name": "putafegslice", "brief": "Modifies a slice of the vector g.", "desc": "Modifies a slice in the vector :math:`g` of constant terms in affine expressions using the principle\n\n.. math:: g_{\\mathtt{j}} = \\mathtt{slice[j-first\\idxorg]}, \\quad j=\\mathrm{first},..,\\mathrm{last}-1", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slice", "brief": "The slice of g as a dense vector.", "desc": "The slice of :math:`g` as a dense vector. The length is ``last-first``.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-afe-g-slice", "api-name": "putafegslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumdjc": {"caml-name": "put-max-num-djc", "name": "putmaxnumdjc", "brief": "Sets the number of preallocated disjunctive constraints.", "desc": "Sets the number of preallocated disjunctive constraints in the optimization task. When this\nnumber is reached |mosek| will automatically allocate more space.\nIt is never mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumdjc", "brief": "Number of preallocated disjunctive constraints in the task.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-djc", "api-name": "putmaxnumdjc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-djc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumdjc": {"caml-name": "get-num-djc", "name": "getnumdjc", "brief": "Obtains the number of disjunctive constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "The number of disjunctive constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-djc", "api-name": "getnumdjc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumdomain": {"caml-name": "get-djc-num-domain", "name": "getdjcnumdomain", "brief": "Obtains the number of domains in the disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numdomain", "brief": "Number of domains in the disjunctive constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-domain", "api-name": "getdjcnumdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumdomaintot": {"caml-name": "get-djc-num-domain-tot", "name": "getdjcnumdomaintot", "brief": "Obtains the number of domains in all disjunctive constraints.", "desc": "Obtains the total number of domains in all disjunctive constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numdomaintot", "brief": "Number of domains in all disjunctive constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-domain-tot", "api-name": "getdjcnumdomaintot", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumafe": {"caml-name": "get-djc-num-afe", "name": "getdjcnumafe", "brief": "Obtains the number of affine expressions in the disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafe", "brief": "Number of affine expressions in the disjunctive constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-afe", "api-name": "getdjcnumafe", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumafetot": {"caml-name": "get-djc-num-afe-tot", "name": "getdjcnumafetot", "brief": "Obtains the number of affine expressions in all disjunctive constraints.", "desc": "Obtains the total number of affine expressions in all disjunctive constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numafetot", "brief": "Number of affine expressions in all disjunctive constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-afe-tot", "api-name": "getdjcnumafetot", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumterm": {"caml-name": "get-djc-num-term", "name": "getdjcnumterm", "brief": "Obtains the number terms in the disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numterm", "brief": "Number of terms in the disjunctive constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-term", "api-name": "getdjcnumterm", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcnumtermtot": {"caml-name": "get-djc-num-term-tot", "name": "getdjcnumtermtot", "brief": "Obtains the number of terms in all disjunctive constraints.", "desc": "Obtains the total number of terms in all disjunctive constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numtermtot", "brief": "Total number of terms in all disjunctive constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-djc-num-term-tot", "api-name": "getdjcnumtermtot", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumacc": {"caml-name": "put-max-num-acc", "name": "putmaxnumacc", "brief": "Sets the number of preallocated affine conic constraints.", "desc": "Sets the number of preallocated affine conic constraints in the optimization task. When this\nnumber is reached |mosek| will automatically allocate more space.\nIt is never mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumacc", "brief": "Number of preallocated affine conic constraints.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-acc", "api-name": "putmaxnumacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumacc": {"caml-name": "get-num-acc", "name": "getnumacc", "brief": "Obtains the number of affine conic constraints.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "The number of affine conic constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-acc", "api-name": "getnumacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendacc": {"caml-name": "append-acc", "name": "appendacc", "brief": "Appends an affine conic constraint to the task.", "desc": "Appends an affine conic constraint to the task. The affine constraint has the form *a sequence of affine expressions belongs to a domain*.\n\nThe domain index is specified with ``domidx`` and should refer to a domain previously appended with one of the ``append...domain`` functions.\n\nThe length of the affine expression list ``afeidxlist`` must be equal to the dimension :math:`n` of the domain. The elements of ``afeidxlist`` are indexes to the store of affine expressions, i.e. the affine expressions appearing in the affine conic constraint are:\n\n.. math:: F_{\\mathtt{afeidxlist}[k],:}x + g_{\\mathtt{afeidxlist}[k]} \\quad \\mathrm{for}\\ k=\\idxbeg,\\ldots,\\idxend{n}.\n\nIf an optional vector ``b`` of the same length as ``afeidxlist`` is specified then the expressions appearing in the affine constraint will instead be taken as:\n\n.. math:: F_{\\mathtt{afeidxlist}[k],:}x + g_{\\mathtt{afeidxlist}[k]} - b_k \\quad \\mathrm{for}\\ k=\\idxbeg,\\ldots,\\idxend{n}.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Domain index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the dimension of the domain).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "append-acc", "api-name": "appendacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendaccs": {"caml-name": "append-accs", "name": "appendaccs", "brief": "Appends a number of affine conic constraint to the task.", "desc": "Appends ``numaccs`` affine conic constraint to the task. Each single affine conic constraint should be specified as in :msk:func:`task.appendacc` and the input of this function should contain the concatenation of all these descriptions.\n\nIn particular, the length of ``afeidxlist`` must equal the sum of dimensions of domains indexed in ``domainsidxs``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numaccs", "brief": "The number of affine conic constraints to append.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["domidxs"]}]}, {"name": "domidxs", "brief": "Domain indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "append-accs", "api-name": "appendaccs", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendaccseq": {"caml-name": "append-acc-seq", "name": "appendaccseq", "brief": "Appends an affine conic constraint to the task.", "desc": "Appends an affine conic constraint to the task, as in :msk:func:`task.appendacc`. The function assumes the affine expressions forming the constraint are sequential. The affine constraint has the form *a sequence of affine expressions belongs to a domain*.\n\nThe domain index is specified with ``domidx`` and should refer to a domain previously appended with one of the ``append...domain`` functions.\n\nThe number of affine expressions should be equal to the dimension :math:`n` of the domain. The affine expressions forming the affine constraint are arranged sequentially in a contiguous block of the affine expression store starting from position ``afeidxfirst``. That is, the affine expressions appearing in the affine conic constraint are:\n\n.. math:: F_{\\mathtt{afeidxfirst}+k,:}x + g_{\\mathtt{afeidxfirst}+k} \\quad \\mathrm{for}\\ k=\\idxbeg,\\ldots,\\idxend{n}.\n\nIf an optional vector ``b`` of length ``numafeidx`` is specified then the expressions appearing in the affine constraint will instead be taken as\n\n.. math:: F_{\\mathtt{afeidxfirst}+k,:}x + g_{\\mathtt{afeidxfirst}+k} - b_k \\quad \\mathrm{for}\\ k=\\idxbeg,\\ldots,\\idxend{n}.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Domain index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the dimension of the domain).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getdomainn task (arg domidx) return-value)", "ast": ["call", "getdomainn", "task", ["arg", "domidx"], "return-value"], "arg-refs": ["domidx"]}]}, {"name": "afeidxfirst", "brief": "Index of the first affine expression.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "append-acc-seq", "api-name": "appendaccseq", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendaccsseq": {"caml-name": "append-accs-seq", "name": "appendaccsseq", "brief": "Appends a number of affine conic constraint to the task.", "desc": "Appends ``numaccs`` affine conic constraint to the task. It is the block variant of :msk:func:`task.appendaccs`, that is it assumes that the affine expressions appearing in the affine conic constraints are sequential in the affine expression store, starting from position ``afeidxfirst``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numaccs", "brief": "The number of affine conic constraints to append.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["domidxs"]}]}, {"name": "domidxs", "brief": "Domain indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "afeidxfirst", "brief": "Index of the first affine expression.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "append-accs-seq", "api-name": "appendaccsseq", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacc": {"caml-name": "put-acc", "name": "putacc", "brief": "Puts an affine conic constraint.", "desc": "Puts an affine conic constraint. This method overwrites an existing affine conic constraint number ``accidx`` with new data specified in the same format as in :msk:func:`task.appendacc`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Affine conic constraint index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "domidx", "brief": "Domain index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the dimension of the domain).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "put-acc", "api-name": "putacc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putacclist": {"caml-name": "put-acc-list", "name": "putacclist", "brief": "Puts a number of affine conic constraints.", "desc": "Puts affine conic constraints. This method overwrites existing affine conic constraints whose numbers are provided in the list ``accidxs`` with new data which is a concatenation of individual constraint descriptions in the same format as in :msk:func:`task.appendacc` (see also :msk:func:`task.appendaccs`).", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numaccs", "brief": "The number of affine conic constraints to append.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["domidxs", "accidxs"]}]}, {"name": "accidxs", "brief": "Affine conic constraint indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "domidxs", "brief": "Domain indices.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions in the affine expression list (must equal the sum of dimensions of the domains).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}], "ais": "function", "api-caml-name": "put-acc-list", "api-name": "putacclist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaccb": {"caml-name": "put-acc-b", "name": "putaccb", "brief": "Puts the constant vector b in an affine conic constraint.", "desc": "Updates an existing affine conic constraint number ``accidx`` by putting a new vector :math:`b`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Affine conic constraint index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "lengthb", "brief": "Length of the vector (must equal the dimension of this constraint).", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["b"]}]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-acc-b", "api-name": "putaccb", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putaccbj": {"caml-name": "put-acc-b-j", "name": "putaccbj", "brief": "Sets one element in the b vector of an affine conic constraint.", "desc": "Sets one value :math:`b[j]` in the :math:`b` vector for the affine conic constraint number ``accidx``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Affine conic constraint index.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "The index of an element in b to change.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bj", "brief": "The new value of b[j].", "desc": "The new value of :math:`b[j]`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-acc-b-j", "api-name": "putaccbj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccdomain": {"caml-name": "get-acc-domain", "name": "getaccdomain", "brief": "Obtains the domain appearing in the affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "The index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "domidx", "brief": "The index of domain in the affine conic constraint.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-domain", "api-name": "getaccdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccn": {"caml-name": "get-acc-n", "name": "getaccn", "brief": "Obtains the dimension of the affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "The index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "n", "brief": "The dimension of the affine conic constraint (equal to the dimension of its domain).", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-n", "api-name": "getaccn", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccntot": {"caml-name": "get-acc-n-tot", "name": "getaccntot", "brief": "Obtains the total dimension of all affine conic constraints.", "desc": "Obtains the total dimension of all affine conic constraints (the sum of all their dimensions).", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "The total dimension of all affine conic constraints.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-n-tot", "api-name": "getaccntot", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccafeidxlist": {"caml-name": "get-acc-afe-idx-list", "name": "getaccafeidxlist", "brief": "Obtains the list of affine expressions appearing in the affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "afeidxlist", "brief": "List of indexes of affine expressions appearing in the constraint.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getaccn task (arg accidx) return-value)", "ast": ["call", "getaccn", "task", ["arg", "accidx"], "return-value"], "arg-refs": ["accidx"]}]}], "ais": "function", "api-caml-name": "get-acc-afe-idx-list", "api-name": "getaccafeidxlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccb": {"caml-name": "get-acc-b", "name": "getaccb", "brief": "Obtains the additional constant term vector appearing in the affine conic constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accidx", "brief": "Index of the affine conic constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector b appearing in the constraint.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccn task (arg accidx) return-value)", "ast": ["call", "getaccn", "task", ["arg", "accidx"], "return-value"], "arg-refs": ["accidx"]}]}], "ais": "function", "api-caml-name": "get-acc-b", "api-name": "getaccb", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccs": {"caml-name": "get-accs", "name": "getaccs", "brief": "Obtains full data of all affine conic constraints.", "desc": "Obtains full data of all affine conic constraints. The output array ``domainidxlist`` must have at least length determined by :msk:func:`task.getnumacc`. The output arrays ``afeidxlist`` and ``b`` must have at least length determined by :msk:func:`task.getaccntot`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidxlist", "brief": "The list of domains appearing in all affine conic constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getnumacc task return-value)", "ast": ["call", "getnumacc", "task", "return-value"]}]}, {"name": "afeidxlist", "brief": "The concatenation of index lists of affine expressions appearing in all affine conic constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}, {"name": "b", "brief": "The concatenation of vectors b appearing in all affine conic constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-accs", "api-name": "getaccs", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccfnumnz": {"caml-name": "get-acc-f-numnz", "name": "getaccfnumnz", "brief": "Obtains the total number of nonzeros in the ACC implied F matrix.", "desc": "If the AFEs are not added sequentially to the ACCs, then the present function gives the number of nonzero elements in the F matrix that would be implied by the ordering of AFEs within ACCs.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "accfnnz", "brief": "Number of nonzeros in the F matrix implied by ACCs.", "desc": "Number of non-zeros in :math:`F` implied by ACCs.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-f-numnz", "api-name": "getaccfnumnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccftrip": {"caml-name": "get-acc-f-trip", "name": "getaccftrip", "brief": "Obtains the F matrix (implied by the AFE ordering within the ACCs) in triplet format.", "desc": "Obtains the :math:`F` (that would be implied by the ordering of the AFEs within the ACCs) in triplet format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "frow", "brief": "Row indices of nonzeros in the implied F matrix.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getaccfnumnz task return-value)", "ast": ["call", "getaccfnumnz", "task", "return-value"]}]}, {"name": "fcol", "brief": "Column indices of nonzeros in the implied F matrix.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getaccfnumnz task return-value)", "ast": ["call", "getaccfnumnz", "task", "return-value"]}]}, {"name": "fval", "brief": "Values of nonzero entries in the implied F matrix.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccfnumnz task return-value)", "ast": ["call", "getaccfnumnz", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-acc-f-trip", "api-name": "getaccftrip", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getaccgvector": {"caml-name": "get-acc-g-vector", "name": "getaccgvector", "brief": "The g vector as used within the ACCs.", "desc": "If the AFEs are passed out of sequence to the ACCs, then this function can be used to obtain the vector :math:`g` of constant terms used within the ACCs.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "g", "brief": "The g vector as used within the ACCs.", "desc": "The :math:`g` used within the ACCs as a dense vector. The length is sum of the dimensions of the ACCs.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getaccntot task return-value)", "ast": ["call", "getaccntot", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-acc-g-vector", "api-name": "getaccgvector", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-acc"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccbarfnumblocktriplets": {"caml-name": "get-acc-barf-num-block-triplets", "name": "getaccbarfnumblocktriplets", "brief": "Obtains an upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.", "desc": "Obtains an upper bound on the number of elements in the block triplet form of :math:`\\barF`, as used within the ACCs.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numtrip", "brief": "An upper bound on the number of elements in the block triplet form of barf, as used within the ACCs.", "desc": "An upper bound on the number of elements in the block triplet form of :math:`\\barF.`, as used within the ACCs.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-acc-barf-num-block-triplets", "api-name": "getaccbarfnumblocktriplets", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-acc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getaccbarfblocktriplet": {"caml-name": "get-acc-barf-block-triplet", "name": "getaccbarfblocktriplet", "brief": "Obtains barF, implied by the ACCs, in block triplet form.", "desc": "Obtains :math:`\\barF`, implied by the ACCs, in block triplet form. If the AFEs passed to the ACCs were out of order, then this function can be used to obtain the barF as seen by the ACCs.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumtrip", "brief": "acc_afe, bar_var, blk_row, blk_col and blk_val must be numtrip long.", "desc": "``acc_afe``, ``bar_var``, ``blk_row``, ``blk_col`` and ``blk_val`` must be  ``numtrip`` long.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getaccbarfnumblocktriplets task return-value)", "ast": ["call", "getaccbarfnumblocktriplets", "task", "return-value"]}]}, {"name": "numtrip", "brief": "Number of elements in the block triplet form.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}, {"name": "acc_afe", "brief": "Index of the AFE within the concatenated list of AFEs in ACCs.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "bar_var", "brief": "Symmetric matrix variable index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "blk_row", "brief": "Block row index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "blk_col", "brief": "Block column index.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}, {"name": "blk_val", "brief": "The numerical value associated with each block triplet.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxnumtrip)", "ast": ["arg", "maxnumtrip"], "arg-refs": ["maxnumtrip"]}]}], "ais": "function", "api-caml-name": "get-acc-barf-block-triplet", "api-name": "getaccbarfblocktriplet", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-afe", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "const"}, "appenddjcs": {"caml-name": "append-djcs", "name": "appenddjcs", "brief": "Appends a number of empty disjunctive constraints to the task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of empty disjunctive constraints which should be appended.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "append-djcs", "api-name": "appenddjcs", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putdjc": {"caml-name": "put-djc", "name": "putdjc", "brief": "Inputs a disjunctive constraint.", "desc": "Inputs a disjunctive constraint. The constraint has the form\n\n.. math:: T_1\\ \\mathrm{or}\\ T_2\\ \\mathrm{or}\\ \\cdots\\ \\mathrm{or}\\ T_{\\mathrm{numterms}}\n\nFor each :math:`i=1,\\ldots\\mathrm{numterms}` the :math:`i`-th clause (term) :math:`T_i` has the form *a sequence of affine expressions belongs to a product of domains*, where the number of domains is :math:`\\mathrm{termsizelist}[i]` and the number of affine expressions is equal to the sum of dimensions of all domains appearing in :math:`T_i`.\n\nAll the domains and all the affine expressions appearing in the above description are arranged sequentially in the lists ``domidxlist`` and ``afeidxlist``, respectively. In particular, the length of ``domidxlist`` must be equal to the sum of elements of ``termsizelist``, and the length of ``afeidxlist`` must be equal to the sum of dimensions of all the domains appearing in ``domidxlist``.\n\nThe elements of ``domidxlist`` are indexes of domains previously defined with one of the ``append...domain`` functions.\n\nThe elements of ``afeidxlist`` are indexes to the store of affine expressions, i.e. the :math:`k`-th affine expression appearing in the disjunctive constraint is going to be\n\n.. math:: F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]}\n\nIf an optional vector ``b`` of the same length as ``afeidxlist`` is specified then the :math:`k`-th affine expression appearing in the disjunctive constraint will be taken as\n\n.. math:: F_{\\mathrm{afeidxlist}[k],:}x + g_{\\mathrm{afeidxlist}[k]} - b_k", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numdomidx", "brief": "Number of domains.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["domidxlist"]}]}, {"name": "domidxlist", "brief": "List of domain indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}, {"name": "numterms", "brief": "Number of terms in disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["termsizelist"]}]}, {"name": "termsizelist", "brief": "List of term sizes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-djc", "api-name": "putdjc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putdjcslice": {"caml-name": "put-djc-slice", "name": "putdjcslice", "brief": "Inputs a slice of disjunctive constraints.", "desc": "Inputs a slice of disjunctive constraints.\n\nThe array ``termsindjc`` should have length :math:`\\mathrm{idxlast}-\\mathrm{idxfirst}` and contain the number of terms in consecutive constraints forming the slice.\n\nThe rest of the input consists of concatenated descriptions of individual constraints, where each constraint is described as in :msk:func:`task.putdjc`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idxfirst", "brief": "Index of the first disjunctive constraint in the slice.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "idxlast", "brief": "Index of the last disjunctive constraint in the slice plus 1.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numdomidx", "brief": "Number of domains.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["domidxlist"]}]}, {"name": "domidxlist", "brief": "List of domain indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numafeidx", "brief": "Number of affine expressions.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["afeidxlist"]}]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector of constant terms added to affine expressions. Optional.", "desc": "The vector of constant terms added to affine expressions. |optionalvector|", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numafeidx)", "ast": ["arg", "numafeidx"], "arg-refs": ["numafeidx"]}]}, {"name": "numterms", "brief": "Number of terms in the disjunctive constraints.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["termsizelist"]}]}, {"name": "termsizelist", "brief": "List of term sizes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "termsindjc", "brief": "Number of terms in each of the disjunctive constraints in the slice.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg idxlast) (arg idxfirst))", "ast": ["-", ["arg", "idxlast"], ["arg", "idxfirst"]], "arg-refs": ["idxlast", "idxfirst"]}]}], "ais": "function", "api-caml-name": "put-djc-slice", "api-name": "putdjcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdjcdomainidxlist": {"caml-name": "get-djc-domain-idx-list", "name": "getdjcdomainidxlist", "brief": "Obtains the list of domain indexes in a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "domidxlist", "brief": "List of term sizes.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumdomain task (arg djcidx) return-value)", "ast": ["call", "getdjcnumdomain", "task", ["arg", "djcidx"], "return-value"], "arg-refs": ["djcidx"]}]}], "ais": "function", "api-caml-name": "get-djc-domain-idx-list", "api-name": "getdjcdomainidxlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjcafeidxlist": {"caml-name": "get-djc-afe-idx-list", "name": "getdjcafeidxlist", "brief": "Obtains the list of affine expression indexes in a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "afeidxlist", "brief": "List of affine expression indexes.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumafe task (arg djcidx) return-value)", "ast": ["call", "getdjcnumafe", "task", ["arg", "djcidx"], "return-value"], "arg-refs": ["djcidx"]}]}], "ais": "function", "api-caml-name": "get-djc-afe-idx-list", "api-name": "getdjcafeidxlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjcb": {"caml-name": "get-djc-b", "name": "getdjcb", "brief": "Obtains the optional constant term vector of a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "b", "brief": "The vector b.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumafe task (arg djcidx) return-value)", "ast": ["call", "getdjcnumafe", "task", ["arg", "djcidx"], "return-value"], "arg-refs": ["djcidx"]}]}], "ais": "function", "api-caml-name": "get-djc-b", "api-name": "getdjcb", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjctermsizelist": {"caml-name": "get-djc-term-size-list", "name": "getdjctermsizelist", "brief": "Obtains the list of term sizes in a disjunctive constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "djcidx", "brief": "Index of the disjunctive constraint.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "termsizelist", "brief": "List of term sizes.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumterm task (arg djcidx) return-value)", "ast": ["call", "getdjcnumterm", "task", ["arg", "djcidx"], "return-value"], "arg-refs": ["djcidx"]}]}], "ais": "function", "api-caml-name": "get-djc-term-size-list", "api-name": "getdjctermsizelist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdjcs": {"caml-name": "get-djcs", "name": "getdjcs", "brief": "Obtains full data of all disjunctive constraints.", "desc": "Obtains full data of all disjunctive constraints. The output arrays must have minimal lengths determined by the following methods: ``domainidxlist`` by :msk:func:`task.getdjcnumdomaintot`, ``afeidxlist`` and ``b`` by :msk:func:`task.getdjcnumafetot`, ``termsizelist`` by :msk:func:`task.getdjcnumtermtot` and ``numterms`` by :msk:func:`task.getnumdomain`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidxlist", "brief": "The concatenation of index lists of domains appearing in all disjunctive constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumdomaintot task return-value)", "ast": ["call", "getdjcnumdomaintot", "task", "return-value"]}]}, {"name": "afeidxlist", "brief": "The concatenation of index lists of affine expressions appearing in all disjunctive constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumafetot task return-value)", "ast": ["call", "getdjcnumafetot", "task", "return-value"]}]}, {"name": "b", "brief": "The concatenation of vectors b appearing in all disjunctive constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumafetot task return-value)", "ast": ["call", "getdjcnumafetot", "task", "return-value"]}]}, {"name": "termsizelist", "brief": "The concatenation of lists of term sizes appearing in all disjunctive constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getdjcnumtermtot task return-value)", "ast": ["call", "getdjcnumtermtot", "task", "return-value"]}]}, {"name": "numterms", "brief": "The number of terms in each of the disjunctive constraints.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getnumdjc task return-value)", "ast": ["call", "getnumdjc", "task", "return-value"]}]}], "ais": "function", "api-caml-name": "get-djcs", "api-name": "getdjcs", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-djc", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putconbound": {"caml-name": "put-con-bound", "name": "putconbound", "brief": "Changes the bound for one constraint.", "desc": "Changes the bounds for one constraint.\n\nIf the bound value specified is numerically larger than :msk:dparam:`data_tol_bound_inf` it is considered infinite and the bound key is\nchanged accordingly. If a bound value is numerically larger than :msk:dparam:`data_tol_bound_wrn`, a warning will be displayed, but the bound is inputted as specified.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkc", "brief": "New bound key.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blc", "brief": "New lower bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "buc", "brief": "New upper bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-con-bound", "api-name": "putconbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconboundslice"]}], "member-of": ["task-linear", "task-constraint", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconboundlist": {"old-name": "putconboundlist", "caml-name": "put-con-bound-list", "name": "putconboundlist", "brief": "Changes the bounds of a list of constraints.", "desc": "Changes the bounds for a list of constraints. If multiple bound changes are specified for a constraint, then only the last change takes effect. Data checks are performed as in :msk:func:`task.putconbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of bounds that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["bkc", "blc", "buc", "sub"]}]}, {"name": "sub", "brief": "List of constraint indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "buc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-con-bound-list", "api-name": "putconboundlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconbound"]}, {"type": "function", "item": ["mosek", "task", "putconboundslice"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-constraint", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconboundlistconst": {"old-name": "putconboundlistconst", "caml-name": "put-con-bound-list-const", "name": "putconboundlistconst", "brief": "Changes the bounds of a list of constraints.", "desc": "Changes the bounds for one or more constraints. Data checks are performed as in :msk:func:`task.putconbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of bounds that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "List of constraint indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkc", "brief": "New bound key for all constraints in the list.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blc", "brief": "New lower bound for all constraints in the list.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "buc", "brief": "New upper bound for all constraints in the list.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-con-bound-list-const", "api-name": "putconboundlistconst", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconbound"]}, {"type": "function", "item": ["mosek", "task", "putconboundslice"]}, {"type": "function", "item": ["mosek", "task", "putconboundlist"]}, {"type": "function", "item": ["mosek", "task", "putconboundsliceconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-constraint", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconboundslice": {"old-name": "putconboundslice", "caml-name": "put-con-bound-slice", "name": "putconboundslice", "brief": "Changes the bounds for a slice of the constraints.", "desc": "Changes the bounds for a slice of the constraints. Data checks are performed as in :msk:func:`task.putconbound`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "blc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "buc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-con-bound-slice", "api-name": "putconboundslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconbound"]}, {"type": "function", "item": ["mosek", "task", "putconboundlist"]}], "member-of": ["task-linear", "task-constraint", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconboundsliceconst": {"old-name": "putconboundsliceconst", "caml-name": "put-con-bound-slice-const", "name": "putconboundsliceconst", "brief": "Changes the bounds for a slice of the constraints.", "desc": "Changes the bounds for a slice of the constraints. Data checks are performed as in :msk:func:`task.putconbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkc", "brief": "New bound key for all constraints in the slice.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blc", "brief": "New lower bound for all constraints in the slice.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "buc", "brief": "New upper bound for all constraints in the slice.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-con-bound-slice-const", "api-name": "putconboundsliceconst", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putconbound"]}, {"type": "function", "item": ["mosek", "task", "putconboundslice"]}, {"type": "function", "item": ["mosek", "task", "putconboundlist"]}, {"type": "function", "item": ["mosek", "task", "putconboundlistconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-constraint", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarbound": {"old-name": "putvarbound", "caml-name": "put-var-bound", "name": "putvarbound", "brief": "Changes the bounds for one variable.", "desc": "Changes the bounds for one variable.\n\nIf the bound value specified is numerically larger than\n:msk:dparam:`data_tol_bound_inf` it is considered infinite and the bound key is\nchanged accordingly. If a bound value is numerically larger than\n:msk:dparam:`data_tol_bound_wrn`, a warning will be displayed, but the bound is\ninputted as specified.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkx", "brief": "New bound key.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blx", "brief": "New lower bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "bux", "brief": "New upper bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-var-bound", "api-name": "putvarbound", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarboundslice"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlist"]}, {"type": "function", "item": ["mosek", "task", "putvarboundsliceconst"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlistconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-variable", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarboundlist": {"old-name": "putvarboundlist", "caml-name": "put-var-bound-list", "name": "putvarboundlist", "brief": "Changes the bounds of a list of variables.", "desc": "Changes the bounds for one or more variables. If multiple bound changes are specified for a variable, then only the last change takes effect. Data checks are performed as in :msk:func:`task.putvarbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of bounds that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["blx", "bux", "bkx", "sub"]}]}, {"name": "sub", "brief": "List of variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true}, {"name": "blx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "bux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-var-bound-list", "api-name": "putvarboundlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarbound"]}, {"type": "function", "item": ["mosek", "task", "putvarboundslice"]}, {"type": "function", "item": ["mosek", "task", "putvarboundsliceconst"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlistconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-variable", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarboundlistconst": {"old-name": "putvarboundlistconst", "caml-name": "put-var-bound-list-const", "name": "putvarboundlistconst", "brief": "Changes the bounds of a list of variables.", "desc": "Changes the bounds for one or more variables. Data checks are performed as in :msk:func:`task.putvarbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of bounds that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["sub"]}]}, {"name": "sub", "brief": "List of variable indexes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkx", "brief": "New bound key for all variables in the list.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blx", "brief": "New lower bound for all variables in the list.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "bux", "brief": "New upper bound for all variables in the list.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-var-bound-list-const", "api-name": "putvarboundlistconst", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarbound"]}, {"type": "function", "item": ["mosek", "task", "putvarboundslice"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlist"]}, {"type": "function", "item": ["mosek", "task", "putvarboundsliceconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-variable", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarboundslice": {"old-name": "putvarboundslice", "caml-name": "put-var-bound-slice", "name": "putvarboundslice", "brief": "Changes the bounds for a slice of the variables.", "desc": "Changes the bounds for a slice of the variables. Data checks are performed as in :msk:func:`task.putvarbound`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "boundkey"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "blx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}, {"name": "bux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-var-bound-slice", "api-name": "putvarboundslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarbound"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlist"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlistconst"]}, {"type": "function", "item": ["mosek", "task", "putvarboundsliceconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-variable", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarboundsliceconst": {"old-name": "putvarboundsliceconst", "caml-name": "put-var-bound-slice-const", "name": "putvarboundsliceconst", "brief": "Changes the bounds for a slice of the variables.", "desc": "Changes the bounds for a slice of the variables. Data checks are performed as in :msk:func:`task.putvarbound`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "bkx", "brief": "New bound key for all variables in the slice.", "mode": "i", "type": ["const-class", "mosek", "boundkey"], "null?": false, "api?": true}, {"name": "blx", "brief": "New lower bound for all variables in the slice.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "bux", "brief": "New upper bound for all variables in the slice.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-var-bound-slice-const", "api-name": "putvarboundsliceconst", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvarbound"]}, {"type": "function", "item": ["mosek", "task", "putvarboundslice"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlist"]}, {"type": "function", "item": ["mosek", "task", "putvarboundlistconst"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_inf"]}, {"type": "constant", "item": ["mosek", "dparam", "data_tol_bound_wrn"]}], "member-of": ["task-linear", "task-variable", "task-bound"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putcallbackfunc": {"old-name": "putcallbackfunc", "caml-name": "put-callback-func", "name": "putcallbackfunc", "brief": "Input the progress callback function.", "desc": "Sets a user-defined progress callback function of type :msk:type:`callbackfunc`. The callback function is called frequently during\nthe optimization process. See Section :ref:`doc.callback` for an example.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "func", "brief": "A pointer to a user-defined callback function.", "desc": "A user-defined function which will be called occasionally from within the\n|mosek| optimizers.  If the argument is |null|, then a previously\ndefined callback function is removed. The progress function has the type\n:msk:type:`callbackfunc`.", "mode": "i", "type": ["defined", "mosek", "callbackfunc"], "null?": false, "api?": true}, {"name": "handle", "brief": "A pointer to user-defined structure.", "desc": "A pointer to a user-defined data structure.  Whenever the function\n``func`` is called, then ``handle`` is passed to the function.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-callback-func", "api-name": "putcallbackfunc", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [{"type": "constant", "item": ["mosek", "iparam", "log_sim_freq"]}], "member-of": ["callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putcfix": {"old-name": "putcfix", "caml-name": "put-cfix", "name": "putcfix", "brief": "Replaces the fixed term in the objective.", "desc": "Replaces the fixed term in the objective by a new one.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "cfix", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-cfix", "api-name": "putcfix", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putcj": {"caml-name": "put-c-j", "name": "putcj", "brief": "Modifies one linear coefficient in the objective.", "desc": "Modifies one coefficient in the linear objective vector :math:`c`, i.e.\n\n.. math:: c_{\\mathtt{j}} = \\mathtt{cj}.\n\nIf the absolute value exceeds :msk:dparam:`data_tol_c_huge` an error is generated. If the absolute value exceeds :msk:dparam:`data_tol_cj_large`, a warning is generated, but the coefficient is inputted as specified.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable whose objective coefficient should be changed.", "desc": "Index of the variable for which :math:`c` should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "cj", "brief": "New coefficient value.", "desc": "New value of :math:`c_j`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-c-j", "api-name": "putcj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putclist"]}, {"type": "function", "item": ["mosek", "task", "putcslice"]}], "member-of": ["task-linear", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putobjsense": {"old-name": "putobjsense", "caml-name": "put-obj-sense", "name": "putobjsense", "brief": "Sets the objective sense.", "desc": "Sets the objective sense of the task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "sense", "brief": "The objective sense of the task", "desc": "The objective sense of the task. The values :msk:const:`objsense.maximize`  and\n:msk:const:`objsense.minimize`  mean that the problem is maximized or minimized respectively.", "mode": "i", "type": ["const-class", "mosek", "objsense"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-obj-sense", "api-name": "putobjsense", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "getobjsense"]}], "member-of": ["task-linear", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getobjsense": {"old-name": "getobjsense", "caml-name": "get-obj-sense", "name": "getobjsense", "brief": "Gets the objective sense.", "desc": "Gets the objective sense of the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "sense", "brief": "The returned objective sense.", "mode": "o", "type": ["ref", ["const-class", "mosek", "objsense"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-obj-sense", "api-name": "getobjsense", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putobjsense"]}], "member-of": ["task-linear"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putclist": {"old-name": "putclist", "caml-name": "put-c-list", "name": "putclist", "brief": "Modifies a part of the linear objective coefficients.", "desc": "Modifies the coefficients in the linear term :math:`c` in the objective using the principle\n\n.. math:: c_{\\mathtt{subj[t]}} = \\mathtt{val[t]}, \\quad t=\\idxbeg,\\ldots,\\idxend{\\mathtt{num}}.\n\nIf a variable index is specified multiple times in ``subj`` only the last entry is used. Data checks are performed as in :msk:func:`task.putcj`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of coefficients that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["val", "subj"]}]}, {"name": "subj", "brief": "Indices of variables for which objective coefficients should be changed.", "desc": "Indices of variables for which the coefficient in :math:`c` should be changed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "val", "brief": "New numerical values for the objective coefficients that should be modified.", "desc": "New numerical values for coefficients in :math:`c` that should be modified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-c-list", "api-name": "putclist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-variable", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putcslice": {"old-name": "putcslice", "caml-name": "put-c-slice", "name": "putcslice", "brief": "Modifies a slice of the linear objective coefficients.", "desc": "Modifies a slice in the linear term :math:`c` in the objective using the principle\n\n.. math:: c_{\\mathtt{j}} = \\mathtt{slice[j-first\\idxorg]}, \\quad j=\\mathtt{first},..,\\mathtt{last}-1\n\nData checks are performed as in :msk:func:`task.putcj`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "first", "brief": "First element in the slice of c.", "desc": "First element in the slice of :math:`c`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "last", "brief": "Last element plus 1 of the slice in c to be changed.", "desc": "Last element plus 1 of the slice in :math:`c` to be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "slice", "brief": "New numerical values for the objective coefficients that should be modified.", "desc": "New numerical values for coefficients in :math:`c` that should be modified.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(- (arg last) (arg first))", "ast": ["-", ["arg", "last"], ["arg", "first"]], "arg-refs": ["first", "last"]}]}], "ais": "function", "api-caml-name": "put-c-slice", "api-name": "putcslice", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putbarcj": {"caml-name": "put-barc-j", "name": "putbarcj", "brief": "Changes one element in barc.", "desc": "This function sets one entry in the :math:`\\barC` vector.\n\nEach element in the :math:`\\barC` vector is a weighted sum of\nsymmetric matrices from the symmetric matrix storage :math:`E`, so\n:math:`\\barC_{j}` is a symmetric matrix. By default all elements in\n:math:`\\barC` are 0, so only non-zero elements need be added.\nSetting the same element again will overwrite the earlier entry.\n\nThe symmetric matrices from :math:`E` are defined separately\nusing the function :msk:func:`task.appendsparsesymmat`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the element in barc` that should be changed.", "desc": "Index of the element in :math:`\\barC` that should be changed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "num", "brief": "The number elements appearing in the sum that forms the j'th element of barc.", "desc": "The number of elements in the weighted sum that forms :math:`\\barC_j`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["weights", "sub"]}]}, {"name": "sub", "brief": "sub is list of indexes of those symmetric matrices appearing in sum.", "desc": "Indices in :math:`E` of matrices appearing in the weighted sum for :math:`\\barC_j`", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "weights", "brief": "The weights of the terms in the weighted sum.", "desc": "``weights[k]`` is the coefficient of the ``sub[k]``-th element of :math:`E` in the weighted sum forming :math:`\\barC_j`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-barc-j", "api-name": "putbarcj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putcone": {"caml-name": "put-cone", "name": "putcone", "brief": "Replaces a conic constraint.", "desc": "|deprecate-cones-v10|", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "Index of the cone.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "ct", "mode": "i", "type": ["const-class", "mosek", "conetype"], "null?": false, "api?": true}, {"name": "conepar", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "nummem", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["submem"]}]}, {"name": "submem", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-cone", "api-name": "putcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumdomain": {"caml-name": "put-max-num-domain", "name": "putmaxnumdomain", "brief": "Sets the number of preallocated domains in the optimization task.", "desc": "Sets the number of preallocated domains in the optimization task. When this\nnumber is reached |mosek| will automatically allocate more space.\nIt is never mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumdomain", "brief": "Number of preallocated domains.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-domain", "api-name": "putmaxnumdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getnumdomain": {"caml-name": "get-num-domain", "name": "getnumdomain", "brief": "Obtain the number of domains defined.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numdomain", "brief": "Number of domains in the task.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-num-domain", "api-name": "getnumdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendrplusdomain": {"caml-name": "append-rplus-domain", "name": "appendrplusdomain", "brief": "Appends the n dimensional positive orthant to the list of domains.", "desc": "Appends the :math:`n`-dimensional positive orthant :math:`\\{ x \\in \\real^n: \\, x \\geq 0 \\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-rplus-domain", "api-name": "appendrplusdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendrminusdomain": {"caml-name": "append-rminus-domain", "name": "appendrminusdomain", "brief": "Appends the n dimensional negative orthant to the list of domains.", "desc": "Appends the :math:`n`-dimensional negative orthant :math:`\\{ x \\in \\real^n: \\, x \\leq 0 \\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-rminus-domain", "api-name": "appendrminusdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendrdomain": {"caml-name": "append-r-domain", "name": "appendrdomain", "brief": "Appends the n dimensional real number domain.", "desc": "Appends the :math:`n`-dimensional real space :math:`\\{ x \\in \\real^n \\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-r-domain", "api-name": "appendrdomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendrzerodomain": {"caml-name": "append-rzero-domain", "name": "appendrzerodomain", "brief": "Appends the n dimensional 0 domain.", "desc": "Appends the zero in :math:`n`-dimensional real space :math:`\\{ x \\in \\real^n: \\, x = 0 \\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-rzero-domain", "api-name": "appendrzerodomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendquadraticconedomain": {"caml-name": "append-quadratic-cone-domain", "name": "appendquadraticconedomain", "brief": "Appends the n dimensional quadratic cone domain.", "desc": "Appends the :math:`n`-dimensional quadratic cone :math:`\\left\\{x\\in\\real^n~:~x_0 \\geq \\sqrt{\\sum_{i=1}^{n-1} x_i^2}\\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-quadratic-cone-domain", "api-name": "appendquadraticconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendrquadraticconedomain": {"caml-name": "append-r-quadratic-cone-domain", "name": "appendrquadraticconedomain", "brief": "Appends the n dimensional rotated quadratic cone domain.", "desc": "Appends the :math:`n`-dimensional rotated quadratic cone :math:`\\left\\{x\\in\\real^n~:~2 x_0 x_1 \\geq \\sum_{i=2}^{n-1} x_i^2,\\ x_0,x_1\\geq 0\\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-r-quadratic-cone-domain", "api-name": "appendrquadraticconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendprimalexpconedomain": {"caml-name": "append-primal-exp-cone-domain", "name": "appendprimalexpconedomain", "brief": "Appends the primal exponential cone domain.", "desc": "Appends the primal exponential cone :math:`\\left\\{ x\\in \\real^3 ~:~ x_0 \\geq x_1 e^{x_2/x_1},\\ x_0,x_1> 0 \\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-primal-exp-cone-domain", "api-name": "appendprimalexpconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appenddualexpconedomain": {"caml-name": "append-dual-exp-cone-domain", "name": "appenddualexpconedomain", "brief": "Appends the dual exponential cone domain.", "desc": "Appends the dual exponential cone :math:`\\left\\{ x\\in \\real^3 ~:~ x_0 \\geq -x_2 e^{-1} e^{x_1/x_2},\\ x_0> 0,\\ x_2< 0 \\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-dual-exp-cone-domain", "api-name": "appenddualexpconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendprimalgeomeanconedomain": {"caml-name": "append-primal-geo-mean-cone-domain", "name": "appendprimalgeomeanconedomain", "brief": "Appends the primal geometric mean cone domain.", "desc": "Appends the primal geometric mean cone :math:`\\left\\{ x\\in \\real^n ~:~ \\left(\\prod_{i=0}^{n-2} x_i\\right)^{1/(n-1)} \\geq |x_{n-1}|,\\ x_0\\ldots,x_{n-2}\\geq 0 \\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-primal-geo-mean-cone-domain", "api-name": "appendprimalgeomeanconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appenddualgeomeanconedomain": {"caml-name": "append-dual-geo-mean-cone-domain", "name": "appenddualgeomeanconedomain", "brief": "Appends the dual geometric mean cone domain.", "desc": "Appends the dual geometric mean cone :math:`\\left\\{ x\\in \\real^n ~:~ (n-1) \\left(\\prod_{i=0}^{n-2} x_i\\right)^{1/(n-1)} \\geq |x_{n-1}|,\\ x_0,\\ldots,x_{n-2}\\geq 0 \\right\\}` to the list of domains.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimmension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-dual-geo-mean-cone-domain", "api-name": "appenddualgeomeanconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendprimalpowerconedomain": {"caml-name": "append-primal-power-cone-domain", "name": "appendprimalpowerconedomain", "brief": "Appends the primal power cone domain.", "desc": "Appends the primal power cone domain of dimension :math:`n`, with :math:`n_\\ell` variables appearing on the left-hand side, where :math:`n_\\ell` is the length of :math:`\\alpha`, and with a homogenous sequence of exponents :math:`\\alpha_0,\\ldots,\\alpha_{n_\\ell-1}`.\n\nFormally, let :math:`s = \\sum_i \\alpha_i` and :math:`\\beta_i = \\alpha_i / s`, so that :math:`\\sum_i \\beta_i=1`. Then the primal power cone is defined as follows:\n\n.. math:: \\left\\{ x\\in \\real^n ~:~ \\prod_{i=0}^{n_\\ell-1} x_i^{\\beta_i} \\geq \\sqrt{\\sum_{j=n_\\ell}^{n-1}x_j^2},\\ x_0\\ldots,x_{n_\\ell-1}\\geq 0 \\right\\}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "nleft", "brief": "Number of variables on the left hand side.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["alpha"]}]}, {"name": "alpha", "brief": "The sequence proportional to exponents. Must be positive.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-primal-power-cone-domain", "api-name": "appendprimalpowerconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appenddualpowerconedomain": {"caml-name": "append-dual-power-cone-domain", "name": "appenddualpowerconedomain", "brief": "Appends the dual power cone domain.", "desc": "Appends the dual power cone domain of dimension :math:`n`, with :math:`n_\\ell` variables appearing on the left-hand side, where :math:`n_\\ell` is the length of :math:`\\alpha`, and with a homogenous sequence of exponents :math:`\\alpha_0,\\ldots,\\alpha_{n_\\ell-1}`.\n\nFormally, let :math:`s = \\sum_i \\alpha_i` and :math:`\\beta_i = \\alpha_i / s`, so that :math:`\\sum_i \\beta_i=1`. Then the dual power cone is defined as follows:\n\n.. math:: \\left\\{ x\\in \\real^n ~:~ \\prod_{i=0}^{n_\\ell-1} \\left(\\frac{x_i}{\\beta_i}\\right)^{\\beta_i} \\geq \\sqrt{\\sum_{j=n_\\ell}^{n-1}x_j^2},\\ x_0\\ldots,x_{n_\\ell-1}\\geq 0 \\right\\}", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimension of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "nleft", "brief": "Number of variables on the left hand side.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["alpha"]}]}, {"name": "alpha", "brief": "The sequence proportional to exponents. Must be positive.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-dual-power-cone-domain", "api-name": "appenddualpowerconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendsvecpsdconedomain": {"caml-name": "append-svec-psd-cone-domain", "name": "appendsvecpsdconedomain", "brief": "Appends the vectorized SVEC PSD cone domain.", "desc": "Appends the domain consisting of vectors of length :math:`n=d(d+1)/2` defined as follows\n\n.. math:: \\{(x_1,\\ldots,x_{d(d+1)/2})\\in \\real^n~:~ \\mathrm{sMat}(x)\\in\\PSD^d\\} = \\{\\mathrm{sVec}(X)~:~X\\in\\PSD^d\\},\n\nwhere\n\n.. math:: \\mathrm{sVec}(X) = (X_{11},\\sqrt{2}X_{21},\\ldots,\\sqrt{2}X_{d1},X_{22},\\sqrt{2}X_{32},\\ldots,X_{dd}),\n\nand\n\n.. math::\n\n   \\mathrm{sMat}(x) = \\left[\\begin{array}{cccc}x_1 & x_2/\\sqrt{2} & \\cdots & x_{d}/\\sqrt{2} \\\\\n                                                      x_2/\\sqrt{2} & x_{d+1} & \\cdots & x_{2d-1}/\\sqrt{2} \\\\\n                                                      \\cdots        & \\cdots & \\cdots & \\cdots \\\\\n                                                      x_{d}/\\sqrt{2} & x_{2d-1}/\\sqrt{2} & \\cdots & x_{d(d+1)/2}\\end{array}\\right].\n\nIn other words, the domain consists of vectorizations of the lower-triangular part of a positive semidefinite matrix, with the non-diagonal elements additionally rescaled.\n\nThis domain is a self-dual cone.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Dimension of the domain.", "desc": "Dimension of the domain, must be of the form :math:`d(d+1)/2`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "ais": "function", "api-caml-name": "append-svec-psd-cone-domain", "api-name": "appendsvecpsdconedomain", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getdomaintype": {"caml-name": "get-domain-type", "name": "getdomaintype", "brief": "Returns the type of the domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "domtype", "brief": "The type of the domain.", "mode": "o", "type": ["ref", ["const-class", "mosek", "domaintype"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-domain-type", "api-name": "getdomaintype", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getdomainn": {"caml-name": "get-domain-n", "name": "getdomainn", "brief": "Obtains the dimension of the domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "n", "brief": "Dimension of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-domain-n", "api-name": "getdomainn", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getpowerdomaininfo": {"caml-name": "get-power-domain-info", "name": "getpowerdomaininfo", "brief": "Obtains structural information about a power domain.", "desc": "Obtains structural information about a primal or dual power cone domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "n", "brief": "Dimension of the domain.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "nleft", "brief": "Number of variables on the left hand side.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-power-domain-info", "api-name": "getpowerdomaininfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getpowerdomainalpha": {"caml-name": "get-power-domain-alpha", "name": "getpowerdomainalpha", "brief": "Obtains the exponent vector of a power domain.", "desc": "Obtains the exponent vector :math:`\\alpha` of a primal or dual power cone domain.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "domidx", "brief": "Index of the domain.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "alpha", "brief": "The exponent vector of the domain.", "desc": "The vector :math:`\\alpha`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(call getpowerdomaininfo task (arg domidx) dummy-value return-value)", "ast": ["call", "getpowerdomaininfo", "task", ["arg", "domidx"], "dummy-value", "return-value"], "arg-refs": ["domidx"]}]}], "ais": "function", "api-caml-name": "get-power-domain-alpha", "api-name": "getpowerdomainalpha", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-domain", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendsparsesymmat": {"old-name": "appendsparsesymmat", "caml-name": "append-sparse-sym-mat", "name": "appendsparsesymmat", "brief": "Appends a general sparse symmetric matrix to the storage of symmetric matrices.", "desc": "|mosek| maintains a storage of symmetric data matrices that is used to build\n:math:`\\barC` and :math:`\\barA`. The storage can be thought of as a vector of\nsymmetric matrices denoted :math:`E`. Hence, :math:`E_i` is a symmetric matrix of certain\ndimension.\n\nThis function appends a general sparse symmetric matrix on triplet form to the\nvector :math:`E` of symmetric matrices.  The vectors ``subi``, ``subj``, and\n``valij`` contains the row subscripts, column subscripts and values of each\nelement in the symmetric matrix to be appended.  Since the matrix that is\nappended is symmetric, only the lower triangular part should be specified.\nMoreover, duplicates are not allowed.\n\nObserve the function reports the index (position) of the appended matrix in\n:math:`E`. This index should be used for later references to the appended matrix.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "dim", "brief": "Dimension of the symmetric matrix that is appended.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "nz", "brief": "Number of triplets.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subi", "valij", "subj"]}]}, {"name": "subi", "brief": "Row subscript in the triplets.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "subj", "brief": "Column subscripts in the triplets.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "valij", "brief": "Values of each triplet.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "idx", "brief": "Unique index assigned to the inputted matrix.", "desc": "Unique index assigned to the inputted matrix that can be used for later reference.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "defaultout": true}], "sparse-matrix": {"type": "triltrip", "arg": "data", "fmt": ["subi", "subj", "valij"]}, "ais": "function", "api-caml-name": "append-sparse-sym-mat", "api-name": "appendsparsesymmat", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "appendsparsesymmatlist": {"old-name": "appendsparsesymmatlist", "caml-name": "append-sparse-sym-mat-list", "name": "appendsparsesymmatlist", "brief": "Appends a general sparse symmetric matrix to the storage of symmetric matrices.", "desc": "|mosek| maintains a storage of symmetric data matrices that is used to build\n:math:`\\barC` and :math:`\\barA`. The storage can be thought of as a vector of\nsymmetric matrices denoted :math:`E`. Hence, :math:`E_i` is a symmetric matrix of certain\ndimension.\n\nThis function appends general sparse symmetric matrixes on triplet form to the\nvector :math:`E` of symmetric matrices.  The vectors ``subi``, ``subj``, and\n``valij`` contains the row subscripts, column subscripts and values of each\nelement in the symmetric matrix to be appended.  Since the matrix that is\nappended is symmetric, only the lower triangular part should be specified.\nMoreover, duplicates are not allowed.\n\nObserve the function reports the index (position) of the appended matrix in\n:math:`E`. This index should be used for later references to the appended matrix.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of matrixes to append.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["nz", "dims"]}]}, {"name": "dims", "brief": "Dimensions of the symmetric matrixes.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "nz", "brief": "Number of nonzeros for each matrix.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "subi", "brief": "Row subscript in the triplets.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(sum (arg nz))", "ast": ["sum", ["arg", "nz"]], "arg-refs": ["nz"]}]}, {"name": "subj", "brief": "Column subscripts in the triplets.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(sum (arg nz))", "ast": ["sum", ["arg", "nz"]], "arg-refs": ["nz"]}]}, {"name": "valij", "brief": "Values of each triplet.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(sum (arg nz))", "ast": ["sum", ["arg", "nz"]], "arg-refs": ["nz"]}]}, {"name": "idx", "brief": "Unique index assigned to the inputted matrix.", "desc": "Unique index assigned to the inputted matrix that can be used for later reference.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg num)", "ast": ["arg", "num"], "arg-refs": ["num"]}]}], "ais": "function", "api-caml-name": "append-sparse-sym-mat-list", "api-name": "appendsparsesymmatlist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getsymmatinfo": {"old-name": "getsymmatinfo", "caml-name": "get-sym-mat-info", "name": "getsymmatinfo", "brief": "Obtains information about a matrix from the symmetric matrix storage.", "desc": "|mosek| maintains a vector denoted by :math:`E` of symmetric data matrices. This function makes it possible to obtain important information about a single matrix in :math:`E`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Index of the matrix for which information is requested.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "dim", "brief": "Returns the dimension of the requested matrix.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "nz", "brief": "Returns the number of non-zeros in the requested matrix.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true}, {"name": "mattype", "brief": "Returns the type of the requested matrix.", "mode": "o", "type": ["ref", ["const-class", "mosek", "symmattype"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-sym-mat-info", "api-name": "getsymmatinfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getnumsymmat": {"old-name": "getnumsymmat", "caml-name": "get-num-sym-mat", "name": "getnumsymmat", "brief": "Obtains the number of symmetric matrices stored.", "desc": "Obtains the number of symmetric matrices stored in the vector :math:`E`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "The number of symmetric sparse matrices.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-num-sym-mat", "api-name": "getnumsymmat", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getsparsesymmat": {"old-name": "getsparsesymmat", "caml-name": "get-sparse-sym-mat", "name": "getsparsesymmat", "brief": "Gets a single symmetric matrix from the matrix store.", "desc": "Get a single symmetric matrix from the matrix store.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "idx", "brief": "Index of the matrix to retrieve.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "maxlen", "brief": "Length of the output arrays subi, subj and valij.", "desc": "Length of the output arrays ``subi``, ``subj`` and ``valij``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(call getsymmatinfo task (arg idx) dummy-value return-value dummy-value)", "ast": ["call", "getsymmatinfo", "task", ["arg", "idx"], "dummy-value", "return-value", "dummy-value"], "arg-refs": ["idx"]}]}, {"name": "subi", "brief": "Row subscripts of the matrix non-zero elements.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxlen)", "ast": ["arg", "maxlen"], "arg-refs": ["maxlen"]}]}, {"name": "subj", "brief": "Column subscripts of the matrix non-zero elements.", "mode": "o", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg maxlen)", "ast": ["arg", "maxlen"], "arg-refs": ["maxlen"]}]}, {"name": "valij", "brief": "Coefficients of the matrix non-zero elements.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg maxlen)", "ast": ["arg", "maxlen"], "arg-refs": ["maxlen"]}]}], "ais": "function", "api-caml-name": "get-sparse-sym-mat", "api-name": "getsparsesymmat", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-barvars", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putdouparam": {"old-name": "putdouparam", "caml-name": "put-dou-param", "name": "putdouparam", "brief": "Sets a double parameter.", "desc": "Sets the value of a double parameter.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "dparam"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-dou-param", "api-name": "putdouparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putintparam": {"old-name": "putintparam", "caml-name": "put-int-param", "name": "putintparam", "brief": "Sets an integer parameter.", "desc": "Sets the value of an integer parameter.\n\n.. msk_only:: java\n\n   Please notice that some parameters take values that are defined in Enum\n   classes. This function accepts only integer values, so to use e.g. the value\n   :msk:const:`onoffkey.on`, is necessary to use the member ``.value``. For example: ::\n\n       task.putintparam(mosek.iparam.opf_write_problem, mosek.onoffkey.on.value)", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "iparam"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-int-param", "api-name": "putintparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumcon": {"old-name": "putmaxnumcon", "caml-name": "put-max-num-con", "name": "putmaxnumcon", "brief": "Sets the number of preallocated constraints in the optimization task.", "desc": "Sets the number of preallocated constraints in the optimization task. When this\nnumber of constraints is reached |mosek| will automatically allocate more space\nfor constraints.\n\nIt is never mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.\n\nPlease note that ``maxnumcon`` must be larger than the current number of\nconstraints in the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-con", "api-name": "putmaxnumcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-constraint"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumcone": {"old-name": "putmaxnumcone", "caml-name": "put-max-num-cone", "name": "putmaxnumcone", "brief": "Sets the number of preallocated conic constraints in the optimization task.", "desc": "|deprecate-cones-v10|\n\nSets the number of preallocated conic constraints in the optimization task.\nWhen this number of conic constraints is reached |mosek| will automatically\nallocate more space for conic constraints.\n\nIt is not mandatory to call this function, since |mosek| will reallocate any\ninternal structures whenever it is required.\n\nPlease note that ``maxnumcon`` must be larger than the current number of conic\nconstraints in the task.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcone", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-cone", "api-name": "putmaxnumcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getmaxnumcone": {"old-name": "getmaxnumcone", "caml-name": "get-max-num-cone", "name": "getmaxnumcone", "brief": "Obtains the number of preallocated cones in the optimization task.", "desc": "|deprecate-cones-v10|\n\nObtains the number of preallocated cones in the optimization task. When this\nnumber of cones is reached |mosek| will automatically allocate space for more\ncones.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcone", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-max-num-cone", "api-name": "getmaxnumcone", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-conic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putmaxnumvar": {"old-name": "putmaxnumvar", "caml-name": "put-max-num-var", "name": "putmaxnumvar", "brief": "Sets the number of preallocated variables in the optimization task.", "desc": "Sets the number of preallocated variables in the optimization task. When this\nnumber of variables is reached |mosek| will automatically allocate more space\nfor variables.\n\nIt is not mandatory to call this function. It only gives\na hint about the amount of data to preallocate for efficiency reasons.\n\nPlease note that ``maxnumvar`` must be larger than the current number of\nvariables in the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumvar", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-var", "api-name": "putmaxnumvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-variable"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumbarvar": {"old-name": "putmaxnumbarvar", "caml-name": "put-max-num-barvar", "name": "putmaxnumbarvar", "brief": "Sets the number of preallocated symmetric matrix variables.", "desc": "Sets the number of preallocated symmetric matrix variables in the optimization\ntask. When this number of variables is reached |mosek| will automatically\nallocate more space for variables.\n\nIt is not mandatory to call this function. It only gives a\nhint about the amount of data to preallocate for efficiency reasons.\n\nPlease note that ``maxnumbarvar`` must be larger than the current number of\nsymmetric matrix variables in the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumbarvar", "brief": "Number of preallocated symmetric matrix variables.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-barvar", "api-name": "putmaxnumbarvar", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-barvars"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumanz": {"old-name": "putmaxnumanz", "caml-name": "put-max-num-a-nz", "name": "putmaxnumanz", "brief": "Sets the number of preallocated non-zero entries in the linear coefficient matrix.", "desc": "Sets the number of preallocated non-zero entries in :math:`A`.\n\n|mosek| stores only the non-zero elements in the linear coefficient matrix :math:`A` and it\ncannot predict how much storage is required to store :math:`A`. Using this\nfunction it is possible to specify the number of non-zeros to preallocate for\nstoring :math:`A`.\n\nIf the number of non-zeros in the problem is known, it is a good idea to set\n``maxnumanz`` slightly larger than this number, otherwise a rough estimate can\nbe used. In general, if :math:`A` is inputted in many small chunks, setting\nthis value may speed up the data input phase.\n\nIt is not mandatory to call this function, since |mosek| will reallocate\ninternal structures whenever it is necessary.\n\nThe function call has no effect if both ``maxnumcon`` and ``maxnumvar`` are zero.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumanz", "brief": "New size of the storage reserved for storing the linear coefficient matrix.", "desc": "Number of preallocated non-zeros in :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-a-nz", "api-name": "putmaxnumanz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-linear"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putmaxnumqnz": {"old-name": "putmaxnumqnz", "caml-name": "put-max-num-q-nz", "name": "putmaxnumqnz", "brief": "Sets the number of preallocated non-zero entries in quadratic terms.", "desc": "Sets the number of preallocated non-zero entries in quadratic terms.\n\n|mosek| stores only the non-zero elements in :math:`Q`. Therefore, |mosek|\ncannot predict how much storage is required to store :math:`Q`. Using this\nfunction it is possible to specify the number non-zeros to preallocate for\nstoring :math:`Q` (both objective and constraints).\n\nIt may be advantageous to reserve more non-zeros for :math:`Q` than actually\nneeded since it may improve the internal efficiency of |mosek|, however, it is\nnever worthwhile to specify more than the double of the anticipated number of\nnon-zeros in :math:`Q`.\n\nIt is not mandatory to call this function, since |mosek| will reallocate\ninternal structures whenever it is necessary.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumqnz", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-max-num-q-nz", "api-name": "putmaxnumqnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getmaxnumqnz": {"old-name": "getmaxnumqnz", "caml-name": "get-max-num-q-nz", "name": "getmaxnumqnz", "brief": "Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints.", "desc": "Obtains the number of preallocated non-zeros for :math:`Q` (both objective and\nconstraints). When this number of non-zeros is reached |mosek| will\nautomatically allocate more space for :math:`Q`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumqnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-max-num-q-nz", "api-name": "getmaxnumqnz", "targets": ["c", "cmdln", "no-overload", "rpc"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getmaxnumqnz64": {"old-name": "getmaxnumqnz64", "caml-name": "get-max-num-q-nz-64", "name": "getmaxnumqnz64", "brief": "Obtains the number of preallocated non-zeros for all quadratic terms in objective and constraints.", "desc": "Obtains the number of preallocated non-zeros for :math:`Q` (both objective and\nconstraints). When this number of non-zeros is reached |mosek| will\nautomatically allocate more space for :math:`Q`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumqnz", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-max-num-q-nz", "api-name": "getmaxnumqnz", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-inspect", "task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "putnadouparam": {"old-name": "putnadouparam", "caml-name": "put-na-dou-param", "name": "putnadouparam", "brief": "Sets a double parameter.", "desc": "Sets the value of a named double parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-na-dou-param", "api-name": "putnadouparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putnaintparam": {"old-name": "putnaintparam", "caml-name": "put-na-int-param", "name": "putnaintparam", "brief": "Sets an integer parameter.", "desc": "Sets the value of a named integer parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-na-int-param", "api-name": "putnaintparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putnastrparam": {"old-name": "putnastrparam", "caml-name": "put-na-str-param", "name": "putnastrparam", "brief": "Sets a string parameter.", "desc": "Sets the value of a named string parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "paramname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-na-str-param", "api-name": "putnastrparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putobjname": {"old-name": "putobjname", "caml-name": "put-obj-name", "name": "putobjname", "brief": "Assigns a new name to the objective.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "objname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-obj-name", "api-name": "putobjname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-linear", "naming", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putparam": {"old-name": "putparam", "caml-name": "put-param", "name": "putparam", "brief": "Modifies the value of parameter.", "desc": "Checks if ``parname`` is valid parameter name. If it is, the parameter is\nassigned the value specified by ``parvalue``.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "parname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-param", "api-name": "putparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putqcon": {"old-name": "putqcon", "caml-name": "put-q-con", "name": "putqcon", "brief": "Replaces all quadratic terms in constraints.", "desc": "Replace all quadratic entries in the constraints. The list of constraints has the form\n\n.. math:: l_k^c \\leq  \\half \\sum_{i=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} \\sum_{j=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} q_{ij}^k x_i x_j + \\sum_{j=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} a_{kj} x_j \\leq u_k^c, ~\\  k=\\idxbeg,\\ldots,\\idxend{m}.\n\nThis function sets all the quadratic terms to zero and then performs the update:\n\n.. math:: q_{\\mathtt{qcsubi[t]},\\mathtt{qcsubj[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}} = q_{\\mathtt{\\mathtt{qcsubj[t]},qcsubi[t]}}^{\\mathtt{qcsubk[t]}}  + \\mathtt{qcval[t]},\n\nfor :math:`t=\\idxbeg,\\ldots,\\idxend{\\mathtt{numqcnz}}`.\n\nPlease note that:\n\n* For large problems it is essential for the efficiency that the function :msk:func:`task.putmaxnumqnz` is employed to pre-allocate space.\n* Only the lower triangular parts should be specified because the :math:`Q` matrices are symmetric. Specifying entries where :math:`i < j` will result in an error.\n* Only non-zero elements should be specified.\n* The order in which the non-zero elements are specified is insignificant.\n* Duplicate elements are added together as shown above. Hence, it is usually not recommended to specify the same entry multiple times.\n\nFor a code example see Section :ref:`doc.tutorial_qo`", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numqcnz", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["qcval", "qcsubi", "qcsubj"]}]}, {"name": "qcsubk", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qcsubi", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qcsubj", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qcval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-q-con", "api-name": "putqcon", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putqconk"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumqnz"]}], "member-of": ["task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putqconk": {"old-name": "putqconk", "caml-name": "put-q-con-k", "name": "putqconk", "brief": "Replaces all quadratic terms in a single constraint.", "desc": "Replaces all the quadratic entries in one constraint. This function performs the same operations as :msk:func:`task.putqcon` but only with respect to constraint number ``k`` and it does not modify the other constraints. See the description of :msk:func:`task.putqcon` for definitions and important remarks.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "k", "brief": "The constraint in which the new quadratic elements are inserted.", "desc": "The constraint in which the new :math:`Q` elements are inserted.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "numqcnz", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["qcval", "qcsubi", "qcsubj"]}]}, {"name": "qcsubi", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qcsubj", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qcval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "triltrip", "arg": "Qk", "fmt": ["qcsubi", "qcsubj", "qcval"]}, "ais": "function", "api-caml-name": "put-q-con-k", "api-name": "putqconk", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putqcon"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumqnz"]}], "member-of": ["task-quadratic"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putqobj": {"old-name": "putqobj", "caml-name": "put-q-obj", "name": "putqobj", "brief": "Replaces all quadratic terms in the objective.", "desc": "Replace all quadratic terms in the objective. If the objective has the form\n\n.. math:: \\half \\sum_{i=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} \\sum_{j=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} q_{ij}^o x_i x_j + \\sum_{j=\\idxbeg}^{\\idxend{\\mathtt{numvar}}} c_{j} x_j + c^f\n\nthen this function sets all the quadratic terms to zero and then performs the update:\n\n.. math:: q_{\\mathtt{qosubi[t]},\\mathtt{qosubj[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o} = q_{\\mathtt{\\mathtt{qosubj[t]},qosubi[t]}}^{o}  + \\mathtt{qoval[t]},\n\nfor :math:`t=\\idxbeg,\\ldots,\\idxend{\\mathtt{numqonz}}`.\n\nSee the description of :msk:func:`task.putqcon` for important remarks and example.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numqonz", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["qosubi", "qoval", "qosubj"]}]}, {"name": "qosubi", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qosubj", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qoval", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "explicit-lengths": true, "sparse-matrix": {"type": "triltrip", "arg": "Qk", "fmt": ["qosubi", "qosubj", "qoval"]}, "ais": "function", "api-caml-name": "put-q-obj", "api-name": "putqobj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-quadratic", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putqobjij": {"old-name": "putqobjij", "caml-name": "put-q-obj-i-j", "name": "putqobjij", "brief": "Replaces one coefficient in the quadratic term in the objective.", "desc": "Replaces one coefficient in the quadratic term in the objective. The function\nperforms the assignment\n\n.. math:: q_{ij}^o = q_{ji}^o = \\mathtt{qoij}.\n\nOnly the elements in the lower triangular part are accepted. Setting\n:math:`q_{ij}` with :math:`j>i` will cause an error.\n\nPlease note that replacing all quadratic elements one by one is more\ncomputationally expensive than replacing them all at once. Use\n:msk:func:`task.putqobj` instead whenever possible.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Row index for the coefficient to be replaced.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "j", "brief": "Column index for the coefficient to be replaced.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "qoij", "brief": "The new coefficient value.", "desc": "The new value for :math:`q_{ij}^o`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-q-obj-i-j", "api-name": "putqobjij", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["task-quadratic", "task-objective"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsolution": {"old-name": "putsolution", "caml-name": "put-solution", "name": "putsolution", "brief": "Inserts a solution.", "desc": "Inserts a solution into the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "skx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "skn", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "xc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "xx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "y", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "slc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "suc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "slx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "sux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "snx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-solution", "api-name": "putsolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsolutionnew": {"caml-name": "put-solution-new", "name": "putsolutionnew", "brief": "Inserts a solution.", "desc": "Inserts a solution into the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "skc", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "skx", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "skn", "mode": "i", "type": ["ptr", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}, {"name": "xc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "xx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "y", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "slc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "suc", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "slx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "sux", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "snx", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}, {"name": "doty", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-solution-new", "api-name": "putsolutionnew", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putconsolutioni": {"caml-name": "put-con-solution-i", "name": "putconsolutioni", "brief": "Sets the primal and dual solution information for a single constraint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the constraint.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "sk", "brief": "Status key of the constraint.", "mode": "i", "type": ["const-class", "mosek", "stakey"], "null?": false, "api?": true}, {"name": "x", "brief": "Primal solution value of the constraint.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "sl", "brief": "Solution value of the dual variable associated with the lower bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "su", "brief": "Solution value of the dual variable associated with the upper bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-con-solution-i", "api-name": "putconsolutioni", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvarsolutionj": {"caml-name": "put-var-solution-j", "name": "putvarsolutionj", "brief": "Sets the primal and dual solution information for a single variable.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "sk", "brief": "Status key of the variable.", "mode": "i", "type": ["const-class", "mosek", "stakey"], "null?": false, "api?": true}, {"name": "x", "brief": "Primal solution value of the variable.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "sl", "brief": "Solution value of the dual variable associated with the lower bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "su", "brief": "Solution value of the dual variable associated with the upper bound.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "sn", "brief": "Solution value of the dual variable associated with the conic constraint.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-var-solution-j", "api-name": "putvarsolutionj", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-primal", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putsolutionyi": {"old-name": "putsolutionyi", "caml-name": "put-solution-y-i", "name": "putsolutionyi", "brief": "Inputs the dual variable of a solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "i", "brief": "Index of the dual variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "y", "brief": "Solution value of the dual variable.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-solution-y-i", "api-name": "putsolutionyi", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information", "solution-dual"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putstrparam": {"old-name": "putstrparam", "caml-name": "put-str-param", "name": "putstrparam", "brief": "Sets a string parameter.", "desc": "Sets the value of a string parameter.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "param", "mode": "i", "type": ["const-class", "mosek", "sparam"], "null?": false, "api?": true}, {"name": "parvalue", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-str-param", "api-name": "putstrparam", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "puttaskname": {"old-name": "puttaskname", "caml-name": "put-task-name", "name": "puttaskname", "brief": "Assigns a new name to the task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "taskname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-task-name", "api-name": "puttaskname", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvartype": {"caml-name": "put-var-type", "name": "putvartype", "brief": "Sets the variable type of one variable.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "j", "brief": "Index of the variable.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "vartype", "brief": "The new variable type.", "mode": "i", "type": ["const-class", "mosek", "variabletype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-var-type", "api-name": "putvartype", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvartypelist"]}], "member-of": ["task-variable"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putvartypelist": {"old-name": "putvartypelist", "caml-name": "put-var-type-list", "name": "putvartypelist", "brief": "Sets the variable type for one or more variables.", "desc": "Sets the variable type for one or more variables. If the same index is specified multiple times in ``subj`` only the last entry\ntakes effect.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Number of variables for which the variable type should be set.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["vartype", "subj"]}]}, {"name": "subj", "brief": "A list of variable indexes for which the variable type should be changed.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "vartype", "brief": "A list of variable types.", "desc": "A list of variable types that should be assigned to the variables specified by ``subj``.", "mode": "i", "type": ["ptr", ["const-class", "mosek", "variabletype"]], "null?": false, "api?": true}], "explicit-lengths": true, "ais": "function", "api-caml-name": "put-var-type-list", "api-name": "putvartypelist", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putvartype"]}], "member-of": ["task-variable"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readdata": {"old-name": "readdata", "caml-name": "read-data", "name": "readdata", "brief": "Reads problem data from a file.", "desc": "Reads an optimization problem and associated data from a file. The extension of the file name is used to deduce the file format.\n\nFor a list of supported file types and their extensions see :ref:`doc.shared.file_formats`.\n\nData is read from the file ``filename`` if it is a nonempty string. Otherwise data is read from the file specified by :msk:sparam:`data_file_name`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-data", "api-name": "readdata", "targets": ["c", "cmdln"], "references": [{"type": "function", "item": ["mosek", "task", "writedata"]}], "member-of": ["input-output"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "readdatacb": {"old-name": "readdatacb", "caml-name": "read-data-cb", "name": "readdatacb", "brief": "Reads problem data from a handle.", "desc": "Reads an optimization problem and associated data from\na handle.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "format", "mode": "i", "type": ["const-class", "mosek", "dataformat"], "null?": false, "api?": true}, {"name": "compress", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}, {"name": "path", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-data-cb", "api-name": "readdatacb", "targets": ["c", "cmdln"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "writedatahandle": {"caml-name": "write-data-handle", "name": "writedatahandle", "brief": "Writes problem data to a user-defined handle.", "desc": "Writes an optimization problem and associated data using a user-defined stream write function ``func``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "func", "brief": "A user-defined write function.", "desc": "A user-defined write function which receives the data.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "handle", "brief": "A user-defined handle.", "desc": "A user-defined handle which is passed to the user-defined function ``func`` (can be |null|).", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "format", "brief": "Selects data format.", "mode": "i", "type": ["const-class", "mosek", "dataformat"], "null?": false, "api?": true}, {"name": "compress", "brief": "Selects compression type.", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-data-handle", "api-name": "writedatahandle", "targets": ["c", "cmdln", "no-overload"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "readdataformat": {"old-name": "readdataformat", "caml-name": "read-data-format", "name": "readdataformat", "brief": "Reads problem data from a file.", "desc": "Reads an optimization problem and associated data from a file.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "format", "brief": "File data format.", "mode": "i", "type": ["const-class", "mosek", "dataformat"], "null?": false, "api?": true}, {"name": "compress", "brief": "File compression type.", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-data-format", "api-name": "readdataformat", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "readdataautoformat": {"old-name": "readdataautoformat", "caml-name": "read-data-auto-format", "name": "readdataautoformat", "brief": "Reads problem data from a file.", "desc": "Reads an optimization problem and associated data from a file.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-data", "api-name": "readdata", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": true, "log": false, "const": "mut"}, "readparamfile": {"old-name": "readparamfile", "caml-name": "read-param-file", "name": "readparamfile", "brief": "Reads a parameter file.", "desc": "Reads |mosek| parameters from a file. Data is read from the file ``filename`` if it is a nonempty string. Otherwise data is read from the file specified by :msk:sparam:`param_read_file_name`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-param-file", "api-name": "readparamfile", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output", "parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readsolution": {"old-name": "readsolution", "caml-name": "read-solution", "name": "readsolution", "brief": "Reads a solution from a file.", "desc": "Reads a solution file and inserts it as a specified solution in the task. Data is read from the file ``filename`` if it is a nonempty string. Otherwise data is read from one of the files specified by :msk:sparam:`bas_sol_file_name`, :msk:sparam:`itr_sol_file_name` or :msk:sparam:`int_sol_file_name` depending on which solution is chosen.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-solution", "api-name": "readsolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readjsonsol": {"caml-name": "read-json-sol", "name": "readjsonsol", "brief": "Reads a solution from a JSOL file.", "desc": "Reads a solution file in JSON format (JSOL file) and inserts it in the task. Only the section ``Task/solutions`` is taken into consideration.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-json-sol", "api-name": "readjsonsol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readsummary": {"old-name": "readsummary", "caml-name": "read-summary", "name": "readsummary", "brief": "Prints information about last file read.", "desc": "Prints a short summary of last file that was read.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-summary", "api-name": "readsummary", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output", "task-inspect"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "resizetask": {"old-name": "resizetask", "caml-name": "resize-task", "name": "resizetask", "brief": "Resizes an optimization task.", "desc": "Sets the amount of preallocated space assigned for each type of data in an\noptimization task.\n\nIt is never mandatory to call this function, since it only gives\na hint about the amount of data to preallocate for efficiency reasons.\n\nPlease note that the procedure is **destructive** in the sense that all\nexisting data stored in the task is destroyed.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "brief": "New maximum number of constraints.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumvar", "brief": "New maximum number of variables.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumcone", "brief": "New maximum number of cones.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumanz", "brief": "New maximum number of linear non-zero elements.", "desc": "New maximum number of non-zeros in :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "maxnumqnz", "brief": "New maximum number of quadratic non-zeros elements.", "desc": "New maximum number of non-zeros in all :math:`Q` matrices.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "resize-task", "api-name": "resizetask", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "putmaxnumvar"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumcon"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumcone"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumanz"]}, {"type": "function", "item": ["mosek", "task", "putmaxnumqnz"]}], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "checkmemtask": {"old-name": "checkmemtask", "caml-name": "check-mem-task", "name": "checkmemtask", "brief": "Checks the memory allocated by the task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "check-mem", "api-name": "checkmem", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getmemusagetask": {"old-name": "getmemusagetask", "caml-name": "get-mem-usage-task", "name": "getmemusagetask", "brief": "Obtains information about the amount of memory used by a task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "meminuse", "brief": "Amount of memory currently used by the task.", "desc": "Amount of memory currently used by the ``task``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "maxmemuse", "brief": "Maximum amount of memory used by the task until now.", "desc": "Maximum amount of memory used by the ``task`` until now.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "get-mem-usage", "api-name": "getmemusage", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "const"}, "setdefaults": {"old-name": "setdefaults", "caml-name": "set-defaults", "name": "setdefaults", "brief": "Resets all parameter values.", "desc": "Resets all the parameters to their default values.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "set-defaults", "api-name": "setdefaults", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "sktostr": {"old-name": "sktostr", "caml-name": "sk-to-str", "name": "sktostr", "brief": "Obtains a status key abbreviation.", "desc": "Obtains a status key abbreviation string, one of ``UN``, ``BS``, ``SB``, ``LL``, ``UL``, ``EQ``, ``**``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "sk", "brief": "A valid status key.", "mode": "i", "type": ["const-class", "mosek", "stakey"], "null?": false, "api?": true}, {"name": "str", "brief": "Abbreviation string corresponding to the status key.", "desc": "Abbreviation string corresponding to the status key ``sk``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "sk-to-str", "api-name": "sktostr", "targets": ["c", "cmdln", "go", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "solstatostr": {"old-name": "solstatostr", "caml-name": "sol-sta-to-str", "name": "solstatostr", "brief": "Obtains a solution status string.", "desc": "Obtains an explanatory string corresponding to a solution status.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "solutionsta", "mode": "i", "type": ["const-class", "mosek", "solsta"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the solution status.", "desc": "String corresponding to the solution status ``solsta``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "sol-sta-to-str", "api-name": "solstatostr", "targets": ["c", "cmdln", "go", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "solutiondef": {"old-name": "solutiondef", "caml-name": "solution-def", "name": "solutiondef", "brief": "Checks whether a solution is defined.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "isdef", "brief": "Is non-zero if the requested solution is defined.", "mode": "o", "type": ["ref", ["defined", "mosek", "booleant"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "solution-def", "api-name": "solutiondef", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["solution-information"], "locked": true, "breakable": false, "log": false, "const": "const"}, "deletesolution": {"old-name": "deletesolution", "caml-name": "delete-solution", "name": "deletesolution", "brief": "Undefine a solution and free the memory it uses.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "delete-solution", "api-name": "deletesolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["management", "solution-information"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "writestat": {"caml-name": "write-stat", "name": "writestat", "brief": "Appends a record to the statistics file.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-stat", "api-name": "writestat", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": [], "locked": true, "breakable": false, "log": false, "const": "mut"}, "onesolutionsummary": {"caml-name": "one-solution-summary", "name": "onesolutionsummary", "brief": "Prints a short summary of a specified solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "one-solution-summary", "api-name": "onesolutionsummary", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["logging", "solution-information"], "locked": true, "breakable": false, "log": true, "const": "const"}, "solutionsummary": {"caml-name": "solution-summary", "name": "solutionsummary", "brief": "Prints a short summary of the current solutions.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "solution-summary", "api-name": "solutionsummary", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["logging", "solution-information"], "locked": true, "breakable": false, "log": true, "const": "const"}, "updatesolutioninfo": {"caml-name": "update-solution-info", "name": "updatesolutioninfo", "brief": "Update the information items related to the solution.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "update-solution-info", "api-name": "updatesolutioninfo", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["information-items"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "optimizersummary": {"old-name": "optimizersummary", "caml-name": "optimizer-summary", "name": "optimizersummary", "brief": "Prints a short summary with optimizer statistics from last optimization.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "optimizer-summary", "api-name": "optimizersummary", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["logging"], "locked": true, "breakable": false, "log": true, "const": "const"}, "strtoconetype": {"old-name": "strtoconetype", "caml-name": "str-to-cone-type", "name": "strtoconetype", "brief": "Obtains a cone type code.", "desc": "|deprecate-cones-v10|\n\nObtains cone type code corresponding to a cone type string.", "status": "deprecated", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "str", "brief": "String corresponding to the cone type code.", "desc": "String corresponding to the cone type code ``conetype``.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "conetype", "brief": "The cone type corresponding to str.", "desc": "The cone type corresponding to the string ``str``.", "mode": "o", "type": ["ref", ["const-class", "mosek", "conetype"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "str-to-cone-type", "api-name": "strtoconetype", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "strtosk": {"old-name": "strtosk", "caml-name": "str-to-sk", "name": "strtosk", "brief": "Obtains a status key.", "desc": "Obtains the status key corresponding to an abbreviation string.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "str", "brief": "A status key abbreviation string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "sk", "brief": "Status key corresponding to the string.", "mode": "o", "type": ["ref", ["const-class", "mosek", "stakey"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "str-to-sk", "api-name": "strtosk", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "whichparam": {"old-name": "whichparam", "caml-name": "which-param", "name": "whichparam", "brief": "Checks a parameter name.", "desc": "Checks if ``parname`` is a valid parameter name. If yes\nthen ``partype`` and ``param`` denote the type and\nthe index of the parameter, respectively.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "parname", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "partype", "mode": "o", "type": ["ref", ["const-class", "mosek", "parametertype"]], "null?": true, "api?": true}, {"name": "param", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "which-param", "api-name": "whichparam", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writedata": {"old-name": "writedata", "caml-name": "write-data", "name": "writedata", "brief": "Writes problem data to a file.", "desc": "Writes problem data associated with the optimization task to a file in one of\nthe supported formats. See Section :ref:`doc.shared.file_formats` for the complete list.\n\nThe data file format is determined by the file name extension. To write\nin compressed format append the extension ``.gz``.  E.g to write a gzip\ncompressed MPS file use the extension ``mps.gz``.\n\nPlease note that MPS, LP and OPF files require all variables to have unique\nnames. If a task contains no names, it is possible to write the file with\nautomatically generated anonymous names by setting the\n:msk:iparam:`write_generic_names` parameter to :msk:const:`onoffkey.on`.\n\nData is written to the file ``filename``\nif it is a nonempty string. Otherwise data is written\nto the file specified by :msk:sparam:`data_file_name`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-data", "api-name": "writedata", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "readdata"]}], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writetask": {"old-name": "writetask", "caml-name": "write-task", "name": "writetask", "brief": "Write a complete binary dump of the task data.", "desc": "Write a binary dump of the task data. This format saves all problem data, coefficients and parameter settings. See section :ref:`doc.shared.taskformat` for a description of the Task format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-task", "api-name": "writetask", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writebsolution": {"caml-name": "write-b-solution", "name": "writebsolution", "brief": "Write a binary dump of the task solution and information items.", "desc": "Write a binary dump of the task solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "compress", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-b-solution", "api-name": "writebsolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writebsolutionhandle": {"caml-name": "write-b-solution-handle", "name": "writebsolutionhandle", "brief": "Write a binary dump of the task solution and information items.", "desc": "Write a binary dump of the task solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "func", "brief": "A user-defined write function.", "desc": "A user-defined write function which receives the data.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "handle", "brief": "A user-defined handle.", "desc": "A user-defined handle which is passed to the user-defined function ``func`` (can be |null|).", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "compress", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-b-solution-handle", "api-name": "writebsolutionhandle", "targets": ["c", "cmdln", "no-overload"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "readbsolution": {"caml-name": "read-b-solution", "name": "readbsolution", "brief": "Read a binary dump of the task solution and information items.", "desc": "Read a binary dump of the task solution.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "compress", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-b-solution", "api-name": "readbsolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writesolutionfile": {"caml-name": "write-solution-file", "name": "writesolutionfile", "brief": "Write solution file in format determined by the filename", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-solution-file", "api-name": "writesolutionfile", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "readsolutionfile": {"caml-name": "read-solution-file", "name": "readsolutionfile", "brief": "Read solution file in format determined by the filename", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-solution-file", "api-name": "readsolutionfile", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "readtask": {"old-name": "readtask", "caml-name": "read-task", "name": "readtask", "brief": "Load task data from a file.", "desc": "Load task data from a file, replacing any data that already exists in the task\nobject. All problem data, parameters and other settings are resorted, but if the file contains solutions, the\nsolution status after loading a file is set to unknown, even if it was optimal\nor otherwise well-defined when the file was dumped.\n\nSee section :ref:`doc.shared.taskformat` for a description of the Task format.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-task", "api-name": "readtask", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readopfstring": {"caml-name": "read-opf-string", "name": "readopfstring", "brief": "Load task data from a string in OPF format.", "desc": "Load task data from a string in OPF format, replacing any data that already exists in the task\nobject.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "data", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-opf-string", "api-name": "readopfstring", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readlpstring": {"old-name": "readlpstring", "caml-name": "read-lp-string", "name": "readlpstring", "brief": "Load task data from a string in LP format.", "desc": "Load task data from a string in LP format, replacing any data that already exists in the task\nobject.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "data", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-lp-string", "api-name": "readlpstring", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readjsonstring": {"caml-name": "read-json-string", "name": "readjsonstring", "brief": "Load task data from a string in JSON format.", "desc": "Load task data from a JSON string, replacing any data that already exists in the task\nobject. All problem data, parameters and other settings are resorted, but if the string contains solutions, the\nsolution status after loading a file is set to unknown, even if it is optimal\nor otherwise well-defined.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "data", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-json-string", "api-name": "readjsonstring", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "readptfstring": {"old-name": "readptfstring", "caml-name": "read-ptf-string", "name": "readptfstring", "brief": "Load task data from a string in PTF format.", "desc": "Load task data from a PTF string, replacing any data that already exists in the task\nobject. All problem data, parameters and other settings are resorted, but if the string contains solutions, the\nsolution status after loading a file is set to unknown, even if it is optimal\nor otherwise well-defined.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "data", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "read-ptf-string", "api-name": "readptfstring", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "writeparamfile": {"caml-name": "write-param-file", "name": "writeparamfile", "brief": "Writes all the parameters to a parameter file.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-param-file", "api-name": "writeparamfile", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output", "parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getinfeasiblesubproblem": {"caml-name": "get-infeasible-sub-problem", "name": "getinfeasiblesubproblem", "brief": "Obtains an infeasible subproblem.", "desc": "Given the solution is a certificate of primal or dual infeasibility then a\nprimal or dual infeasible subproblem is obtained respectively.  The subproblem\ntends to be much smaller than the original problem and hence it is easier to locate\nthe infeasibility inspecting the subproblem than the original problem.\n\nFor the procedure to be useful it is important to assign meaningful\nnames to constraints, variables etc. in the original task because those names\nwill be duplicated in the subproblem.\n\nThe function is only applicable to linear and conic quadratic optimization problems.\n\nFor more information see :numref:`doc.debugging.infeas` and :numref:`doc.shared.feas_repair`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "brief": "Which solution to use when determining the infeasible subproblem.", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "inftask", "brief": "A new task containing the infeasible subproblem.", "mode": "o", "type": ["ref", ["defined", "mosek", "task_t"]], "null?": true, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-infeasible-sub-problem", "api-name": "getinfeasiblesubproblem", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python"], "references": [{"type": "constant", "item": ["mosek", "iparam", "infeas_prefer_primal"]}], "member-of": ["infeasibility-diagnostic"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writesolution": {"old-name": "writesolution", "caml-name": "write-solution", "name": "writesolution", "brief": "Write a solution to a file.", "desc": "Saves the current basic, interior-point, or integer solution to a file.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichsol", "mode": "i", "type": ["const-class", "mosek", "soltype"], "null?": false, "api?": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-solution", "api-name": "writesolution", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "constant", "item": ["mosek", "iparam", "write_sol_ignore_invalid_names"]}, {"type": "constant", "item": ["mosek", "iparam", "write_sol_head"]}, {"type": "constant", "item": ["mosek", "iparam", "write_sol_constraints"]}, {"type": "constant", "item": ["mosek", "iparam", "write_sol_variables"]}, {"type": "constant", "item": ["mosek", "iparam", "write_sol_barvariables"]}, {"type": "constant", "item": ["mosek", "iparam", "write_bas_head"]}, {"type": "constant", "item": ["mosek", "iparam", "write_bas_constraints"]}, {"type": "constant", "item": ["mosek", "iparam", "write_bas_variables"]}], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writejsonsol": {"caml-name": "write-json-sol", "name": "writejsonsol", "brief": "Writes a solution to a JSON file.", "desc": "Saves the current solutions and solver information items in a JSON file. If the file name has the extensions .gz or .zst, then the file is gzip or Zstd compressed respectively.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-json-sol", "api-name": "writejsonsol", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["input-output"], "locked": true, "breakable": false, "log": false, "const": "const"}, "primalsensitivity": {"old-name": "primalsensitivity", "caml-name": "primal-sensitivity", "name": "primalsensitivity", "brief": "Perform sensitivity analysis on bounds.", "desc": "Calculates sensitivity information for bounds on variables and constraints. For details on sensitivity\nanalysis, the definitions of *shadow price* and *linearity interval* and an example see Section :ref:`doc.sensitivity_analysis`.\n\nThe type of sensitivity analysis to be performed (basis or optimal partition)\nis controlled by the parameter :msk:iparam:`sensitivity_type`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numi", "brief": "Number constraint bounds to analyze.", "desc": "Number of bounds on constraints to be analyzed. Length of ``subi`` and ``marki``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["marki", "subi"]}]}, {"name": "subi", "brief": "Indexes of constraints to analyze.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "marki", "brief": "Mark which constraint bounds to analyze.", "desc": "The value of ``marki[i]`` indicates for which bound of constraint ``subi[i]`` sensitivity\nanalysis is performed.  If ``marki[i]`` = :msk:const:`mark.up` the upper bound of\nconstraint ``subi[i]`` is analyzed, and if ``marki[i]`` = :msk:const:`mark.lo` the\nlower bound is analyzed.  If ``subi[i]`` is an equality constraint, either\n:msk:const:`mark.lo` or :msk:const:`mark.up` can be used to select the\nconstraint for sensitivity analysis.", "mode": "i", "type": ["ptr", ["const-class", "mosek", "mark"]], "null?": false, "api?": true}, {"name": "numj", "brief": "Number of variable bounds to analyze.", "desc": "Number of bounds on variables to be analyzed. Length of ``subj`` and ``markj``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["markj", "subj"]}]}, {"name": "subj", "brief": "Indexes of variables to analyze.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "markj", "brief": "Mark which variable bounds to analyze.", "desc": "The value of ``markj[j]`` indicates for which bound of variable ``subj[j]`` sensitivity\nanalysis is performed.  If ``markj[j]`` = :msk:const:`mark.up` the upper bound of\nvariable ``subj[j]`` is analyzed, and if ``markj[j]`` = :msk:const:`mark.lo` the\nlower bound is analyzed. If ``subj[j]`` is a fixed variable, either :msk:const:`mark.lo` or\n:msk:const:`mark.up` can be used to select the bound for sensitivity\nanalysis.", "mode": "i", "type": ["ptr", ["const-class", "mosek", "mark"]], "null?": false, "api?": true}, {"name": "leftpricei", "brief": "Left shadow price for constraints.", "desc": "``leftpricei[i]`` is the left shadow price for the bound ``marki[i]`` of constraint ``subi[i]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numi)", "ast": ["arg", "numi"], "arg-refs": ["numi"]}]}, {"name": "rightpricei", "brief": "Right shadow price for constraints.", "desc": "``rightpricei[i]`` is the right shadow price for the bound ``marki[i]`` of constraint ``subi[i]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numi)", "ast": ["arg", "numi"], "arg-refs": ["numi"]}]}, {"name": "leftrangei", "brief": "Left range for constraints.", "desc": "``leftrangei[i]`` is the left range :math:`\\beta_1` for the bound ``marki[i]`` of constraint ``subi[i]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numi)", "ast": ["arg", "numi"], "arg-refs": ["numi"]}]}, {"name": "rightrangei", "brief": "Right range for constraints.", "desc": "``rightrangei[i]`` is the right range :math:`\\beta_2` for the bound ``marki[i]`` of constraint ``subi[i]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numi)", "ast": ["arg", "numi"], "arg-refs": ["numi"]}]}, {"name": "leftpricej", "brief": "Left shadow price for variables.", "desc": "``leftpricej[j]`` is the left shadow price for the bound ``markj[j]`` of variable  ``subj[j]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "rightpricej", "brief": "Right shadow price for variables.", "desc": "``rightpricej[j]`` is the right shadow price for the bound ``markj[j]`` of variable  ``subj[j]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "leftrangej", "brief": "Left range for variables.", "desc": "``leftrangej[j]`` is the left range :math:`\\beta_1` for the bound ``markj[j]`` of variable ``subj[j]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "rightrangej", "brief": "Right range for variables.", "desc": "``rightrangej[j]`` is the right range :math:`\\beta_2` for the bound ``markj[j]`` of variable ``subj[j]``.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}], "explicit-lengths": true, "ais": "function", "api-caml-name": "primal-sensitivity", "api-name": "primalsensitivity", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "dualsensitivity"]}, {"type": "function", "item": ["mosek", "task", "sensitivityreport"]}, {"type": "constant", "item": ["mosek", "iparam", "sensitivity_type"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity_opt"]}], "member-of": ["sensitivity-analysis"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "sensitivityreport": {"old-name": "sensitivityreport", "caml-name": "sensitivity-report", "name": "sensitivityreport", "brief": "Creates a sensitivity report.", "desc": "Reads a sensitivity format file from a location given by\n:msk:sparam:`sensitivity_file_name` and writes the result to the stream\n``whichstream``. If :msk:sparam:`sensitivity_res_file_name` is set to a non-empty\nstring, then the sensitivity report is also written to a file of this name.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "sensitivity-report", "api-name": "sensitivityreport", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "dualsensitivity"]}, {"type": "function", "item": ["mosek", "task", "primalsensitivity"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity_opt"]}, {"type": "constant", "item": ["mosek", "iparam", "sensitivity_type"]}], "member-of": ["sensitivity-analysis"], "locked": true, "breakable": false, "log": false, "const": "const"}, "dualsensitivity": {"old-name": "dualsensitivity", "caml-name": "dual-sensitivity", "name": "dualsensitivity", "brief": "Performs sensitivity analysis on objective coefficients.", "desc": "Calculates sensitivity information for objective coefficients. The indexes of the coefficients to analyze are\n\n.. math:: \\{\\mathtt{subj}[i] ~|~ i = \\idxbeg,\\ldots,\\idxend{\\mathtt{numj}}\\}\n\nThe type of sensitivity analysis to perform (basis or optimal partition) is controlled by the parameter :msk:iparam:`sensitivity_type`.\n\nFor an example, please see Section :ref:`doc.shared.sensitivity_example`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numj", "brief": "Length of the subscripts array.", "desc": "Number of coefficients to be analyzed. Length of ``subj``.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["subj"]}]}, {"name": "subj", "brief": "Indexes of objective coefficients to analyze.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "leftpricej", "brief": "Left shadow prices for requested coefficients.", "desc": ":math:`\\mathtt{leftpricej}[j]` is the left shadow price for the\ncoefficient with index :math:`\\mathtt{subj[j]}`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "rightpricej", "brief": "Right shadow prices for requested coefficients.", "desc": ":math:`\\mathtt{rightpricej}[j]` is the right shadow price for the\ncoefficient with index :math:`\\mathtt{subj[j]}`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "leftrangej", "brief": "Left range for requested coefficients.", "desc": ":math:`\\mathtt{leftrangej}[j]` is the left range :math:`\\beta_1` for the\ncoefficient with index :math:`\\mathtt{subj[j]}`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}, {"name": "rightrangej", "brief": "Right range for requested coefficients.", "desc": ":math:`\\mathtt{rightrangej}[j]` is the right range :math:`\\beta_2` for the\ncoefficient with index :math:`\\mathtt{subj[j]}`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numj)", "ast": ["arg", "numj"], "arg-refs": ["numj"]}]}], "ais": "function", "api-caml-name": "dual-sensitivity", "api-name": "dualsensitivity", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "primalsensitivity"]}, {"type": "function", "item": ["mosek", "task", "sensitivityreport"]}, {"type": "constant", "item": ["mosek", "iparam", "sensitivity_type"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sensitivity_opt"]}], "member-of": ["sensitivity-analysis"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getlasterror": {"old-name": "getlasterror", "caml-name": "get-last-error", "name": "getlasterror", "brief": "Obtains the last error code and error message reported in MOSEK.", "desc": "Obtains the last response code and corresponding message reported in |mosek|.\n\nIf there is no previous error, warning or termination code for this task,\n``lastrescode`` returns :msk:const:`rescode.ok` and ``lastmsg`` returns an empty string,\notherwise the last response code different from :msk:const:`rescode.ok` and the\ncorresponding message are returned.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "lastrescode", "brief": "Returns the last error code reported in the task.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "sizelastmsg", "brief": "The length of the lastmsg buffer.", "desc": "The length of the ``lastmsg`` buffer.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "lastmsglen", "brief": "Returns the length of the last error message reported in the task.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "lastmsg", "brief": "Returns the last error message reported in the task.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "defaultout": true}], "ais": "function", "api-caml-name": "get-last-error", "api-name": "getlasterror", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["errors"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getlasterror64": {"old-name": "getlasterror64", "caml-name": "get-last-error-64", "name": "getlasterror64", "brief": "Obtains the last error code and error message reported in MOSEK.", "desc": "Obtains the last response code and corresponding message reported in |mosek|.\n\nIf there is no previous error, warning or termination code for this task,\n``lastrescode`` returns :msk:const:`rescode.ok` and ``lastmsg``\nreturns an empty string, otherwise the last response code different from\n:msk:const:`rescode.ok` and the corresponding message are returned.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "lastrescode", "brief": "Returns the last error code reported in the task.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "sizelastmsg", "brief": "The length of the lastmsg buffer.", "desc": "The length of the ``lastmsg`` buffer.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "CODE", "code": "(+ (call getlasterror64 task dummy-value 0 return-value nil) (int64 1))", "ast": ["+", ["call", "getlasterror64", "task", "dummy-value", "0", "return-value", "nil"], ["int64", "1"]]}]}, {"name": "lastmsglen", "brief": "Returns the length of the last error message reported in the task.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "lastmsg", "brief": "Returns the last error message reported in the task.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg sizelastmsg)", "ast": ["arg", "sizelastmsg"], "arg-refs": ["sizelastmsg"]}], "defaultout": true}], "ais": "function", "api-caml-name": "get-last-error", "api-name": "getlasterror", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [], "member-of": ["errors"], "locked": true, "breakable": false, "log": false, "const": "const"}, "writetasksolverresult_file": {"caml-name": "write-task-solver-result_file", "name": "writetasksolverresult_file", "brief": "Internal", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "compress", "mode": "i", "type": ["const-class", "mosek", "compresstype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "write-task-solver-result_file", "api-name": "writetasksolverresult_file", "targets": ["c", "cmdln", "no-overload", "python", "rust"], "references": [], "member-of": [], "locked": true, "breakable": false, "log": false, "const": "const"}, "optimizermt": {"caml-name": "optimize-rmt", "name": "optimizermt", "brief": "Offload the optimization task to a solver server and wait for the solution.", "desc": "Offload the optimization task to an instance of |optserver| specified by ``addr``, which should be a valid URL,\nfor example ``http://server:port`` or ``https://server:port``. The call will block until a result is\navailable or the connection closes.\n\nIf the server requires authentication, the authentication token can be passed in the ``accesstoken`` argument.\n\nIf the server requires encryption, the keys can be passed using one of the solver parameters\n:msk:sparam:`remote_tls_cert` or :msk:sparam:`remote_tls_cert_path`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "trmcode", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "optimize-rmt", "api-name": "optimizermt", "targets": ["c", "cmdln", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert_path"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "optimizecb": {"caml-name": "optimize-cb", "name": "optimizecb", "brief": "Offload the optimization task to a solver server.", "desc": "Offload the optimization task to a solver server\ndefined by ``server:port``. The call will block until a result is\navailable or the connection closes.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "addr", "brief": "Address of the solver server.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "trmcode", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "optimize-cb", "api-name": "optimizecb", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncoptimizecb": {"caml-name": "async-optimize-cb", "name": "asyncoptimizecb", "brief": "Offload the optimization task to a solver server.", "desc": "Offload the optimization task to a solver server. The\ncall will return immediately and not wait for the\nresult.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "token", "brief": "Returns the task token", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "33", "ast": "33"}], "defaultout": true}], "ais": "function", "api-caml-name": "async-optimize-cb", "api-name": "asyncoptimizecb", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncgetlogcb": {"caml-name": "async-get-log-cb", "name": "asyncgetlogcb", "brief": "Get the solver log from a remote job.", "desc": "Get the solver log from a remote job and print it to\nthe log stream.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "addr", "brief": "Address of the solver server", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "token", "brief": "Returns the task token", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "33", "ast": "33"}], "defaultout": true}], "ais": "function", "api-caml-name": "async-get-log-cb", "api-name": "asyncgetlogcb", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncstopcb": {"caml-name": "async-stop-cb", "name": "asyncstopcb", "brief": "Request that the job identified by the token is terminated.", "desc": "Request that the job identified by the ``token`` is terminated.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "addr", "brief": "Address of the solver server", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-stop-cb", "api-name": "asyncstopcb", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncgetresultcb": {"caml-name": "async-get-result-cb", "name": "asyncgetresultcb", "brief": "Request a response from a remote job.", "desc": "Request a response from a remote job. If successful, solver response, termination code and solutions are retrieved.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "addr", "brief": "Address of the solver server.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "respavailable", "brief": "Indicates if a remote response is available.", "desc": "Indicates if a remote response is available. If this is not true, ``resp`` and ``trm`` should be ignored.", "mode": "o", "type": ["ref", ["defined", "mosek", "booleant"]], "null?": false, "api?": true, "defaultout": true}, {"name": "resp", "brief": "Is the response code from the remote solver.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "trm", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-get-result-cb", "api-name": "asyncgetresultcb", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncpollcb": {"caml-name": "async-poll-cb", "name": "asyncpollcb", "brief": "Requests information about the status of the remote job.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "access_token", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "addr", "brief": "Address of the solver server", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "h", "brief": "Handle for reading and writing.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "hread", "brief": "Handle read function.", "mode": "i", "type": ["defined", "mosek", "hreadfunc"], "null?": false, "api?": true}, {"name": "hwrite", "brief": "Handle write function.", "mode": "i", "type": ["defined", "mosek", "hwritefunc"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "respavailable", "brief": "Indicates if a remote response is available.", "desc": "Indicates if a remote response is available. If this is not true, ``resp`` and ``trm`` should be ignored.", "mode": "o", "type": ["ref", ["defined", "mosek", "booleant"]], "null?": false, "api?": true, "defaultout": true}, {"name": "resp", "brief": "Is the response code from the remote solver.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "trm", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-poll-cb", "api-name": "asyncpollcb", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncoptimize": {"caml-name": "async-optimize", "name": "asyncoptimize", "brief": "Offload the optimization task to a solver server in asynchronous mode.", "desc": "Offload the optimization task to an instance of |optserver| specified by ``addr``, which should be a valid URL,\nfor example ``http://server:port`` or ``https://server:port``. The call will exit immediately.\n\nIf the server requires authentication, the authentication token can be passed in the ``accesstoken`` argument.\n\nIf the server requires encryption, the keys can be passed using one of the solver parameters\n:msk:sparam:`remote_tls_cert` or :msk:sparam:`remote_tls_cert_path`.\n\nThe function returns a token which should be used in future calls to identify the task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "token", "brief": "Returns the task token.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "33", "ast": "33"}], "defaultout": true}], "ais": "function", "api-caml-name": "async-optimize", "api-name": "asyncoptimize", "targets": ["c", "cmdln", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "optimizermt"]}, {"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert_path"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncgetlog": {"caml-name": "async-get-log", "name": "asyncgetlog", "brief": "Get the optimizer log from a remote job.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "addr", "brief": "Address of the solver server", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token string.", "desc": "Access token string or |null| if no token is given.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "44", "ast": "44"}]}, {"name": "token", "brief": "Job token", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "33", "ast": "33"}], "defaultout": true}], "ais": "function", "api-caml-name": "async-get-log", "api-name": "asyncgetlog", "targets": ["c", "cmdln", "julia", "no-overload", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncstop": {"caml-name": "async-stop", "name": "asyncstop", "brief": "Request that the job identified by the token is terminated.", "desc": "Request that the remote job identified by ``token`` is terminated. For other arguments see :msk:func:`task.asyncoptimize`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-stop", "api-name": "asyncstop", "targets": ["c", "cmdln", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert_path"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncpoll": {"caml-name": "async-poll", "name": "asyncpoll", "brief": "Requests information about the status of the remote job.", "desc": "Requests information about the status of the remote job identified by the argument ``token``. For other arguments see :msk:func:`task.asyncoptimize`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "respavailable", "brief": "Indicates if a remote response is available.", "desc": "Indicates if a remote response is available. If this is not true, ``resp`` and ``trm`` should be ignored.", "mode": "o", "type": ["ref", ["defined", "mosek", "booleant"]], "null?": false, "api?": true, "defaultout": true}, {"name": "resp", "brief": "Is the response code from the remote solver.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "trm", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-poll", "api-name": "asyncpoll", "targets": ["c", "cmdln", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncgetresult"]}, {"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert_path"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "asyncgetresult": {"caml-name": "async-get-result", "name": "asyncgetresult", "brief": "Request a solution from a remote job.", "desc": "Request a solution from a remote job identified by the argument ``token``. For other arguments see :msk:func:`task.asyncoptimize`. If the solution is available it\nwill be retrieved and loaded into the local task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "address", "brief": "Address of the OptServer.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "accesstoken", "brief": "Access token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "token", "brief": "The task token.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "respavailable", "brief": "Indicates if a remote response is available.", "desc": "Indicates if a remote response is available. If this is not true, ``resp`` and ``trm`` should be ignored.", "mode": "o", "type": ["ref", ["defined", "mosek", "booleant"]], "null?": false, "api?": true, "defaultout": true}, {"name": "resp", "brief": "Is the response code from the remote solver.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}, {"name": "trm", "brief": "Is either OK or a termination response code.", "desc": "Is either :msk:const:`rescode.ok` or a termination response code.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "async-get-result", "api-name": "asyncgetresult", "targets": ["c", "cmdln", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "task", "asyncoptimize"]}, {"type": "function", "item": ["mosek", "task", "asyncpoll"]}, {"type": "function", "item": ["mosek", "task", "asyncstop"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert"]}, {"type": "constant", "item": ["mosek", "sparam", "remote_tls_cert_path"]}], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putoptserverhost": {"caml-name": "put-optserver-host", "name": "putoptserverhost", "brief": "Specify an OptServer for remote calls.", "desc": "Specify an |optserver| URL for remote calls. The URL should contain protocol, host and port in the form ``http://server:port`` or\n``https://server:port``. If the URL is set using this function, all subsequent calls to any |mosek| function that involves synchronous optimization\nwill be sent to the specified |optserver| instead of being executed locally. Passing |null| or empty string deactivates this redirection.\n\nHas the same effect as setting the parameter :msk:sparam:`remote_optserver_host`.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "task", "mode": "i", "type": ["defined", "mosek", "task_t"], "null?": false, "api?": true, "classarg": true}, {"name": "host", "brief": "A URL specifying the optimization server to be used.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-optserver-host", "api-name": "putoptserverhost", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["remote"], "locked": true, "breakable": false, "log": false, "const": "mut"}}}, "env": {"name": "env", "prefix": "_", "functions": {"optimizebatch": {"caml-name": "optimize-batch", "name": "optimizebatch", "brief": "Optimize a number of tasks in parallel using a specified number of threads.", "desc": "Optimize a number of tasks in parallel using a specified number of threads. All callbacks and log output streams are disabled.\n\nAssuming that each task takes about same time and there many more tasks than number of threads then a linear speedup can be achieved, also known as strong scaling. A typical application of this method is to solve many small tasks of similar type; in this case it is recommended that each of them is allocated a single thread by setting :msk:iparam:`num_threads` to :math:`1`.\n\nIf the parameters ``israce`` or ``maxtime`` are used, then the result may not be deterministic, in the sense that the tasks which complete first may vary between runs.\n\nThe remaining behavior, including termination and response codes returned for each task, are the same as if each task was optimized separately.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": null}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "israce", "brief": "If nonzero, then the function is terminated after the first task has been completed.", "mode": "i", "type": ["defined", "mosek", "booleant"], "null?": false, "api?": true}, {"name": "maxtime", "brief": "Time limit for the function.", "desc": "Time limit for the function: if nonnegative, then the function is terminated after maxtime (seconds) has expired.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "numthreads", "brief": "Number of threads to be employed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "numtask", "brief": "Number of tasks to optimize.", "desc": "Number of tasks to optimize. Length of the ``task`` array.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["task"]}]}, {"name": "task", "brief": "An array of tasks to optimize in parallel.", "mode": "i", "type": ["ptr", ["defined", "mosek", "task_t"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numtask)", "ast": ["arg", "numtask"], "arg-refs": ["numtask"]}]}, {"name": "trmcode", "brief": "The termination code for each task.", "mode": "o", "type": ["ptr", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numtask)", "ast": ["arg", "numtask"], "arg-refs": ["numtask"]}]}, {"name": "rcode", "brief": "The response code for each task.", "mode": "o", "type": ["ptr", ["const-class", "mosek", "rescode"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg numtask)", "ast": ["arg", "numtask"], "arg-refs": ["numtask"]}]}], "ais": "function", "api-caml-name": "optimize-batch", "api-name": "optimizebatch", "targets": ["c", "dotnet", "go", "java", "julia", "no-overload", "python", "rust"], "references": [], "member-of": ["optimize"], "locked": true, "breakable": false, "log": false, "const": "const"}, "callbackcodetostr": {"caml-name": "callback-code-to-str", "name": "callbackcodetostr", "brief": "Obtains a callback code string identifier.", "desc": "Obtains the string representation of a callback code.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "code", "brief": "A callback code.", "mode": "i", "type": ["const-class", "mosek", "callbackcode"], "null?": false, "api?": true}, {"name": "callbackcodestr", "brief": "String corresponding to the callback code.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}], "defaultout": true}], "ais": "function", "api-caml-name": "callback-code-to-str", "api-name": "callbackcodetostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "isinfinity": {"old-name": "isinfinity", "caml-name": "is-infinity", "name": "isinfinity", "brief": "Return true if value is considered infinity by MOSEK.", "desc": "Return true if ``value`` is considered infinity by |mosek|.", "status": "obscure", "returns": {"type": ["defined", "mosek", "booleant"], "name": null, "brief": "True if the value represents infinity."}, "args": [{"name": "value", "brief": "The value to be checked", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "is-infinity", "api-name": "isinfinity", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": [], "locked": true, "breakable": false, "log": false, "const": "const"}, "enablegarcolenv": {"old-name": "enablegarcolenv", "caml-name": "enable-gar-col-env", "name": "enablegarcolenv", "brief": "Enable reference counting for environments.", "desc": "Enable reference counting for environments. When this is\nenabled, environment objects will be deleted only when the\nlast task has been deleted. That is, deleting every task\nbelonging to an environment, then deleting the environment\nworks as usual. Deleting the environment while there are\nstill tasks left belonging to it, means that the\nenvironment is automatically deleted immediately after the\nlast task is deleted.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": null}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "enable-gar-col-env", "api-name": "enablegarcolenv", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": [], "locked": true, "breakable": false, "log": false, "const": "mut"}, "makeenvdebug": {"caml-name": "make-env-debug", "name": "makeenvdebug", "brief": "Private.", "status": "internal", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "o", "type": ["ref", ["defined", "mosek", "env_t"]], "null?": true, "api?": true}, {"name": "maxnumalloc", "brief": "If it is nonnegative then it is the maximum number of alloacations allowed.", "mode": "io", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true}, {"name": "dbgfile", "brief": "A user-defined file debug file.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "make-env-debug", "api-name": "makeenvdebug", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "unittestmain": {"old-name": "unittestmain", "caml-name": "unittest-main", "name": "unittestmain", "brief": "Run unit tests.", "status": "internal", "returns": {"type": ["ctype", "int"], "name": null}, "args": [{"name": "cuintinterface", "mode": "i", "type": ["ctype", "int"], "null?": false, "api?": true}, {"name": "fileroot", "mode": "i", "type": ["ptr", ["ctype", "char"]], "null?": false, "api?": true}, {"name": "debuglogstring", "mode": "io", "type": ["ptr", ["ctype", "char"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "1024", "ast": "1024"}]}, {"name": "loglevel", "mode": "i", "type": ["ctype", "int"], "null?": false, "api?": true}, {"name": "suite", "mode": "io", "type": ["ptr", ["ctype", "char"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "1024", "ast": "1024"}]}, {"name": "test", "mode": "io", "type": ["ptr", ["ctype", "char"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "1024", "ast": "1024"}]}], "ais": "function", "api-caml-name": "unittest-main", "api-name": "unittestmain", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": [], "locked": true, "breakable": false, "log": false, "const": "mut"}, "checkoutlicense": {"old-name": "checkoutlicense", "caml-name": "check-out-license", "name": "checkoutlicense", "brief": "Check out a license feature from the license server ahead of time.", "desc": "Checks out a license feature from the license server. Normally the required\nlicense features will be automatically checked out the first time they are needed\nby the function :msk:func:`task.optimize`. This function can be used to check out one\nor more features ahead of time.\n\nThe feature will remain checked out until the environment is deleted or the function\n:msk:func:`env.checkinlicense` is called.\n\nIf a given feature is already checked out when this function is called, the call has no effect.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "feature", "brief": "Feature to check out from the license system.", "mode": "i", "type": ["const-class", "mosek", "feature"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "check-out-license", "api-name": "checkoutlicense", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "checkinlicense": {"old-name": "checkinlicense", "caml-name": "check-in-license", "name": "checkinlicense", "brief": "Check in a license feature back to the license server ahead of time.", "desc": "Check in a license feature to the license server. By default all licenses\nconsumed by functions using a single environment are kept checked out for the\nlifetime of the |mosek| environment. This function checks in a given license\nfeature back to the license server immediately.\n\nIf the given license feature is not checked out at all, or it is in use by a call to\n:msk:func:`task.optimize`, calling this function has no effect.\n\nPlease note that returning a license to the license server incurs a small\noverhead, so frequent calls to this function should be avoided.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "feature", "brief": "Feature to check in to the license system.", "mode": "i", "type": ["const-class", "mosek", "feature"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "check-in-license", "api-name": "checkinlicense", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "checkinall": {"caml-name": "check-in-all", "name": "checkinall", "brief": "Check in all unused license features to the license token server.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "check-in-all", "api-name": "checkinall", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "expirylicenses": {"name": "expirylicenses", "brief": "Reports when the first license feature expires.", "desc": "Reports when the first license feature expires. It reports the number of days to the expiry of the first feature of all the features that were ever checked out from the start of the process, or from the last call to :msk:func:`env.resetexpirylicenses`, until now.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "expiry", "brief": "If nonnegative, then it is the minimum number days to expiry of any feature that has been checked out.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "expirylicenses", "api-name": "expirylicenses", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "resetexpirylicenses": {"caml-name": "reset-expiry-licenses", "name": "resetexpirylicenses", "brief": "Reset the license expiry reporting startpoint.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}], "ais": "function", "api-caml-name": "reset-expiry-licenses", "api-name": "resetexpirylicenses", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getbuildinfo": {"caml-name": "get-build-info", "name": "getbuildinfo", "brief": "Obtains build information.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "buildstate", "brief": "State of binaries, i.e. a debug, release candidate or final release.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}, {"name": "builddate", "brief": "Date when the binaries were built.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "get-build-info", "api-name": "getbuildinfo", "targets": ["c", "cmdln", "dotnet", "no-overload", "rpc", "rust"], "references": [], "member-of": ["version"], "locked": false, "breakable": false, "log": false, "const": "const"}, "getresponseclass": {"old-name": "getresponseclass", "caml-name": "get-response-class", "name": "getresponseclass", "brief": "Obtain the class of a response code.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "r", "mode": "i", "type": ["const-class", "mosek", "rescode"], "null?": false, "api?": true}, {"name": "rc", "brief": "The response class.", "mode": "o", "type": ["ref", ["const-class", "mosek", "rescodetype"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-response-class", "api-name": "getresponseclass", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["errors"], "locked": true, "breakable": false, "log": false, "const": "const"}, "callocenv": {"old-name": "callocenv", "caml-name": "calloc-env", "name": "callocenv", "brief": "A replacement for the system calloc function.", "desc": "Equivalent to ``calloc`` i.e. allocate space for an array of length\n``number`` where each element is of size ``size``.", "status": "obscure", "returns": {"type": ["ptr", ["ctype", "void"]], "name": null, "brief": "A pointer to the memory allocated through the environment."}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "number", "brief": "Number of elements.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "size", "brief": "Size of each individual element.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "calloc", "api-name": "calloc", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "callocdbgenv": {"old-name": "callocdbgenv", "caml-name": "calloc-dbg-env", "name": "callocdbgenv", "brief": "Debug version of the system calloc function.", "desc": "Debug version of :msk:func:`env.callocenv`.", "status": "obscure", "returns": {"type": ["ptr", ["ctype", "void"]], "name": null, "brief": "A pointer to the memory allocated through the environment."}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "number", "brief": "Number of elements.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "size", "brief": "Size of each individual element.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["ctype", "unsigned"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "calloc-dbg", "api-name": "callocdbg", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "deleteenv": {"old-name": "deleteenv", "caml-name": "delete-env", "name": "deleteenv", "brief": "Delete a MOSEK environment.", "desc": "Deletes a |mosek| environment and all the data associated with it.\n\nBefore calling this function it is a good idea to call the function\n:msk:func:`env.unlinkfuncfromenvstream` for each stream that has had a function\nlinked to it.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "io", "type": ["ref", ["defined", "mosek", "env_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "delete-env", "api-name": "deleteenv", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "echoenv": {"old-name": "echoenv", "caml-name": "echo-env", "name": "echoenv", "brief": "Prints a formatted message to the environment stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "format", "brief": "A valid printf-compatible format string", "desc": "Is a valid C format string which matches the arguments in ``...``.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "varnumarg", "brief": "A variable argument list.", "mode": "i", "type": ["vararg"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "echo", "api-name": "echo", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["logging"], "locked": true, "breakable": false, "log": false, "const": "const"}, "echointro": {"caml-name": "echo-intro", "name": "echointro", "brief": "Prints an intro to message stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "longver", "brief": "If non-zero, then the intro is slightly longer.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "echo-intro", "api-name": "echointro", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["logging"], "locked": true, "breakable": false, "log": false, "const": "const"}, "freeenv": {"old-name": "freeenv", "caml-name": "free-env", "name": "freeenv", "brief": "Frees space allocated by MOSEK.", "desc": "Frees space allocated by a |mosek| function. Must not be applied\nto the |mosek| environment and task.", "status": "obscure", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "buffer", "brief": "A pointer.", "mode": "io", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "0", "ast": "0"}]}], "ais": "function", "api-caml-name": "free", "api-name": "free", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "freedbgenv": {"old-name": "freedbgenv", "caml-name": "free-dbg-env", "name": "freedbgenv", "brief": "Frees space allocated by MOSEK.", "desc": "Frees space allocated by |mosek|. Debug version of :msk:func:`env.freeenv`.", "status": "obscure", "returns": {"type": ["ctype", "void"], "name": null}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "buffer", "brief": "A pointer.", "mode": "io", "type": ["ptr", ["ctype", "void"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "0", "ast": "0"}]}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["ctype", "unsigned"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "freedbg", "api-name": "freedbg", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "getcodedesc": {"old-name": "getcodedesc", "caml-name": "get-code-desc", "name": "getcodedesc", "brief": "Obtains a short description of a response code.", "desc": "Obtains a short description of the meaning of the response code given by ``code``.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "code", "brief": "A valid response code.", "desc": "A valid |mosek| response code.", "mode": "i", "type": ["const-class", "mosek", "rescode"], "null?": false, "api?": true}, {"name": "symname", "brief": "Symbolic name corresponding to the code.", "desc": "Symbolic name corresponding to ``code``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}, {"name": "str", "brief": "Obtains a short description of a response code.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "get-code-desc", "api-name": "getcodedesc", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["naming", "errors"], "locked": false, "breakable": false, "log": false, "const": "const"}, "getsymbcondim": {"old-name": "getsymbcondim", "caml-name": "get-symb-con-dim", "name": "getsymbcondim", "brief": "Obtains dimensional information for the defined symbolic constants.", "desc": "Obtains the number of symbolic constants defined by |mosek|\nand the maximum length of the name of any symbolic constant.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "num", "brief": "Returns the number of symbolic constants.", "desc": "Number of symbolic constants defined by |mosek|.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "maxlen", "brief": "Maximum length of the name of any symbolic constants.", "mode": "o", "type": ["ref", ["ctype", "size_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-symb-con-dim", "api-name": "getsymbcondim", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["parameters"], "locked": true, "breakable": false, "log": false, "const": "const"}, "rescodetostr": {"caml-name": "rescode-to-str", "name": "rescodetostr", "brief": "Obtains a response code string identifier.", "desc": "Obtains an identifier string corresponding to a response code.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "res", "brief": "Response code.", "mode": "i", "type": ["const-class", "mosek", "rescode"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the response code.", "desc": "String corresponding to the bound response code ``res``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "rescode-to-str", "api-name": "rescodetostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "iinfitemtostr": {"caml-name": "iinfitem-to-str", "name": "iinfitemtostr", "brief": "Obtains a information item string identifier.", "desc": "Obtains an identifier string corresponding to a information item.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "item", "brief": "Information item.", "mode": "i", "type": ["const-class", "mosek", "iinfitem"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the information item.", "desc": "String corresponding to the bound information item ``item``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "iinfitem-to-str", "api-name": "iinfitemtostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "dinfitemtostr": {"caml-name": "dinfitem-to-str", "name": "dinfitemtostr", "brief": "Obtains a information item string identifier.", "desc": "Obtains an identifier string corresponding to a information item.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "item", "brief": "Information item.", "mode": "i", "type": ["const-class", "mosek", "dinfitem"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the information item.", "desc": "String corresponding to the bound information item ``item``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "dinfitem-to-str", "api-name": "dinfitemtostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "liinfitemtostr": {"caml-name": "liinfitem-to-str", "name": "liinfitemtostr", "brief": "Obtains a information item string identifier.", "desc": "Obtains an identifier string corresponding to a information item.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "item", "brief": "Information item.", "mode": "i", "type": ["const-class", "mosek", "liinfitem"], "null?": false, "api?": true}, {"name": "str", "brief": "String corresponding to the information item.", "desc": "String corresponding to the bound information item ``item``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}]}], "ais": "function", "api-caml-name": "liinfitem-to-str", "api-name": "liinfitemtostr", "targets": ["c", "cmdln", "julia", "no-overload"], "references": [], "member-of": ["naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "getversion": {"old-name": "getversion", "caml-name": "get-version", "name": "getversion", "brief": "Obtains MOSEK version information.", "desc": "Obtains |mosek| version information.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "major", "brief": "Major version number.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "minor", "brief": "Minor version number.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}, {"name": "revision", "brief": "Revision number.", "mode": "o", "type": ["ref", ["defined", "mosek", "int32t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "get-version", "api-name": "getversion", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["version"], "locked": false, "breakable": false, "log": false, "const": "const"}, "checkversion": {"old-name": "checkversion", "caml-name": "check-version", "name": "checkversion", "brief": "Compares a version of the MOSEK DLL with a specified version.", "desc": "Compares the version of the |mosek| DLL with a specified version. Returns :msk:res:`ok` if the versions match and one of :msk:res:`err_newer_dll`, :msk:res:`err_older_dll` otherwise.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "major", "brief": "Major version number.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "minor", "brief": "Minor version number.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "revision", "brief": "Revision number.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "check-version", "api-name": "checkversion", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["version"], "locked": true, "breakable": false, "log": false, "const": "const"}, "iparvaltosymnam": {"old-name": "iparvaltosymnam", "caml-name": "ipar-val-to-sym-nam", "name": "iparvaltosymnam", "brief": "Obtains the symbolic name corresponding to a value that can be assigned to an integer parameter.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichparam", "brief": "Which parameter.", "mode": "i", "type": ["const-class", "mosek", "iparam"], "null?": false, "api?": true}, {"name": "whichvalue", "brief": "Which value.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "symbolicname", "brief": "The symbolic name corresponding to the whichvalue argument.", "desc": "The symbolic name corresponding to ``whichvalue``.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "ipar-val-to-sym-nam", "api-name": "iparvaltosymnam", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["parameters", "naming"], "locked": true, "breakable": false, "log": false, "const": "const"}, "linkfiletoenvstream": {"old-name": "linkfiletoenvstream", "caml-name": "link-file-to-env-stream", "name": "linkfiletoenvstream", "brief": "Directs all output from a stream to a file.", "desc": "Sends all output from the stream defined by ``whichstream`` to the file given by ``filename``.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "filename", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "append", "brief": "If this argument is 0 the file will be overwritten, otherwise it will be appended to.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "linkfiletosenvtream", "api-name": "linkfiletosenvtream", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["logging"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "linkfunctoenvstream": {"old-name": "linkfunctoenvstream", "caml-name": "link-func-to-env-stream", "name": "linkfunctoenvstream", "brief": "Connects a user-defined function to a stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}, {"name": "handle", "brief": "Pointer to a user-defined structure.", "desc": "A user-defined handle which is passed to the user-defined function ``func``.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}, {"name": "func", "brief": "Pointer to a user-defined function for handling strings.", "desc": "All output to the stream ``whichstream`` is passed to ``func``.", "mode": "i", "type": ["defined", "mosek", "streamfunc"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "link-func-to-stream", "api-name": "linkfunctostream", "targets": ["c", "cmdln", "no-overload", "rust"], "references": [], "member-of": ["logging", "callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "unlinkfuncfromenvstream": {"caml-name": "unlink-func-from-env-stream", "name": "unlinkfuncfromenvstream", "brief": "Disconnects a user-defined function from a stream.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "whichstream", "mode": "i", "type": ["const-class", "mosek", "streamtype"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "unlink-func-from-stream", "api-name": "unlinkfuncfromstream", "targets": ["c", "cmdln"], "references": [], "member-of": ["logging", "callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "makeenv": {"caml-name": "make-env", "name": "makeenv", "brief": "Creates a new MOSEK environment.", "desc": "Creates a new |mosek| environment. The environment must be shared among all tasks in a program.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "o", "type": ["ref", ["defined", "mosek", "env_t"]], "null?": true, "api?": true}, {"name": "dbgfile", "brief": "A user-defined memory debug file.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "make-env", "api-name": "makeenv", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [{"type": "function", "item": ["mosek", "env", "deleteenv"]}], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putlicensedebug": {"caml-name": "put-license-debug", "name": "putlicensedebug", "brief": "Enables debug information for the license system.", "desc": "Enables debug information for the license system. If ``licdebug`` is non-zero, then |mosek| will print debug info regarding the license checkout.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "licdebug", "brief": "Enable output of license check-out debug information.", "desc": "Whether license checkout debug info should be printed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-license-debug", "api-name": "putlicensedebug", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putlicensecode": {"caml-name": "put-license-code", "name": "putlicensecode", "brief": "Input a runtime license code.", "desc": "Input a runtime license code.  This function has an effect only before the first optimization.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "code", "brief": "A license key string.", "desc": "A runtime license code.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.license_buffer_length)", "ast": ["const", "value.license_buffer_length"]}]}], "ais": "function", "api-caml-name": "put-license-code", "api-name": "putlicensecode", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putlicensewait": {"caml-name": "put-license-wait", "name": "putlicensewait", "brief": "Control whether mosek should wait for an available license if no license is available.", "desc": "Control whether |mosek| should wait for an available license if no license is available. If ``licwait`` is non-zero, then |mosek| will wait for ``licwait-1`` milliseconds between each check for an available license.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "licwait", "brief": "Enable waiting for a license.", "desc": "Whether |mosek| should wait for a license if no license\nis available.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-license-wait", "api-name": "putlicensewait", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putlicensepath": {"caml-name": "put-license-path", "name": "putlicensepath", "brief": "Set the path to the license file.", "desc": "Set the path to the license file. This function has an effect only before the first optimization.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "licensepath", "brief": "A path specifying where to search for the license.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "put-license-path", "api-name": "putlicensepath", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "maketask": {"caml-name": "make-task", "name": "maketask", "brief": "Creates a new task.", "status": "api", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "maxnumcon", "brief": "An optional estimate on the maximum number of constraints in the task.", "desc": "An optional estimate on the maximum number of constraints in the task. Can be :math:`0` if no such estimate is known.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "maxnumvar", "brief": "An optional estimate on the maximum number of variables in the task.", "desc": "An optional estimate on the maximum number of variables in the task. Can be :math:`0` if no such estimate is known.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "task", "mode": "o", "type": ["ref", ["defined", "mosek", "task_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "make-task", "api-name": "maketask", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "makeemptytask": {"caml-name": "make-empty-task", "name": "makeemptytask", "brief": "Creates a new and empty optimization task.", "desc": "Creates a new optimization task.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "task", "mode": "o", "type": ["ref", ["defined", "mosek", "task_t"]], "null?": true, "api?": true}], "ais": "function", "api-caml-name": "make-empty-task", "api-name": "makeemptytask", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["management"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "putexitfunc": {"old-name": "putexitfunc", "caml-name": "put-exit-func", "name": "putexitfunc", "brief": "Inputs a user-defined exit function which is called in case of fatal errors.", "desc": "In case |mosek| experiences a fatal error, then a user-defined exit function can be called.\nThe exit function should terminate |mosek|. In general it is not necessary\nto define an exit function.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "exitfunc", "brief": "A user-defined exit function.", "mode": "i", "type": ["defined", "mosek", "exitfunc"], "null?": false, "api?": true}, {"name": "handle", "brief": "A pointer to a user-defined data structure.", "desc": "A pointer to a user-defined data structure which is passed to ``exitfunc`` when called.", "mode": "i", "type": ["defined", "mosek", "userhandle_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "put-exit-func", "api-name": "putexitfunc", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["logging", "callback"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "utf8towchar": {"old-name": "utf8towchar", "caml-name": "utf8-to-wchar", "name": "utf8towchar", "brief": "Converts an UTF8 string to a wchar string.", "desc": "Converts an UTF8 string to a :msk:type:`wchart` string.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "outputlen", "brief": "The length of the output buffer.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "len", "brief": "The length of the string contained in the output buffer.", "mode": "o", "type": ["ptr", ["ctype", "size_t"]], "null?": true, "api?": true}, {"name": "conv", "brief": "Returns the number of characters converted.", "desc": "Returns the number of characters converted, i.e. ``input[conv]`` is the\nfirst character which was not converted. If the whole string was converted, then\n``input[conv]=0``.", "mode": "o", "type": ["ptr", ["ctype", "size_t"]], "null?": true, "api?": true}, {"name": "output", "brief": "The input string converted to a wchar string.", "desc": "The input string converted to a :msk:type:`wchart` string.", "mode": "o", "type": ["ptr", ["defined", "mosek", "wchart"]], "null?": true, "api?": true}, {"name": "input", "brief": "The UTF8 input string.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "utf8-to-wchar", "api-name": "utf8towchar", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "const"}, "wchartoutf8": {"old-name": "wchartoutf8", "caml-name": "wchar-to-utf8", "name": "wchartoutf8", "brief": "Converts a wchar string to an UTF8 string.", "desc": "Converts a :msk:type:`wchart` string to an UTF8 string.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "outputlen", "brief": "The length of the output buffer.", "mode": "i", "type": ["ctype", "size_t"], "null?": false, "api?": true}, {"name": "len", "brief": "The length of the string contained in the output buffer.", "mode": "o", "type": ["ptr", ["ctype", "size_t"]], "null?": true, "api?": true}, {"name": "conv", "brief": "Returns the number of characters converted.", "desc": "Returns the number of characters from converted, i.e. ``input[conv]`` is the\nfirst char which was not converted. If the whole string was converted, then\n``input[conv]=0``.", "mode": "o", "type": ["ptr", ["ctype", "size_t"]], "null?": true, "api?": true}, {"name": "output", "brief": "The input string converted to a UTF8 string.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true}, {"name": "input", "brief": "The wchar input string.", "desc": "The :msk:type:`wchart` input string.", "mode": "i", "type": ["ptr", ["defined", "mosek", "wchart"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "wchar-to-utf8", "api-name": "wchartoutf8", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "const"}, "checkmemenv": {"old-name": "checkmemenv", "caml-name": "check-mem-env", "name": "checkmemenv", "brief": "Checks the memory allocated by the environment.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "file", "brief": "File from which the function is called.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "line", "brief": "Line in the file from which the function is called.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "check-mem", "api-name": "checkmem", "targets": ["c", "cmdln"], "references": [], "member-of": ["system"], "locked": true, "breakable": false, "log": false, "const": "mut"}, "symnamtovalue": {"old-name": "symnamtovalue", "caml-name": "sym-nam-to-value", "name": "symnamtovalue", "brief": "Obtains the value corresponding to a symbolic name defined by MOSEK.", "desc": "Obtains the value corresponding to a symbolic name defined by |mosek|.", "status": "obscure", "returns": {"type": ["defined", "mosek", "booleant"], "name": null, "brief": "Indicates if the symbolic name has been converted."}, "args": [{"name": "name", "brief": "Symbolic name.", "mode": "i", "type": ["defined", "mosek", "string_t"], "null?": false, "api?": true}, {"name": "value", "brief": "The corresponding value.", "mode": "o", "type": ["defined", "mosek", "string_t"], "null?": true, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(const value.max_str_len)", "ast": ["const", "value.max_str_len"]}], "defaultout": true}], "ais": "function", "api-caml-name": "sym-nam-to-value", "api-name": "symnamtovalue", "targets": ["c", "cmdln", "no-overload", "rpc", "rust"], "references": [], "member-of": ["parameters"], "locked": false, "breakable": false, "log": false, "const": "const"}, "axpy": {"name": "axpy", "brief": "Computes vector addition and multiplication by a scalar.", "desc": "Adds :math:`\\alpha x` to :math:`y`, i.e. performs the update\n\n.. math:: y := \\alpha x + y.\n\nNote that the result is stored overwriting :math:`y`. It must not overlap with the other input arrays.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Length of the vectors.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "alpha", "brief": "The scalar that multiplies x.", "desc": "The scalar that multiplies :math:`x`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "x", "brief": "The x vector.", "desc": "The :math:`x` vector.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}, {"name": "y", "brief": "The y vector.", "desc": "The :math:`y` vector.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "axpy", "api-name": "axpy", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "dot": {"name": "dot", "brief": "Computes the inner product of two vectors.", "desc": "Computes the inner product of two vectors :math:`x,y` of length :math:`n\\geq 0`, i.e\n\n.. math:: x\\cdot y= \\sum_{i=1}^n x_i y_i.\n\nNote that if :math:`n=0`, then the result of the operation is 0.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "n", "brief": "Length of the vectors.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "x", "brief": "The x vector.", "desc": "The :math:`x` vector.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}, {"name": "y", "brief": "The y vector.", "desc": "The :math:`y` vector.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}, {"name": "xty", "brief": "The result of the inner product.", "desc": "The result of the inner product between :math:`x` and :math:`y`.", "mode": "o", "type": ["ref", ["defined", "mosek", "realt"]], "null?": false, "api?": true}], "ais": "function", "api-caml-name": "dot", "api-name": "dot", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "gemv": {"name": "gemv", "brief": "Computes dense matrix times a dense vector product.", "desc": "Computes the multiplication of a scaled dense matrix times a dense vector, plus a scaled dense vector. Precisely, if ``trans`` is :msk:const:`transpose.no` then the update is\n\n.. math:: y := \\alpha A x + \\beta y,\n\nand if ``trans`` is :msk:const:`transpose.yes` then\n\n.. math:: y := \\alpha A^T x + \\beta y,\n\nwhere :math:`\\alpha,\\beta` are scalar values and :math:`A` is a matrix with :math:`m` rows and :math:`n` columns.\n\nNote that the result is stored overwriting :math:`y`. It must not overlap with the other input arrays.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "transa", "brief": "Indicates whether the matrix A must be transposed.", "desc": "Indicates whether the matrix :math:`A` must be transposed.", "mode": "i", "type": ["const-class", "mosek", "transpose"], "null?": false, "api?": true}, {"name": "m", "brief": "Specifies the number of rows of the matrix A.", "desc": "Specifies the number of rows of the matrix :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "n", "brief": "Specifies the number of columns of the matrix A.", "desc": "Specifies the number of columns of the matrix :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "alpha", "brief": "A scalar value multiplying the matrix A.", "desc": "A scalar value multiplying the matrix :math:`A`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "a", "brief": "A pointer to the array storing matrix A in a column-major format.", "desc": "A pointer to the array storing matrix :math:`A` in a column-major format.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg m) )", "ast": ["*", ["arg", "n"], ["arg", "m"]], "arg-refs": ["m", "n"]}]}, {"name": "x", "brief": "A pointer to the array storing the vector x.", "desc": "A pointer to the array storing the vector :math:`x`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(if (== (arg transa) (const transpose.no)) (arg n) (arg m) )", "ast": ["if", ["==", ["arg", "transa"], ["const", "transpose.no"]], ["arg", "n"], ["arg", "m"]], "arg-refs": ["transa", "m", "n"]}]}, {"name": "beta", "brief": "A scalar value multiplying the vector y.", "desc": "A scalar value multiplying the vector :math:`y`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "y", "brief": "A pointer to the array storing the vector y.", "desc": "A pointer to the array storing the vector :math:`y`.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(if (== (arg transa) (const transpose.no)) (arg m) (arg n) )", "ast": ["if", ["==", ["arg", "transa"], ["const", "transpose.no"]], ["arg", "m"], ["arg", "n"]], "arg-refs": ["transa", "n", "m"]}]}], "ais": "function", "api-caml-name": "gemv", "api-name": "gemv", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "gemm": {"name": "gemm", "brief": "Performs a dense matrix multiplication.", "desc": "Performs a matrix multiplication plus addition of dense matrices. Given\n:math:`A`, :math:`B` and :math:`C` of compatible dimensions, this function\ncomputes\n\n.. math:: C:= \\alpha op(A)op(B) + \\beta C\n\nwhere :math:`\\alpha,\\beta` are two scalar values. The function :math:`op(X)`\ndenotes :math:`X` if transX is :msk:const:`transpose.no`, or :math:`X^T` if set to :msk:const:`transpose.yes`. The matrix :math:`C` has :math:`m` rows and :math:`n` columns, and the other matrices must have compatible dimensions.\n\nThe result of this operation is stored in :math:`C`. It must not overlap with the other input arrays.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "transa", "brief": "Indicates whether the matrix A must be transposed.", "desc": "Indicates whether the matrix :math:`A` must be transposed.", "mode": "i", "type": ["const-class", "mosek", "transpose"], "null?": false, "api?": true}, {"name": "transb", "brief": "Indicates whether the matrix B must be transposed.", "desc": "Indicates whether the matrix :math:`B` must be transposed.", "mode": "i", "type": ["const-class", "mosek", "transpose"], "null?": false, "api?": true}, {"name": "m", "brief": "Indicates the number of rows of matrix C.", "desc": "Indicates the number of rows of matrix :math:`C`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "n", "brief": "Indicates the number of columns of matrix C.", "desc": "Indicates the number of columns of matrix :math:`C`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "k", "brief": "Specifies the common dimension along which op(A) and op(B) are multiplied.", "desc": "Specifies the common dimension along which :math:`op(A)` and :math:`op(B)` are multiplied. For example, if neither :math:`A` nor :math:`B` are transposed, then this is the number of columns in :math:`A` and also the number of rows in :math:`B`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "alpha", "brief": "A scalar value multiplying the result of the matrix multiplication.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "a", "brief": "The pointer to the array storing matrix A in a column-major format.", "desc": "The pointer to the array storing matrix :math:`A` in a column-major format.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg m) (arg k) )", "ast": ["*", ["arg", "m"], ["arg", "k"]], "arg-refs": ["k", "m"]}]}, {"name": "b", "brief": "The pointer to the array storing matrix B in a column-major format.", "desc": "The pointer to the array storing matrix :math:`B` in a column-major format.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg k) (arg n) )", "ast": ["*", ["arg", "k"], ["arg", "n"]], "arg-refs": ["k", "n"]}]}, {"name": "beta", "brief": "A scalar value that multiplies C.", "desc": "A scalar value that multiplies :math:`C`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "c", "brief": "The pointer to the array storing matrix C in a column-major format.", "desc": "The pointer to the array storing matrix :math:`C` in a column-major format.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg m) (arg n) )", "ast": ["*", ["arg", "m"], ["arg", "n"]], "arg-refs": ["n", "m"]}]}], "ais": "function", "api-caml-name": "gemm", "api-name": "gemm", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "syrk": {"name": "syrk", "brief": "Performs a rank-k update of a symmetric matrix.", "desc": "Performs a symmetric rank-:math:`k` update for a symmetric matrix.\n\nGiven a symmetric matrix :math:`C\\in \\real^{n\\times n}`, two scalars\n:math:`\\alpha,\\beta` and a matrix :math:`A` of rank :math:`k\\leq n`, it\ncomputes either\n\n.. math:: C := \\alpha A A^T + \\beta C,\n\nwhen ``trans`` is set to :msk:const:`transpose.no` and :math:`A\\in \\real^{n\\times k}`, or\n\n.. math:: C := \\alpha A^T A + \\beta C,\n\nwhen ``trans`` is set to :msk:const:`transpose.yes` and :math:`A\\in \\real^{k\\times n}`.\n\nOnly the part of :math:`C` indicated by ``uplo`` is used and only that part is updated with the result. It must not overlap with the other input arrays.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "uplo", "brief": "Indicates whether the upper or lower triangular part of C is used.", "desc": "Indicates whether the upper or lower triangular part of :math:`C` is used.", "mode": "i", "type": ["const-class", "mosek", "uplo"], "null?": false, "api?": true}, {"name": "trans", "brief": "Indicates whether the matrix A must be transposed.", "desc": "Indicates whether the matrix :math:`A` must be transposed.", "mode": "i", "type": ["const-class", "mosek", "transpose"], "null?": false, "api?": true}, {"name": "n", "brief": "Specifies the order of C.", "desc": "Specifies the order of :math:`C`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "k", "brief": "Indicates the number of rows or columns of A, and its rank.", "desc": "Indicates the number of rows or columns of :math:`A`, depending on whether or not it is transposed, and its rank.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "hints": ["index"]}, {"name": "alpha", "brief": "A scalar value multiplying the result of the matrix multiplication.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "a", "brief": "The pointer to the array storing matrix A in a column-major format.", "desc": "The pointer to the array storing matrix :math:`A` in a column-major format.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg k) )", "ast": ["*", ["arg", "n"], ["arg", "k"]], "arg-refs": ["k", "n"]}]}, {"name": "beta", "brief": "A scalar value that multiplies C.", "desc": "A scalar value that multiplies :math:`C`.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "c", "brief": "The pointer to the array storing matrix C in a column-major format.", "desc": "The pointer to the array storing matrix :math:`C` in a column-major format.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg n) )", "ast": ["*", ["arg", "n"], ["arg", "n"]], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "syrk", "api-name": "syrk", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "computesparsecholesky": {"caml-name": "compute-sparse-cholesky", "name": "computesparsecholesky", "brief": "Computes a Cholesky factorization of sparse matrix.", "desc": "The function computes a Cholesky factorization of a sparse positive semidefinite matrix. Sparsity is exploited\nduring the computations to reduce the amount of space and work required. Both the input and output matrices\nare represented using the sparse format.\n\nTo be precise, given a symmetric matrix :math:`A \\in \\real^{n\\times n}` the function computes a nonsingular lower triangular matrix :math:`L`, a diagonal matrix :math:`D` and a permutation matrix :math:`P` such that\n\n.. math::  LL^T - D = P A P^T.\n\nIf ``ordermethod`` is zero then reordering heuristics are not employed and :math:`P` is the identity.\n\nIf a pivot during the computation of the Cholesky factorization is less than\n\n.. math::        -\\rho\\cdot\\max((PAP^T)_{jj},1.0)\n\nthen the matrix is declared negative semidefinite. On the hand if a pivot is smaller than\n\n.. math::        \\rho\\cdot\\max((PAP^T)_{jj},1.0),\n\nthen :math:`D_{jj}` is increased from zero to\n\n.. math::        \\rho\\cdot\\max((PAP^T)_{jj},1.0).\n\nTherefore, if :math:`A` is sufficiently positive definite then :math:`D` will be the zero matrix.\nHere :math:`\\rho` is set equal to value of ``tolsingular``.\n\n.. msk_only:: c\n\n   The function allocates memory for the output arrays. It must be freed by the user with :msk:func:`env.freeenv`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "numthreads", "brief": "The number threads that can be used to do the computation. 0 means the code makes the choice.", "desc": "The number threads that can be used to do the computation. 0 means the code makes the choice. NOTE: API change in version 10: in versions up to 9 the argument in this position indicated whether to use multithreading or not.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "ordermethod", "brief": "If nonzero, then a sparsity preserving ordering will be employed.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "tolsingular", "brief": "A positive parameter controlling when a pivot is declared zero.", "mode": "i", "type": ["defined", "mosek", "realt"], "null?": false, "api?": true}, {"name": "n", "brief": "Specifies the order of A.", "desc": "Specifies the order of :math:`A`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["anzc", "aptrc"]}]}, {"name": "anzc", "brief": "anzc[j] is the number of nonzeros in the jth column of A.", "desc": "``anzc[j]`` is the number of nonzeros in the :math:`j`-th column of :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true}, {"name": "aptrc", "brief": "aptrc[j] is a pointer to the first element in column j.", "desc": "``aptrc[j]`` is a pointer to the first element in column :math:`j` of :math:`A`.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "asubc", "brief": "Row indexes for each column stored in increasing order.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"]}, {"name": "avalc", "brief": "The value corresponding to row indexed stored in asubc.", "desc": "The value corresponding to row indexed stored in ``asubc``.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true}, {"name": "perm", "brief": "Permutation array used to specify the permutation matrix P computed by the function.", "desc": "Permutation array used to specify the permutation matrix :math:`P` computed by the function.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "int32t"]]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTH", "arg-refs": ["n"]}]}, {"name": "diag", "brief": "The diagonal elements of matrix D.", "desc": "The diagonal elements of matrix :math:`D`.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "realt"]]], "null?": false, "api?": false, "compute": [{"type": "LENGTH", "arg-refs": ["n"]}]}, {"name": "lnzc", "brief": "lnzc[j] is the number of non zero elements in column j.", "desc": "``lnzc[j]`` is the number of non zero elements in column :math:`j` of :math:`L`.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "int32t"]]], "null?": false, "api?": false, "compute": [{"type": "LENGTH", "arg-refs": ["n"]}]}, {"name": "lptrc", "brief": "lptrc[j] is a pointer to the first row index and value in column j.", "desc": "``lptrc[j]`` is a pointer to the first row index and value in column :math:`j` of :math:`L`.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "int64t"]]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTH", "arg-refs": ["n"]}]}, {"name": "lensubnval", "brief": "Number of elements in lsubc and lvalc.", "desc": "Number of elements in ``lsubc`` and ``lvalc``.", "mode": "o", "type": ["ref", ["defined", "mosek", "int64t"]], "null?": false, "api?": true}, {"name": "lsubc", "brief": "Row indexes for each column stored in increasing order.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "int32t"]]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "LENGTH", "arg-refs": ["lensubnval"]}]}, {"name": "lvalc", "brief": "The values corresponding to row indexed stored in lsubc.", "desc": "The values corresponding to row indexed stored in ``lsubc``.", "mode": "o", "type": ["ref", ["ptr", ["defined", "mosek", "realt"]]], "null?": false, "api?": true, "compute": [{"type": "LENGTH", "arg-refs": ["lensubnval"]}]}], "ais": "function", "api-caml-name": "compute-sparse-cholesky", "api-name": "computesparsecholesky", "targets": ["c", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "env", "sparsetriangularsolvedense"]}], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "sparsetriangularsolvedense": {"old-name": "sparsetriangularsolvedense", "caml-name": "sparse-triangular-solve-dense", "name": "sparsetriangularsolvedense", "brief": "Solves a sparse triangular system of linear equations.", "desc": "The function solves a triangular system of the form\n\n.. math:: L x = b\n\nor\n\n.. math:: L^T x = b\n\nwhere :math:`L` is a sparse lower triangular nonsingular matrix. This implies in particular that diagonals in :math:`L` are nonzero.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "transposed", "brief": "Controls whether the solve is with L or the transposed L.", "desc": "Controls whether to use with :math:`L` or :math:`L^T`.", "mode": "i", "type": ["const-class", "mosek", "transpose"], "null?": false, "api?": true}, {"name": "n", "brief": "Specifies the dimension of L.", "desc": "Dimension of :math:`L`.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["lptrc", "b", "lnzc"]}]}, {"name": "lnzc", "brief": "lnzc[j] is the number of nonzeros in column j.", "desc": "``lnzc[j]`` is the number of nonzeros in column ``j``.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": false, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}, {"name": "lptrc", "brief": "lptrc[j] is a pointer to the first row index and value in column j.", "desc": "``lptrc[j]`` is a pointer to the first row index and value in column ``j``.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int64t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}, {"name": "lensubnval", "brief": "Number of elements in lsubc and lvalc.", "desc": "Number of elements in ``lsubc`` and ``lvalc``.", "mode": "i", "type": ["defined", "mosek", "int64t"], "null?": false, "api?": true, "compute": [{"type": "LENGTHOF", "arg-refs": ["lvalc", "lsubc"]}]}, {"name": "lsubc", "brief": "Row indexes for each column stored sequentially.", "desc": "Row indexes for each column stored sequentially. Must be stored in increasing order for each column.", "mode": "i", "type": ["ptr", ["defined", "mosek", "int32t"]], "null?": false, "api?": true, "hints": ["index"], "compute": [{"type": "MINLENGTH", "code": "(arg lensubnval)", "ast": ["arg", "lensubnval"], "arg-refs": ["lensubnval"]}]}, {"name": "lvalc", "brief": "The value corresponding to row indexed stored lsubc.", "desc": "The value corresponding to the row index stored in ``lsubc``.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg lensubnval)", "ast": ["arg", "lensubnval"], "arg-refs": ["lensubnval"]}]}, {"name": "b", "brief": "The right-hand side of linear equation system to be solved as a dense vector.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": false, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "sparse-triangular-solve-dense", "api-name": "sparsetriangularsolvedense", "targets": ["c", "dotnet", "java", "julia", "no-overload", "python", "rust"], "references": [{"type": "function", "item": ["mosek", "env", "computesparsecholesky"]}], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "potrf": {"name": "potrf", "brief": "Computes a Cholesky factorization of a dense matrix.", "desc": "Computes a Cholesky factorization of a real symmetric positive definite dense matrix.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "uplo", "brief": "Indicates whether the upper or lower triangular part of the matrix is stored.", "mode": "i", "type": ["const-class", "mosek", "uplo"], "null?": false, "api?": true}, {"name": "n", "brief": "Dimension of the symmetric matrix.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "a", "brief": "A symmetric matrix stored in column-major order.", "desc": "A symmetric matrix stored in column-major order. Only the lower or the upper triangular part is used, accordingly with the ``uplo`` parameter. It will contain the result on exit.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg n) )", "ast": ["*", ["arg", "n"], ["arg", "n"]], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "potrf", "api-name": "potrf", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "syeig": {"name": "syeig", "brief": "Computes all eigenvalues of a symmetric dense matrix.", "desc": "Computes all eigenvalues of a real symmetric matrix :math:`A`. Given a matrix :math:`A\\in\\real^{n\\times n}` it returns a vector :math:`w\\in\\real^n` containing the eigenvalues of :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "uplo", "brief": "Indicates whether the upper or lower triangular part is used.", "mode": "i", "type": ["const-class", "mosek", "uplo"], "null?": false, "api?": true}, {"name": "n", "brief": "Dimension of the symmetric input matrix.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "a", "brief": "Input matrix A.", "desc": "A symmetric matrix :math:`A` stored in column-major order. Only the part indicated by ``uplo`` is used.", "mode": "i", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg n) )", "ast": ["*", ["arg", "n"], ["arg", "n"]], "arg-refs": ["n"]}]}, {"name": "w", "brief": "Array of length at least n containing the eigenvalues of A.", "desc": "Array of length at least ``n`` containing the eigenvalues of :math:`A`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "syeig", "api-name": "syeig", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "syevd": {"name": "syevd", "brief": "Computes all the eigenvalues and eigenvectors of a symmetric dense matrix, and thus its eigenvalue decomposition.", "desc": "Computes all the eigenvalues and eigenvectors a real symmetric matrix.\nGiven the input matrix :math:`A\\in \\real^{n\\times n}`, this function returns a\nvector :math:`w\\in \\real^n` containing the eigenvalues of :math:`A` and it also computes the eigenvectors\nof :math:`A`. Therefore, this function computes the eigenvalue decomposition of :math:`A` as\n\n.. math:: A= U V U^T,\n\nwhere :math:`V=\\diag(w)` and :math:`U` contains the eigenvectors of :math:`A`.\n\nNote that the matrix :math:`U` overwrites the input data :math:`A`.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [{"name": "env", "mode": "i", "type": ["defined", "mosek", "env_t"], "null?": false, "api?": true, "classarg": true}, {"name": "uplo", "brief": "Indicates whether the upper or lower triangular part is used.", "mode": "i", "type": ["const-class", "mosek", "uplo"], "null?": false, "api?": true}, {"name": "n", "brief": "Dimension of the symmetric input matrix.", "mode": "i", "type": ["defined", "mosek", "int32t"], "null?": false, "api?": true}, {"name": "a", "brief": "Input matrix A.", "desc": "A symmetric matrix :math:`A` stored in column-major order. Only the part indicated by ``uplo`` is used. On exit it will be overwritten by the matrix :math:`U`.", "mode": "io", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(* (arg n) (arg n) )", "ast": ["*", ["arg", "n"], ["arg", "n"]], "arg-refs": ["n"]}]}, {"name": "w", "brief": "Array of length at least n containing the eigenvalues of A.", "desc": "Array of length at least ``n`` containing the eigenvalues of :math:`A`.", "mode": "o", "type": ["ptr", ["defined", "mosek", "realt"]], "null?": false, "api?": true, "compute": [{"type": "MINLENGTH", "code": "(arg n)", "ast": ["arg", "n"], "arg-refs": ["n"]}]}], "ais": "function", "api-caml-name": "syevd", "api-name": "syevd", "targets": ["c", "cmdln", "dotnet", "go", "java", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["linear-algebra"], "locked": true, "breakable": false, "log": false, "const": "const"}, "licensecleanup": {"caml-name": "license-cleanup", "name": "licensecleanup", "brief": "Stops all threads and delete all handles used by the license system.", "desc": "Stops all threads and deletes all handles used by the license system. If this\nfunction is called, it must be called as the last |mosek| API call. No other\n|mosek| API calls are valid after this.", "status": "obscure", "returns": {"type": ["const-class", "mosek", "rescode"], "name": "ret"}, "args": [], "ais": "function", "api-caml-name": "license-cleanup", "api-name": "licensecleanup", "targets": ["c", "cmdln", "dotnet", "go", "java", "julia", "no-overload", "python", "rpc", "rust"], "references": [], "member-of": ["license"], "locked": false, "breakable": false, "log": false, "const": "mut"}}}}, "constclasses": {"language": {"name": "language", "brief": "Language selection constants", "is-enumerable": true, "prefix": "LANG_", "value-type": "int", "values-asgn": "sequential", "api-class": "internal", "members": [{"caml-name": "ENG", "name": "eng", "brief": "English language selection", "value": "0"}, {"caml-name": "DAN", "name": "dan", "brief": "Danish language selection", "value": "1"}]}, "basindtype": {"name": "basindtype", "brief": "Basis identification", "is-enumerable": false, "prefix": "BI_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NEVER", "name": "never", "brief": "Never do basis identification.", "value": "0"}, {"caml-name": "ALWAYS", "name": "always", "brief": "Basis identification is always performed even if the interior-point optimizer terminates abnormally.", "value": "1"}, {"caml-name": "NO_ERROR", "name": "no_error", "brief": "Basis identification is performed if the interior-point optimizer terminates without an error.", "value": "2"}, {"caml-name": "IF_FEASIBLE", "name": "if_feasible", "brief": "Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.", "value": "3"}, {"caml-name": "RESERVERED", "name": "reservered", "brief": "Not currently in use.", "value": "4"}]}, "boundkey": {"name": "boundkey", "brief": "Bound keys", "is-enumerable": true, "prefix": "BK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The constraint or variable has a finite lower bound and an infinite upper bound.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The constraint or variable has an infinite lower bound and an finite upper bound.", "value": "1"}, {"caml-name": "FX", "name": "fx", "brief": "The constraint or variable is fixed.", "value": "2"}, {"caml-name": "FR", "name": "fr", "brief": "The constraint or variable is free.", "value": "3"}, {"caml-name": "RA", "name": "ra", "brief": "The constraint or variable is ranged.", "value": "4"}]}, "mark": {"name": "mark", "brief": "Mark", "is-enumerable": true, "prefix": "MARK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The lower bound is selected for sensitivity analysis.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The upper bound is selected for sensitivity analysis.", "value": "1"}]}, "simdegen": {"name": "simdegen", "brief": "Degeneracy strategies", "is-enumerable": true, "prefix": "SIM_DEGEN_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The simplex optimizer should use no degeneration strategy.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer chooses the degeneration strategy.", "value": "1"}, {"caml-name": "AGGRESSIVE", "name": "aggressive", "brief": "The simplex optimizer should use an aggressive degeneration strategy.", "value": "2"}, {"caml-name": "MODERATE", "name": "moderate", "brief": "The simplex optimizer should use a moderate degeneration strategy.", "value": "3"}, {"caml-name": "MINIMUM", "name": "minimum", "brief": "The simplex optimizer should use a minimum degeneration strategy.", "value": "4"}]}, "transpose": {"name": "transpose", "brief": "Transposed matrix.", "is-enumerable": true, "prefix": "TRANSPOSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NO", "name": "no", "brief": "No transpose is applied.", "value": "0"}, {"caml-name": "YES", "name": "yes", "brief": "A transpose is applied.", "value": "1"}]}, "uplo": {"name": "uplo", "brief": "Triangular part of a symmetric matrix.", "is-enumerable": true, "prefix": "UPLO_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "Lower part.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "Upper part.", "value": "1"}]}, "simreform": {"name": "simreform", "brief": "Problem reformulation.", "is-enumerable": true, "prefix": "SIM_REFORMULATION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Allow the simplex optimizer to reformulate the problem.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Disallow the simplex optimizer to reformulate the problem.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer can choose freely.", "value": "2"}, {"caml-name": "AGGRESSIVE", "name": "aggressive", "brief": "The simplex optimizer should use an aggressive reformulation strategy.", "value": "3"}]}, "simdupvec": {"name": "simdupvec", "brief": "Exploit duplicate columns.", "is-enumerable": true, "prefix": "SIM_EXPLOIT_DUPVEC_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Allow the simplex optimizer to exploit duplicated columns.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Disallow the simplex optimizer to exploit duplicated columns.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer can choose freely.", "value": "2"}]}, "simhotstart": {"name": "simhotstart", "brief": "Hot-start type employed by the simplex optimizer", "is-enumerable": true, "prefix": "SIM_HOTSTART_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The simplex optimizer performs a coldstart.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimize chooses the hot-start type.", "value": "1"}, {"caml-name": "STATUS_KEYS", "name": "status_keys", "brief": "Only the status keys of the constraints and variables are used to choose the type of hot-start.", "value": "2"}]}, "intpnthotstart": {"name": "intpnthotstart", "brief": "Hot-start type employed by the interior-point optimizers.", "is-enumerable": true, "prefix": "INTPNT_HOTSTART_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The interior-point optimizer performs a coldstart.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The interior-point optimizer exploits the primal solution only.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The interior-point optimizer exploits the dual solution only.", "value": "2"}, {"caml-name": "PRIMAL_DUAL", "name": "primal_dual", "brief": "The interior-point optimizer exploits both the primal and dual solution.", "value": "3"}]}, "purify": {"name": "purify", "brief": "Solution purification employed optimizer.", "is-enumerable": true, "prefix": "PURIFY_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The optimizer performs no solution purification.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The optimizer purifies the primal solution.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The optimizer purifies the dual solution.", "value": "2"}, {"caml-name": "PRIMAL_DUAL", "name": "primal_dual", "brief": "The optimizer purifies both the primal and dual solution.", "value": "3"}, {"caml-name": "AUTO", "name": "auto", "brief": "TBD", "value": "4"}]}, "callbackcode": {"name": "callbackcode", "brief": "Progress callback codes", "is-enumerable": true, "prefix": "CALLBACK_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "BEGIN_ROOT_CUTGEN", "name": "begin_root_cutgen", "brief": "The callback function is called when root cut generation is started.", "value": "21"}, {"caml-name": "IM_ROOT_CUTGEN", "name": "im_root_cutgen", "brief": "The callback is called from within root cut generation at an intermediate stage.", "value": "75"}, {"caml-name": "END_ROOT_CUTGEN", "name": "end_root_cutgen", "brief": "The callback function is called when root cut generation is terminated.", "value": "50"}, {"caml-name": "BEGIN_SOLVE_ROOT_RELAX", "name": "begin_solve_root_relax", "brief": "The callback function is called when solution of root relaxation is started.", "value": "24"}, {"caml-name": "END_SOLVE_ROOT_RELAX", "name": "end_solve_root_relax", "brief": "The callback function is called when solution of root relaxation is terminated.", "value": "53"}, {"caml-name": "BEGIN_OPTIMIZER", "name": "begin_optimizer", "brief": "The callback function is called when the optimizer is started.", "value": "11"}, {"caml-name": "END_OPTIMIZER", "name": "end_optimizer", "brief": "The callback function is called when the optimizer is terminated.", "value": "40"}, {"caml-name": "BEGIN_PRESOLVE", "name": "begin_presolve", "brief": "The callback function is called when the presolve is started.", "value": "12"}, {"caml-name": "UPDATE_PRESOLVE", "name": "update_presolve", "brief": "The callback function is called from within the presolve procedure.", "value": "88"}, {"caml-name": "IM_PRESOLVE", "name": "im_presolve", "brief": "The callback function is called from within the presolve procedure at an intermediate stage.", "value": "69"}, {"caml-name": "END_PRESOLVE", "name": "end_presolve", "brief": "The callback function is called when the presolve is completed.", "value": "41"}, {"caml-name": "BEGIN_INTPNT", "name": "begin_intpnt", "brief": "The callback function is called when the interior-point optimizer is started.", "value": "8"}, {"caml-name": "INTPNT", "name": "intpnt", "brief": "The callback function is called from within the interior-point optimizer after the information database has been updated.", "value": "78"}, {"caml-name": "IM_INTPNT", "name": "im_intpnt", "brief": "The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated.", "value": "61"}, {"caml-name": "END_INTPNT", "name": "end_intpnt", "brief": "The callback function is called when the interior-point optimizer is terminated.", "value": "37"}, {"caml-name": "BEGIN_CONIC", "name": "begin_conic", "brief": "The callback function is called when the conic optimizer is started.", "value": "1"}, {"caml-name": "CONIC", "name": "conic", "brief": "The callback function is called from within the conic optimizer after the information database has been updated.", "value": "27"}, {"caml-name": "IM_CONIC", "name": "im_conic", "brief": "The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated.", "value": "57"}, {"caml-name": "END_CONIC", "name": "end_conic", "brief": "The callback function is called when the conic optimizer is terminated.", "value": "30"}, {"caml-name": "PRIMAL_SIMPLEX", "name": "primal_simplex", "brief": "The callback function is called from within the primal simplex optimizer.", "value": "80"}, {"caml-name": "DUAL_SIMPLEX", "name": "dual_simplex", "brief": "The callback function is called from within the dual simplex optimizer.", "value": "28"}, {"caml-name": "BEGIN_BI", "name": "begin_bi", "brief": "The basis identification procedure has been started.", "value": "0"}, {"caml-name": "IM_BI", "name": "im_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point.", "value": "56"}, {"caml-name": "END_BI", "name": "end_bi", "brief": "The callback function is called when the basis identification procedure is terminated.", "value": "29"}, {"caml-name": "BEGIN_PRIMAL_BI", "name": "begin_primal_bi", "brief": "The callback function is called from within the basis identification procedure when the primal phase is started.", "value": "13"}, {"caml-name": "IM_PRIMAL_BI", "name": "im_primal_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.", "value": "70"}, {"caml-name": "UPDATE_PRIMAL_BI", "name": "update_primal_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.", "value": "89"}, {"caml-name": "END_PRIMAL_BI", "name": "end_primal_bi", "brief": "The callback function is called from within the basis identification procedure when the primal phase is terminated.", "value": "42"}, {"caml-name": "BEGIN_DUAL_BI", "name": "begin_dual_bi", "brief": "The callback function is called from within the basis identification procedure when the dual phase is started.", "value": "2"}, {"caml-name": "IM_DUAL_BI", "name": "im_dual_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.", "value": "58"}, {"caml-name": "UPDATE_DUAL_BI", "name": "update_dual_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.", "value": "85"}, {"caml-name": "END_DUAL_BI", "name": "end_dual_bi", "brief": "The callback function is called from within the basis identification procedure when the dual phase is terminated.", "value": "31"}, {"caml-name": "BEGIN_SIMPLEX_BI", "name": "begin_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the simplex clean-up phase is started.", "value": "23"}, {"caml-name": "IM_SIMPLEX_BI", "name": "im_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase.", "desc": "The callback function is called\nfrom within the basis identification procedure\nat an intermediate point in the simplex clean-up phase.\nThe frequency of the callbacks is controlled by the\n:msk:iparam:`log_sim_freq` parameter.", "value": "77"}, {"caml-name": "BEGIN_PRIMAL_SIMPLEX_BI", "name": "begin_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started.", "value": "18"}, {"caml-name": "UPDATE_PRIMAL_SIMPLEX_BI", "name": "update_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase.", "desc": "The callback function is called\nfrom within the basis identification procedure\nat an intermediate point in the primal simplex clean-up phase.\nThe frequency of the callbacks is controlled by the\n:msk:iparam:`log_sim_freq` parameter.", "value": "91"}, {"caml-name": "END_PRIMAL_SIMPLEX_BI", "name": "end_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated.", "value": "47"}, {"caml-name": "BEGIN_DUAL_SIMPLEX_BI", "name": "begin_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started.", "value": "6"}, {"caml-name": "UPDATE_DUAL_SIMPLEX_BI", "name": "update_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.", "desc": "The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.\nThe frequency of the callbacks is controlled by the :msk:iparam:`log_sim_freq` parameter.", "value": "87"}, {"caml-name": "END_DUAL_SIMPLEX_BI", "name": "end_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated.", "value": "35"}, {"caml-name": "END_SIMPLEX_BI", "name": "end_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated.", "value": "52"}, {"caml-name": "BEGIN_MIO", "name": "begin_mio", "brief": "The callback function is called when the mixed-integer optimizer is started.", "value": "10"}, {"caml-name": "IM_MIO", "name": "im_mio", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer.", "value": "64"}, {"caml-name": "NEW_INT_MIO", "name": "new_int_mio", "brief": "The callback function is called after a new integer solution has been located by the mixed-integer optimizer.", "value": "79"}, {"caml-name": "END_MIO", "name": "end_mio", "brief": "The callback function is called when the mixed-integer optimizer is terminated.", "value": "39"}, {"caml-name": "RESTART_MIO", "name": "restart_mio", "brief": "The callback function is called when the mixed-integer optimizer is restarted.", "value": "83"}, {"caml-name": "BEGIN_SIMPLEX", "name": "begin_simplex", "brief": "The callback function is called when the simplex optimizer is started.", "value": "22"}, {"caml-name": "IM_SIMPLEX", "name": "im_simplex", "brief": "The callback function is called from within the simplex optimizer at an intermediate point.", "value": "76"}, {"caml-name": "UPDATE_SIMPLEX", "name": "update_simplex", "brief": "The callback function is called from simplex optimizer.", "value": "92"}, {"caml-name": "BEGIN_DUAL_SIMPLEX", "name": "begin_dual_simplex", "brief": "The callback function is called when the dual simplex optimizer started.", "value": "5"}, {"caml-name": "IM_DUAL_SIMPLEX", "name": "im_dual_simplex", "brief": "The callback function is called at an intermediate point in the dual simplex optimizer.", "value": "60"}, {"caml-name": "UPDATE_DUAL_SIMPLEX", "name": "update_dual_simplex", "brief": "The callback function is called in the dual simplex optimizer.", "value": "86"}, {"caml-name": "END_DUAL_SIMPLEX", "name": "end_dual_simplex", "brief": "The callback function is called when the dual simplex optimizer is terminated.", "value": "34"}, {"caml-name": "BEGIN_PRIMAL_SIMPLEX", "name": "begin_primal_simplex", "brief": "The callback function is called when the primal simplex optimizer is started.", "value": "17"}, {"caml-name": "IM_PRIMAL_SIMPLEX", "name": "im_primal_simplex", "brief": "The callback function is called at an intermediate point in the primal simplex optimizer.", "value": "72"}, {"caml-name": "UPDATE_PRIMAL_SIMPLEX", "name": "update_primal_simplex", "brief": "The callback function is called  in the primal simplex optimizer.", "value": "90"}, {"caml-name": "END_PRIMAL_SIMPLEX", "name": "end_primal_simplex", "brief": "The callback function is called when the primal simplex optimizer is terminated.", "value": "46"}, {"caml-name": "END_SIMPLEX", "name": "end_simplex", "brief": "The callback function is called when the simplex optimizer is terminated.", "value": "51"}, {"caml-name": "BEGIN_INFEAS_ANA", "name": "begin_infeas_ana", "brief": "The callback function is called when the infeasibility analyzer is started.", "value": "7"}, {"caml-name": "END_INFEAS_ANA", "name": "end_infeas_ana", "brief": "The callback function is called when the infeasibility analyzer is terminated.", "value": "36"}, {"caml-name": "IM_PRIMAL_SENSIVITY", "name": "im_primal_sensivity", "brief": "The callback function is called at an intermediate stage of the primal sensitivity analysis.", "value": "71"}, {"caml-name": "IM_DUAL_SENSIVITY", "name": "im_dual_sensivity", "brief": "The callback function is called at an intermediate stage of the dual sensitivity analysis.", "value": "59"}, {"caml-name": "IM_MIO_INTPNT", "name": "im_mio_intpnt", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer.", "value": "66"}, {"caml-name": "IM_MIO_PRIMAL_SIMPLEX", "name": "im_mio_primal_simplex", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer.", "value": "67"}, {"caml-name": "IM_MIO_DUAL_SIMPLEX", "name": "im_mio_dual_simplex", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer.", "value": "65"}, {"caml-name": "BEGIN_PRIMAL_SETUP_BI", "name": "begin_primal_setup_bi", "brief": "The callback function is called when the primal BI setup is started.", "value": "16"}, {"caml-name": "END_PRIMAL_SETUP_BI", "name": "end_primal_setup_bi", "brief": "The callback function is called when the primal BI setup is terminated.", "value": "45"}, {"caml-name": "BEGIN_DUAL_SETUP_BI", "name": "begin_dual_setup_bi", "brief": "The callback function is called when the dual BI phase is started.", "value": "4"}, {"caml-name": "END_DUAL_SETUP_BI", "name": "end_dual_setup_bi", "brief": "The callback function is called when the dual BI phase is terminated.", "value": "33"}, {"caml-name": "BEGIN_PRIMAL_SENSITIVITY", "name": "begin_primal_sensitivity", "brief": "Primal sensitivity analysis is started.", "value": "15"}, {"caml-name": "END_PRIMAL_SENSITIVITY", "name": "end_primal_sensitivity", "brief": "Primal sensitivity analysis is terminated.", "value": "44"}, {"caml-name": "BEGIN_DUAL_SENSITIVITY", "name": "begin_dual_sensitivity", "brief": "Dual sensitivity analysis is started.", "value": "3"}, {"caml-name": "END_DUAL_SENSITIVITY", "name": "end_dual_sensitivity", "brief": "Dual sensitivity analysis is terminated.", "value": "32"}, {"caml-name": "BEGIN_LICENSE_WAIT", "name": "begin_license_wait", "brief": "Begin waiting for license.", "value": "9"}, {"caml-name": "END_LICENSE_WAIT", "name": "end_license_wait", "brief": "End waiting for license.", "value": "38"}, {"caml-name": "IM_LICENSE_WAIT", "name": "im_license_wait", "brief": "MOSEK is waiting for a license.", "desc": "|mosek| is waiting for a license.", "value": "62"}, {"caml-name": "BEGIN_QCQO_REFORMULATE", "name": "begin_qcqo_reformulate", "brief": "Begin QCQO reformulation.", "value": "19"}, {"caml-name": "END_QCQO_REFORMULATE", "name": "end_qcqo_reformulate", "brief": "End QCQO reformulation.", "value": "48"}, {"caml-name": "IM_QO_REFORMULATE", "name": "im_qo_reformulate", "brief": "The callback function is called at an intermediate stage of the conic quadratic reformulation.", "value": "73"}, {"caml-name": "BEGIN_TO_CONIC", "name": "begin_to_conic", "brief": "Begin conic reformulation.", "value": "25"}, {"caml-name": "END_TO_CONIC", "name": "end_to_conic", "brief": "End conic reformulation.", "value": "54"}, {"caml-name": "BEGIN_PRIMAL_REPAIR", "name": "begin_primal_repair", "brief": "Begin primal feasibility repair.", "value": "14"}, {"caml-name": "END_PRIMAL_REPAIR", "name": "end_primal_repair", "brief": "End primal feasibility repair.", "value": "43"}, {"caml-name": "BEGIN_READ", "name": "begin_read", "brief": "MOSEK has started reading a problem file.", "desc": "|mosek| has started reading a problem file.", "value": "20"}, {"caml-name": "IM_READ", "name": "im_read", "brief": "Intermediate stage in reading.", "value": "74"}, {"caml-name": "END_READ", "name": "end_read", "brief": "MOSEK has finished reading a problem file.", "desc": "|mosek| has finished reading a problem file.", "value": "49"}, {"caml-name": "BEGIN_WRITE", "name": "begin_write", "brief": "MOSEK has started writing a problem file.", "desc": "|mosek| has started writing a problem file.", "value": "26"}, {"caml-name": "END_WRITE", "name": "end_write", "brief": "MOSEK has finished writing a problem file.", "desc": "|mosek| has finished writing a problem file.", "value": "55"}, {"caml-name": "READ_OPF_SECTION", "name": "read_opf_section", "brief": "A chunk of Q non-zeros has been read from a problem file.", "desc": "A chunk of :math:`Q` non-zeros has been read from a problem file.", "value": "82"}, {"caml-name": "IM_LU", "name": "im_lu", "brief": "The callback function is called from within the LU factorization procedure at an intermediate point.", "value": "63"}, {"caml-name": "IM_ORDER", "name": "im_order", "brief": "The callback function is called from within the matrix ordering procedure at an intermediate point.", "value": "68"}, {"caml-name": "READ_OPF", "name": "read_opf", "brief": "The callback function is called from the OPF reader.", "value": "81"}, {"caml-name": "WRITE_OPF", "name": "write_opf", "brief": "The callback function is called from the OPF writer.", "value": "93"}, {"caml-name": "SOLVING_REMOTE", "name": "solving_remote", "brief": "The callback function is called while the task is being solved on a remote server.", "value": "84"}]}, "compresstype": {"name": "compresstype", "brief": "Compression types", "is-enumerable": true, "prefix": "COMPRESS_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No compression is used.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The type of compression used is chosen automatically.", "value": "1"}, {"caml-name": "GZIP", "name": "gzip", "brief": "The type of compression used is gzip compatible.", "value": "2"}, {"caml-name": "ZSTD", "name": "zstd", "brief": "The type of compression used is zstd compatible.", "value": "3"}]}, "conetype": {"name": "conetype", "brief": "Cone types", "is-enumerable": true, "prefix": "CT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "QUAD", "name": "quad", "brief": "The cone is a quadratic cone.", "value": "0"}, {"caml-name": "RQUAD", "name": "rquad", "brief": "The cone is a rotated quadratic cone.", "value": "1"}, {"caml-name": "PEXP", "name": "pexp", "brief": "A primal exponential cone.", "value": "2"}, {"caml-name": "DEXP", "name": "dexp", "brief": "A dual exponential cone.", "value": "3"}, {"caml-name": "PPOW", "name": "ppow", "brief": "A primal power cone.", "value": "4"}, {"caml-name": "DPOW", "name": "dpow", "brief": "A dual power cone.", "value": "5"}, {"caml-name": "ZERO", "name": "zero", "brief": "The zero cone.", "value": "6"}]}, "domaintype": {"name": "domaintype", "brief": "Cone types", "is-enumerable": true, "prefix": "DOMAIN_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "R", "name": "r", "brief": "R.", "value": "0"}, {"caml-name": "RZERO", "name": "rzero", "brief": "The zero vector.", "value": "1"}, {"caml-name": "RPLUS", "name": "rplus", "brief": "The positive orthant.", "value": "2"}, {"caml-name": "RMINUS", "name": "rminus", "brief": "The negative orthant.", "value": "3"}, {"caml-name": "QUADRATIC_CONE", "name": "quadratic_cone", "brief": "The quadratic cone.", "value": "4"}, {"caml-name": "RQUADRATIC_CONE", "name": "rquadratic_cone", "brief": "The rotated quadratic cone.", "value": "5"}, {"caml-name": "PRIMAL_EXP_CONE", "name": "primal_exp_cone", "brief": "The primal exponential cone.", "value": "6"}, {"caml-name": "DUAL_EXP_CONE", "name": "dual_exp_cone", "brief": "The dual exponential cone.", "value": "7"}, {"caml-name": "PRIMAL_POWER_CONE", "name": "primal_power_cone", "brief": "The primal power cone.", "value": "8"}, {"caml-name": "DUAL_POWER_CONE", "name": "dual_power_cone", "brief": "The dual power cone.", "value": "9"}, {"caml-name": "PRIMAL_GEO_MEAN_CONE", "name": "primal_geo_mean_cone", "brief": "The primal geometric mean cone.", "value": "10"}, {"caml-name": "DUAL_GEO_MEAN_CONE", "name": "dual_geo_mean_cone", "brief": "The dual geometric mean cone.", "value": "11"}, {"caml-name": "SVEC_PSD_CONE", "name": "svec_psd_cone", "brief": "The vectorized positive semidefinite cone.", "value": "12"}]}, "nametype": {"name": "nametype", "brief": "Name types", "is-enumerable": true, "prefix": "NAME_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "GEN", "name": "gen", "brief": "General names. However, no duplicate and blank names are allowed.", "value": "0"}, {"caml-name": "MPS", "name": "mps", "brief": "MPS type names.", "value": "1"}, {"caml-name": "LP", "name": "lp", "brief": "LP type names.", "value": "2"}]}, "symmattype": {"name": "symmattype", "brief": "Cone types", "is-enumerable": true, "prefix": "SYMMAT_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "SPARSE", "name": "sparse", "brief": "Sparse symmetric matrix.", "value": "0"}]}, "dataformat": {"name": "dataformat", "brief": "Data format types", "is-enumerable": true, "prefix": "DATA_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "EXTENSION", "name": "extension", "brief": "The file extension is used to determine the data file format.", "value": "0"}, {"caml-name": "MPS", "name": "mps", "brief": "The data file is MPS formatted.", "value": "1"}, {"caml-name": "LP", "name": "lp", "brief": "The data file is LP formatted.", "value": "2"}, {"caml-name": "OP", "name": "op", "brief": "The data file is an optimization problem formatted file.", "value": "3"}, {"caml-name": "FREE_MPS", "name": "free_mps", "brief": "The data a free MPS formatted file.", "value": "4"}, {"caml-name": "TASK", "name": "task", "brief": "Generic task dump file.", "value": "5"}, {"caml-name": "PTF", "name": "ptf", "brief": "(P)retty (T)ext (F)format.", "value": "6"}, {"caml-name": "CB", "name": "cb", "brief": "Conic benchmark format,", "value": "7"}, {"caml-name": "JSON_TASK", "name": "json_task", "brief": "JSON based task format.", "value": "8"}]}, "solformat": {"name": "solformat", "brief": "Data format types", "is-enumerable": true, "prefix": "SOL_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "EXTENSION", "name": "extension", "brief": "The file extension is used to determine the data file format.", "value": "0"}, {"caml-name": "B", "name": "b", "brief": "Simple binary format", "value": "1"}, {"caml-name": "TASK", "name": "task", "brief": "Tar based format.", "value": "2"}, {"caml-name": "JSON_TASK", "name": "json_task", "brief": "JSON based format.", "value": "3"}]}, "dinfitem": {"name": "dinfitem", "brief": "Double information items", "is-enumerable": true, "prefix": "DINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY", "name": "ana_pro_scalarized_constraint_matrix_density", "brief": "Density percentage of the scalarized constraint matrix.", "value": "0"}, {"caml-name": "BI_TIME", "name": "bi_time", "brief": "Time spent within the basis identification procedure since its invocation.", "value": "6"}, {"caml-name": "BI_PRIMAL_TIME", "name": "bi_primal_time", "brief": "Time  spent within the primal phase of the basis identification procedure since its invocation.", "value": "5"}, {"caml-name": "BI_DUAL_TIME", "name": "bi_dual_time", "brief": "Time spent within the dual phase basis identification procedure since its invocation.", "value": "4"}, {"caml-name": "BI_CLEAN_TIME", "name": "bi_clean_time", "brief": "Time spent within the clean-up phase of the basis identification procedure since its invocation.", "value": "3"}, {"caml-name": "BI_CLEAN_PRIMAL_TIME", "name": "bi_clean_primal_time", "brief": "Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation.", "value": "2"}, {"caml-name": "BI_CLEAN_DUAL_TIME", "name": "bi_clean_dual_time", "brief": "Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation.", "value": "1"}, {"caml-name": "INTPNT_TIME", "name": "intpnt_time", "brief": "Time spent within the interior-point optimizer since its invocation.", "value": "14"}, {"caml-name": "INTPNT_ORDER_TIME", "name": "intpnt_order_time", "brief": "Order time (in seconds).", "value": "11"}, {"caml-name": "INTPNT_PRIMAL_OBJ", "name": "intpnt_primal_obj", "brief": "Primal objective value reported by the interior-point optimizer.", "value": "13"}, {"caml-name": "INTPNT_DUAL_OBJ", "name": "intpnt_dual_obj", "brief": "Dual objective value reported by the interior-point optimizer.", "value": "8"}, {"caml-name": "INTPNT_PRIMAL_FEAS", "name": "intpnt_primal_feas", "brief": "Primal feasibility measure reported by the interior-point optimizer.", "desc": "Primal feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed).", "value": "12"}, {"caml-name": "INTPNT_DUAL_FEAS", "name": "intpnt_dual_feas", "brief": "Dual feasibility measure reported by the interior-point optimizer.", "desc": "Dual feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed.)", "value": "7"}, {"caml-name": "INTPNT_OPT_STATUS", "name": "intpnt_opt_status", "brief": "A measure of optimality of the solution.", "desc": "A measure of optimality of the solution. It should converge to :math:`+1` if the problem has a primal-dual optimal solution, and converge to :math:`-1` if the problem is (strictly) primal or dual infeasible. If the measure converges to another constant, or fails to settle, the problem is usually ill-posed.", "value": "10"}, {"caml-name": "SIM_TIME", "name": "sim_time", "brief": "Time spent in the simplex optimizer since invoking it.", "value": "61"}, {"caml-name": "SIM_PRIMAL_TIME", "name": "sim_primal_time", "brief": "Time spent in the primal simplex optimizer since invoking it.", "value": "60"}, {"caml-name": "SIM_DUAL_TIME", "name": "sim_dual_time", "brief": "Time spent in the dual simplex optimizer since invoking it.", "value": "57"}, {"caml-name": "SIM_OBJ", "name": "sim_obj", "brief": "Objective value reported by the simplex optimizer.", "value": "59"}, {"caml-name": "SIM_FEAS", "name": "sim_feas", "brief": "Feasibility measure reported by the simplex optimizer.", "value": "58"}, {"caml-name": "MIO_TIME", "name": "mio_time", "brief": "Time spent in the mixed-integer optimizer.", "value": "42"}, {"caml-name": "MIO_ROOT_PRESOLVE_TIME", "name": "mio_root_presolve_time", "brief": "Time spent presolving the problem at the root node.", "value": "38"}, {"caml-name": "MIO_ROOT_OPTIMIZER_TIME", "name": "mio_root_optimizer_time", "brief": "Time spent in the contiuous optimizer while processing the root node relaxation.", "value": "37"}, {"caml-name": "MIO_ROOT_TIME", "name": "mio_root_time", "brief": "Time spent processing the root node.", "value": "39"}, {"caml-name": "TO_CONIC_TIME", "name": "to_conic_time", "brief": "Time spent in the last to conic reformulation.", "value": "109"}, {"caml-name": "MIO_CONSTRUCT_SOLUTION_OBJ", "name": "mio_construct_solution_obj", "brief": "Optimal objective value corresponding to the feasible solution.", "desc": "If |mosek| has successfully constructed an integer feasible solution, then this item contains the optimal objective value corresponding to the feasible solution.", "value": "19"}, {"caml-name": "MIO_INITIAL_FEASIBLE_SOLUTION_OBJ", "name": "mio_initial_feasible_solution_obj", "brief": "Optimal objective value corresponding to the user provided initial solution.", "desc": "If the user provided solution was found to be feasible this information item contains it's objective value.", "value": "25"}, {"caml-name": "MIO_OBJ_INT", "name": "mio_obj_int", "brief": "The primal objective value corresponding to the best integer feasible solution.", "desc": "The primal objective value corresponding to the best integer feasible solution. Please note that at least one integer feasible solution must have been located i.e. check :msk:const:`iinfitem.mio_num_int_solutions`.", "value": "32"}, {"caml-name": "MIO_OBJ_BOUND", "name": "mio_obj_bound", "brief": "The best bound on the objective value known.", "desc": "The best known bound on the objective function. This value is undefined until at least\none relaxation has been solved: To see if this is the case check that :msk:const:`iinfitem.mio_num_relax` is\nstrictly positive.", "value": "31"}, {"caml-name": "MIO_OBJ_REL_GAP", "name": "mio_obj_rel_gap", "brief": "If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the relative gap.", "desc": "Given that the mixed-integer optimizer has computed a feasible solution and a bound\non the optimal objective value, then this item contains the relative gap defined by\n\n.. math:: \\frac{| \\mbox{(objective value of feasible solution)}-\\mbox{(objective bound)} | }{\\max(\\delta,|\\mbox{(objective value of feasible solution)}|)}.\n\nwhere :math:`\\delta` is given by the parameter :msk:dparam:`mio_rel_gap_const`. Otherwise it has the value :math:`-1.0`.", "value": "33"}, {"caml-name": "MIO_OBJ_ABS_GAP", "name": "mio_obj_abs_gap", "brief": "If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the absolute gap.", "desc": "Given the mixed-integer optimizer has computed a feasible solution and a bound on the optimal objective value, then this item contains the absolute gap defined by\n\n.. math::  |\\mbox{(objective value of feasible solution)}-\\mbox{(objective bound)}|.\n\nOtherwise it has the value -1.0.", "value": "30"}, {"caml-name": "MIO_USER_OBJ_CUT", "name": "mio_user_obj_cut", "brief": "If the objective cut is used, then this information item has the value of the cut.", "value": "43"}, {"caml-name": "MIO_CMIR_SEPARATION_TIME", "name": "mio_cmir_separation_time", "brief": "Separation time for CMIR cuts.", "value": "18"}, {"caml-name": "MIO_CLIQUE_SEPARATION_TIME", "name": "mio_clique_separation_time", "brief": "Separation time for clique cuts.", "value": "16"}, {"caml-name": "MIO_KNAPSACK_COVER_SEPARATION_TIME", "name": "mio_knapsack_cover_separation_time", "brief": "Separation time for knapsack cover.", "value": "27"}, {"caml-name": "MIO_GMI_SEPARATION_TIME", "name": "mio_gmi_separation_time", "brief": "Separation time for GMI cuts.", "value": "22"}, {"caml-name": "MIO_IMPLIED_BOUND_SEPARATION_TIME", "name": "mio_implied_bound_separation_time", "brief": "Separation time for implied bound cuts.", "value": "24"}, {"caml-name": "MIO_LIPRO_SEPARATION_TIME", "name": "mio_lipro_separation_time", "brief": "Separation time for lift-and-project cuts.", "value": "29"}, {"caml-name": "MIO_ROOT_CUT_SEPARATION_TIME", "name": "mio_root_cut_separation_time", "brief": "Total time for cut separation.", "value": "36"}, {"caml-name": "MIO_CMIR_SELECTION_TIME", "name": "mio_cmir_selection_time", "brief": "Selection time for CMIR cuts.", "value": "17"}, {"caml-name": "MIO_CLIQUE_SELECTION_TIME", "name": "mio_clique_selection_time", "brief": "Selection time for clique cuts.", "value": "15"}, {"caml-name": "MIO_KNAPSACK_COVER_SELECTION_TIME", "name": "mio_knapsack_cover_selection_time", "brief": "Selection time for knapsack cover.", "value": "26"}, {"caml-name": "MIO_GMI_SELECTION_TIME", "name": "mio_gmi_selection_time", "brief": "Selection time for GMI cuts.", "value": "21"}, {"caml-name": "MIO_IMPLIED_BOUND_SELECTION_TIME", "name": "mio_implied_bound_selection_time", "brief": "Selection time for implied bound cuts.", "value": "23"}, {"caml-name": "MIO_LIPRO_SELECTION_TIME", "name": "mio_lipro_selection_time", "brief": "Selection time for lift-and-project cuts.", "value": "28"}, {"caml-name": "MIO_ROOT_CUT_SELECTION_TIME", "name": "mio_root_cut_selection_time", "brief": "Total time for cut selection.", "value": "35"}, {"caml-name": "MIO_PROBING_TIME", "name": "mio_probing_time", "brief": "Total time for probing.", "value": "34"}, {"caml-name": "MIO_SYMMETRY_DETECTION_TIME", "name": "mio_symmetry_detection_time", "brief": "Total time for symmetry detection.", "value": "40"}, {"caml-name": "OPTIMIZER_TIME", "name": "optimizer_time", "brief": "Total time spent in the optimizer since it was invoked.", "value": "45"}, {"caml-name": "OPTIMIZER_TICKS", "name": "optimizer_ticks", "brief": "Total number of ticks spent in the optimizer since it was invoked. It is strictly negative if it is not available.", "value": "44"}, {"caml-name": "PRESOLVE_TIME", "name": "presolve_time", "brief": "Total time (in seconds) spent in the presolve since it was invoked.", "value": "48"}, {"caml-name": "MIO_SYMMETRY_FACTOR", "name": "mio_symmetry_factor", "brief": "Degree to which the problem is affected by detected symmetry.", "value": "41"}, {"caml-name": "MIO_DUAL_BOUND_AFTER_PRESOLVE", "name": "mio_dual_bound_after_presolve", "brief": "Value of the dual bound after presolve but before cut generation.", "value": "20"}, {"caml-name": "PRESOLVE_ELI_TIME", "name": "presolve_eli_time", "brief": "Total time spent in the eliminator since the presolve was invoked.", "value": "46"}, {"caml-name": "PRESOLVE_LINDEP_TIME", "name": "presolve_lindep_time", "brief": "Total time spent  in the linear dependency checker since the presolve was invoked.", "value": "47"}, {"caml-name": "READ_DATA_TIME", "name": "read_data_time", "brief": "Time spent reading the data file.", "value": "55"}, {"caml-name": "WRITE_DATA_TIME", "name": "write_data_time", "brief": "Time spent writing the data file.", "value": "110"}, {"caml-name": "SOL_ITR_PRIMAL_OBJ", "name": "sol_itr_primal_obj", "brief": "Primal objective value of the interior-point solution.", "desc": "Primal objective value of the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "103"}, {"caml-name": "SOL_ITR_PVIOLCON", "name": "sol_itr_pviolcon", "brief": "Maximal primal bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "106"}, {"caml-name": "SOL_ITR_PVIOLVAR", "name": "sol_itr_pviolvar", "brief": "Maximal primal bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "108"}, {"caml-name": "SOL_ITR_PVIOLBARVAR", "name": "sol_itr_pviolbarvar", "brief": "Maximal primal bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`\\barX` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "105"}, {"caml-name": "SOL_ITR_PVIOLCONES", "name": "sol_itr_pviolcones", "brief": "Maximal primal violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "107"}, {"caml-name": "SOL_ITR_PVIOLACC", "name": "sol_itr_pviolacc", "brief": "Maximal primal violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for affine conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "104"}, {"caml-name": "SOL_ITR_DUAL_OBJ", "name": "sol_itr_dual_obj", "brief": "Dual objective value of the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Dual objective value of the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "87"}, {"caml-name": "SOL_ITR_DVIOLCON", "name": "sol_itr_dviolcon", "brief": "Maximal dual bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^c` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "90"}, {"caml-name": "SOL_ITR_DVIOLVAR", "name": "sol_itr_dviolvar", "brief": "Maximal dual bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^x` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "92"}, {"caml-name": "SOL_ITR_DVIOLBARVAR", "name": "sol_itr_dviolbarvar", "brief": "Maximal dual bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`\\barX` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "89"}, {"caml-name": "SOL_ITR_DVIOLCONES", "name": "sol_itr_dviolcones", "brief": "Maximal dual violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual violation for conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "91"}, {"caml-name": "SOL_ITR_DVIOLACC", "name": "sol_itr_dviolacc", "brief": "Maximal dual violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual violation for the affine conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "88"}, {"caml-name": "SOL_ITR_NRM_XC", "name": "sol_itr_nrm_xc", "brief": "Infinity norm of xc in the interior-point solution.", "desc": "Infinity norm of :math:`x^c` in the interior-point solution.", "value": "100"}, {"caml-name": "SOL_ITR_NRM_XX", "name": "sol_itr_nrm_xx", "brief": "Infinity norm of xx in the interior-point solution.", "desc": "Infinity norm of :math:`x^x` in the interior-point solution.", "value": "101"}, {"caml-name": "SOL_ITR_NRM_BARX", "name": "sol_itr_nrm_barx", "brief": "Infinity norm of barx in the interior-point solution.", "desc": "Infinity norm of :math:`\\barX` in the interior-point solution.", "value": "94"}, {"caml-name": "SOL_ITR_NRM_Y", "name": "sol_itr_nrm_y", "brief": "Infinity norm of Y in the interior-point solution.", "desc": "Infinity norm of :math:`y` in the interior-point solution.", "value": "102"}, {"caml-name": "SOL_ITR_NRM_SLC", "name": "sol_itr_nrm_slc", "brief": "Infinity norm of slc in the interior-point solution.", "desc": "Infinity norm of :math:`s_l^c` in the interior-point solution.", "value": "95"}, {"caml-name": "SOL_ITR_NRM_SUC", "name": "sol_itr_nrm_suc", "brief": "Infinity norm of suc in the interior-point solution.", "desc": "Infinity norm of :math:`s_u^c` in the interior-point solution.", "value": "98"}, {"caml-name": "SOL_ITR_NRM_SLX", "name": "sol_itr_nrm_slx", "brief": "Infinity norm of slx in the interior-point solution.", "desc": "Infinity norm of :math:`s_l^x` in the interior-point solution.", "value": "96"}, {"caml-name": "SOL_ITR_NRM_SUX", "name": "sol_itr_nrm_sux", "brief": "Infinity norm of sux in the interior-point solution.", "desc": "Infinity norm of :math:`s_u^X` in the interior-point solution.", "value": "99"}, {"caml-name": "SOL_ITR_NRM_SNX", "name": "sol_itr_nrm_snx", "brief": "Infinity norm of snx in the interior-point solution.", "desc": "Infinity norm of :math:`s_n^x` in the interior-point solution.", "value": "97"}, {"caml-name": "SOL_ITR_NRM_BARS", "name": "sol_itr_nrm_bars", "brief": "Infinity norm of bars in the interior-point solution.", "desc": "Infinity norm of :math:`\\barS` in the interior-point solution.", "value": "93"}, {"caml-name": "SOL_BAS_PRIMAL_OBJ", "name": "sol_bas_primal_obj", "brief": "Primal objective value of the basic solution. Updated by the function updatesolutioninfo.", "desc": "Primal objective value of the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "73"}, {"caml-name": "SOL_BAS_PVIOLCON", "name": "sol_bas_pviolcon", "brief": "Maximal primal bound violation for xc in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "74"}, {"caml-name": "SOL_BAS_PVIOLVAR", "name": "sol_bas_pviolvar", "brief": "Maximal primal bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "75"}, {"caml-name": "SOL_BAS_DUAL_OBJ", "name": "sol_bas_dual_obj", "brief": "Dual objective value of the basic solution. Updated by the function updatesolutioninfo.", "desc": "Dual objective value of the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "62"}, {"caml-name": "SOL_BAS_DVIOLCON", "name": "sol_bas_dviolcon", "brief": "Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^c` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "63"}, {"caml-name": "SOL_BAS_DVIOLVAR", "name": "sol_bas_dviolvar", "brief": "Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^x` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "64"}, {"caml-name": "SOL_BAS_NRM_XC", "name": "sol_bas_nrm_xc", "brief": "Infinity norm of xc in the basic solution.", "desc": "Infinity norm of :math:`x^c` in the basic solution.", "value": "70"}, {"caml-name": "SOL_BAS_NRM_XX", "name": "sol_bas_nrm_xx", "brief": "Infinity norm of xx in the basic solution.", "desc": "Infinity norm of :math:`x^x` in the basic solution.", "value": "71"}, {"caml-name": "SOL_BAS_NRM_BARX", "name": "sol_bas_nrm_barx", "brief": "Infinity norm of barx in the basic solution.", "desc": "Infinity norm of :math:`\\barX` in the basic solution.", "value": "65"}, {"caml-name": "SOL_BAS_NRM_Y", "name": "sol_bas_nrm_y", "brief": "Infinity norm of Y in the basic solution.", "desc": "Infinity norm of :math:`y` in the basic solution.", "value": "72"}, {"caml-name": "SOL_BAS_NRM_SLC", "name": "sol_bas_nrm_slc", "brief": "Infinity norm of slc in the basic solution.", "desc": "Infinity norm of :math:`s_l^c` in the basic solution.", "value": "66"}, {"caml-name": "SOL_BAS_NRM_SUC", "name": "sol_bas_nrm_suc", "brief": "Infinity norm of suc in the basic solution.", "desc": "Infinity norm of :math:`s_u^c` in the basic solution.", "value": "68"}, {"caml-name": "SOL_BAS_NRM_SLX", "name": "sol_bas_nrm_slx", "brief": "Infinity norm of slx in the basic solution.", "desc": "Infinity norm of :math:`s_l^x` in the basic solution.", "value": "67"}, {"caml-name": "SOL_BAS_NRM_SUX", "name": "sol_bas_nrm_sux", "brief": "Infinity norm of sux in the basic solution.", "desc": "Infinity norm of :math:`s_u^X` in the basic solution.", "value": "69"}, {"caml-name": "SOL_ITG_PRIMAL_OBJ", "name": "sol_itg_primal_obj", "brief": "Primal objective value of the integer solution. Updated by the function updatesolutioninfo.", "desc": "Primal objective value of the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "79"}, {"caml-name": "SOL_ITG_PVIOLCON", "name": "sol_itg_pviolcon", "brief": "Maximal primal bound violation for xc in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "82"}, {"caml-name": "SOL_ITG_PVIOLVAR", "name": "sol_itg_pviolvar", "brief": "Maximal primal bound violation for xx in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "86"}, {"caml-name": "SOL_ITG_PVIOLBARVAR", "name": "sol_itg_pviolbarvar", "brief": "Maximal primal bound violation for barx in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`\\barX` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "81"}, {"caml-name": "SOL_ITG_PVIOLCONES", "name": "sol_itg_pviolcones", "brief": "Maximal primal violation for primal conic constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for primal conic constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "83"}, {"caml-name": "SOL_ITG_PVIOLACC", "name": "sol_itg_pviolacc", "brief": "Maximal primal violation for affine conic constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for affine conic constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "80"}, {"caml-name": "SOL_ITG_PVIOLITG", "name": "sol_itg_pviolitg", "brief": "Maximal violation for the integer constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal violation for the integer constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "85"}, {"caml-name": "SOL_ITG_PVIOLDJC", "name": "sol_itg_pvioldjc", "brief": "Maximal primal violation for disjunctive constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for disjunctive constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "84"}, {"caml-name": "SOL_ITG_NRM_XC", "name": "sol_itg_nrm_xc", "brief": "Infinity norm of xc in the integer solution.", "desc": "Infinity norm of :math:`x^c` in the integer solution.", "value": "77"}, {"caml-name": "SOL_ITG_NRM_XX", "name": "sol_itg_nrm_xx", "brief": "Infinity norm of xx in the integer solution.", "desc": "Infinity norm of :math:`x^x` in the integer solution.", "value": "78"}, {"caml-name": "SOL_ITG_NRM_BARX", "name": "sol_itg_nrm_barx", "brief": "Infinity norm of barx in the integer solution.", "desc": "Infinity norm of :math:`\\barX` in the integer solution.", "value": "76"}, {"caml-name": "PRESOLVE_TOTAL_PRIMAL_PERTURBATION", "name": "presolve_total_primal_perturbation", "brief": "Total perturbation of the bounds of the primal problem.", "value": "49"}, {"caml-name": "INTPNT_FACTOR_NUM_FLOPS", "name": "intpnt_factor_num_flops", "brief": "An estimate of the number of flops used in the factorization.", "value": "9"}, {"caml-name": "QCQO_REFORMULATE_TIME", "name": "qcqo_reformulate_time", "brief": "Time spent with conic quadratic reformulation.", "value": "52"}, {"caml-name": "QCQO_REFORMULATE_MAX_PERTURBATION", "name": "qcqo_reformulate_max_perturbation", "brief": "Maximum absolute diagonal perturbation occurring during the QCQO reformulation.", "value": "51"}, {"caml-name": "QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING", "name": "qcqo_reformulate_worst_cholesky_diag_scaling", "brief": "Worst Cholesky diagonal scaling.", "value": "54"}, {"caml-name": "QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING", "name": "qcqo_reformulate_worst_cholesky_column_scaling", "brief": "Worst Cholesky column scaling.", "value": "53"}, {"caml-name": "PRIMAL_REPAIR_PENALTY_OBJ", "name": "primal_repair_penalty_obj", "brief": "The optimal objective value of the penalty function.", "value": "50"}, {"caml-name": "REMOTE_TIME", "name": "remote_time", "brief": "The total real time in seconds spent when optimizing on a server by the process performing the optimization on the server", "value": "56"}]}, "feature": {"name": "feature", "brief": "License feature", "is-enumerable": true, "prefix": "FEATURE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "PTS", "name": "pts", "brief": "Base system.", "value": "0"}, {"caml-name": "PTON", "name": "pton", "brief": "Conic extension.", "value": "1"}]}, "dparam": {"name": "dparam", "brief": "Double parameters", "desc": "The enumeration type containing all double parameters.", "is-enumerable": true, "prefix": "DPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "DATA_TOL_CJ_LARGE", "name": "data_tol_cj_large", "brief": "Data tolerance threshold.", "desc": "An element in :math:`c` which is larger than this value in absolute terms causes a warning message to be printed.", "value": "13", "default": "1.0e8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_C_HUGE", "name": "data_tol_c_huge", "brief": "Data tolerance threshold.", "desc": "An element in :math:`c` which is larger than the value of this parameter in absolute terms is considered to be huge and generates an error.", "value": "12", "default": "1.0e16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_AIJ_LARGE", "name": "data_tol_aij_large", "brief": "Data tolerance threshold.", "desc": "An element in :math:`A` which is larger than this value in absolute size causes a warning message to be printed.", "value": "9", "default": "1.0e10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_AIJ_HUGE", "name": "data_tol_aij_huge", "brief": "Data tolerance threshold.", "desc": "An element in :math:`A` which is larger than this value in absolute size causes an error.", "value": "8", "default": "1.0e20", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL", "name": "data_sym_mat_tol", "brief": "Zero tolerance threshold for symmetric matrices.", "desc": "Absolute zero tolerance for elements in in symmetric matrices. If any value in a symmetric matrix is smaller than this parameter in absolute terms |mosek| will treat the values as zero and generate a warning.", "value": "5", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL_LARGE", "name": "data_sym_mat_tol_large", "brief": "Data tolerance threshold.", "desc": "An element in a symmetric matrix which is larger than this value in absolute size causes a warning message to be printed.", "value": "7", "default": "1.0e10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL_HUGE", "name": "data_sym_mat_tol_huge", "brief": "Data tolerance threshold.", "desc": "An element in a symmetric matrix which is larger than this value in absolute size causes an error.", "value": "6", "default": "1.0e20", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_BOUND_INF", "name": "data_tol_bound_inf", "brief": "Data tolerance threshold.", "desc": "Any bound which in absolute value\nis greater than this parameter is\nconsidered infinite.", "value": "10", "default": "1.0e16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_BOUND_WRN", "name": "data_tol_bound_wrn", "brief": "Data tolerance threshold.", "desc": "If a bound value is larger than this value\nin absolute size, then a warning message is issued.", "value": "11", "default": "1.0e8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_QIJ", "name": "data_tol_qij", "brief": "Data tolerance threshold.", "desc": "Absolute zero tolerance for elements in :math:`Q` matrices.", "value": "14", "default": "1.0e-16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_X", "name": "data_tol_x", "brief": "Data tolerance threshold.", "desc": "Zero tolerance for constraints and variables i.e.\nif the distance between the lower and upper bound\nis less than this value, then the lower and upper\nbound is considered identical.", "value": "15", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "SEMIDEFINITE_TOL_APPROX", "name": "semidefinite_tol_approx", "brief": "Tolerance to define a matrix to be positive semidefinite.", "value": "57", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "OPTIMIZER_MAX_TIME", "name": "optimizer_max_time", "brief": "Solver time limit.", "desc": "Maximum amount of time the optimizer is allowed to spent on the optimization.\nA negative number means infinity.", "value": "49", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "OPTIMIZER_MAX_TICKS", "name": "optimizer_max_ticks", "brief": "Solver ticks limit.", "desc": "CURRENTLY NOT IN USE.\n\nMaximum amount of ticks the optimizer is allowed to spent on the optimization.\nA negative number means infinity.", "value": "48", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "LOWER_OBJ_CUT", "name": "lower_obj_cut", "brief": "Objective bound.", "desc": "If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.", "value": "38", "default": "-1.0e30", "references": [{"type": "constant", "item": ["mosek", "dparam", "lower_obj_cut_finite_trh"]}], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "UPPER_OBJ_CUT", "name": "upper_obj_cut", "brief": "Objective bound.", "desc": "If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.", "value": "60", "default": "1.0e30", "references": [{"type": "constant", "item": ["mosek", "dparam", "upper_obj_cut_finite_trh"]}], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "UPPER_OBJ_CUT_FINITE_TRH", "name": "upper_obj_cut_finite_trh", "brief": "Objective bound.", "desc": "If the upper objective cut is greater than the value of this parameter, then the\nupper objective cut :msk:dparam:`upper_obj_cut` is treated as :math:`\\infty`.", "value": "61", "default": "0.5e30", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "LOWER_OBJ_CUT_FINITE_TRH", "name": "lower_obj_cut_finite_trh", "brief": "Objective bound.", "desc": "If the lower objective cut is less than the value of this parameter value, then the lower objective cut i.e. :msk:dparam:`lower_obj_cut`  is treated as :math:`-\\infty`.", "value": "39", "default": "-0.5e30", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "INTPNT_TOL_REL_GAP", "name": "intpnt_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for linear problems.", "value": "35", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param", "intpnt-param"]}, {"caml-name": "INTPNT_TOL_STEP_SIZE", "name": "intpnt_tol_step_size", "brief": "Minimal step size tolerance for the interior-point optimizer.", "desc": "Minimal step size tolerance. If the step size falls below the value of this parameter, then the interior-point optimizer assumes that it is stalled. In other words the interior-point optimizer does not make any progress and therefore it is better to stop.", "value": "37", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "SIM_LU_TOL_REL_PIV", "name": "sim_lu_tol_rel_piv", "brief": "Relative pivot tolerance employed when computing the LU factorization of the basis matrix.", "desc": "Relative pivot tolerance employed when computing the LU factorization\nof the basis in the simplex optimizers and in the basis identification procedure.\nA value closer to 1.0 generally improves numerical stability but typically also implies an\nincrease in the computational work.", "value": "58", "default": "0.01", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "simplex-param"]}, {"caml-name": "INTPNT_TOL_REL_STEP", "name": "intpnt_tol_rel_step", "brief": "Relative step size to the boundary for linear and quadratic optimization problems.", "value": "36", "default": "0.9999", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_PATH", "name": "intpnt_tol_path", "brief": "Interior-point centering aggressiveness.", "desc": "Controls how close\nthe interior-point optimizer follows the central path. A large\nvalue of this parameter means the central path is\nfollowed very closely. On numerically unstable\nproblems it may be worthwhile to increase this\nparameter.", "value": "32", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_PFEAS", "name": "intpnt_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for linear problems.", "value": "33", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_DFEAS", "name": "intpnt_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for linear problems.", "value": "28", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_MU_RED", "name": "intpnt_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.", "value": "31", "default": "1.0e-16", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_INFEAS", "name": "intpnt_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for linear problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for linear problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "30", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_CO_TOL_REL_GAP", "name": "intpnt_co_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for conic problems.", "value": "21", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_PFEAS", "name": "intpnt_co_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for conic problems.", "value": "20", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_DFEAS", "name": "intpnt_co_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for conic problems.", "value": "16", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_MU_RED", "name": "intpnt_co_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.", "value": "18", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_NEAR_REL", "name": "intpnt_co_tol_near_rel", "brief": "Optimality tolerance used by the interior-point optimizer for conic problems.", "desc": "Optimality tolerance used by the interior-point optimizer for conic problems.\nIf |mosek| cannot compute a solution that has the prescribed accuracy then\nit will check if the solution found satisfies the termination criteria with all tolerances\nmultiplied by the value of this parameter. If yes, then the solution is also declared optimal.", "value": "19", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_INFEAS", "name": "intpnt_co_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for conic problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for conic problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "17", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_QO_TOL_REL_GAP", "name": "intpnt_qo_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.", "value": "27", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_PFEAS", "name": "intpnt_qo_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.", "value": "26", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_DFEAS", "name": "intpnt_qo_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.", "value": "22", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_MU_RED", "name": "intpnt_qo_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.", "value": "24", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_NEAR_REL", "name": "intpnt_qo_tol_near_rel", "brief": "Optimality tolerance used by the interior-point optimizer for quadratic problems.", "desc": "Optimality tolerance used by the interior-point optimizer for quadratic problems.\nIf |mosek| cannot compute a solution that has the prescribed accuracy then\nit will check if the solution found satisfies the termination criteria with all tolerances\nmultiplied by the value of this parameter. If yes, then the solution is also declared optimal.", "value": "25", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_INFEAS", "name": "intpnt_qo_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for quadratic problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for quadratic problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "23", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_PSAFE", "name": "intpnt_tol_psafe", "brief": "Controls the interior-point primal starting point.", "desc": "Controls the initial primal starting point used by\nthe interior-point optimizer. If the interior-point optimizer\nconverges slowly and/or the constraint or variable bounds are very\nlarge, then it may be worthwhile to increase this value.", "value": "34", "default": "1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_DSAFE", "name": "intpnt_tol_dsafe", "brief": "Controls the interior-point dual starting point.", "desc": "Controls the initial dual starting point used by\nthe interior-point optimizer. If the interior-point optimizer\nconverges slowly and/or the constraint or variable bounds are very large,\nthen it might be worthwhile to increase this value.", "value": "29", "default": "1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "MIO_MAX_TIME", "name": "mio_max_time", "brief": "Time limit for the mixed-integer optimizer.", "desc": "This parameter limits the maximum time spent by the mixed-integer optimizer.\nA negative number means infinity.", "value": "41", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_REL_GAP_CONST", "name": "mio_rel_gap_const", "brief": "This value is used to compute the relative gap for the solution to an integer optimization problem.", "value": "42", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_TOL_REL_GAP", "name": "mio_tol_rel_gap", "brief": "Relative optimality tolerance employed by the mixed-integer optimizer.", "value": "47", "default": "1.0e-4", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_TOL_ABS_GAP", "name": "mio_tol_abs_gap", "brief": "Absolute optimality tolerance employed by the mixed-integer optimizer.", "value": "43", "default": "0.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "MIO_TOL_ABS_RELAX_INT", "name": "mio_tol_abs_relax_int", "brief": "Integer feasibility tolerance.", "desc": "Absolute integer feasibility tolerance. If the distance to the nearest integer is less than this tolerance\nthen an integer constraint is assumed to be satisfied.", "value": "44", "default": "1.0e-5", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "MIO_DJC_MAX_BIGM", "name": "mio_djc_max_bigm", "brief": "Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints.", "desc": "Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints. Higher\nvalues make it more likely that a disjunction is reformulated to linear constraints, but also\nincrease the risk of numerical problems.", "value": "40", "default": "1.0e6", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "BASIS_TOL_X", "name": "basis_tol_x", "brief": "Maximum absolute primal bound violation allowed in an optimal basic solution.", "value": "3", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "BASIS_TOL_S", "name": "basis_tol_s", "brief": "Maximum absolute dual bound violation in an optimal basic solution.", "value": "2", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "BASIS_REL_TOL_S", "name": "basis_rel_tol_s", "brief": "Maximum relative dual bound violation allowed in an optimal basic solution.", "value": "1", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "PRESOLVE_TOL_X", "name": "presolve_tol_x", "brief": "Absolute zero tolerance employed for variables in the presolve.", "desc": "Absolute zero tolerance employed for :math:`x_j` in the presolve.", "value": "55", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION", "name": "presolve_tol_primal_infeas_perturbation", "brief": "The presolve is allowed to perturb a bound on a constraint or variable by this amount if it removes an infeasibility.", "value": "52", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_S", "name": "presolve_tol_s", "brief": "Absolute zero tolerance employed for slack variables in the presolve.", "desc": "Absolute zero tolerance employed for :math:`s_i` in the presolve.", "value": "54", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_AIJ", "name": "presolve_tol_aij", "brief": "Absolute zero tolerance employed for constraint coefficients in the presolve.", "desc": "Absolute zero tolerance employed for :math:`a_{ij}` in the presolve.", "value": "51", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_ABS_LINDEP", "name": "presolve_tol_abs_lindep", "brief": "Absolute tolerance employed by the linear dependency checker.", "value": "50", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_REL_LINDEP", "name": "presolve_tol_rel_lindep", "brief": "Relative tolerance employed by the linear dependency checker.", "value": "53", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "SIMPLEX_ABS_TOL_PIV", "name": "simplex_abs_tol_piv", "brief": "Absolute pivot tolerance employed by the simplex optimizers.", "value": "59", "default": "1.0e-7", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"]}, {"caml-name": "MIO_TOL_FEAS", "name": "mio_tol_feas", "brief": "Feasibility tolerance for mixed integer solver.", "value": "45", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "ANA_SOL_INFEAS_TOL", "name": "ana_sol_infeas_tol", "brief": "If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.", "value": "0", "default": "1e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["ana-param"]}, {"caml-name": "CHECK_CONVEXITY_REL_TOL", "name": "check_convexity_rel_tol", "brief": "Convexity check tolerance.", "desc": "This parameter controls when the full convexity check declares a problem to be non-convex.\nIncreasing this tolerance relaxes the criteria for declaring the problem non-convex.\n\nA problem is declared non-convex if negative (positive) pivot elements are detected in the Cholesky factor of a matrix\nwhich is required to be PSD (NSD). This parameter controls how much this non-negativity requirement may be violated.\n\nIf :math:`d_i` is the pivot element for column :math:`i`, then the matrix :math:`Q` is considered to not be PSD if:\n\n.. math::  d_i \\leq - |Q_{ii}|  \\mathtt{check\\_convexity\\_rel\\_tol}", "value": "4", "default": "1e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "QCQO_REFORMULATE_REL_DROP_TOL", "name": "qcqo_reformulate_rel_drop_tol", "brief": "This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.", "value": "56", "default": "1e-15", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT", "name": "mio_tol_rel_dual_bound_improvement", "brief": "Controls cut generation for mixed-integer optimizer.", "desc": "If the relative improvement of the dual bound is smaller than this value, the solver will terminate the root cut generation.\nA value of 0.0 means that the value is selected automatically.", "value": "46", "default": "0.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}], "type": "double"}, "liinfitem": {"name": "liinfitem", "brief": "Long integer information items.", "is-enumerable": true, "prefix": "LIINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS", "name": "ana_pro_scalarized_constraint_matrix_num_rows", "brief": "Number of rows in the scalarized constraint matrix.", "value": "2"}, {"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS", "name": "ana_pro_scalarized_constraint_matrix_num_columns", "brief": "Number of columns in the scalarized constraint matrix.", "value": "0"}, {"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ", "name": "ana_pro_scalarized_constraint_matrix_num_nz", "brief": "Number of non-zero entries in the scalarized constraint matrix.", "value": "1"}, {"caml-name": "MIO_ANZ", "name": "mio_anz", "brief": "Number of non-zero entries in the constraint matrix of the problem to be solved by the mixed-integer optimizer.", "value": "10"}, {"caml-name": "MIO_PRESOLVED_ANZ", "name": "mio_presolved_anz", "brief": "Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve.", "value": "14"}, {"caml-name": "MIO_SIMPLEX_ITER", "name": "mio_simplex_iter", "brief": "Number of simplex iterations performed by the mixed-integer optimizer.", "value": "15"}, {"caml-name": "MIO_INTPNT_ITER", "name": "mio_intpnt_iter", "brief": "Number of interior-point iterations performed by the mixed-integer optimizer.", "value": "11"}, {"caml-name": "MIO_NUM_PRIM_ILLPOSED_CER", "name": "mio_num_prim_illposed_cer", "brief": "Number of primal illposed certificates encountered by the mixed-integer optimizer.", "value": "13"}, {"caml-name": "MIO_NUM_DUAL_ILLPOSED_CER", "name": "mio_num_dual_illposed_cer", "brief": "Number of dual illposed certificates encountered by the mixed-integer optimizer.", "value": "12"}, {"caml-name": "BI_PRIMAL_ITER", "name": "bi_primal_iter", "brief": "Number of primal pivots performed in the basis identification.", "value": "8"}, {"caml-name": "BI_DUAL_ITER", "name": "bi_dual_iter", "brief": "Number of dual pivots performed in the basis identification.", "value": "7"}, {"caml-name": "BI_CLEAN_PRIMAL_ITER", "name": "bi_clean_primal_iter", "brief": "Number of primal clean iterations performed in the basis identification.", "value": "6"}, {"caml-name": "BI_CLEAN_DUAL_ITER", "name": "bi_clean_dual_iter", "brief": "Number of dual clean iterations performed in the basis identification.", "value": "4"}, {"caml-name": "BI_CLEAN_PRIMAL_DEG_ITER", "name": "bi_clean_primal_deg_iter", "brief": "Number of primal degenerate clean iterations performed in the basis identification.", "value": "5"}, {"caml-name": "BI_CLEAN_DUAL_DEG_ITER", "name": "bi_clean_dual_deg_iter", "brief": "Number of dual degenerate clean iterations performed in the basis identification.", "value": "3"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ", "name": "intpnt_factor_num_nz", "brief": "Number of non-zeros in factorization.", "value": "9"}, {"caml-name": "RD_NUMACC", "name": "rd_numacc", "brief": "Number of affince conic constraints.", "value": "16"}, {"caml-name": "RD_NUMDJC", "name": "rd_numdjc", "brief": "Number of disjuncive constraints.", "value": "18"}, {"caml-name": "RD_NUMANZ", "name": "rd_numanz", "brief": "Number of non-zeros in A that is read.", "value": "17"}, {"caml-name": "RD_NUMQNZ", "name": "rd_numqnz", "brief": "Number of Q non-zeros.", "value": "19"}, {"caml-name": "SIMPLEX_ITER", "name": "simplex_iter", "brief": "Number of iterations performed by the simplex optimizer.", "value": "20"}]}, "internal_liinf": {"name": "internal_liinf", "is-enumerable": true, "prefix": "LIINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "INTPNT_LENBARVAR", "name": "intpnt_lenbarvar", "value": "3"}, {"caml-name": "PRESOLVE_STACK_SIZE", "name": "presolve_stack_size", "value": "4"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ_BEFORE", "name": "intpnt_factor_num_nz_before", "value": "2"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ_AFTER", "name": "intpnt_factor_num_nz_after", "value": "1"}, {"caml-name": "INTPNT_FACTOR_GP_ORDER_SAVED_NZS", "name": "intpnt_factor_gp_order_saved_nzs", "value": "0"}, {"caml-name": "SIMPLEX_PRIMAL_ITER", "name": "simplex_primal_iter", "value": "15"}, {"caml-name": "SIMPLEX_DUAL_ITER", "name": "simplex_dual_iter", "value": "5"}, {"caml-name": "SIMPLEX_PRIMAL_NUM_TICKS", "name": "simplex_primal_num_ticks", "value": "16"}, {"caml-name": "SIMPLEX_DUAL_NUM_TICKS", "name": "simplex_dual_num_ticks", "value": "6"}, {"caml-name": "SIMPLEX_NUM_DUAL_ILLPOSED_CER", "name": "simplex_num_dual_illposed_cer", "value": "10"}, {"caml-name": "SIMPLEX_NUM_CAND", "name": "simplex_num_cand", "value": "9"}, {"caml-name": "SIMPLEX_NUM_PROGRESS_STALL", "name": "simplex_num_progress_stall", "value": "13"}, {"caml-name": "SIMPLEX_NUM_SINGULAR_BASES", "name": "simplex_num_singular_bases", "value": "14"}, {"caml-name": "SIMPLEX_NUM_FATAL_FEASIBILITY_LOSS", "name": "simplex_num_fatal_feasibility_loss", "value": "11"}, {"caml-name": "SIMPLEX_NUM_FATAL_GRADIENT_STALL", "name": "simplex_num_fatal_gradient_stall", "value": "12"}, {"caml-name": "SIMPLEX_LU_FACTOR_NUM_TICKS", "name": "simplex_lu_factor_num_ticks", "value": "7"}, {"caml-name": "SIMPLEX_LU_SOLVE_NUM_TICKS", "name": "simplex_lu_solve_num_ticks", "value": "8"}]}, "iinfitem": {"name": "iinfitem", "brief": "Integer information items.", "is-enumerable": true, "prefix": "IINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_NUM_CON", "name": "ana_pro_num_con", "brief": "Number of constraints in the problem.", "desc": "Number of constraints in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "0"}, {"caml-name": "ANA_PRO_NUM_CON_LO", "name": "ana_pro_num_con_lo", "brief": "Number of constraints with a lower bound and an infinite upper bound.", "desc": "Number of constraints with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "3"}, {"caml-name": "ANA_PRO_NUM_CON_UP", "name": "ana_pro_num_con_up", "brief": "Number of constraints with an upper bound and an infinite lower bound.", "desc": "Number of constraints with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "5"}, {"caml-name": "ANA_PRO_NUM_CON_RA", "name": "ana_pro_num_con_ra", "brief": "Number of constraints with finite lower and upper bounds.", "desc": "Number of constraints with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "4"}, {"caml-name": "ANA_PRO_NUM_CON_EQ", "name": "ana_pro_num_con_eq", "brief": "Number of equality constraints.", "desc": "Number of equality constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "1"}, {"caml-name": "ANA_PRO_NUM_CON_FR", "name": "ana_pro_num_con_fr", "brief": "Number of unbounded constraints.", "desc": "Number of unbounded constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "2"}, {"caml-name": "ANA_PRO_NUM_VAR", "name": "ana_pro_num_var", "brief": "Number of variables in the problem.", "desc": "Number of variables in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "6"}, {"caml-name": "ANA_PRO_NUM_VAR_LO", "name": "ana_pro_num_var_lo", "brief": "Number of variables with a lower bound and an infinite upper bound.", "desc": "Number of variables with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "12"}, {"caml-name": "ANA_PRO_NUM_VAR_UP", "name": "ana_pro_num_var_up", "brief": "Number of variables with an upper bound and an infinite lower bound.", "desc": "Number of variables with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "14"}, {"caml-name": "ANA_PRO_NUM_VAR_RA", "name": "ana_pro_num_var_ra", "brief": "Number of variables with finite lower and upper bounds.", "desc": "Number of variables with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "13"}, {"caml-name": "ANA_PRO_NUM_VAR_EQ", "name": "ana_pro_num_var_eq", "brief": "Number of fixed variables.", "desc": "Number of fixed variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "9"}, {"caml-name": "ANA_PRO_NUM_VAR_FR", "name": "ana_pro_num_var_fr", "brief": "Number of unbounded constraints.", "desc": "Number of free variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "10"}, {"caml-name": "ANA_PRO_NUM_VAR_CONT", "name": "ana_pro_num_var_cont", "brief": "Number of continuous variables.", "desc": "Number of continuous variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "8"}, {"caml-name": "ANA_PRO_NUM_VAR_BIN", "name": "ana_pro_num_var_bin", "brief": "Number of binary variables.", "desc": "Number of binary (0-1) variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "7"}, {"caml-name": "ANA_PRO_NUM_VAR_INT", "name": "ana_pro_num_var_int", "brief": "Number of general integer variables.", "desc": "Number of general integer variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "11"}, {"caml-name": "OPTIMIZE_RESPONSE", "name": "optimize_response", "brief": "The response code returned by optimize.", "value": "86"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_PERTURBATIONS", "name": "presolve_num_primal_perturbations", "brief": "Number perturbations to thhe bounds of the primal problem.", "value": "87"}, {"caml-name": "INTPNT_ITER", "name": "intpnt_iter", "brief": "Number of interior-point iterations since invoking the interior-point optimizer.", "value": "16"}, {"caml-name": "INTPNT_FACTOR_DIM_DENSE", "name": "intpnt_factor_dim_dense", "brief": "Dimension of the dense sub system in factorization.", "value": "15"}, {"caml-name": "INTPNT_SOLVE_DUAL", "name": "intpnt_solve_dual", "brief": "Non-zero if the interior-point optimizer is solving the dual problem.", "value": "18"}, {"caml-name": "MIO_NODE_DEPTH", "name": "mio_node_depth", "brief": "Depth of the last node solved.", "value": "23"}, {"caml-name": "MIO_NUMVAR", "name": "mio_numvar", "brief": "Number of variables in the problem to be solved by the mixed-integer optimizer.", "value": "61"}, {"caml-name": "MIO_NUMBIN", "name": "mio_numbin", "brief": "Number of binary variables in the problem to be solved by the mixed-integer optimizer.", "value": "45"}, {"caml-name": "MIO_NUMINT", "name": "mio_numint", "brief": "Number of integer variables in the problem to be solved by the mixed-integer optimizer.", "value": "55"}, {"caml-name": "MIO_NUMCONT", "name": "mio_numcont", "brief": "Number of continuous variables in the problem to be solved by the mixed-integer optimizer.", "value": "50"}, {"caml-name": "MIO_NUMCON", "name": "mio_numcon", "brief": "Number of constraints in the problem to be solved by the mixed-integer optimizer.", "value": "47"}, {"caml-name": "MIO_NUMCONE", "name": "mio_numcone", "brief": "Number of cones in the problem to be solved by the mixed-integer optimizer.", "value": "48"}, {"caml-name": "MIO_NUMQCONES", "name": "mio_numqcones", "brief": "Number of quadratic cones in the problem to be solved by the mixed-integer optimizer.", "value": "59"}, {"caml-name": "MIO_NUMRQCONES", "name": "mio_numrqcones", "brief": "Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer.", "value": "60"}, {"caml-name": "MIO_NUMPEXPCONES", "name": "mio_numpexpcones", "brief": "Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer.", "value": "57"}, {"caml-name": "MIO_NUMDEXPCONES", "name": "mio_numdexpcones", "brief": "Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer.", "value": "52"}, {"caml-name": "MIO_NUMPPOWCONES", "name": "mio_numppowcones", "brief": "Number of primal power cones in the problem to be solved by the mixed-integer optimizer.", "value": "58"}, {"caml-name": "MIO_NUMDPOWCONES", "name": "mio_numdpowcones", "brief": "Number of dual power cones in the problem to be solved by the mixed-integer optimizer.", "value": "54"}, {"caml-name": "MIO_NUMCONEVAR", "name": "mio_numconevar", "brief": "Number of cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "49"}, {"caml-name": "MIO_NUMBINCONEVAR", "name": "mio_numbinconevar", "brief": "Number of binary cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "46"}, {"caml-name": "MIO_NUMINTCONEVAR", "name": "mio_numintconevar", "brief": "Number of integer cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "56"}, {"caml-name": "MIO_NUMCONTCONEVAR", "name": "mio_numcontconevar", "brief": "Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "51"}, {"caml-name": "MIO_NUMDJC", "name": "mio_numdjc", "brief": "Number of disjunctive constraints in the problem to be solved by the mixed-integer optimizer.", "value": "53"}, {"caml-name": "MIO_PRESOLVED_NUMVAR", "name": "mio_presolved_numvar", "brief": "Number of variables in the problem after the mixed-integer optimizer's presolve.", "value": "79"}, {"caml-name": "MIO_PRESOLVED_NUMBIN", "name": "mio_presolved_numbin", "brief": "Number of binary variables in the problem after the mixed-integer optimizer's presolve.", "value": "63"}, {"caml-name": "MIO_PRESOLVED_NUMINT", "name": "mio_presolved_numint", "brief": "Number of integer variables in the problem after the mixed-integer optimizer's presolve.", "value": "73"}, {"caml-name": "MIO_PRESOLVED_NUMCONT", "name": "mio_presolved_numcont", "brief": "Number of continuous variables in the problem after the mixed-integer optimizer's presolve.", "value": "68"}, {"caml-name": "MIO_PRESOLVED_NUMCON", "name": "mio_presolved_numcon", "brief": "Number of constraints in the problem after the mixed-integer optimizer's presolve.", "value": "65"}, {"caml-name": "MIO_PRESOLVED_NUMCONE", "name": "mio_presolved_numcone", "brief": "Number of cones in the problem after the mixed-integer optimizer's presolve.", "value": "66"}, {"caml-name": "MIO_PRESOLVED_NUMQCONES", "name": "mio_presolved_numqcones", "brief": "Number of quadratic cones in the problem after the mixed-integer optimizer's presolve.", "value": "77"}, {"caml-name": "MIO_PRESOLVED_NUMRQCONES", "name": "mio_presolved_numrqcones", "brief": "Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve.", "value": "78"}, {"caml-name": "MIO_PRESOLVED_NUMPEXPCONES", "name": "mio_presolved_numpexpcones", "brief": "Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve.", "value": "75"}, {"caml-name": "MIO_PRESOLVED_NUMDEXPCONES", "name": "mio_presolved_numdexpcones", "brief": "Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve.", "value": "70"}, {"caml-name": "MIO_PRESOLVED_NUMPPOWCONES", "name": "mio_presolved_numppowcones", "brief": "Number of primal power cones in the problem after the mixed-integer optimizer's presolve.", "value": "76"}, {"caml-name": "MIO_PRESOLVED_NUMDPOWCONES", "name": "mio_presolved_numdpowcones", "brief": "Number of dual power cones in the problem after the mixed-integer optimizer's presolve.", "value": "72"}, {"caml-name": "MIO_PRESOLVED_NUMCONEVAR", "name": "mio_presolved_numconevar", "brief": "Number of cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "67"}, {"caml-name": "MIO_PRESOLVED_NUMBINCONEVAR", "name": "mio_presolved_numbinconevar", "brief": "Number of binary cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "64"}, {"caml-name": "MIO_PRESOLVED_NUMINTCONEVAR", "name": "mio_presolved_numintconevar", "brief": "Number of integer cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "74"}, {"caml-name": "MIO_PRESOLVED_NUMCONTCONEVAR", "name": "mio_presolved_numcontconevar", "brief": "Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "69"}, {"caml-name": "MIO_PRESOLVED_NUMDJC", "name": "mio_presolved_numdjc", "brief": "Number of disjunctive constraints in the problem after the mixed-integer optimizer's presolve.", "value": "71"}, {"caml-name": "MIO_CLIQUE_TABLE_SIZE", "name": "mio_clique_table_size", "brief": "Size of the clique table.", "value": "20"}, {"caml-name": "MIO_CONSTRUCT_SOLUTION", "name": "mio_construct_solution", "brief": "Informs if MOSEK successfully constructed an initial integer feasible solution.", "desc": "This item informs if |mosek| constructed an initial integer feasible solution.\n\n* -1: tried, but failed,\n* 0: no partial solution supplied by the user,\n* 1: constructed feasible solution.", "value": "21"}, {"caml-name": "MIO_INITIAL_FEASIBLE_SOLUTION", "name": "mio_initial_feasible_solution", "brief": "Informs if MOSEK found the solution provided by the user to be feasible", "desc": "This item informs if |mosek| found the solution provided by the user to be feasible\n\n* 0: solution provided by the user was not found to be feasible for the current problem,\n* 1: user provided solution was found to be feasible.", "value": "22"}, {"caml-name": "MIO_NUM_INT_SOLUTIONS", "name": "mio_num_int_solutions", "brief": "Number of integer feasible solutions that have been found.", "value": "27"}, {"caml-name": "MIO_OBJ_BOUND_DEFINED", "name": "mio_obj_bound_defined", "brief": "Non-zero if a valid objective bound has been found, otherwise zero.", "value": "62"}, {"caml-name": "MIO_NUM_ACTIVE_NODES", "name": "mio_num_active_nodes", "brief": "Number of active branch and bound nodes.", "value": "24"}, {"caml-name": "MIO_NUM_RELAX", "name": "mio_num_relax", "brief": "Number of relaxations solved during the optimization.", "value": "28"}, {"caml-name": "MIO_NUM_SOLVED_NODES", "name": "mio_num_solved_nodes", "brief": "Number of branch and bounds nodes solved in the main branch and bound tree.", "value": "44"}, {"caml-name": "MIO_NUM_BRANCH", "name": "mio_num_branch", "brief": "Number of branches performed during the optimization.", "value": "26"}, {"caml-name": "MIO_NUM_RESTARTS", "name": "mio_num_restarts", "brief": "Number of restarts performed during the optimization.", "value": "30"}, {"caml-name": "MIO_NUM_ROOT_CUT_ROUNDS", "name": "mio_num_root_cut_rounds", "brief": "Number of cut separation rounds at the root node of the mixed-integer optimizer.", "value": "31"}, {"caml-name": "MIO_NUM_ACTIVE_ROOT_CUTS", "name": "mio_num_active_root_cuts", "brief": "Number of active cuts in the final relaxation after the mixed-integer optimizer's root cut generation.", "value": "25"}, {"caml-name": "MIO_TOTAL_NUM_SELECTED_CUTS", "name": "mio_total_num_selected_cuts", "brief": "Total number of cuts selected to be included in the relaxation by the mixed-integer optimizer.", "value": "81"}, {"caml-name": "MIO_NUM_SELECTED_CMIR_CUTS", "name": "mio_num_selected_cmir_cuts", "brief": "Number of Complemented Mixed Integer Rounding (CMIR) cuts selected to be included in the relaxation.", "value": "33"}, {"caml-name": "MIO_NUM_SELECTED_CLIQUE_CUTS", "name": "mio_num_selected_clique_cuts", "brief": "Number of clique cuts selected to be included in the relaxation.", "value": "32"}, {"caml-name": "MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS", "name": "mio_num_selected_implied_bound_cuts", "brief": "Number of implied bound cuts selected to be included in the relaxation.", "value": "35"}, {"caml-name": "MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS", "name": "mio_num_selected_knapsack_cover_cuts", "brief": "Number of clique cuts selected to be included in the relaxation.", "value": "36"}, {"caml-name": "MIO_NUM_SELECTED_GOMORY_CUTS", "name": "mio_num_selected_gomory_cuts", "brief": "Number of Gomory cuts selected to be included in the relaxation.", "value": "34"}, {"caml-name": "MIO_NUM_SELECTED_LIPRO_CUTS", "name": "mio_num_selected_lipro_cuts", "brief": "Number of lift-and-project cuts selected to be included in the relaxation.", "value": "37"}, {"caml-name": "MIO_TOTAL_NUM_SEPARATED_CUTS", "name": "mio_total_num_separated_cuts", "brief": "Total number of cuts separated by the mixed-integer optimizer.", "value": "82"}, {"caml-name": "MIO_NUM_SEPARATED_CMIR_CUTS", "name": "mio_num_separated_cmir_cuts", "brief": "Number of separated Complemented Mixed Integer Rounding (CMIR) cuts.", "value": "39"}, {"caml-name": "MIO_NUM_SEPARATED_CLIQUE_CUTS", "name": "mio_num_separated_clique_cuts", "brief": "Number of separated clique cuts.", "value": "38"}, {"caml-name": "MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS", "name": "mio_num_separated_implied_bound_cuts", "brief": "Number of separated implied bound cuts.", "value": "41"}, {"caml-name": "MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS", "name": "mio_num_separated_knapsack_cover_cuts", "brief": "Number of separated clique cuts.", "value": "42"}, {"caml-name": "MIO_NUM_SEPARATED_GOMORY_CUTS", "name": "mio_num_separated_gomory_cuts", "brief": "Number of separated Gomory cuts.", "value": "40"}, {"caml-name": "MIO_NUM_SEPARATED_LIPRO_CUTS", "name": "mio_num_separated_lipro_cuts", "brief": "Number of separated lift-and-project cuts.", "value": "43"}, {"caml-name": "MIO_NUM_REPEATED_PRESOLVE", "name": "mio_num_repeated_presolve", "brief": "Number of times presolve was repeated at root.", "value": "29"}, {"caml-name": "MIO_USER_OBJ_CUT", "name": "mio_user_obj_cut", "brief": "If it is non-zero, then the objective cut is used.", "value": "83"}, {"caml-name": "MIO_RELGAP_SATISFIED", "name": "mio_relgap_satisfied", "brief": "Non-zero if relative gap is within tolerances.", "value": "80"}, {"caml-name": "MIO_ABSGAP_SATISFIED", "name": "mio_absgap_satisfied", "brief": "Non-zero if absolute gap is within tolerances.", "value": "19"}, {"caml-name": "RD_PROTYPE", "name": "rd_protype", "brief": "Problem type.", "value": "96"}, {"caml-name": "RD_NUMCON", "name": "rd_numcon", "brief": "Number of constraints read.", "value": "91"}, {"caml-name": "RD_NUMVAR", "name": "rd_numvar", "brief": "Number of variables read.", "value": "95"}, {"caml-name": "RD_NUMBARVAR", "name": "rd_numbarvar", "brief": "Number of symmetric variables read.", "value": "90"}, {"caml-name": "RD_NUMINTVAR", "name": "rd_numintvar", "brief": "Number of integer-constrained variables read.", "value": "93"}, {"caml-name": "RD_NUMQ", "name": "rd_numq", "brief": "Number of nonempty Q matrices read.", "value": "94"}, {"caml-name": "SIM_DUAL_DEG_ITER", "name": "sim_dual_deg_iter", "brief": "The number of dual degenerate iterations.", "value": "97"}, {"caml-name": "SIM_DUAL_INF_ITER", "name": "sim_dual_inf_iter", "brief": "The number of iterations taken with dual infeasibility.", "value": "100"}, {"caml-name": "SIM_DUAL_HOTSTART_LU", "name": "sim_dual_hotstart_lu", "brief": "If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.", "value": "99"}, {"caml-name": "SIM_PRIMAL_ITER", "name": "sim_primal_iter", "brief": "Number of primal simplex iterations during the last optimization.", "value": "108"}, {"caml-name": "SIM_DUAL_ITER", "name": "sim_dual_iter", "brief": "Number of dual simplex iterations during the last optimization.", "value": "101"}, {"caml-name": "INTPNT_NUM_THREADS", "name": "intpnt_num_threads", "brief": "Number of threads that the interior-point optimizer is using.", "value": "17"}, {"caml-name": "SIM_PRIMAL_INF_ITER", "name": "sim_primal_inf_iter", "brief": "The number of iterations taken with primal infeasibility.", "value": "107"}, {"caml-name": "SIM_PRIMAL_DEG_ITER", "name": "sim_primal_deg_iter", "brief": "The number of primal degenerate iterations.", "value": "104"}, {"caml-name": "SIM_PRIMAL_HOTSTART", "name": "sim_primal_hotstart", "brief": "If 1 then the primal simplex algorithm is solving from an advanced basis.", "value": "105"}, {"caml-name": "SIM_PRIMAL_HOTSTART_LU", "name": "sim_primal_hotstart_lu", "brief": "If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.", "value": "106"}, {"caml-name": "SIM_DUAL_HOTSTART", "name": "sim_dual_hotstart", "brief": "If 1 then the dual simplex algorithm is solving from an advanced basis.", "value": "98"}, {"caml-name": "SOL_ITR_PROSTA", "name": "sol_itr_prosta", "brief": "Problem status of the interior-point solution. Updated after each optimization.", "value": "114"}, {"caml-name": "SOL_ITR_SOLSTA", "name": "sol_itr_solsta", "brief": "Solution status of the interior-point solution. Updated after each optimization.", "value": "115"}, {"caml-name": "SOL_BAS_PROSTA", "name": "sol_bas_prosta", "brief": "Problem status of the basic solution. Updated after each optimization.", "value": "110"}, {"caml-name": "SOL_BAS_SOLSTA", "name": "sol_bas_solsta", "brief": "Solution status of the basic solution. Updated after each optimization.", "value": "111"}, {"caml-name": "SOL_ITG_PROSTA", "name": "sol_itg_prosta", "brief": "Problem status of the integer solution. Updated after each optimization.", "value": "112"}, {"caml-name": "SOL_ITG_SOLSTA", "name": "sol_itg_solsta", "brief": "Solution status of the integer solution. Updated after each optimization.", "value": "113"}, {"caml-name": "SIM_NUMCON", "name": "sim_numcon", "brief": "Number of constraints in the problem solved by the simplex optimizer.", "value": "102"}, {"caml-name": "SIM_NUMVAR", "name": "sim_numvar", "brief": "Number of variables in the problem solved by the simplex optimizer.", "value": "103"}, {"caml-name": "OPT_NUMCON", "name": "opt_numcon", "brief": "Number of constraints in the problem solved when the optimizer is called.", "value": "84"}, {"caml-name": "OPT_NUMVAR", "name": "opt_numvar", "brief": "Number of variables in the problem solved when the optimizer is called", "value": "85"}, {"caml-name": "STO_NUM_A_REALLOC", "name": "sto_num_a_realloc", "brief": "Number of times the storage for storing the linear coefficient matrix has been changed.", "desc": "Number of times the storage for storing :math:`A` has been changed.\nA large value may indicates that memory fragmentation may occur.", "value": "116"}, {"caml-name": "RD_NUMCONE", "name": "rd_numcone", "brief": "Number of conic constraints read.", "value": "92"}, {"caml-name": "SIM_SOLVE_DUAL", "name": "sim_solve_dual", "brief": "Is non-zero if dual problem is solved.", "value": "109"}, {"caml-name": "PURIFY_PRIMAL_SUCCESS", "name": "purify_primal_success", "brief": "Is nonzero if the primal solution is purified.", "value": "89"}, {"caml-name": "PURIFY_DUAL_SUCCESS", "name": "purify_dual_success", "brief": "Is nonzero if the dual solution is purified.", "value": "88"}]}, "inftype": {"name": "inftype", "brief": "Information item types", "is-enumerable": true, "prefix": "INF_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "DOU_TYPE", "name": "dou_type", "brief": "Is a double information type.", "value": "0"}, {"caml-name": "INT_TYPE", "name": "int_type", "brief": "Is an integer.", "value": "1"}, {"caml-name": "LINT_TYPE", "name": "lint_type", "brief": "Is a long integer.", "value": "2"}]}, "internal_dinf": {"name": "internal_dinf", "is-enumerable": true, "prefix": "DINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "SENSITIVITY_PRIMAL_TIME", "name": "sensitivity_primal_time", "value": "92"}, {"caml-name": "SENSITIVITY_DUAL_TIME", "name": "sensitivity_dual_time", "value": "91"}, {"caml-name": "INTPNT_GFEAS", "name": "intpnt_gfeas", "value": "67"}, {"caml-name": "INTPNT_MU", "name": "intpnt_mu", "value": "74"}, {"caml-name": "INTPNT_INIT_ITER_TIME", "name": "intpnt_init_iter_time", "value": "69"}, {"caml-name": "INTPNT_FACTOR_TIME", "name": "intpnt_factor_time", "value": "65"}, {"caml-name": "INTPNT_INIT_SEARCH_TIME", "name": "intpnt_init_search_time", "value": "70"}, {"caml-name": "INTPNT_FORM_SEARCH_TIME", "name": "intpnt_form_search_time", "value": "66"}, {"caml-name": "INTPNT_CORRECTOR_TIME", "name": "intpnt_corrector_time", "value": "12"}, {"caml-name": "INTPNT_UPDATE_TIME", "name": "intpnt_update_time", "value": "79"}, {"caml-name": "INTPNT_FACTOR_SETUP_TIME", "name": "intpnt_factor_setup_time", "value": "58"}, {"caml-name": "INTPNT_FACTOR_SCHUR_TIME", "name": "intpnt_factor_schur_time", "value": "51"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_TIME", "name": "intpnt_factor_hat_schur_time", "value": "48"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PUSH_TIME", "name": "intpnt_factor_hat_schur_push_time", "value": "47"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PULL_TIME", "name": "intpnt_factor_hat_schur_pull_time", "value": "45"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_TIME", "name": "intpnt_factor_bar_schur_time", "value": "17"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_DE_TAB_TIME", "name": "intpnt_factor_bar_schur_de_tab_time", "value": "13"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_SP_TAB_TIME", "name": "intpnt_factor_bar_schur_sp_tab_time", "value": "16"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_TIME", "name": "intpnt_factor_sparse_l_time", "value": "62"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_UPDATE_LAST_TIME", "name": "intpnt_factor_sparse_l_update_last_time", "value": "64"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FACTOR_LAST_TIME", "name": "intpnt_factor_sparse_l_factor_last_time", "value": "60"}, {"caml-name": "INTPNT_FACTOR_DENSE_L_TIME", "name": "intpnt_factor_dense_l_time", "value": "40"}, {"caml-name": "INTPNT_FACTOR_DENSE_TIME", "name": "intpnt_factor_dense_time", "value": "41"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_TIME", "name": "intpnt_factor_dense_dota_time", "value": "28"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_SOLVE_TIME", "name": "intpnt_factor_dense_dota_solve_time", "value": "27"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTATDOTA_TIME", "name": "intpnt_factor_dense_dotatdota_time", "value": "30"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_INIT_TIME", "name": "intpnt_factor_dense_dotl_init_time", "value": "37"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR_TIME", "name": "intpnt_factor_dense_dotl_factor_time", "value": "36"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_TIME", "name": "intpnt_factor_bar_schur_update_time", "value": "25"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_COMPRESSED_E_TIME", "name": "intpnt_factor_bar_schur_update_compressed_e_time", "value": "18"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_TIME", "name": "intpnt_factor_bar_schur_update_sparse_time", "value": "24"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_SYR2K_TIME", "name": "intpnt_factor_bar_schur_update_sparse_syr2k_time", "value": "23"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_DOT_TIME", "name": "intpnt_factor_bar_schur_update_sparse_dot_time", "value": "22"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_TIME", "name": "intpnt_factor_bar_schur_update_dense_time", "value": "21"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_SYR2K_TIME", "name": "intpnt_factor_bar_schur_update_dense_syr2k_time", "value": "20"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_DOT_TIME", "name": "intpnt_factor_bar_schur_update_dense_dot_time", "value": "19"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_PUSH_TIME", "name": "intpnt_factor_bar_schur_push_time", "value": "15"}, {"caml-name": "INTPNT_ITER_NON_CORRECTOR_FLOPS", "name": "intpnt_iter_non_corrector_flops", "value": "71"}, {"caml-name": "INTPNT_ITER_ONE_CORRECTOR_FLOPS", "name": "intpnt_iter_one_corrector_flops", "value": "72"}, {"caml-name": "INTPNT_SOLVE_TIME", "name": "intpnt_solve_time", "value": "78"}, {"caml-name": "INTPNT_ITER_REF_TIME", "name": "intpnt_iter_ref_time", "value": "73"}, {"caml-name": "INTPNT_SOLVE_SPARSE_L_TIME", "name": "intpnt_solve_sparse_l_time", "value": "77"}, {"caml-name": "INTPNT_SOLVE_DENSE_L_TIME", "name": "intpnt_solve_dense_l_time", "value": "76"}, {"caml-name": "INTPNT_FACTOR_SETUP_FLOPS", "name": "intpnt_factor_setup_flops", "value": "53"}, {"caml-name": "INTPNT_FACTOR_SETUP_HAT_SCHUR_FLOPS", "name": "intpnt_factor_setup_hat_schur_flops", "value": "56"}, {"caml-name": "INTPNT_FACTOR_SCHUR_FLOPS", "name": "intpnt_factor_schur_flops", "value": "50"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_FLOPS", "name": "intpnt_factor_hat_schur_flops", "value": "43"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PUSH_FLOPS", "name": "intpnt_factor_hat_schur_push_flops", "value": "46"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PULL_FLOPS", "name": "intpnt_factor_hat_schur_pull_flops", "value": "44"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_FLOPS", "name": "intpnt_factor_bar_schur_flops", "value": "14"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FLOPS", "name": "intpnt_factor_sparse_l_flops", "value": "61"}, {"caml-name": "INTPNT_FACTOR_ML_ORDER_SPARSE_L_FLOPS", "name": "intpnt_factor_ml_order_sparse_l_flops", "value": "49"}, {"caml-name": "INTPNT_FACTOR_GP_ORDER_SPARSE_L_FLOPS", "name": "intpnt_factor_gp_order_sparse_l_flops", "value": "42"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_UPDATE_LAST_FLOPS", "name": "intpnt_factor_sparse_l_update_last_flops", "value": "63"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FACTOR_LAST_FLOPS", "name": "intpnt_factor_sparse_l_factor_last_flops", "value": "59"}, {"caml-name": "INTPNT_FACTOR_DENSE_L_FLOPS", "name": "intpnt_factor_dense_l_flops", "value": "39"}, {"caml-name": "INTPNT_FACTOR_DENSE_FLOPS", "name": "intpnt_factor_dense_flops", "value": "38"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_FLOPS", "name": "intpnt_factor_dense_dota_flops", "value": "26"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTATDOTA_FLOPS", "name": "intpnt_factor_dense_dotatdota_flops", "value": "29"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR__INIT_FLOPS", "name": "intpnt_factor_dense_dotl_factor__init_flops", "value": "34"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl_factor_flops", "value": "35"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL11_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl11_factor_flops", "value": "31"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL21_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl21_factor_flops", "value": "32"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL22_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl22_factor_flops", "value": "33"}, {"caml-name": "PRESOLVE_PRIMAL_LIN_DEP_TIME", "name": "presolve_primal_lin_dep_time", "value": "86"}, {"caml-name": "PRESOLVE_DUAL_LIN_DEP_TIME", "name": "presolve_dual_lin_dep_time", "value": "82"}, {"caml-name": "PRESOLVE_ACOLT_TIME", "name": "presolve_acolt_time", "value": "80"}, {"caml-name": "PRESOLVE_SETUP_TIME", "name": "presolve_setup_time", "value": "87"}, {"caml-name": "PRESOLVE_CHECKPRO_TIME", "name": "presolve_checkpro_time", "value": "81"}, {"caml-name": "PRESOLVE_DUPCON_TIME", "name": "presolve_dupcon_time", "value": "83"}, {"caml-name": "PRESOLVE_DUPVAR_TIME", "name": "presolve_dupvar_time", "value": "84"}, {"caml-name": "PRESOLVE_FINAL_TIME", "name": "presolve_final_time", "value": "85"}, {"caml-name": "PRESOLVE_SUB_DOMVAR_TIME", "name": "presolve_sub_domvar_time", "value": "88"}, {"caml-name": "PRESOLVE_SUB_RELAX_TIME", "name": "presolve_sub_relax_time", "value": "89"}, {"caml-name": "PRIMAL_SIMPLEX_INFTIME", "name": "primal_simplex_inftime", "value": "90"}, {"caml-name": "DUAL_SIMPLEX_INFTIME", "name": "dual_simplex_inftime", "value": "11"}, {"caml-name": "INTPNT_GP_ORDER_SAVED_FLOPS", "name": "intpnt_gp_order_saved_flops", "value": "68"}, {"caml-name": "INTPNT_FACTOR_SETUP_DETECT_DENSE_TIME", "name": "intpnt_factor_setup_detect_dense_time", "value": "52"}, {"caml-name": "INTPNT_FACTOR_SETUP_ML_ORDER_TIME", "name": "intpnt_factor_setup_ml_order_time", "value": "57"}, {"caml-name": "INTPNT_FACTOR_SETUP_GP_ORDER_TIME", "name": "intpnt_factor_setup_gp_order_time", "value": "55"}, {"caml-name": "INTPNT_FACTOR_SETUP_GP_ORDER_POST_TIME", "name": "intpnt_factor_setup_gp_order_post_time", "value": "54"}, {"caml-name": "BI_CRASH_TIME", "name": "bi_crash_time", "value": "1"}, {"caml-name": "BI_CRASH_LU_TIME", "name": "bi_crash_lu_time", "value": "0"}, {"caml-name": "BI_FACTOR_TIME", "name": "bi_factor_time", "value": "5"}, {"caml-name": "BI_FACTOR_WORK", "name": "bi_factor_work", "value": "6"}, {"caml-name": "BI_PRIMAL_DONE", "name": "bi_primal_done", "value": "8"}, {"caml-name": "BI_DUAL_DONE", "name": "bi_dual_done", "value": "2"}, {"caml-name": "SIMPLEX_BASISCONDITION", "name": "simplex_basiscondition", "value": "93"}, {"caml-name": "SIMPLEX_PRIMAL_OBJ", "name": "simplex_primal_obj", "value": "97"}, {"caml-name": "SIMPLEX_PRIMAL_FEAS", "name": "simplex_primal_feas", "value": "96"}, {"caml-name": "SIMPLEX_DUAL_OBJ", "name": "simplex_dual_obj", "value": "95"}, {"caml-name": "SIMPLEX_DUAL_FEAS", "name": "simplex_dual_feas", "value": "94"}, {"caml-name": "BI_INITIAL_BASIS_COND", "name": "bi_initial_basis_cond", "value": "7"}, {"caml-name": "BI_PRIMAL_OBJ", "name": "bi_primal_obj", "value": "10"}, {"caml-name": "BI_DUAL_OBJ", "name": "bi_dual_obj", "value": "4"}, {"caml-name": "BI_PRIMAL_FEAS", "name": "bi_primal_feas", "value": "9"}, {"caml-name": "BI_DUAL_FEAS", "name": "bi_dual_feas", "value": "3"}, {"caml-name": "INTPNT_PURIFY_TIME", "name": "intpnt_purify_time", "value": "75"}]}, "internal_iinf": {"name": "internal_iinf", "is-enumerable": true, "prefix": "IINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "VERSION_MAJOR", "name": "version_major", "value": "124"}, {"caml-name": "VERSION_MINOR", "name": "version_minor", "value": "125"}, {"caml-name": "VERSION_REVISION", "name": "version_revision", "value": "126"}, {"caml-name": "PRESOLVE_LINDEP_WORK", "name": "presolve_lindep_work", "value": "68"}, {"caml-name": "PRESOLVE_LINDEP_PIVOTS", "name": "presolve_lindep_pivots", "value": "66"}, {"caml-name": "PRESOLVE_LINDEP_SKIPPED", "name": "presolve_lindep_skipped", "brief": "The linear dependency check was skipped due to numerical problems or because the computational cost was too high.", "value": "67"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEP_ATTEMPTS", "name": "presolve_num_primal_lin_dep_attempts", "brief": "Number of times the primal linear dependency check was attempted.", "value": "74"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEP_SUCCESS_ATTEMPTS", "name": "presolve_num_primal_lin_dep_success_attempts", "brief": "Number successful the primal linear dependency check attempts.", "value": "75"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEP_ATTEMPTS", "name": "presolve_num_dual_lin_dep_attempts", "brief": "Number of times the dual linear dependency check was attempted.", "value": "70"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEP_SUCCESS_ATTEMPTS", "name": "presolve_num_dual_lin_dep_success_attempts", "brief": "Number successful the dual linear dependency check attempts.", "value": "71"}, {"caml-name": "PRESOLVE_OUTOFSPACE", "name": "presolve_outofspace", "brief": "The presolve terminated with of space.", "value": "93"}, {"caml-name": "OPT_OBJECTIVE_SENSE", "name": "opt_objective_sense", "value": "38"}, {"caml-name": "OPTIMIZER", "name": "optimizer", "value": "39"}, {"caml-name": "INTPNT_FIR_REF_ITER", "name": "intpnt_fir_ref_iter", "value": "17"}, {"caml-name": "INTPNT_NUM_REF_STEPS", "name": "intpnt_num_ref_steps", "value": "22"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_DUP", "name": "intpnt_factor_schur_num_dup", "value": "15"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_BLK", "name": "intpnt_factor_schur_num_blk", "value": "14"}, {"caml-name": "INTPNT_FACTOR_SCHUR_MIN_BLK_DIM", "name": "intpnt_factor_schur_min_blk_dim", "value": "13"}, {"caml-name": "INTPNT_FACTOR_SCHUR_MAX_BLK_DIM", "name": "intpnt_factor_schur_max_blk_dim", "value": "12"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_SINGULAR", "name": "intpnt_factor_schur_num_singular", "value": "16"}, {"caml-name": "INTPNT_FACTOR_DIM", "name": "intpnt_factor_dim", "value": "2"}, {"caml-name": "INTPNT_FACTOR_L_DIM", "name": "intpnt_factor_l_dim", "value": "3"}, {"caml-name": "INTPNT_FACTOR_ORDER_ML_L_NUM_DENSE", "name": "intpnt_factor_order_ml_l_num_dense", "value": "11"}, {"caml-name": "INTPNT_FACTOR_ORDER_ML_L_MAX_HEIGHT", "name": "intpnt_factor_order_ml_l_max_height", "value": "10"}, {"caml-name": "INTPNT_FACTOR_ORDER_GP_L_MAX_HEIGHT", "name": "intpnt_factor_order_gp_l_max_height", "value": "9"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_A", "name": "intpnt_factor_num_dense_a", "value": "5"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_A_DUP", "name": "intpnt_factor_num_dense_a_dup", "value": "6"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_W", "name": "intpnt_factor_num_dense_w", "value": "7"}, {"caml-name": "INTPNT_NUMCON", "name": "intpnt_numcon", "value": "29"}, {"caml-name": "INTPNT_NUMVAR", "name": "intpnt_numvar", "value": "36"}, {"caml-name": "INTPNT_NUMBARVAR", "name": "intpnt_numbarvar", "value": "23"}, {"caml-name": "INTPNT_NUMBLO", "name": "intpnt_numblo", "value": "26"}, {"caml-name": "INTPNT_NUMBUP", "name": "intpnt_numbup", "value": "28"}, {"caml-name": "INTPNT_NUMBFR", "name": "intpnt_numbfr", "value": "24"}, {"caml-name": "INTPNT_NUMBFX", "name": "intpnt_numbfx", "value": "25"}, {"caml-name": "INTPNT_NUMCONE", "name": "intpnt_numcone", "value": "30"}, {"caml-name": "INTPNT_NUMCONEVAR", "name": "intpnt_numconevar", "value": "31"}, {"caml-name": "INTPNT_NUMBNDCONE", "name": "intpnt_numbndcone", "value": "27"}, {"caml-name": "INTPNT_NUMRQCONES", "name": "intpnt_numrqcones", "value": "35"}, {"caml-name": "INTPNT_NUMQCONES", "name": "intpnt_numqcones", "value": "34"}, {"caml-name": "INTPNT_NUMPEXPCONES", "name": "intpnt_numpexpcones", "value": "32"}, {"caml-name": "INTPNT_NUMPPOWCONES", "name": "intpnt_numppowcones", "value": "33"}, {"caml-name": "INTPNT_MINCONEDIM", "name": "intpnt_minconedim", "value": "21"}, {"caml-name": "INTPNT_MAXCONEDIM", "name": "intpnt_maxconedim", "value": "20"}, {"caml-name": "INTPNT_MAXBARVARDIM", "name": "intpnt_maxbarvardim", "value": "19"}, {"caml-name": "PRESOLVE_NUMCON", "name": "presolve_numcon", "value": "82"}, {"caml-name": "PRESOLVE_NUMCFR", "name": "presolve_numcfr", "value": "78"}, {"caml-name": "PRESOLVE_NUMCFX", "name": "presolve_numcfx", "value": "79"}, {"caml-name": "PRESOLVE_NUMCLO", "name": "presolve_numclo", "value": "80"}, {"caml-name": "PRESOLVE_NUMCUP", "name": "presolve_numcup", "value": "84"}, {"caml-name": "PRESOLVE_NUMCRA", "name": "presolve_numcra", "value": "83"}, {"caml-name": "PRESOLVE_NUMCNL", "name": "presolve_numcnl", "value": "81"}, {"caml-name": "PRESOLVE_NUMVAR", "name": "presolve_numvar", "value": "86"}, {"caml-name": "PRESOLVE_NUMVFR", "name": "presolve_numvfr", "value": "87"}, {"caml-name": "PRESOLVE_NUMVFX", "name": "presolve_numvfx", "value": "88"}, {"caml-name": "PRESOLVE_NUMVLO", "name": "presolve_numvlo", "value": "89"}, {"caml-name": "PRESOLVE_NUMVUP", "name": "presolve_numvup", "value": "92"}, {"caml-name": "PRESOLVE_NUMVRA", "name": "presolve_numvra", "value": "91"}, {"caml-name": "PRESOLVE_NUMVNL", "name": "presolve_numvnl", "value": "90"}, {"caml-name": "PRESOLVE_NUMNZA", "name": "presolve_numnza", "value": "85"}, {"caml-name": "PRESOLVE_FNUMCON", "name": "presolve_fnumcon", "value": "49"}, {"caml-name": "PRESOLVE_FNUMCFR", "name": "presolve_fnumcfr", "value": "45"}, {"caml-name": "PRESOLVE_FNUMCFX", "name": "presolve_fnumcfx", "value": "46"}, {"caml-name": "PRESOLVE_FNUMCLO", "name": "presolve_fnumclo", "value": "47"}, {"caml-name": "PRESOLVE_FNUMCUP", "name": "presolve_fnumcup", "value": "51"}, {"caml-name": "PRESOLVE_FNUMCRA", "name": "presolve_fnumcra", "value": "50"}, {"caml-name": "PRESOLVE_FNUMCNL", "name": "presolve_fnumcnl", "value": "48"}, {"caml-name": "PRESOLVE_FNUMVAR", "name": "presolve_fnumvar", "value": "53"}, {"caml-name": "PRESOLVE_FNUMVFR", "name": "presolve_fnumvfr", "value": "54"}, {"caml-name": "PRESOLVE_FNUMVFX", "name": "presolve_fnumvfx", "value": "55"}, {"caml-name": "PRESOLVE_FNUMVLO", "name": "presolve_fnumvlo", "value": "56"}, {"caml-name": "PRESOLVE_FNUMVUP", "name": "presolve_fnumvup", "value": "59"}, {"caml-name": "PRESOLVE_FNUMVRA", "name": "presolve_fnumvra", "value": "58"}, {"caml-name": "PRESOLVE_FNUMVNL", "name": "presolve_fnumvnl", "value": "57"}, {"caml-name": "PRESOLVE_FNUMNZA", "name": "presolve_fnumnza", "value": "52"}, {"caml-name": "PRESOLVE_NUM_ELIMNS", "name": "presolve_num_elimns", "value": "73"}, {"caml-name": "PRESOLVE_ELI_NUM_TRIES", "name": "presolve_eli_num_tries", "value": "44"}, {"caml-name": "PRESOLVE_ELI_NUM_FREED_CON", "name": "presolve_eli_num_freed_con", "value": "42"}, {"caml-name": "PRESOLVE_ELI_NUM_FREED_CON_TOTAL", "name": "presolve_eli_num_freed_con_total", "value": "43"}, {"caml-name": "PRESOLVE_LINDEP_NUM_TRIES", "name": "presolve_lindep_num_tries", "value": "64"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEPS", "name": "presolve_num_primal_lin_deps", "value": "76"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEPS", "name": "presolve_num_dual_lin_deps", "value": "72"}, {"caml-name": "PRESOLVE_FORCE_CON_NUM", "name": "presolve_force_con_num", "value": "60"}, {"caml-name": "PRESOLVE_FORCE_CON_NUM_VAR", "name": "presolve_force_con_num_var", "value": "61"}, {"caml-name": "PRESOLVE_FORCE_VAR_NUM", "name": "presolve_force_var_num", "value": "62"}, {"caml-name": "PRESOLVE_FORCE_VAR_NUM_CON", "name": "presolve_force_var_num_con", "value": "63"}, {"caml-name": "PRESOLVE_PIV_ON_CON_NUM", "name": "presolve_piv_on_con_num", "value": "94"}, {"caml-name": "PRESOLVE_NUM_DOU_BLOCKS", "name": "presolve_num_dou_blocks", "value": "69"}, {"caml-name": "PRESOLVE_NUM_SIMPLIFIED_DOU_BLOCKS", "name": "presolve_num_simplified_dou_blocks", "value": "77"}, {"caml-name": "PRESOLVE_SIZE_SIMPLIFIED_DOU_BLOCKS", "name": "presolve_size_simplified_dou_blocks", "value": "95"}, {"caml-name": "PRESOLVE_ACC_NUM_DUP_VAR_IN_NRMTWO", "name": "presolve_acc_num_dup_var_in_nrmtwo", "value": "41"}, {"caml-name": "PRESOLVE_ACC_NUM_DOUBLETON_CHAIN_IN_NRMTWO", "name": "presolve_acc_num_doubleton_chain_in_nrmtwo", "value": "40"}, {"caml-name": "INTPNT_FACTOR_NUM", "name": "intpnt_factor_num", "value": "4"}, {"caml-name": "INTPNT_FACTOR_NUM_SOLVE", "name": "intpnt_factor_num_solve", "value": "8"}, {"caml-name": "SIMPLEX_PRIMAL_HOTSTART_NUM_BASICS", "name": "simplex_primal_hotstart_num_basics", "value": "114"}, {"caml-name": "SIMPLEX_PRIMAL_HOTSTART_BASIS_RANK", "name": "simplex_primal_hotstart_basis_rank", "value": "113"}, {"caml-name": "SIMPLEX_DUAL_HOTSTART_NUM_BASICS", "name": "simplex_dual_hotstart_num_basics", "value": "109"}, {"caml-name": "SIMPLEX_DUAL_HOTSTART_BASIS_RANK", "name": "simplex_dual_hotstart_basis_rank", "value": "108"}, {"caml-name": "INTPNT_GP_ORDER_EMPLOYED", "name": "intpnt_gp_order_employed", "value": "18"}, {"caml-name": "NUM_LU_FACTORIZATIONS", "name": "num_lu_factorizations", "value": "37"}, {"caml-name": "SIMPLEX_PWL_NUM_POTENTIAL", "name": "simplex_pwl_num_potential", "value": "120"}, {"caml-name": "SIMPLEX_PWL_NUM_USED", "name": "simplex_pwl_num_used", "value": "121"}, {"caml-name": "SIMPLEX_PWL_NUM_VARIABLES", "name": "simplex_pwl_num_variables", "value": "122"}, {"caml-name": "SIMPLEX_PWL_MIN_NUM_BREAKPOINTS", "name": "simplex_pwl_min_num_breakpoints", "value": "119"}, {"caml-name": "SIMPLEX_PWL_MAX_NUM_BREAKPOINTS", "name": "simplex_pwl_max_num_breakpoints", "value": "117"}, {"caml-name": "SIMPLEX_PWL_MAX_NZ", "name": "simplex_pwl_max_nz", "value": "118"}, {"caml-name": "SIMPLEX_PWL_NZ_REDUCTION", "name": "simplex_pwl_nz_reduction", "value": "123"}, {"caml-name": "SIMPLEX_PRIMAL_NUM_SETBACKS", "name": "simplex_primal_num_setbacks", "value": "115"}, {"caml-name": "SIMPLEX_DUAL_NUM_SETBACKS", "name": "simplex_dual_num_setbacks", "value": "110"}, {"caml-name": "SIMPLEX_PRIMAL_FEAS_NA", "name": "simplex_primal_feas_na", "value": "112"}, {"caml-name": "SIMPLEX_DUAL_FEAS_NA", "name": "simplex_dual_feas_na", "value": "107"}, {"caml-name": "SIMPLEX_PRIMAL_OBJ_NA", "name": "simplex_primal_obj_na", "value": "116"}, {"caml-name": "SIMPLEX_DUAL_OBJ_NA", "name": "simplex_dual_obj_na", "value": "111"}, {"caml-name": "SIM_NUM_PRIMAL_BOUNDSWAPS", "name": "sim_num_primal_boundswaps", "brief": "Boundswaps performed in the primal simplex optimizer due to linear duplicated columns.", "value": "106"}, {"caml-name": "SIM_NUM_DUAL_BOUNDSWAPS", "name": "sim_num_dual_boundswaps", "brief": "Boundswaps performed in the dual simplex optimizer.", "value": "104"}, {"caml-name": "SIM_NUM_DUAL_INTEGER_PIVOTS", "name": "sim_num_dual_integer_pivots", "brief": "Numbers of iterations where dual simplex made the entering variable integer.", "value": "105"}, {"caml-name": "PURIFY_NUM_ROW", "name": "purify_num_row", "value": "101"}, {"caml-name": "PURIFY_P_NUM_NULL_ROW", "name": "purify_p_num_null_row", "value": "102"}, {"caml-name": "PURIFY_P_NUM_SINGLETON_COL", "name": "purify_p_num_singleton_col", "value": "103"}, {"caml-name": "PURIFY_CRASH_L11_NUM_ROW", "name": "purify_crash_l11_num_row", "value": "96"}, {"caml-name": "PURIFY_CRASH_L22_NUM_ROW", "name": "purify_crash_l22_num_row", "value": "97"}, {"caml-name": "PURIFY_CRASH_L33_NUM_ROW", "name": "purify_crash_l33_num_row", "value": "99"}, {"caml-name": "PURIFY_CRASH_L33_NUM_COL", "name": "purify_crash_l33_num_col", "value": "98"}, {"caml-name": "PURIFY_CRASH_SINGULARITY", "name": "purify_crash_singularity", "value": "100"}, {"caml-name": "BI_PRIMAL_INFO", "name": "bi_primal_info", "value": "1"}, {"caml-name": "BI_DUAL_INFO", "name": "bi_dual_info", "value": "0"}, {"caml-name": "PRESOLVE_LINDEP_NUM_TRUNC_TRIES", "name": "presolve_lindep_num_trunc_tries", "value": "65"}]}, "iomode": {"name": "iomode", "brief": "Input/output modes", "is-enumerable": false, "prefix": "IOMODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "READ", "name": "read", "brief": "The file is read-only.", "value": "0"}, {"caml-name": "WRITE", "name": "write", "brief": "The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened.", "value": "1"}, {"caml-name": "READWRITE", "name": "readwrite", "brief": "The file is to read and write.", "value": "2"}]}, "iparam": {"name": "iparam", "brief": "Integer parameters", "desc": "The enumeration type containing all integer parameters.", "is-enumerable": true, "prefix": "IPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "AUTO_UPDATE_SOL_INFO", "name": "auto_update_sol_info", "brief": "Controls whether the solution information items are automatically updated after an optimization is performed.", "value": "3", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "REMOVE_UNUSED_SOLUTIONS", "name": "remove_unused_solutions", "brief": "Removes unused solutions before the optimization is performed.", "value": "130", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_HOTSTART", "name": "intpnt_hotstart", "brief": "Currently not in use.", "value": "17", "default": "none", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "intpnthotstart"]}}, {"caml-name": "INTPNT_PURIFY", "name": "intpnt_purify", "brief": "Currently not in use.", "value": "24", "default": "none", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "purify"]}}, {"caml-name": "NUM_THREADS", "name": "num_threads", "brief": "The number of threads employed by the optimizer.", "desc": "Controls the number of threads employed by the optimizer. If set to 0 the number of threads used will be equal to the number of cores detected on the machine.", "value": "97", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "TIMING_LEVEL", "name": "timing_level", "brief": "Controls the amount of timing performed inside MOSEK.", "desc": "Controls the amount of timing performed inside |mosek|.", "value": "165", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MT_SPINCOUNT", "name": "mt_spincount", "brief": "Set the number of iterations to spin before sleeping.", "value": "95", "default": "0", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "1000000000"}}, {"caml-name": "MAX_NUM_WARNINGS", "name": "max_num_warnings", "brief": "Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.", "value": "57", "default": "10", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "OPTIMIZER", "name": "optimizer", "brief": "Controls which optimizer is used to optimize the task.", "desc": "The parameter controls which optimizer is used to optimize the task.", "value": "107", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "BI_MAX_ITERATIONS", "name": "bi_max_iterations", "brief": "Maximum number of iterations after basis identification.", "desc": "Controls the maximum number of\nsimplex iterations allowed to optimize\na basis after the basis identification.", "value": "8", "default": "1000000", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LICENSE_TRH_EXPIRY_WRN", "name": "license_trh_expiry_wrn", "brief": "Controls when expiry warnings are issued.", "desc": "If a license feature expires in a numbers of days less than the value of this parameter then a warning will be issued.", "value": "32", "default": "7", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_INCLUDE_SUMMARY", "name": "log_include_summary", "brief": "Controls whether solution summary should be printed by the optimizer.", "desc": ".. msk_only:: optimizer\n\n   If on, then the solution summary will be printed by :msk:func:`task.optimize`, so a separate call to :msk:func:`task.solutionsummary` is not necessary.\n\n.. msk_only:: not optimizer\n\n   Not relevant for this API.", "value": "42", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_CUT_SECOND_OPT", "name": "log_cut_second_opt", "brief": "Controls the reduction in the log levels for the second and any subsequent optimizations.", "desc": "If a task is employed to solve a sequence of optimization problems, then the value of the log levels is reduced by the value\nof this parameter. E.g :msk:iparam:`log` and :msk:iparam:`log_sim` are reduced by the value of this parameter\nfor the second and any subsequent optimizations.", "value": "38", "default": "1", "references": [{"type": "constant", "item": ["mosek", "iparam", "log"]}, {"type": "constant", "item": ["mosek", "iparam", "log_intpnt"]}, {"type": "constant", "item": ["mosek", "iparam", "log_mio"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sim"]}], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_ANA_PRO", "name": "log_ana_pro", "brief": "Controls amount of output from the problem analyzer.", "value": "35", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["ana-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_RESPONSE", "name": "log_response", "brief": "Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.", "value": "50", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_LOCAL_INFO", "name": "log_local_info", "brief": "Control whether local identifying information is printed to the log.", "desc": "Controls whether local identifying information like\nenvironment variables, filenames, IP addresses\netc. are printed to the log.\n\nNote that this will only affect some functions. Some\nfunctions that specifically emit system information\nwill not be affected.", "value": "45", "default": "on", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_BI", "name": "log_bi", "brief": "Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.", "value": "36", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_BI_FREQ", "name": "log_bi_freq", "brief": "Controls the logging frequency.", "desc": "Controls how frequently the optimizer\noutputs information about the basis identification\nand how frequent the user-defined callback function\nis called.", "value": "37", "default": "2500", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "BI_CLEAN_OPTIMIZER", "name": "bi_clean_optimizer", "brief": "Controls which simplex optimizer is used in the clean-up phase.", "desc": "Controls which simplex optimizer is used in the clean-up phase. Anything else than :msk:const:`optimizertype.primal_simplex` or :msk:const:`optimizertype.dual_simplex` is equivalent to :msk:const:`optimizertype.free_simplex`.", "value": "5", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "INTPNT_MAX_NUM_REFINEMENT_STEPS", "name": "intpnt_max_num_refinement_steps", "brief": "Maximum number of steps to be used by the iterative search direction refinement.", "desc": "Maximum number of steps to be used by the iterative\nrefinement of the search direction. A negative value\nimplies that the optimizer chooses the maximum number\nof iterative refinement steps.", "value": "20", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "INTPNT_STARTING_POINT", "name": "intpnt_starting_point", "brief": "Starting point used by the interior-point optimizer.", "value": "28", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "startpointtype"]}}, {"caml-name": "INTPNT_DIFF_STEP", "name": "intpnt_diff_step", "brief": "Controls whether different step sizes are allowed in the primal and dual space.", "value": "16", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_SCALING", "name": "intpnt_scaling", "brief": "Controls how the problem is scaled before the interior-point optimizer is used.", "value": "26", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "scalingtype"]}}, {"caml-name": "INTPNT_SOLVE_FORM", "name": "intpnt_solve_form", "brief": "Controls whether the primal or the dual problem is solved.", "value": "27", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "solveform"]}}, {"caml-name": "LOG_INTPNT", "name": "log_intpnt", "brief": "Controls the amount of log information from the interior-point optimizers.", "desc": "Controls amount of output printed\nby the interior-point optimizer. A higher level implies that more information is logged.", "value": "44", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_MAX_ITERATIONS", "name": "intpnt_max_iterations", "brief": "Controls the maximum number of iterations allowed in the interior-point optimizer.", "value": "18", "default": "400", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_OFF_COL_TRH", "name": "intpnt_off_col_trh", "brief": "Controls the aggressiveness of the offending column detection.", "desc": "Controls how many offending columns are detected in the Jacobian of the constraint matrix.\n\n+----------+-----------------------------------------------+\n|:math:`0` |  no detection                                 |\n+----------+-----------------------------------------------+\n|:math:`1` |  aggressive detection                         |\n+----------+-----------------------------------------------+\n|:math:`>1`|  higher values mean less aggressive detection |\n+----------+-----------------------------------------------+", "value": "21", "default": "40", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_ORDER_METHOD", "name": "intpnt_order_method", "brief": "Controls the ordering strategy.", "desc": "Controls the ordering strategy used by the interior-point\noptimizer when factorizing the Newton\nequation system.", "value": "23", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "orderingtype"]}}, {"caml-name": "INTPNT_ORDER_GP_NUM_SEEDS", "name": "intpnt_order_gp_num_seeds", "brief": "This parameter controls the number of random seeds tried.", "desc": "The GP ordering is dependent on a random seed. Therefore, trying several random seeds may lead to a better ordering.\nThis parameter controls the number of random seeds tried.\n\nA value of 0 means that MOSEK makes the choice.", "value": "22", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_BASIS", "name": "intpnt_basis", "brief": "Controls whether basis identification is performed.", "desc": "Controls whether the interior-point optimizer also\ncomputes an optimal basis.", "value": "15", "default": "ALWAYS", "references": [{"type": "constant", "item": ["mosek", "iparam", "bi_ignore_max_iter"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_ignore_num_error"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_max_iterations"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_clean_optimizer"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "basindtype"]}}, {"caml-name": "BI_IGNORE_MAX_ITER", "name": "bi_ignore_max_iter", "brief": "Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.", "desc": "If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to maximum number of iterations, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.", "value": "6", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "BI_IGNORE_NUM_ERROR", "name": "bi_ignore_num_error", "brief": "Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.", "desc": "If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to a numerical problem, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.", "value": "7", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_MAX_NUM_COR", "name": "intpnt_max_num_cor", "brief": "Maximum number of correction steps.", "desc": "Controls the maximum number of correctors allowed by the multiple corrector procedure. A negative value means that |mosek| is making the choice.", "value": "19", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "-1", "upper": "+inf"}}, {"caml-name": "PRESOLVE_USE", "name": "presolve_use", "brief": "Controls whether the presolve is applied to a problem before it is optimized.", "value": "119", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "valuesfrom": {"from": ["mosek", "presolvemode"]}}, {"caml-name": "PRESOLVE_LEVEL", "name": "presolve_level", "brief": "Currently not used.", "value": "112", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "LOG_PRESOLVE", "name": "log_presolve", "brief": "Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.", "value": "49", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "PRESOLVE_LINDEP_USE", "name": "presolve_lindep_use", "brief": "Controls whether the linear constraints are checked for linear dependencies.", "value": "116", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_LINDEP_NEW", "name": "presolve_lindep_new", "brief": "Controls whether whether a new experimental linear dependency checker is employed.", "value": "114", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_MAX_NUM_PASS", "name": "presolve_max_num_pass", "brief": "Control the maximum number of times presolve passes over the problem.", "desc": "Control the maximum number of times presolve passes over the problem. A negative value implies |mosek| decides.", "value": "117", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_ELIMINATOR_MAX_NUM_TRIES", "name": "presolve_eliminator_max_num_tries", "brief": "Control the maximum number of times the eliminator is tried.", "desc": "Control the maximum number of times the eliminator is tried. A negative value implies |mosek| decides.", "value": "111", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_ELIMINATOR_MAX_FILL", "name": "presolve_eliminator_max_fill", "brief": "Maximum amount of fill-in created in one pivot during the elimination phase.", "desc": "Controls the maximum amount of fill-in that can be created by one pivot in the elimination phase\nof the presolve. A negative value means the parameter value is selected automatically.", "value": "110", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_MAX_NUM_REDUCTIONS", "name": "presolve_max_num_reductions", "brief": "Controls the maximum number of reductions performed by the presolve.", "desc": "Controls the maximum number of reductions performed by the\npresolve. The value of the parameter is normally only changed\nin connection with debugging. A negative value implies that an\ninfinite number of reductions are allowed.", "value": "118", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SIM_DETECT_PWL", "name": "sim_detect_pwl", "brief": "Not in use.", "value": "136", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_STABILITY_PRIORITY", "name": "sim_stability_priority", "brief": "Controls how high priority the numerical stability should be given.", "value": "158", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_PRIMAL_CRASH", "name": "sim_primal_crash", "brief": "Controls the simplex crash.", "desc": "Controls whether crashing is performed in the primal simplex optimizer.\nIn general, if a basis consists of more than (100-this parameter value)\\%\nfixed variables, then a crash will be performed.", "value": "147", "default": "90", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM", "name": "log_sim", "brief": "Controls the amount of log information from the simplex optimizers.", "desc": "Controls amount of output printed by the simplex optimizer. A higher level implies that more information is logged.", "value": "53", "default": "4", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM_MINOR", "name": "log_sim_minor", "brief": "Currently not in use.", "value": "55", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM_FREQ", "name": "log_sim_freq", "brief": "Controls simplex logging frequency.", "desc": "Controls how frequent the simplex optimizer\noutputs information about the optimization\nand how frequent the user-defined callback function\nis called.", "value": "54", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_PRIMAL_RESTRICT_SELECTION", "name": "sim_primal_restrict_selection", "brief": "Controls how aggressively restricted selection is used.", "desc": "The primal simplex optimizer can use a so-called restricted selection/pricing strategy to\nchoose the outgoing variable. Hence, if restricted selection is applied, then the primal simplex optimizer first\nchoose a subset of all the potential incoming variables. Next, for some time it will choose the incoming\nvariable only among the subset. From time to time the subset is redefined.\nA larger value of this parameter implies that the optimizer will be more aggressive in its\nrestriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.", "value": "149", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_PRIMAL_SELECTION", "name": "sim_primal_selection", "brief": "Controls the primal simplex strategy.", "desc": "Controls the choice of the incoming variable,\nknown as the selection strategy, in the primal\nsimplex optimizer.", "value": "150", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "valuesfrom": {"from": ["mosek", "simseltype"]}}, {"caml-name": "SIM_DUAL_RESTRICT_SELECTION", "name": "sim_dual_restrict_selection", "brief": "Controls how aggressively restricted selection is used.", "desc": "The dual simplex optimizer can use a so-called restricted selection/pricing strategy to\nchoose the outgoing variable. Hence, if restricted selection is applied, then the dual simplex optimizer first\nchoose a subset of all the potential outgoing variables. Next, for some time it will choose the outgoing\nvariable only among the subset. From time to time the subset is redefined.\nA larger value of this parameter implies that the optimizer will be more aggressive in its\nrestriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.", "value": "139", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_DUAL_SELECTION", "name": "sim_dual_selection", "brief": "Controls the dual simplex strategy.", "desc": "Controls the choice of the incoming variable,\nknown as the selection strategy, in the dual\nsimplex optimizer.", "value": "140", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "valuesfrom": {"from": ["mosek", "simseltype"]}}, {"caml-name": "SIM_MAX_ITERATIONS", "name": "sim_max_iterations", "brief": "Maximum number of iterations that can be used by a simplex optimizer.", "value": "144", "default": "10000000", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_HOTSTART_LU", "name": "sim_hotstart_lu", "brief": "Determines if the simplex optimizer should exploit the initial factorization.", "value": "143", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_REFACTOR_FREQ", "name": "sim_refactor_freq", "brief": "Controls the basis refactoring frequency.", "desc": "Controls how frequent the basis is refactorized.\nThe value 0 means that the optimizer determines\nthe best point of refactorization.\nIt is strongly recommended NOT to change this parameter.", "value": "151", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_SEED", "name": "sim_seed", "brief": "Sets the random seed used for randomization in the simplex optimizers.", "value": "156", "default": "23456", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "32749"}}, {"caml-name": "MIO_MODE", "name": "mio_mode", "brief": "Turns on/off the mixed-integer mode.", "desc": "Controls whether the optimizer includes\nthe integer restrictions and disjunctive constraints when solving a\n(mixed) integer optimization problem.", "value": "79", "default": "SATISFIED", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "miomode"]}}, {"caml-name": "LOG_MIO", "name": "log_mio", "brief": "Controls the amount of log information from the mixed-integer optimizers.", "desc": "Controls the log level for the mixed-integer optimizer. A higher level implies that more information is logged.", "value": "46", "default": "4", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_MIO_FREQ", "name": "log_mio_freq", "brief": "The mixed-integer optimizer logging frequency.", "desc": "Controls how frequent the mixed-integer optimizer prints the log line. It\nwill print line every time :msk:iparam:`log_mio_freq` relaxations have been solved.", "value": "47", "default": "10", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "info-param", "log-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_RELAXS", "name": "mio_max_num_relaxs", "brief": "Maximum number of relaxations in branch and bound search.", "desc": "Maximum number of relaxations allowed during the branch and bound search. A negative\nvalue means infinite.", "value": "73", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_BRANCHES", "name": "mio_max_num_branches", "brief": "Maximum number of branches allowed during the branch and bound search.", "desc": "Maximum number of branches allowed during the branch and bound search. A negative\nvalue means infinite.", "value": "72", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_RESTARTS", "name": "mio_max_num_restarts", "brief": "Maximum number of restarts allowed during the branch and bound search.", "value": "74", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_ROOT_CUT_ROUNDS", "name": "mio_max_num_root_cut_rounds", "brief": "Maximum number of cut separation rounds at the root node.", "value": "75", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_SOLUTIONS", "name": "mio_max_num_solutions", "brief": "Controls how many feasible solutions the mixed-integer optimizer investigates.", "desc": "The mixed-integer optimizer can be terminated after a certain number of different feasible\nsolutions has been located. If this parameter has the value :math:`n>0`, then the mixed-integer optimizer\nwill be terminated when :math:`n` feasible solutions have been located.", "value": "76", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_NODE_SELECTION", "name": "mio_node_selection", "brief": "Controls the node selection strategy employed by the mixed-integer optimizer.", "value": "81", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "mionodeseltype"]}}, {"caml-name": "MIO_VAR_SELECTION", "name": "mio_var_selection", "brief": "Controls the variable selection strategy employed by the mixed-integer optimizer.", "value": "93", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miovarseltype"]}}, {"caml-name": "MIO_MIN_REL", "name": "mio_min_rel", "brief": "Number of times a variable must have been branched on for its pseudocost to be considered reliable.", "value": "78", "default": "5", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_HEURISTIC_LEVEL", "name": "mio_heuristic_level", "brief": "Controls the heuristic employed by the mixed-integer optimizer to locate an initial integer feasible solution.", "desc": "Controls the heuristic employed by the mixed-integer\noptimizer to locate an initial good integer feasible\nsolution.  A value of zero means the heuristic is not used\nat all. A larger value than :math:`0` means that a gradually more\nsophisticated heuristic is used which is computationally\nmore expensive. A negative value implies that the optimizer\nchooses the heuristic. Normally a value around :math:`3` to :math:`5`\nshould be optimal.", "value": "71", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_PROBING_LEVEL", "name": "mio_probing_level", "brief": "Controls the amount of probing employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of probing employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of probing employed\n* :math:`0`. Probing is disabled\n* :math:`1`. A low amount of probing is employed\n* :math:`2`. A medium amount of probing is employed\n* :math:`3`. A high amount of probing is employed", "value": "85", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "3"}}, {"caml-name": "MIO_SYMMETRY_LEVEL", "name": "mio_symmetry_level", "brief": "Controls the amount of symmetry detection and handling employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of symmetry detection and handling employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of symmetry detection and handling employed\n* :math:`0`. Symmetry detection and handling is disabled\n* :math:`1`. A low amount of symmetry detection and handling is employed\n* :math:`2`. A medium amount of symmetry detection and handling is employed\n* :math:`3`. A high amount of symmetry detection and handling is employed\n* :math:`4`. An extremely high amount of symmetry detection and handling is employed", "value": "92", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "4"}}, {"caml-name": "MIO_DUAL_RAY_ANALYSIS_LEVEL", "name": "mio_dual_ray_analysis_level", "brief": "Controls the amount of dual ray analysis employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of symmetry detection and handling employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of dual ray analysis employed\n* :math:`0`. Dual ray analysis is disabled\n* :math:`1`. A lower amount of dual ray analysis is employed\n* :math:`2`. A higher amount of dual ray analysis is employed", "value": "69", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "2"}}, {"caml-name": "MIO_PRESOLVE_AGGREGATOR_USE", "name": "mio_presolve_aggregator_use", "brief": "Controls if the aggregator should be used.", "value": "84", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_NUMERICAL_EMPHASIS_LEVEL", "name": "mio_numerical_emphasis_level", "brief": "Controls how much emphasis is put on reducing numerical problems", "desc": "Controls how much emphasis is put on reducing numerical problems possibly at the expense of solution\nspeed.\n\n* :math:`0`. The optimizer chooses\n* :math:`1`. More emphasis is put on reducing numerical problems\n* :math:`2`. Even more emphasis", "value": "82", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+2"}}, {"caml-name": "MIO_MEMORY_EMPHASIS_LEVEL", "name": "mio_memory_emphasis_level", "brief": "Controls how much emphasis is put on reducing memory usage.", "desc": "Controls how much emphasis is put on reducing memory usage. Being more conservative about memory\nusage may come at the cost of decreased solution speed.\n\n* :math:`0`. The optimizer chooses\n* :math:`1`. More emphasis is put on reducing memory usage and less on speed", "value": "77", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+1"}}, {"caml-name": "MIO_CUT_SELECTION_LEVEL", "name": "mio_cut_selection_level", "brief": "Controls how aggressively generated cuts are selected to be included in the relaxation.", "desc": "Controls how aggressively generated cuts are selected to be included in the relaxation.\n\n* :math:`-1`. The optimizer chooses the level of cut selection\n* :math:`0`. Generated cuts less likely to be added to the relaxation\n* :math:`1`. Cuts are more aggressively selected to be included in the relaxation", "value": "67", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+1"}}, {"caml-name": "MIO_VB_DETECTION_LEVEL", "name": "mio_vb_detection_level", "brief": "Controls how much effort is put into detecting variable bounds.", "desc": "Controls how much effort is put into detecting variable bounds.\n\n* :math:`-1`. The optimizer chooses\n* :math:`0`. No variable bounds are detected\n* :math:`1`. Only detect variable bounds that are directly represented in the problem\n* :math:`2`. Detect variable bounds in probing", "value": "94", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+2"}}, {"caml-name": "MIO_BRANCH_DIR", "name": "mio_branch_dir", "brief": "Controls whether the mixed-integer optimizer is branching up or down by default.", "value": "58", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "branchdir"]}}, {"caml-name": "MIO_ROOT_OPTIMIZER", "name": "mio_root_optimizer", "brief": "Controls which optimizer is employed at the root node in the mixed-integer optimizer.", "value": "89", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_NODE_OPTIMIZER", "name": "mio_node_optimizer", "brief": "Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.", "value": "80", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_PERSPECTIVE_REFORMULATE", "name": "mio_perspective_reformulate", "brief": "Enables or disables perspective reformulation in presolve.", "value": "83", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_PROPAGATE_OBJECTIVE_CONSTRAINT", "name": "mio_propagate_objective_constraint", "brief": "Use objective domain propagation.", "value": "86", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_SEED", "name": "mio_seed", "brief": "Sets the random seed used for randomization in the mixed integer optimizer.", "desc": "Sets the random seed used for randomization in the mixed integer optimizer.\nSelecting a different seed can change the path the optimizer takes to the optimal solution.", "value": "91", "default": "42", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_CONIC_OUTER_APPROXIMATION", "name": "mio_conic_outer_approximation", "brief": "Toggles outer approximation for conic problems.", "desc": "If this option is turned on outer approximation is used when solving relaxations of conic problems; otherwise interior point is used.", "value": "59", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_QCQO_REFORMULATION_METHOD", "name": "mio_qcqo_reformulation_method", "brief": "Controls what reformulation method is applied to mixed-integer quadratic problems.", "value": "87", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miqcqoreformmethod"]}}, {"caml-name": "MIO_DATA_PERMUTATION_METHOD", "name": "mio_data_permutation_method", "brief": "Controls what problem data permutation method is appplied to mixed-integer problems.", "value": "68", "default": "NONE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miodatapermmethod"]}}, {"caml-name": "READ_KEEP_FREE_CON", "name": "read_keep_free_con", "brief": "Controls whether the free constraints are included in the problem.", "value": "125", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "READ_MPS_FORMAT", "name": "read_mps_format", "brief": "Controls how strictly the MPS file reader interprets the MPS format.", "value": "126", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "mpsformat"]}}, {"caml-name": "WRITE_MPS_FORMAT", "name": "write_mps_format", "brief": "Controls in which format the MPS is written.", "value": "181", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "mpsformat"]}}, {"caml-name": "READ_MPS_WIDTH", "name": "read_mps_width", "brief": "Controls the maximal number of characters allowed in one line of the MPS file.", "value": "127", "default": "1024", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "80", "upper": "+inf"}}, {"caml-name": "READ_DEBUG", "name": "read_debug", "brief": "Turns on additional debugging information when reading files.", "value": "124", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_DATA_PARAM", "name": "write_data_param", "brief": "Controls output file data.", "desc": "If this option is turned on the parameter settings are written to the\ndata file as parameters.", "value": "170", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_FREE_CON", "name": "write_free_con", "brief": "Controls the output file data.", "desc": "Controls whether the free\nconstraints are written to the\ndata file.", "value": "171", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_GENERIC_NAMES", "name": "write_generic_names", "brief": "Controls the output file data.", "desc": "Controls whether generic names should be used instead of user-defined names when writing to the data file.", "value": "172", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_GENERIC_NAMES_IO", "name": "write_generic_names_io", "brief": "Index origin used in  generic names.", "value": "173", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "WRITE_COMPRESSION", "name": "write_compression", "brief": "Controls output file compression.", "desc": "Controls whether the data file is compressed while it is written.\n0 means no compression while higher values mean more compression.", "value": "169", "default": "9", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "WRITE_MPS_INT", "name": "write_mps_int", "brief": "Controls the output file data.", "desc": "Controls if  marker records are written to the MPS file\nto indicate whether variables are integer restricted.", "value": "182", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_LP_LINE_WIDTH", "name": "write_lp_line_width", "brief": "Controls the LP output file format.", "desc": "Maximum width of line in an LP file written by |mosek|.", "value": "180", "default": "80", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "40", "upper": "+inf"}}, {"caml-name": "WRITE_LP_FULL_OBJ", "name": "write_lp_full_obj", "brief": "Write full linear objective", "desc": "Write all variables, including the ones with 0-coefficients, in the objective.", "value": "179", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_JSON_INDENTATION", "name": "write_json_indentation", "brief": "When set, the JSON task and solution files are written with indentation for better readability.", "value": "178", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_IGNORE_INVALID_NAMES", "name": "write_sol_ignore_invalid_names", "brief": "Controls whether the user specified names are employed even if they are invalid names.", "desc": "Even if the names are invalid MPS names, then they are employed when writing the solution file.", "value": "186", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_HEAD", "name": "write_sol_head", "brief": "Controls solution file format.", "desc": "Controls whether the header section is written to the\nsolution file.", "value": "185", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_CONSTRAINTS", "name": "write_sol_constraints", "brief": "Controls the solution file format.", "desc": "Controls whether the constraint section is written to the\nsolution file.", "value": "184", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_VARIABLES", "name": "write_sol_variables", "brief": "Controls the solution file format.", "desc": "Controls whether the variables section is written to the\nsolution file.", "value": "187", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_BARVARIABLES", "name": "write_sol_barvariables", "brief": "Controls the solution file format.", "desc": "Controls whether the symmetric matrix variables section is written to the\nsolution file.", "value": "183", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_HEAD", "name": "write_bas_head", "brief": "Controls the basic solution file format.", "desc": "Controls whether the header section is written to the\nbasic solution file.", "value": "167", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_CONSTRAINTS", "name": "write_bas_constraints", "brief": "Controls the basic solution file format.", "desc": "Controls whether the constraint section is written to the\nbasic solution file.", "value": "166", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_VARIABLES", "name": "write_bas_variables", "brief": "Controls the basic solution file format.", "desc": "Controls whether the variables section is written to the\nbasic solution file.", "value": "168", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_HEAD", "name": "write_int_head", "brief": "Controls the integer solution file format.", "desc": "Controls whether the header section is written to the\ninteger solution file.", "value": "176", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_CONSTRAINTS", "name": "write_int_constraints", "brief": "Controls the integer solution file format.", "desc": "Controls whether the constraint section is written to the\ninteger solution file.", "value": "175", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_VARIABLES", "name": "write_int_variables", "brief": "Controls the integer solution file format.", "desc": "Controls whether the variables section is written to the\ninteger solution file.", "value": "177", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_READ_NAME_WIDTH", "name": "sol_read_name_width", "brief": "Controls the input solution file format.", "desc": "When a solution is read by |mosek| and some constraint, variable or cone names contain blanks, then a maximum name width much be specified. A negative value implies that no name contain blanks.", "value": "162", "default": "-1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SOL_READ_WIDTH", "name": "sol_read_width", "brief": "Controls the input solution file format.", "desc": "Controls the maximal acceptable width of line in the solutions when read by |mosek|.", "value": "163", "default": "1024", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "bounds": {"lower": "80", "upper": "+inf"}}, {"caml-name": "INFEAS_REPORT_AUTO", "name": "infeas_report_auto", "brief": "Turns the feasibility report on or off.", "desc": "Controls whether an infeasibility report is automatically\nproduced after the optimization if the problem is primal or dual\ninfeasible.", "value": "13", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INFEAS_REPORT_LEVEL", "name": "infeas_report_level", "brief": "Controls the contents of the infeasibility report.", "desc": "Controls the amount of information presented in an infeasibility report.\nHigher values imply more information.", "value": "14", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["infeas-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INFEAS_GENERIC_NAMES", "name": "infeas_generic_names", "brief": "Controls the contents of the infeasibility report.", "desc": "Controls whether generic names are used when an infeasible subproblem is created.", "value": "11", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["infeas-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_INFEAS_ANA", "name": "log_infeas_ana", "brief": "Controls log level for the infeasibility analyzer.", "desc": "Controls amount of output printed by the infeasibility analyzer procedures. A higher level implies that more information is logged.", "value": "43", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["infeas-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LICENSE_WAIT", "name": "license_wait", "brief": "Controls if MOSEK should queue for a license if none is available.", "desc": "If all licenses are in use |mosek| returns with an error code.\nHowever, by turning on this parameter |mosek| will wait for an available license.", "value": "33", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "system-param", "lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LICENSE_SUPPRESS_EXPIRE_WRNS", "name": "license_suppress_expire_wrns", "brief": "Controls license manager client behavior.", "desc": "Controls whether license features expire warnings are suppressed.", "value": "31", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param", "info-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LICENSE_PAUSE_TIME", "name": "license_pause_time", "brief": "Controls license manager client behavior.", "desc": "If :msk:iparam:`license_wait` is :msk:const:`onoffkey.on` and no license is available, then |mosek| sleeps a number\nof milliseconds between each check of whether a license has become free.", "value": "30", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "bounds": {"lower": "0", "upper": "1000000"}}, {"caml-name": "LICENSE_DEBUG", "name": "license_debug", "brief": "Controls the license manager client debugging behavior.", "desc": "This option is used to turn on debugging of the license manager.", "value": "29", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_FILTER_KEEP_BASIC", "name": "sol_filter_keep_basic", "brief": "Control the contents of the solution files.", "desc": "If turned on, then basic and super basic constraints and variables\nare written to the solution file independent of the filter setting.", "value": "160", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_FILTER_KEEP_RANGED", "name": "sol_filter_keep_ranged", "brief": "Control the contents of the solution files.", "desc": "If turned on, then ranged constraints and variables are written to the solution file\nindependent of the filter setting.", "value": "161", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG", "name": "log", "brief": "Controls the amount of log information.", "desc": "Controls the amount of log information. The value 0 implies that all log information is suppressed. A higher level implies that more information is logged.\n\nPlease note that if a task is employed to solve a sequence of optimization problems the value of this parameter is reduced by the value of :msk:iparam:`log_cut_second_opt` for the second and any subsequent optimizations.", "value": "34", "default": "10", "references": [{"type": "constant", "item": ["mosek", "iparam", "log_cut_second_opt"]}], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_EXPAND", "name": "log_expand", "brief": "Controls the amount of logging when a data item such as the maximum number constrains is expanded.", "value": "39", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_FILE", "name": "log_file", "brief": "If turned on, then some log info is printed when a file is written or read.", "value": "41", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["dataio-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_ORDER", "name": "log_order", "brief": "If turned on, then factor lines are added to the log.", "value": "48", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SENSITIVITY", "name": "log_sensitivity", "brief": "Control logging in sensitivity analyzer.", "desc": "Controls the amount of logging during the sensitivity analysis.\n\n* :math:`0`. Means no logging information is produced.\n* :math:`1`. Timing information is printed.\n* :math:`2`. Sensitivity results are printed.", "value": "51", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SENSITIVITY_OPT", "name": "log_sensitivity_opt", "brief": "Control logging in sensitivity analyzer.", "desc": "Controls the amount of logging from the optimizers employed during the sensitivity analysis.\n0 means no logging information is produced.", "value": "52", "default": "0", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "READ_TASK_IGNORE_PARAM", "name": "read_task_ignore_param", "brief": "Controls what information is used from the task files.", "desc": "Controls whether |mosek| should ignore the parameter setting defined in the task file and use the default parameter setting instead.", "value": "128", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_TASK_INC_SOL", "name": "write_task_inc_sol", "brief": "Controls whether the solutions are stored in the task file too.", "value": "188", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PARAM_READ_CASE_NAME", "name": "param_read_case_name", "brief": "If turned on, then names in the parameter file are case sensitive.", "value": "108", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PARAM_READ_IGN_ERROR", "name": "param_read_ign_error", "brief": "If turned on, then errors in parameter settings is ignored.", "value": "109", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOLUTION_CALLBACK", "name": "solution_callback", "brief": "Indicates whether solution callbacks will be performed during the optimization.", "value": "164", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["callback-param", "solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_SCALING", "name": "sim_scaling", "brief": "Controls how much effort is used in scaling the problem before a simplex optimizer is used.", "value": "154", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "scalingtype"]}}, {"caml-name": "SIM_SCALING_METHOD", "name": "sim_scaling_method", "brief": "Controls how the problem is scaled before a simplex optimizer is used.", "value": "155", "default": "POW2", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "scalingmethod"]}}, {"caml-name": "SIM_PRIMAL_PHASEONE_METHOD", "name": "sim_primal_phaseone_method", "brief": "An experimental feature.", "value": "148", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "10"}}, {"caml-name": "SIM_DUAL_PHASEONE_METHOD", "name": "sim_dual_phaseone_method", "brief": "An experimental feature.", "value": "138", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "10"}}, {"caml-name": "SIM_MAX_NUM_SETBACKS", "name": "sim_max_num_setbacks", "brief": "Controls how many set-backs that are allowed within a simplex optimizer.", "desc": "Controls how many set-backs are allowed within a simplex\noptimizer. A set-back is an event where the optimizer moves in\nthe wrong direction. This is impossible in theory but may happen due\nto numerical problems.", "value": "145", "default": "250", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_HOTSTART", "name": "sim_hotstart", "brief": "Controls the type of hot-start that the simplex optimizer perform.", "value": "142", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simhotstart"]}}, {"caml-name": "SIM_BASIS_FACTOR_USE", "name": "sim_basis_factor_use", "brief": "Controls whether an LU factorization of the basis is used in a hot-start.", "desc": "Controls whether an LU factorization of the basis is used in a hot-start. Forcing a refactorization sometimes improves the stability of the simplex optimizers, but in most cases there is a performance penalty.", "value": "134", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_DEGEN", "name": "sim_degen", "brief": "Controls how aggressively degeneration is handled.", "value": "135", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simdegen"]}}, {"caml-name": "SIM_REFORMULATION", "name": "sim_reformulation", "brief": "Controls if the simplex optimizers are allowed to reformulate the problem.", "value": "152", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simreform"]}}, {"caml-name": "SIM_EXPLOIT_DUPVEC", "name": "sim_exploit_dupvec", "brief": "Controls if the simplex optimizers are allowed to exploit duplicated columns.", "value": "141", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simdupvec"]}}, {"caml-name": "SIM_SAVE_LU", "name": "sim_save_lu", "brief": "Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.", "value": "153", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_NON_SINGULAR", "name": "sim_non_singular", "brief": "Controls if the simplex optimizer ensures a non-singular basis, if possible.", "value": "146", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_DUAL_CRASH", "name": "sim_dual_crash", "brief": "Controls whether crashing is performed in the dual simplex optimizer.", "desc": "Controls whether crashing is performed in the dual simplex optimizer. If this parameter is set to :math:`x`, then a crash will be performed if a basis consists of more than :math:`(100-x)\\mod f_v` entries, where :math:`f_v` is the number of fixed variables.", "value": "137", "default": "90", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_STORAGE", "name": "log_storage", "brief": "Controls the memory related log information.", "desc": "When turned on, |mosek| prints messages regarding the storage usage and allocation.", "value": "56", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "system-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INFEAS_PREFER_PRIMAL", "name": "infeas_prefer_primal", "brief": "Controls which certificate is used if both primal- and dual- certificate of infeasibility is available.", "desc": "If both certificates of primal and dual infeasibility are supplied then\nonly the primal is used when this option is turned on.", "value": "12", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_LINE_LENGTH", "name": "opf_write_line_length", "brief": "Aim to keep lines in OPF files not much longer than this.", "value": "100", "default": "80", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "OPF_WRITE_HINTS", "name": "opf_write_hints", "brief": "Write a hint section with problem dimensions in the beginning of an OPF file.", "value": "99", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_PARAMETERS", "name": "opf_write_parameters", "brief": "Write a parameter section in an OPF file.", "value": "101", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_PROBLEM", "name": "opf_write_problem", "brief": "Write objective, constraints, bounds etc. to an OPF file.", "value": "102", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_HEADER", "name": "opf_write_header", "brief": "Write a text header with date and MOSEK version in an OPF file.", "desc": "Write a text header with date and |mosek| version in an OPF file.", "value": "98", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOLUTIONS", "name": "opf_write_solutions", "brief": "Enable inclusion of solutions in the OPF files.", "value": "106", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_BAS", "name": "opf_write_sol_bas", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and a basic solution is defined, include the basic solution in OPF files.", "value": "103", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_ITG", "name": "opf_write_sol_itg", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an integer solution is defined, write the integer solution in OPF files.", "value": "104", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_ITR", "name": "opf_write_sol_itr", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an interior solution is defined, write the interior  solution in OPF files.", "value": "105", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_TRANSFORM", "name": "ptf_write_transform", "brief": "Controls if simple transformation are done when writing PTF files.", "desc": "If :msk:iparam:`ptf_write_transform` is\n:msk:const:`onoffkey.on`, constraint blocks with\nidentifiable conic slacks are transformed into conic\nconstraints and the slacks are eliminated.", "value": "123", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_SOLUTIONS", "name": "ptf_write_solutions", "brief": "Controls whether solution section is written in PTF files.", "desc": "If :msk:iparam:`ptf_write_solutions` is\n:msk:const:`onoffkey.on`, the solution section is\nwritten if any solutions are available, otherwise\nsolution section is not written even if solutions\nare available.", "value": "122", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_PARAMETERS", "name": "ptf_write_parameters", "brief": "Controls whether parameters section is written in PTF files.", "desc": "If :msk:iparam:`ptf_write_parameters` is\n:msk:const:`onoffkey.on`, the parameters section is\nwritten.", "value": "121", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRIMAL_REPAIR_OPTIMIZER", "name": "primal_repair_optimizer", "brief": "Controls which optimizer that is used to find the optimal repair.", "value": "120", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_ROOT_REPEAT_PRESOLVE_LEVEL", "name": "mio_root_repeat_presolve_level", "brief": "Controls whether presolve can be repeated at root node.", "desc": "Controls whether presolve can be repeated at root node.\n\n* :math:`-1`. The optimizer chooses whether presolve is repeated\n* :math:`0`. Never repeat presolve\n* :math:`1`. Always repeat presolve", "value": "90", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "1"}}, {"caml-name": "MIO_CUT_CMIR", "name": "mio_cut_cmir", "brief": "Controls whether mixed integer rounding cuts should be generated.", "value": "62", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_CLIQUE", "name": "mio_cut_clique", "brief": "Controls whether clique cuts should be generated.", "value": "61", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_IMPLIED_BOUND", "name": "mio_cut_implied_bound", "brief": "Controls whether implied bound cuts should be generated.", "value": "64", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_KNAPSACK_COVER", "name": "mio_cut_knapsack_cover", "brief": "Controls whether knapsack cover cuts should be generated.", "value": "65", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_GMI", "name": "mio_cut_gmi", "brief": "Controls whether GMI cuts should be generated.", "value": "63", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_LIPRO", "name": "mio_cut_lipro", "brief": "Controls whether lift-and-project cuts should be generated.", "value": "66", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SENSITIVITY_TYPE", "name": "sensitivity_type", "brief": "Controls which type of sensitivity analysis is to be performed.", "value": "133", "default": "BASIS", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "sensitivitytype"]}}, {"caml-name": "MIO_CONSTRUCT_SOL", "name": "mio_construct_sol", "brief": "Controls if an initial mixed integer solution should be constructed from the values of the integer variables.", "desc": "If set to :msk:const:`onoffkey.on` and all integer variables have been given a\nvalue for which a feasible mixed integer solution exists, then |mosek|\ngenerates an initial solution to the mixed integer problem by fixing all integer\nvalues and solving the remaining problem.", "value": "60", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_LINDEP_REL_WORK_TRH", "name": "presolve_lindep_rel_work_trh", "brief": "Controls linear dependency check in presolve.", "desc": "Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.", "value": "115", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_LINDEP_ABS_WORK_TRH", "name": "presolve_lindep_abs_work_trh", "brief": "Controls linear dependency check in presolve.", "desc": "Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.", "value": "113", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SENSITIVITY_ALL", "name": "sensitivity_all", "brief": "Controls sensitivity report behavior.", "desc": ".. msk_only:: not optimizer\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If set to :msk:const:`onoffkey.on`, then :msk:func:`task.sensitivityreport` analyzes all\n   bounds and variables instead of reading a specification from the file.", "value": "131", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_FEAS_REPAIR", "name": "log_feas_repair", "brief": "Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.", "value": "40", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "CACHE_LICENSE", "name": "cache_license", "brief": "Control license caching.", "desc": "Specifies if the license is kept checked out for the\nlifetime of the |mosek| environment/model/process (:msk:const:`onoffkey.on`) or\nreturned to the server immediately after the\noptimization (:msk:const:`onoffkey.off`).\n\n.. msk_only:: optimizer\n\n   By default the license is checked out for the lifetime of the |mosek| environment by the first call to :msk:func:`task.optimize`.\n\n.. msk_only:: fusion\n\n   By default the license is checked out for the lifetime of the process by the first call to :msk:func:`model.solve`.\n\n.. msk_only:: matlab or rmosek\n\n   By default the license is checked out for the lifetime of the session at the start of first optimization.\n\nCheck-in and check-out of licenses have an\noverhead. Frequent communication with the license\nserver should be avoided.", "value": "9", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_REGULARIZATION_USE", "name": "intpnt_regularization_use", "brief": "Controls whether regularization is allowed.", "value": "25", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_SOLVE_FORM", "name": "sim_solve_form", "brief": "Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.", "value": "157", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "solveform"]}}, {"caml-name": "SIM_SWITCH_OPTIMIZER", "name": "sim_switch_optimizer", "brief": "Controls the simplex behavior.", "desc": "The simplex optimizer sometimes chooses to solve the dual problem instead of the primal problem.\nThis implies that if you have chosen to use the dual simplex optimizer and the problem is dualized,\nthen it actually makes sense to use the primal simplex optimizer instead. If this parameter is on\nand the problem is dualized and furthermore the simplex optimizer is chosen to be the primal (dual) one,\nthen it is switched to the dual (primal).", "value": "159", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_IGNORE_INCOMPATIBLE_ITEMS", "name": "write_ignore_incompatible_items", "brief": "Controls if the writer ignores incompatible problem items when writing files.", "value": "174", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "AUTO_SORT_A_BEFORE_OPT", "name": "auto_sort_a_before_opt", "brief": "Controls whether the elements in each column of A are sorted before an optimization is performed.", "desc": "Controls whether the elements in each column of :math:`A` are sorted before an optimization is performed.\nThis is not required but makes the optimization more deterministic.", "value": "2", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["debug-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SENSITIVITY_OPTIMIZER", "name": "sensitivity_optimizer", "brief": "Controls which optimizer is used for optimal partition sensitivity analysis.", "value": "132", "default": "FREE_SIMPLEX", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param", "simplex-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "WRITE_XML_MODE", "name": "write_xml_mode", "brief": "Controls if linear coefficients should be written by row or column when writing in the XML file format.", "value": "189", "default": "ROW", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "xmlwriteroutputtype"]}}, {"caml-name": "ANA_SOL_BASIS", "name": "ana_sol_basis", "brief": "Controls whether the basis matrix is analyzed in solution analyzer.", "value": "0", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["ana-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "ANA_SOL_PRINT_VIOLATED", "name": "ana_sol_print_violated", "brief": "Controls whether a list of violated constraints is printed.", "desc": "A parameter of the problem analyzer. Controls whether a list of violated constraints is printed. All constraints violated by more than the value set by the parameter :msk:dparam:`ana_sol_infeas_tol` will be printed.", "value": "1", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["ana-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "BASIS_SOLVE_USE_PLUS_ONE", "name": "basis_solve_use_plus_one", "brief": "Controls the sign of the columns in the basis matrix corresponding to slack variables.", "desc": "If a slack variable is in the basis, then the corresponding column in the basis is a unit vector\nwith -1 in the right position. However, if this parameter is set to :msk:const:`onoffkey.on`, -1 is replaced by 1.\n\n.. msk_only:: optimizer\n\n   This has significance for the results returned by the :msk:func:`task.solvewithbasis` function.", "value": "4", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "COMPRESS_STATFILE", "name": "compress_statfile", "brief": "Control compression of stat files.", "value": "10", "default": "on", "references": [], "status": "obscure", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_RINS_MAX_NODES", "name": "mio_rins_max_nodes", "brief": "Maximum number of nodes in each call to RINS.", "desc": "Controls the maximum number of nodes allowed in each call to the RINS heuristic. The default value of -1\nmeans that the value is determined automatically. A value of zero turns off the heuristic.", "value": "88", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+inf"}}, {"caml-name": "MIO_FEASPUMP_LEVEL", "name": "mio_feaspump_level", "brief": "Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.", "desc": "Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.\n\n* :math:`-1`. The optimizer chooses how the Feasibility Pump is used\n* :math:`0`. The Feasibility Pump is disabled\n* :math:`1`. The Feasibility Pump is enabled with an effort to improve solution quality\n* :math:`2`. The Feasibility Pump is enabled with an effort to reach feasibility early", "value": "70", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "2"}}, {"caml-name": "NG", "name": "ng", "brief": "Not in use", "desc": "Not in use.", "value": "96", "default": "off", "references": [], "status": "api", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "REMOTE_USE_COMPRESSION", "name": "remote_use_compression", "brief": "Use compression when sending data to an optimization server", "desc": "Use compression when sending data to an optimization server.", "value": "129", "default": "zstd", "references": [], "status": "api", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "compresstype"]}}], "type": "int"}, "branchdir": {"name": "branchdir", "brief": "Specifies the branching direction.", "is-enumerable": false, "prefix": "BRANCH_DIR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The mixed-integer optimizer decides which branch to choose.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The mixed-integer optimizer always chooses the up branch first.", "value": "1"}, {"caml-name": "DOWN", "name": "down", "brief": "The mixed-integer optimizer always chooses the down branch first.", "value": "2"}, {"caml-name": "NEAR", "name": "near", "brief": "Branch in direction nearest to selected fractional variable.", "value": "3"}, {"caml-name": "FAR", "name": "far", "brief": "Branch in direction farthest from selected fractional variable.", "value": "4"}, {"caml-name": "ROOT_LP", "name": "root_lp", "brief": "Chose direction based on root lp value of selected variable.", "value": "5"}, {"caml-name": "GUIDED", "name": "guided", "brief": "Branch in direction of current incumbent.", "value": "6"}, {"caml-name": "PSEUDOCOST", "name": "pseudocost", "brief": "Branch based on the pseudocost of the variable.", "value": "7"}]}, "miqcqoreformmethod": {"name": "miqcqoreformmethod", "brief": "Specifies the reformulation method for mixed-integer quadratic problems.", "is-enumerable": false, "prefix": "MIO_QCQO_REFORMULATION_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The mixed-integer optimizer decides which reformulation method to apply.", "value": "0"}, {"caml-name": "NONE", "name": "none", "brief": "No reformulation method is applied.", "value": "1"}, {"caml-name": "LINEARIZATION", "name": "linearization", "brief": "A reformulation via linearization is applied.", "value": "2"}, {"caml-name": "EIGEN_VAL_METHOD", "name": "eigen_val_method", "brief": "The eigenvalue method is applied.", "value": "3"}, {"caml-name": "DIAG_SDP", "name": "diag_sdp", "brief": "A perturbation of matrix diagonals via the solution of SDPs is applied.", "value": "4"}, {"caml-name": "RELAX_SDP", "name": "relax_sdp", "brief": "A Reformulation based on the solution of an SDP-relaxation of the problem is applied.", "value": "5"}]}, "miodatapermmethod": {"name": "miodatapermmethod", "brief": "Specifies the problem data permutation method for mixed-integer problems.", "is-enumerable": false, "prefix": "MIO_DATA_PERMUTATION_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No problem data permutation is applied.", "value": "0"}, {"caml-name": "CYCLIC_SHIFT", "name": "cyclic_shift", "brief": "A random cyclic shift is applied to permute the problem data.", "value": "1"}, {"caml-name": "RANDOM", "name": "random", "brief": "A random permutation is applied to the problem data.", "value": "2"}]}, "miocontsoltype": {"name": "miocontsoltype", "brief": "Continuous mixed-integer solution type", "is-enumerable": false, "prefix": "MIO_CONT_SOL_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No interior-point or basic solution.", "desc": "No interior-point or basic solution are reported when the mixed-integer optimizer is used.", "value": "0"}, {"caml-name": "ROOT", "name": "root", "brief": "Solutions to the root node problem.", "desc": "The reported interior-point and basic solutions are a solution to the root node problem when mixed-integer optimizer is used.", "value": "1"}, {"caml-name": "ITG", "name": "itg", "brief": "A feasible primal solution.", "desc": "The reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. A solution is only reported in case the problem has a primal feasible solution.", "value": "2"}, {"caml-name": "ITG_REL", "name": "itg_rel", "brief": "A feasible primal solution or a root node solution if the problem is infeasible.", "desc": "In case the problem is primal feasible then the reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. If the problem is primal infeasible, then the solution to the root node problem is reported.", "value": "3"}]}, "miomode": {"name": "miomode", "brief": "Integer restrictions", "is-enumerable": false, "prefix": "MIO_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "IGNORED", "name": "ignored", "brief": "The integer constraints are ignored and the problem is solved as a continuous problem.", "value": "0"}, {"caml-name": "SATISFIED", "name": "satisfied", "brief": "Integer restrictions should be satisfied.", "value": "1"}]}, "mionodeseltype": {"name": "mionodeseltype", "brief": "Mixed-integer node selection types", "is-enumerable": false, "prefix": "MIO_NODE_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer decides the node selection strategy.", "value": "0"}, {"caml-name": "FIRST", "name": "first", "brief": "The optimizer employs a depth first node selection strategy.", "value": "1"}, {"caml-name": "BEST", "name": "best", "brief": "The optimizer employs a best bound node selection strategy.", "value": "2"}, {"caml-name": "PSEUDO", "name": "pseudo", "brief": "The optimizer employs selects the node based on a pseudo cost estimate.", "value": "3"}]}, "miovarseltype": {"name": "miovarseltype", "brief": "Mixed-integer variable selection types", "is-enumerable": false, "prefix": "MIO_VAR_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer decides the variable selection strategy.", "value": "0"}, {"caml-name": "PSEUDOCOST", "name": "pseudocost", "brief": "The optimizer employs pseudocost variable selection.", "value": "1"}, {"caml-name": "STRONG", "name": "strong", "brief": "The optimizer employs strong branching variable selection.", "value": "2"}]}, "mpsformat": {"name": "mpsformat", "brief": "MPS file format type", "is-enumerable": false, "prefix": "MPS_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "STRICT", "name": "strict", "brief": "It is assumed that the input file satisfies the MPS format strictly.", "value": "0"}, {"caml-name": "RELAXED", "name": "relaxed", "brief": "It is assumed that the input file satisfies a slightly relaxed version of the MPS format.", "value": "1"}, {"caml-name": "FREE", "name": "free", "brief": "It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.", "value": "2"}, {"caml-name": "CPLEX", "name": "cplex", "brief": "The CPLEX compatible version of the MPS format is employed.", "value": "3"}]}, "objsense": {"name": "objsense", "brief": "Objective sense types", "is-enumerable": true, "prefix": "OBJECTIVE_SENSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "MINIMIZE", "name": "minimize", "brief": "The problem should be minimized.", "value": "0"}, {"caml-name": "MAXIMIZE", "name": "maximize", "brief": "The problem should be maximized.", "value": "1"}]}, "onoffkey": {"name": "onoffkey", "brief": "On/off", "is-enumerable": false, "prefix": "", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Switch the option on.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Switch the option off.", "value": "0"}]}, "optimizertype": {"name": "optimizertype", "brief": "Optimizer types", "is-enumerable": false, "prefix": "OPTIMIZER_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer is chosen automatically.", "value": "2"}, {"caml-name": "INTPNT", "name": "intpnt", "brief": "The interior-point optimizer is used.", "value": "4"}, {"caml-name": "CONIC", "name": "conic", "brief": "The optimizer for problems having conic constraints.", "value": "0"}, {"caml-name": "PRIMAL_SIMPLEX", "name": "primal_simplex", "brief": "The primal simplex optimizer is used.", "value": "6"}, {"caml-name": "DUAL_SIMPLEX", "name": "dual_simplex", "brief": "The dual simplex optimizer is used.", "value": "1"}, {"caml-name": "FREE_SIMPLEX", "name": "free_simplex", "brief": "One of the simplex optimizers is used.", "value": "3"}, {"caml-name": "MIXED_INT", "name": "mixed_int", "brief": "The mixed-integer optimizer.", "value": "5"}]}, "orderingtype": {"name": "orderingtype", "brief": "Ordering strategies", "is-enumerable": false, "prefix": "ORDER_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The ordering method is chosen automatically.", "value": "0"}, {"caml-name": "APPMINLOC", "name": "appminloc", "brief": "Approximate minimum local fill-in ordering is employed.", "value": "1"}, {"caml-name": "EXPERIMENTAL", "name": "experimental", "brief": "This option should not be used.", "value": "2"}, {"caml-name": "TRY_GRAPHPAR", "name": "try_graphpar", "brief": "Always try the graph partitioning based ordering.", "value": "3"}, {"caml-name": "FORCE_GRAPHPAR", "name": "force_graphpar", "brief": "Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.", "value": "4"}, {"caml-name": "NONE", "name": "none", "brief": "No ordering is used. Note using this value almost always leads to a significantly slow down.", "value": "5"}]}, "presolvemode": {"name": "presolvemode", "brief": "Presolve method.", "is-enumerable": false, "prefix": "PRESOLVE_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "OFF", "name": "off", "brief": "The problem is not presolved before it is optimized.", "value": "0"}, {"caml-name": "ON", "name": "on", "brief": "The problem is presolved before it is optimized.", "value": "1"}, {"caml-name": "FREE", "name": "free", "brief": "It is decided automatically whether to presolve before the problem is optimized.", "value": "2"}]}, "parametertype": {"name": "parametertype", "brief": "Parameter type", "is-enumerable": true, "prefix": "PAR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "INVALID_TYPE", "name": "invalid_type", "brief": "Not a valid parameter.", "value": "0"}, {"caml-name": "DOU_TYPE", "name": "dou_type", "brief": "Is a double parameter.", "value": "1"}, {"caml-name": "INT_TYPE", "name": "int_type", "brief": "Is an integer parameter.", "value": "2"}, {"caml-name": "STR_TYPE", "name": "str_type", "brief": "Is a string parameter.", "value": "3"}]}, "problemitem": {"name": "problemitem", "brief": "Problem data items", "is-enumerable": true, "prefix": "PI_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "VAR", "name": "var", "brief": "Item is a variable.", "value": "0"}, {"caml-name": "CON", "name": "con", "brief": "Item is a constraint.", "value": "1"}, {"caml-name": "CONE", "name": "cone", "brief": "Item is a cone.", "value": "2"}]}, "problemtype": {"name": "problemtype", "brief": "Problem types", "is-enumerable": true, "prefix": "PROBTYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The problem is a linear optimization problem.", "value": "0"}, {"caml-name": "QO", "name": "qo", "brief": "The problem is a quadratic optimization problem.", "value": "1"}, {"caml-name": "QCQO", "name": "qcqo", "brief": "The problem is a quadratically constrained optimization problem.", "value": "2"}, {"caml-name": "CONIC", "name": "conic", "brief": "A conic optimization.", "value": "3"}, {"caml-name": "MIXED", "name": "mixed", "brief": "General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK.", "desc": "General nonlinear constraints and conic constraints. This combination can not be solved by |mosek|.", "value": "4"}]}, "prosta": {"name": "prosta", "brief": "Problem status keys", "is-enumerable": true, "prefix": "PRO_STA_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNKNOWN", "name": "unknown", "brief": "Unknown problem status.", "value": "0"}, {"caml-name": "PRIM_AND_DUAL_FEAS", "name": "prim_and_dual_feas", "brief": "The problem is primal and dual feasible.", "value": "1"}, {"caml-name": "PRIM_FEAS", "name": "prim_feas", "brief": "The problem is primal feasible.", "value": "2"}, {"caml-name": "DUAL_FEAS", "name": "dual_feas", "brief": "The problem is dual feasible.", "value": "3"}, {"caml-name": "PRIM_INFEAS", "name": "prim_infeas", "brief": "The problem is primal infeasible.", "value": "4"}, {"caml-name": "DUAL_INFEAS", "name": "dual_infeas", "brief": "The problem is dual infeasible.", "value": "5"}, {"caml-name": "PRIM_AND_DUAL_INFEAS", "name": "prim_and_dual_infeas", "brief": "The problem is primal and dual infeasible.", "value": "6"}, {"caml-name": "ILL_POSED", "name": "ill_posed", "brief": "The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap.", "value": "7"}, {"caml-name": "PRIM_INFEAS_OR_UNBOUNDED", "name": "prim_infeas_or_unbounded", "brief": "The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems.", "value": "8"}]}, "xmlwriteroutputtype": {"name": "xmlwriteroutputtype", "brief": "XML writer output mode", "is-enumerable": true, "prefix": "WRITE_XML_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ROW", "name": "row", "brief": "Write in row order.", "value": "0"}, {"caml-name": "COL", "name": "col", "brief": "Write in column order.", "value": "1"}]}, "rescode": {"name": "rescode", "brief": "Response codes", "desc": "The enumeration type containing all response codes.", "is-enumerable": true, "prefix": "RES_", "value-type": "int", "values-asgn": "unique", "api-class": "api", "members": [{"caml-name": "OK", "name": "ok", "brief": "No error occurred.", "value": "0", "msg": "No error occurred.", "args": {}}, {"caml-name": "WRN_OPEN_PARAM_FILE", "name": "wrn_open_param_file", "brief": "The parameter file could not be opened.", "value": "50", "msg": "Could not open the parameter file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_LARGE_BOUND", "name": "wrn_large_bound", "brief": "A numerically large bound value is specified.", "value": "51", "msg": "A numerically large bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_LO_BOUND", "name": "wrn_large_lo_bound", "brief": "A numerically large lower bound value is specified.", "value": "52", "msg": "A numerically large lower bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_UP_BOUND", "name": "wrn_large_up_bound", "brief": "A numerically large upper bound value is specified.", "value": "53", "msg": "A numerically large upper bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_CON_FX", "name": "wrn_large_con_fx", "brief": "A equality constraint is fixed to numerically large value.", "desc": "An equality constraint is fixed to a numerically large value. This can cause numerical problems.", "value": "54", "msg": "The equality constraint '%{arg0}' (%{arg1}) is fixed to numerically large value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "e", ["w=8", "j=r", "p=1"]]}}, {"caml-name": "WRN_LARGE_CJ", "name": "wrn_large_cj", "brief": "A numerically large value is specified for one element in c.", "desc": "A numerically large value is specified for one :math:`c_{j}`.", "value": "57", "msg": "A large value of %{arg0} has been specified in c for variable '%{arg1}' (%{arg2}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "WRN_LARGE_AIJ", "name": "wrn_large_aij", "brief": "A numerically large value is specified for an element in A.", "desc": "A numerically large value is specified for an :math:`a_{i,j}` element in :math:`A`.\nThe parameter :msk:dparam:`data_tol_aij_large` controls when an :math:`a_{i,j}` is considered large.", "value": "62", "msg": "The A matrix contains a large value of %{arg0} in constraint '%{arg1}' (%{arg2}) at variable '%{arg3}' (%{arg4}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "WRN_ZERO_AIJ", "name": "wrn_zero_aij", "brief": "One or more zero elements are specified in A.", "value": "63", "msg": "%{arg0} zero element(s) in A are specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_NAME_MAX_LEN", "name": "wrn_name_max_len", "brief": "A name is longer than the buffer that is supposed to hold it.", "value": "65", "msg": "A name of length %{arg0} is longer than the buffer of length %{arg1} that is supposed to hold it.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "WRN_SPAR_MAX_LEN", "name": "wrn_spar_max_len", "brief": "A value for a string parameter is longer than the buffer that is supposed to hold it.", "value": "66", "msg": "A value for a string parameter is longer than the buffer that is supposed to hold it.", "args": {}}, {"caml-name": "WRN_MPS_SPLIT_RHS_VECTOR", "name": "wrn_mps_split_rhs_vector", "brief": "An RHS vector is split into several nonadjacent parts.", "desc": "An RHS vector is split into several nonadjacent parts in an MPS file.", "value": "70", "msg": "The RHS vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MPS_SPLIT_RAN_VECTOR", "name": "wrn_mps_split_ran_vector", "brief": "A RANGE vector is split into several nonadjacent parts in an MPS file.", "value": "71", "msg": "The RANGE vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MPS_SPLIT_BOU_VECTOR", "name": "wrn_mps_split_bou_vector", "brief": "A BOUNDS vector is split into several nonadjacent parts in an MPS file.", "value": "72", "msg": "The BOUNDS vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_LP_OLD_QUAD_FORMAT", "name": "wrn_lp_old_quad_format", "brief": "Missing '/2' after quadratic expressions in bound or objective.", "value": "80", "msg": "Missing '/2' after quadratic expressions in bound or objective.", "args": {}}, {"caml-name": "WRN_LP_DROP_VARIABLE", "name": "wrn_lp_drop_variable", "brief": "Ignore a variable because the variable was not previously defined.", "desc": "Ignored a variable because the variable was not previously defined.\nUsually this implies that a variable appears in the bound section but not in the objective or the constraints.", "value": "85", "msg": "The variable '%{arg0}' is ignored because the variable was not previously defined.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_NZ_IN_UPR_TRI", "name": "wrn_nz_in_upr_tri", "brief": "Non-zero elements specified in the upper triangle of a matrix were ignored.", "value": "200", "msg": "Non-zero elements in the upper triangle of variable '%{arg0}' are ignored.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_DROPPED_NZ_QOBJ", "name": "wrn_dropped_nz_qobj", "brief": "One or more non-zero elements were dropped in the Q matrix in the objective.", "value": "201", "msg": "'%{arg0}' non-zero element(s) are dropped in the Q matrix in the objective.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_IGNORE_INTEGER", "name": "wrn_ignore_integer", "brief": "Ignored integer constraints.", "value": "250", "msg": "Ignored integer constraints.", "args": {}}, {"caml-name": "WRN_NO_GLOBAL_OPTIMIZER", "name": "wrn_no_global_optimizer", "brief": "No global optimizer is available.", "value": "251", "msg": "No global optimizer is available (%{arg0}).", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MIO_INFEASIBLE_FINAL", "name": "wrn_mio_infeasible_final", "brief": "The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.", "value": "270", "msg": "The '%{arg0}' solution reports that final problem with all the integer variables fixed is infeasible while an integer solution has been found.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_SOL_FILTER", "name": "wrn_sol_filter", "brief": "Invalid solution filter is specified.", "value": "300", "msg": "'%{arg0}' is an invalid solution filter is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_UNDEF_SOL_FILE_NAME", "name": "wrn_undef_sol_file_name", "brief": "Undefined name occurred in a solution.", "value": "350", "msg": "'%{arg0}' is an undefined %{arg1} name.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_SOL_FILE_IGNORED_CON", "name": "wrn_sol_file_ignored_con", "brief": "One or more lines in the constraint section were ignored when reading a solution file.", "value": "351", "msg": "%{arg0} lines in the constraint section were ignored when reading a solution file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_SOL_FILE_IGNORED_VAR", "name": "wrn_sol_file_ignored_var", "brief": "One or more lines in the variable section were ignored when reading a solution file.", "value": "352", "msg": "%{arg0} lines in the variable section were ignored when reading a solution file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_TOO_FEW_BASIS_VARS", "name": "wrn_too_few_basis_vars", "brief": "An incomplete basis is specified.", "desc": "An incomplete basis has been specified. Too few basis variables are specified.", "value": "400", "msg": "%{arg1} basis variables are expected but only %{arg0} basis variables are specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "WRN_TOO_MANY_BASIS_VARS", "name": "wrn_too_many_basis_vars", "brief": "A basis with too many variables is specified.", "desc": "A basis with too many variables has been specified.", "value": "405", "msg": "%{arg0} basis variables are specified but %{arg1} are expected.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "WRN_LICENSE_EXPIRE", "name": "wrn_license_expire", "brief": "The license expires.", "value": "500", "msg": "The license expires in %{arg0} days.", "args": {"arg0": ["arg0", "I", []]}}, {"caml-name": "WRN_LICENSE_SERVER", "name": "wrn_license_server", "brief": "The license server is not responding.", "value": "501", "msg": "The license server is not responding.", "args": {}}, {"caml-name": "WRN_EMPTY_NAME", "name": "wrn_empty_name", "brief": "A variable or constraint name is empty. The output file may be invalid.", "value": "502", "msg": "A variable or constraint name is empty. The output file may be invalid.", "args": {}}, {"caml-name": "WRN_USING_GENERIC_NAMES", "name": "wrn_using_generic_names", "brief": "Generic names are used because a name is invalid for requested format.", "desc": "Generic names are used because a name invalid. For instance when writing an LP file the names must not contain blanks or start with a digit.\nAlso remeber to give the objective function a name.", "value": "503", "msg": "Generic names are used because a name is invalid.", "args": {}}, {"caml-name": "WRN_INVALID_MPS_NAME", "name": "wrn_invalid_mps_name", "brief": "A name e.g. a row name is not a valid MPS name.", "value": "504", "msg": "A name e.g. a row name is not a valid MPS name.", "args": {}}, {"caml-name": "WRN_INVALID_MPS_OBJ_NAME", "name": "wrn_invalid_mps_obj_name", "brief": "The objective name is not a valid MPS name.", "value": "505", "msg": "The objective name is not a valid MPS name.", "args": {}}, {"caml-name": "WRN_LICENSE_FEATURE_EXPIRE", "name": "wrn_license_feature_expire", "brief": "The license expires.", "value": "509", "msg": "The license feature '%{arg0}' expires in %{arg1} days.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "I", []]}}, {"caml-name": "WRN_PARAM_NAME_DOU", "name": "wrn_param_name_dou", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a double parameter.", "value": "510", "msg": "The parameter name '%{arg0}' is not recognized as a double parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_NAME_INT", "name": "wrn_param_name_int", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a integer parameter.", "value": "511", "msg": "The parameter name '%{arg0}' is not recognized as an integer parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_NAME_STR", "name": "wrn_param_name_str", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a string parameter.", "value": "512", "msg": "The parameter name '%{arg0}' is not recognized as a string parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_STR_VALUE", "name": "wrn_param_str_value", "brief": "A parameter value is not correct.", "desc": "The string is not recognized as a symbolic value for the parameter.", "value": "515", "msg": "The value '%{arg0}' is not valid for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_PARAM_IGNORED_CMIO", "name": "wrn_param_ignored_cmio", "brief": "A parameter was ignored by the conic mixed integer optimizer.", "value": "516", "msg": "The parameter '%{arg0}' was ignored by the conic mixed integer optimizer.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_ZEROS_IN_SPARSE_ROW", "name": "wrn_zeros_in_sparse_row", "brief": "One or more (near) zero elements are specified in a sparse row of a matrix.", "desc": "One or more (near) zero elements are specified in a sparse row of a matrix. Since, it\nis redundant to specify zero elements then it may indicate an error.", "value": "705", "msg": "%{arg0} (nearly) zero elements are specified in sparse row '%{arg1}'(%{arg2}) of matrix '%{arg3}'.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "WRN_ZEROS_IN_SPARSE_COL", "name": "wrn_zeros_in_sparse_col", "brief": "One or more (near) zero elements are specified in a sparse column of a matrix.", "desc": "One or more (near) zero elements are specified in a sparse column of a matrix.\nIt is redundant to specify zero elements. Hence, it may indicate an error.", "value": "710", "msg": "#%{arg0} (nearly) zero elements are specified in sparse col '%{arg1}' (%{arg2}) of matrix '%{arg3}'.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK", "name": "wrn_incomplete_linear_dependency_check", "brief": "The linear dependency check(s) is incomplete.", "desc": "The linear dependency check(s) is incomplete. Normally\nthis is not an important warning unless the optimization\nproblem has been formulated with linear\ndependencies. Linear dependencies may prevent |mosek| from\nsolving the problem.", "value": "800", "msg": "The linear dependency check(s) is incomplete. Either it was too costly or numerical problems prevented it.", "args": {}}, {"caml-name": "WRN_ELIMINATOR_SPACE", "name": "wrn_eliminator_space", "brief": "The eliminator is skipped at least once due to lack of space.", "value": "801", "msg": "The eliminator is skipped at least once due to lack of space.", "args": {}}, {"caml-name": "WRN_PRESOLVE_OUTOFSPACE", "name": "wrn_presolve_outofspace", "brief": "The presolve is incomplete due to lack of space.", "value": "802", "msg": "The presolve is incomplete due to lack of space.", "args": {}}, {"caml-name": "WRN_PRESOLVE_PRIMAL_PERTUBATIONS", "name": "wrn_presolve_primal_pertubations", "brief": "The presolve perturbed the bounds of the primal problem. This is an indication that the problem is nearly infeasible.", "value": "803", "msg": "The bounds of the constraints and variables was perturbed. The number of perturbations was %num and the total pertubation was %total.", "args": {"num": ["num", "i", []], "total": ["total", "e", ["p=2"]]}}, {"caml-name": "WRN_WRITE_CHANGED_NAMES", "name": "wrn_write_changed_names", "brief": "Some names were changed because they were invalid for the output file format.", "value": "830", "msg": "Some names were changed because they were invalid for the output file format.", "args": {}}, {"caml-name": "WRN_WRITE_DISCARDED_CFIX", "name": "wrn_write_discarded_cfix", "brief": "The fixed objective term was discarded in the output file.", "desc": "The fixed objective term could not be converted to a variable and was discarded in the output file.", "value": "831", "msg": "The fixed objective term was discarded in the output file.", "args": {}}, {"caml-name": "WRN_DUPLICATE_CONSTRAINT_NAMES", "name": "wrn_duplicate_constraint_names", "brief": "Two constraint names are identical.", "value": "850", "msg": "Constraint number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_VARIABLE_NAMES", "name": "wrn_duplicate_variable_names", "brief": "Two variable names are identical.", "value": "851", "msg": "Variable %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_BARVARIABLE_NAMES", "name": "wrn_duplicate_barvariable_names", "brief": "Two barvariable names are identical.", "value": "852", "msg": "Barvariable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_CONE_NAMES", "name": "wrn_duplicate_cone_names", "brief": "Two cone names are identical.", "value": "853", "msg": "Cone number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_WRITE_LP_INVALID_VAR_NAMES", "name": "wrn_write_lp_invalid_var_names", "brief": "LP file will be written with generic variable names.", "value": "854", "msg": "Variable name '%name' (%i) is not a valid LP name: Writing generic variable names.", "args": {"name": ["name", "s", []], "i": ["i", "i", []]}}, {"caml-name": "WRN_WRITE_LP_DUPLICATE_VAR_NAMES", "name": "wrn_write_lp_duplicate_var_names", "brief": "LP file will be written with generic variable names.", "value": "855", "msg": "Variable %i and %j have the same name ('%name'): Writing generic variable names.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_WRITE_LP_INVALID_CON_NAMES", "name": "wrn_write_lp_invalid_con_names", "brief": "LP file will be written with generic constraint names.", "value": "856", "msg": "Constraint name '%name' (%i) is not a valid LP name: Writing generic constraint names.", "args": {"name": ["name", "s", []], "i": ["i", "i", []]}}, {"caml-name": "WRN_WRITE_LP_DUPLICATE_CON_NAMES", "name": "wrn_write_lp_duplicate_con_names", "brief": "LP file will be written with generic constraint names.", "value": "857", "msg": "Constraint %i and %j have the same name ('%name'): Writing generic constraint names.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_ANA_LARGE_BOUNDS", "name": "wrn_ana_large_bounds", "brief": "Warn against very large bounds.", "desc": "This warning is issued by the problem analyzer, if one or more constraint or variable bounds are very large.\nOne should consider omitting these bounds entirely by setting them to +inf or -inf.", "value": "900", "msg": "The problem analyzer found %{arg0} large %{arg1} bound%{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "WRN_ANA_C_ZERO", "name": "wrn_ana_c_zero", "brief": "Warn against all objective coefficients being zero.", "desc": "This warning is issued by the problem analyzer, if the coefficients in the linear part of the objective are all zero.", "value": "901", "msg": "The problem analyzer found all objective coefficients to be zero.", "args": {}}, {"caml-name": "WRN_ANA_EMPTY_COLS", "name": "wrn_ana_empty_cols", "brief": "Warn against empty columns.", "desc": "This warning is issued by the problem analyzer, if columns, in which all coefficients are zero, are found.", "value": "902", "msg": "The problem analyzer found %{arg0} empty column%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_ANA_CLOSE_BOUNDS", "name": "wrn_ana_close_bounds", "brief": "Warn against close bounds.", "desc": "This warning is issued by problem analyzer, if ranged\nconstraints or variables with very close upper and lower\nbounds are detected.  One should consider treating such\nconstraints as equalities and such variables as\nconstants.", "value": "903", "msg": "The problem analyzer found %{arg0} %{arg1} with upper and lower bounds differing less than %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "e", []]}}, {"caml-name": "WRN_ANA_ALMOST_INT_BOUNDS", "name": "wrn_ana_almost_int_bounds", "brief": "Warn against almost integral bounds.", "desc": "This warning is issued by the problem analyzer if a\nconstraint is bound nearly integral.", "value": "904", "msg": "The problem analyzer found %{arg0} constraint bounds differing less than %{arg1} from an integer.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "e", []]}}, {"caml-name": "WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES", "name": "wrn_no_infeasibility_report_when_matrix_variables", "brief": "An infeasibility report is not available when the problem contains matrix variables.", "value": "930", "msg": "An infeasibility report is not available when the problem contains matrix variables.", "args": {}}, {"caml-name": "WRN_NO_DUALIZER", "name": "wrn_no_dualizer", "brief": "No automatic dualizer is available for the specified problem.", "desc": "No automatic dualizer is available for the specified problem. The primal problem is solved.", "value": "950", "msg": "No automatic dualizer is available for the specified problem.", "args": {}}, {"caml-name": "WRN_SYM_MAT_LARGE", "name": "wrn_sym_mat_large", "brief": "A numerically large value is specified for an element in E.", "desc": "A numerically large value is specified for an :math:`e_{i,j}` element in :math:`E`.\nThe parameter :msk:dparam:`data_sym_mat_tol_large` controls when an :math:`e_{i,j}` is considered large.", "value": "960", "msg": "E[%{arg1},%{arg2}] = %{arg0} is large in absolute size.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "WRN_MODIFIED_DOUBLE_PARAMETER", "name": "wrn_modified_double_parameter", "brief": "A double parameter related to solver tolerances has a non-default value.", "value": "970", "msg": "The double parameter %{arg0} has value %{arg1} instead of default value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "e", ["j=r", "p=1"]], "arg2": ["arg2", "e", ["j=r", "p=1"]]}}, {"caml-name": "WRN_LARGE_FIJ", "name": "wrn_large_fij", "brief": "A numerically large value is specified for an element in F.", "desc": "A numerically large value is specified for an :math:`f_{i,j}` element in :math:`F`.\nThe parameter :msk:dparam:`data_tol_aij_large` controls when an :math:`f_{i,j}` is considered large.", "value": "980", "msg": "The F matrix contains a large value of %{arg0} in row %{arg1} and column %{arg2}.", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "l", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_LICENSE", "name": "err_license", "brief": "Invalid license.", "value": "1000", "msg": "Invalid license.", "args": {}}, {"caml-name": "ERR_LICENSE_EXPIRED", "name": "err_license_expired", "brief": "The license has expired.", "value": "1001", "msg": "The license has expired.", "args": {}}, {"caml-name": "ERR_LICENSE_VERSION", "name": "err_license_version", "brief": "Invalid license version.", "desc": "The license is valid for another version of |mosek|.", "value": "1002", "msg": "Feature %{arg0} version %{arg1} is not supported by the license file.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_LICENSE_OLD_SERVER_VERSION", "name": "err_license_old_server_version", "brief": "The license server version is too old.", "desc": "The version of the FlexLM license server is too old. You should upgrade the license server to one matching this version of |mosek|. It will support this and all older versions of |mosek|.\n\nThis error can appear if the client was updated to a new version which includes an upgrade of the licensing module, making it incompatible with a much older license server.", "value": "1003", "msg": "The license server version is too old to support this client. Upgrade the license server binaries using the latest Mosek distribution to fully support this and older Mosek versions.", "args": {}}, {"caml-name": "ERR_SIZE_LICENSE", "name": "err_size_license", "brief": "The problem is bigger than the license.", "value": "1005", "msg": "The problem is bigger than the license.", "args": {}}, {"caml-name": "ERR_PROB_LICENSE", "name": "err_prob_license", "brief": "The software is not licensed to solve the problem.", "value": "1006", "msg": "The software is not licensed to solve the problem.", "args": {}}, {"caml-name": "ERR_FILE_LICENSE", "name": "err_file_license", "brief": "Invalid license file.", "value": "1007", "msg": "Invalid license file.", "args": {}}, {"caml-name": "ERR_MISSING_LICENSE_FILE", "name": "err_missing_license_file", "brief": "A license cannot be located.", "desc": "|mosek| cannot find license file or a token server. See the |mosek| licensing manual for details.", "value": "1008", "msg": "License cannot be located. The default search path is '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_CON", "name": "err_size_license_con", "brief": "The problem has too many constraints.", "desc": "The problem has too many constraints to be solved with the available license.", "value": "1010", "msg": "The problem has %{arg0} constraint(s) but the license allows only %{arg1} constraint(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_VAR", "name": "err_size_license_var", "brief": "The problem has too many variables.", "desc": "The problem has too many variables to be solved with the available license.", "value": "1011", "msg": "The problem has %{arg0} scalar variable(s) but the license allows only %{arg1} scalar variable(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_INTVAR", "name": "err_size_license_intvar", "brief": "The problem contains too many integer variables.", "desc": "The problem contains too many integer variables to be solved with the available license.", "value": "1012", "msg": "The problem contains %{arg0} integer variable(s) but the license allows only %{arg1} integer variable(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_OPTIMIZER_LICENSE", "name": "err_optimizer_license", "brief": "The optimizer required is not licensed.", "value": "1013", "msg": "The optimizer required is not licensed.", "args": {}}, {"caml-name": "ERR_FLEXLM", "name": "err_flexlm", "brief": "The license manager reported an error.", "desc": "The |flexlm| license manager reported an error.", "value": "1014", "msg": "The license manager reported '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_SERVER", "name": "err_license_server", "brief": "The license server is not responding.", "value": "1015", "msg": "The license server is not responding.", "args": {}}, {"caml-name": "ERR_LICENSE_MAX", "name": "err_license_max", "brief": "Maximum number of licenses is reached.", "value": "1016", "msg": "Maximum number of licenses is reached for feature '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_MOSEKLM_DAEMON", "name": "err_license_moseklm_daemon", "brief": "The MOSEKLM license manager daemon is not up and running.", "value": "1017", "msg": "The MOSEKLM license manager daemon is not up and running.", "args": {}}, {"caml-name": "ERR_LICENSE_FEATURE", "name": "err_license_feature", "brief": "A requested feature is not available in the license file(s).", "desc": "A requested feature is not available in the license file(s). Most likely due to an incorrect license system setup.", "value": "1018", "msg": "The feature '%{arg0}' is not in license file. Consult the license manager error message.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PLATFORM_NOT_LICENSED", "name": "err_platform_not_licensed", "brief": "A requested license feature is not available for the required platform.", "value": "1019", "msg": "No license feature '%{arg0}' for the required platform is available.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_CANNOT_ALLOCATE", "name": "err_license_cannot_allocate", "brief": "The license system cannot allocate the memory required.", "value": "1020", "msg": "The license system cannot allocate the memory required.", "args": {}}, {"caml-name": "ERR_LICENSE_CANNOT_CONNECT", "name": "err_license_cannot_connect", "brief": "MOSEK cannot connect to the license server.", "desc": "|mosek| cannot connect to the license server.\nMost likely the license server is not up and running.", "value": "1021", "msg": "MOSEK cannot connect to the license server.", "args": {}}, {"caml-name": "ERR_LICENSE_INVALID_HOSTID", "name": "err_license_invalid_hostid", "brief": "The host ID specified in the license file does not match the host ID of the computer.", "value": "1025", "msg": "The host ID specified in the license file does not match the host ID of the computer.", "args": {}}, {"caml-name": "ERR_LICENSE_SERVER_VERSION", "name": "err_license_server_version", "brief": "The version specified in the checkout request is greater than the highest version number the daemon supports.", "value": "1026", "msg": "The version specified in the checkout request is greater than the highest version number the daemon supports. Please upgrade the license server to the same version distributed with the mosek version that your are running.", "args": {}}, {"caml-name": "ERR_LICENSE_NO_SERVER_SUPPORT", "name": "err_license_no_server_support", "brief": "The license server does not support the requested feature.", "desc": "The license server does not support the requested feature.\nPossible reasons for this error include:\n\n* The feature has expired.\n* The feature's start date is later than today's date.\n* The version requested is higher than feature's the highest supported version.\n* A corrupted license file.\n\nTry restarting the license and inspect the license server debug file, usually called ``lmgrd.log``.", "value": "1027", "msg": "The license server does not support the requested feature '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_NO_SERVER_LINE", "name": "err_license_no_server_line", "brief": "No SERVER lines in license file.", "desc": "There is no ``SERVER`` line in the license file. All non-zero license count features need at least one ``SERVER`` line.", "value": "1028", "msg": "No SERVER lines in license file.", "args": {}}, {"caml-name": "ERR_OLDER_DLL", "name": "err_older_dll", "brief": "The dynamic link library is older than the specified version.", "value": "1035", "msg": "The dynamic link library version %{arg0}.%{arg1}.%{arg2}.%{arg3} is older than expected version %{arg4}.%{arg5}.%{arg6}.%{arg7}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "i", []], "arg5": ["arg5", "i", []], "arg6": ["arg6", "i", []], "arg7": ["arg7", "i", []]}}, {"caml-name": "ERR_NEWER_DLL", "name": "err_newer_dll", "brief": "The dynamic link library is newer than the specified version.", "value": "1036", "msg": "The dynamic link library version %{arg0}.%{arg1}.%{arg2}.%{arg3} is newer than version %{arg4}.%{arg5}.%{arg6}.%{arg7}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "i", []], "arg5": ["arg5", "i", []], "arg6": ["arg6", "i", []], "arg7": ["arg7", "i", []]}}, {"caml-name": "ERR_LINK_FILE_DLL", "name": "err_link_file_dll", "brief": "A file cannot be linked to a stream in the DLL version.", "value": "1040", "msg": "A file cannot be linked to a stream in the DLL version.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_INIT", "name": "err_thread_mutex_init", "brief": "Could not initialize a mutex.", "value": "1045", "msg": "Could not initialize a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_LOCK", "name": "err_thread_mutex_lock", "brief": "Could not lock a mutex.", "value": "1046", "msg": "Could not lock a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_UNLOCK", "name": "err_thread_mutex_unlock", "brief": "Could not unlock a mutex.", "value": "1047", "msg": "Could not unlock a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_CREATE", "name": "err_thread_create", "brief": "Could not create a thread.", "desc": "Could not create a thread. This error may occur if a large\nnumber of environments are created and not deleted again.\nIn any case it is a good practice to minimize the number of\nenvironments created.", "value": "1048", "msg": "Could not create a thread. System error code: %{arg0}", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_THREAD_COND_INIT", "name": "err_thread_cond_init", "brief": "Could not initialize a condition.", "value": "1049", "msg": "Could not initialize a condition.", "args": {}}, {"caml-name": "ERR_UNKNOWN", "name": "err_unknown", "brief": "Unknown error.", "value": "1050", "msg": "Unknown error.", "args": {}}, {"caml-name": "ERR_SPACE", "name": "err_space", "brief": "Out of space.", "value": "1051", "msg": "A (potentially) large memory allocation has failed.", "args": {}}, {"caml-name": "ERR_FILE_OPEN", "name": "err_file_open", "brief": "An error occurred while opening a file.", "desc": "Error while opening a file.", "value": "1052", "msg": "An error occurred while opening file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FILE_READ", "name": "err_file_read", "brief": "An error occurred while reading file.", "desc": "File read error.", "value": "1053", "msg": "An error occurred while reading file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FILE_WRITE", "name": "err_file_write", "brief": "An error occurred while writing to a file.", "desc": "File write error.", "value": "1054", "msg": "An error occurred while writing to file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_DATA_FILE_EXT", "name": "err_data_file_ext", "brief": "The data file format cannot be determined from the file name.", "value": "1055", "msg": "The data file format cannot be determined from the file name '%{arg0}'", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_FILE_NAME", "name": "err_invalid_file_name", "brief": "An invalid file name has been specified.", "value": "1056", "msg": "'%{arg0}' is an invalid file name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_SOL_FILE_NAME", "name": "err_invalid_sol_file_name", "brief": "An invalid file name has been specified.", "value": "1057", "msg": "'%{arg0}' is invalid solution file name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_END_OF_FILE", "name": "err_end_of_file", "brief": "End of file reached.", "value": "1059", "msg": "End of file reached.", "args": {}}, {"caml-name": "ERR_NULL_ENV", "name": "err_null_env", "brief": "env is a null pointer.", "desc": "``env`` is a |null| pointer.", "value": "1060", "msg": "env is a null pointer.", "args": {}}, {"caml-name": "ERR_NULL_TASK", "name": "err_null_task", "brief": "task is a null pointer.", "desc": "``task`` is a |null| pointer.", "value": "1061", "msg": "task is a null pointer.", "args": {}}, {"caml-name": "ERR_INVALID_STREAM", "name": "err_invalid_stream", "brief": "An invalid stream is referenced.", "value": "1062", "msg": "%{arg0} is an invalid stream.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_INIT_ENV", "name": "err_no_init_env", "brief": "Environment is not initialized.", "desc": "``env`` is not initialized.", "value": "1063", "msg": "Environment is not initialized.", "args": {}}, {"caml-name": "ERR_INVALID_TASK", "name": "err_invalid_task", "brief": "The task is invalid.", "desc": "The ``task`` is invalid.", "value": "1064", "msg": "The task is invalid.", "args": {}}, {"caml-name": "ERR_NULL_POINTER", "name": "err_null_pointer", "brief": "An argument to a function is unexpectedly a null pointer.", "desc": "An argument to a function is unexpectedly a |null| pointer.", "value": "1065", "msg": "Argument '%{arg0}' is unexpectedly a null pointer.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LIVING_TASKS", "name": "err_living_tasks", "brief": "Not all tasks associated with the environment have been deleted.", "desc": "All tasks associated with an enviroment must be deleted\nbefore the environment is deleted. There are still some undeleted tasks.", "value": "1066", "msg": "Not all tasks associated with the environment have been deleted.", "args": {}}, {"caml-name": "ERR_READ_GZIP", "name": "err_read_gzip", "brief": "Error encountered in GZIP stream.", "value": "1067", "msg": "Encountered error %{code} in GZIP stream", "args": {"code": ["code", "i", []]}}, {"caml-name": "ERR_READ_ZSTD", "name": "err_read_zstd", "brief": "Error encountered in ZSTD stream.", "value": "1068", "msg": "Encountered error %{code} in GZIP stream", "args": {"code": ["code", "i", []]}}, {"caml-name": "ERR_BLANK_NAME", "name": "err_blank_name", "brief": "An all blank name has been specified.", "value": "1070", "msg": "An all blank name has been specified.", "args": {}}, {"caml-name": "ERR_DUP_NAME", "name": "err_dup_name", "brief": "Duplicate names specified.", "desc": "The same name was used multiple times for the same problem item type.", "value": "1071", "msg": "Name '%{arg0}' is already assigned for an item %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_FORMAT_STRING", "name": "err_format_string", "brief": "The name format string is invalid.", "value": "1072", "msg": "The format string '%{fmt}' is invalid at position %{pos} in argument '%{arg}'.", "args": {"fmt": ["fmt", "s", []], "pos": ["pos", "i", []], "arg": ["arg", "s", []]}}, {"caml-name": "ERR_SPARSITY_SPECIFICATION", "name": "err_sparsity_specification", "brief": "The sparsity included an index that was out of bounds of the shape.", "value": "1073", "msg": "The sparsity specification is invalid.", "args": {}}, {"caml-name": "ERR_MISMATCHING_DIMENSION", "name": "err_mismatching_dimension", "brief": "Mismatching dimensions specified in arguments", "value": "1074", "msg": "Mismatching dimensions specified in %{arg0} and %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INVALID_OBJ_NAME", "name": "err_invalid_obj_name", "brief": "An invalid objective name is specified.", "value": "1075", "msg": "'%{arg0}' is an invalid objective name is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_CON_NAME", "name": "err_invalid_con_name", "brief": "An invalid constraint name is used.", "value": "1076", "msg": "'%{arg0}' is an invalid name for constraint number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_VAR_NAME", "name": "err_invalid_var_name", "brief": "An invalid variable name is used.", "value": "1077", "msg": "'%{arg0}' is an invalid name for variable number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_CONE_NAME", "name": "err_invalid_cone_name", "brief": "An invalid cone name is used.", "value": "1078", "msg": "'%{arg0}' is an invalid name for cone number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_BARVAR_NAME", "name": "err_invalid_barvar_name", "brief": "An invalid symmetric matrix variable name is used.", "value": "1079", "msg": "'%{arg0}' is an invalid name for symmetric matrix variable number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SPACE_LEAKING", "name": "err_space_leaking", "brief": "MOSEK is leaking memory.", "desc": "|mosek| is leaking memory. This can be due to either an incorrect use of |mosek| or a bug.", "value": "1080", "msg": "MOSEK is leaking memory.", "args": {}}, {"caml-name": "ERR_SPACE_NO_INFO", "name": "err_space_no_info", "brief": "No available information about the space usage.", "value": "1081", "msg": "No available information about the space usage.", "args": {}}, {"caml-name": "ERR_DIMENSION_SPECIFICATION", "name": "err_dimension_specification", "brief": "Invalid dimension specification", "value": "1082", "msg": "Invalid dimension specification in %{arg}.", "args": {"arg": ["arg", "s", []]}}, {"caml-name": "ERR_AXIS_NAME_SPECIFICATION", "name": "err_axis_name_specification", "brief": "Invalid axis names specification", "value": "1083", "msg": "Invalid axis names specification.", "args": {}}, {"caml-name": "ERR_READ_FORMAT", "name": "err_read_format", "brief": "The specified format cannot be read.", "value": "1090", "msg": "The specified format cannot be read. The format code is %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_FILE", "name": "err_mps_file", "brief": "An error occurred while reading an MPS file.", "value": "1100", "msg": "An error occurred while reading an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_INV_FIELD", "name": "err_mps_inv_field", "brief": "Invalid field occurred while reading an MPS file.", "desc": "A field in the MPS file is invalid. Probably it is too wide.", "value": "1101", "msg": "Field number %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_INV_MARKER", "name": "err_mps_inv_marker", "brief": "An invalid marker has been specified in the MPS file.", "value": "1102", "msg": "An invalid marker has been specified in the MPS file.", "args": {}}, {"caml-name": "ERR_MPS_NULL_CON_NAME", "name": "err_mps_null_con_name", "brief": "An empty constraint name is used in an MPS file.", "value": "1103", "msg": "An empty constraint name is used in an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_NULL_VAR_NAME", "name": "err_mps_null_var_name", "brief": "An empty variable name is used in an MPS file.", "value": "1104", "msg": "An empty variable name is used in an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_UNDEF_CON_NAME", "name": "err_mps_undef_con_name", "brief": "An undefined constraint name occurred in an MPS file.", "value": "1105", "msg": "'%{arg0}' is an undefined constraint name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_UNDEF_VAR_NAME", "name": "err_mps_undef_var_name", "brief": "An undefined variable name occurred in an MPS file.", "value": "1106", "msg": "'%{arg0}' is an undefined variable name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_CON_KEY", "name": "err_mps_invalid_con_key", "brief": "An invalid constraint key occurred in an MPS file.", "value": "1107", "msg": "'%{arg0}' is an invalid constraint key for constraint '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_BOUND_KEY", "name": "err_mps_invalid_bound_key", "brief": "An invalid bound key occurred in an MPS file.", "value": "1108", "msg": "'%{arg0}' is an invalid bound key.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_SEC_NAME", "name": "err_mps_invalid_sec_name", "brief": "An invalid section name occurred in an MPS file.", "value": "1109", "msg": "An invalid section name was used.", "args": {}}, {"caml-name": "ERR_MPS_NO_OBJECTIVE", "name": "err_mps_no_objective", "brief": "No objective is defined in an MPS file.", "value": "1110", "msg": "No objective was defined.", "args": {}}, {"caml-name": "ERR_MPS_SPLITTED_VAR", "name": "err_mps_splitted_var", "brief": "The non-zero elements in A corresponding to a variable in an MPS file must be specified consecutively.", "desc": "All elements in a column of the :math:`A` matrix must be specified consecutively.  Hence, it is illegal to specify non-zero elements in :math:`A` for variable 1, then for variable 2 and then variable 1 again.", "value": "1111", "msg": "The non-zero elements in a column of A for variable '%{arg0}' is not specified consecutively.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_CON_NAME", "name": "err_mps_mul_con_name", "brief": "A constraint name is specified multiple times in the ROWS section in an MPS file.", "desc": "A constraint name was specified multiple times in the ``ROWS`` section.", "value": "1112", "msg": "The constraint name '%{arg0}' was specified multiple times in the ROWS section.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_QSEC", "name": "err_mps_mul_qsec", "brief": "Multiple QSECTIONs are specified for a constraint.", "desc": "Multiple ``QSECTION``\\ s are specified for a constraint in the MPS data file.", "value": "1113", "msg": "Multiple QSECTIONs are specified for a constraint '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_QOBJ", "name": "err_mps_mul_qobj", "brief": "The Q term in the objective is specified multiple times.", "desc": "The Q term in the objective\nis specified multiple times in the MPS data file.", "value": "1114", "msg": "The Q term in the objective is specified multiple times.", "args": {}}, {"caml-name": "ERR_MPS_INV_SEC_ORDER", "name": "err_mps_inv_sec_order", "brief": "The sections in an MPS file is not in the correct order.", "desc": "The sections in the MPS data file\nare not in the correct order.", "value": "1115", "msg": "Section '%{arg0}' was not expected.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_CSEC", "name": "err_mps_mul_csec", "brief": "Multiple CSECTIONs are given the same name.", "desc": "Multiple ``CSECTION``\\ s are given the same name.", "value": "1116", "msg": "Multiple CSECTIONs are given the name '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_CONE_TYPE", "name": "err_mps_cone_type", "brief": "Invalid cone type specified in a  CSECTION.", "desc": "Invalid cone type specified in a ``CSECTION``\\ .", "value": "1117", "msg": "'%{arg0}' is an invalid cone type in a CSECTION.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_CONE_OVERLAP", "name": "err_mps_cone_overlap", "brief": "A variable is specified to be a member of several cones.", "value": "1118", "msg": "Variable '%{arg0}' is specified to be a member of CSECTION '%{arg1}' and CSECTION '%{arg2}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_MPS_CONE_REPEAT", "name": "err_mps_cone_repeat", "brief": "A variable is repeated within the CSECTION.", "desc": "A variable is repeated within the ``CSECTION``\\ .", "value": "1119", "msg": "Variable '%{arg0}' is repeated in CSECTION '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MPS_NON_SYMMETRIC_Q", "name": "err_mps_non_symmetric_q", "brief": "A non symmetric matrix has been speciefied.", "value": "1120", "msg": "A Q matrix is not symmetric at row '%{rowname}' and column '%{colname}'.", "args": {"rowname": ["rowname", "s", []], "colname": ["colname", "s", []]}}, {"caml-name": "ERR_MPS_DUPLICATE_Q_ELEMENT", "name": "err_mps_duplicate_q_element", "brief": "Duplicate elements is specified in a Q matrix.", "desc": "Duplicate elements is specfied in a :math:`Q` matrix.", "value": "1121", "msg": "An element at row '%{rowname}' and column '%{colname}' is specfied twice.", "args": {"rowname": ["rowname", "s", []], "colname": ["colname", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_OBJSENSE", "name": "err_mps_invalid_objsense", "brief": "An invalid objective sense is specified.", "value": "1122", "msg": "'%{arg0}' is an invalid objective sense.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD2", "name": "err_mps_tab_in_field2", "brief": "A tab char occurred in field 2.", "value": "1125", "msg": "A tab char occurred in field 2.", "args": {}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD3", "name": "err_mps_tab_in_field3", "brief": "A tab char occurred in field 3.", "value": "1126", "msg": "A tab char occurred in field 3.", "args": {}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD5", "name": "err_mps_tab_in_field5", "brief": "A tab char occurred in field 5.", "value": "1127", "msg": "A tab char occurred in field 5.", "args": {}}, {"caml-name": "ERR_MPS_INVALID_OBJ_NAME", "name": "err_mps_invalid_obj_name", "brief": "An invalid objective name is specified.", "value": "1128", "msg": "'%{arg0}' is an invalid objective name is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_KEY", "name": "err_mps_invalid_key", "brief": "An invalid indicator key occurred in an MPS file.", "value": "1129", "msg": "'%{arg0}' is an invalid indicator key.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_CONSTRAINT", "name": "err_mps_invalid_indicator_constraint", "brief": "An invalid indicator constraint is used. It must not be a ranged constraint.", "value": "1130", "msg": "Constraint '%{arg0}' is an invalid indicator constraint.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_VARIABLE", "name": "err_mps_invalid_indicator_variable", "brief": "An invalid indicator variable is specfied. It must be a binary variable.", "value": "1131", "msg": "Variable '%{arg0}' (index=%{arg1}) is an invalid indicator.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_VALUE", "name": "err_mps_invalid_indicator_value", "brief": "An invalid indicator value is specfied. It must be either 0 or 1.", "value": "1132", "msg": "'%{arg0}' is an invalid indicator value.", "args": {"arg0": ["arg0", "e", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT", "name": "err_mps_invalid_indicator_quadratic_constraint", "brief": "A quadratic constraint can be be an indicator constraint.", "value": "1133", "msg": "Constraint '%{arg0}' is quadratic which is invalid for an indicator constraint.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_OPF_SYNTAX", "name": "err_opf_syntax", "brief": "Syntax error in an OPF file", "value": "1134", "msg": "Syntax error in an OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_PREMATURE_EOF", "name": "err_opf_premature_eof", "brief": "Premature end of file in an OPF file.", "value": "1136", "msg": "Premature end of file in an OPF file.", "args": {}}, {"caml-name": "ERR_OPF_MISMATCHED_TAG", "name": "err_opf_mismatched_tag", "brief": "Mismatched end-tag in OPF file", "value": "1137", "msg": "Mismatched end-tag in an OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_BOUND", "name": "err_opf_duplicate_bound", "brief": "Either upper or lower bound was specified twice in OPF file", "value": "1138", "msg": "Either upper or lower bound already specified at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_CONSTRAINT_NAME", "name": "err_opf_duplicate_constraint_name", "brief": "Duplicate constraint name in OPF File", "value": "1139", "msg": "Constraint name re-defined in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INVALID_CONE_TYPE", "name": "err_opf_invalid_cone_type", "brief": "Invalid cone type in OPF File", "value": "1140", "msg": "Invalid cone type in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INCORRECT_TAG_PARAM", "name": "err_opf_incorrect_tag_param", "brief": "Invalid number of parameters in start-tag in OPF File", "value": "1141", "msg": "Invalid number of parameters in start-tag in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INVALID_TAG", "name": "err_opf_invalid_tag", "brief": "Invalid start-tag in OPF File", "value": "1142", "msg": "Invalid start-tag in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_CONE_ENTRY", "name": "err_opf_duplicate_cone_entry", "brief": "Same variable appears in multiple cones in OPF File", "value": "1143", "msg": "Variable already member of a cone OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_TOO_LARGE", "name": "err_opf_too_large", "brief": "The problem is too large to be correctly loaded", "value": "1144", "msg": "The problem contains too many %{arg0} to load correctly.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_OPF_DUAL_INTEGER_SOLUTION", "name": "err_opf_dual_integer_solution", "brief": "Dual solution values are not allowed in OPF File", "value": "1146", "msg": "Dual solution values are not allowed in OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_LP_EMPTY", "name": "err_lp_empty", "brief": "The problem cannot be written to an LP formatted file.", "value": "1151", "msg": "A problem with no variables or constraints cannot be written to a LP formatted file.", "args": {}}, {"caml-name": "ERR_WRITE_MPS_INVALID_NAME", "name": "err_write_mps_invalid_name", "brief": "An invalid name is created while writing an MPS file.", "desc": "An invalid name is created while writing an MPS file. Usually this will make the MPS file unreadable.", "value": "1153", "msg": "The name '%{arg0}' is not a valid MPS name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LP_INVALID_VAR_NAME", "name": "err_lp_invalid_var_name", "brief": "A variable name is invalid when used in an LP formatted file.", "value": "1154", "msg": "The variable name '%{arg0}' cannot be written to an LP formatted file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_WRITE_OPF_INVALID_VAR_NAME", "name": "err_write_opf_invalid_var_name", "brief": "Empty variable names cannot be written to OPF files.", "value": "1156", "msg": "Name of variable index %{arg0} is empty and cannot be written to an OPF file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LP_FILE_FORMAT", "name": "err_lp_file_format", "brief": "Syntax error in an LP file.", "value": "1157", "msg": "Syntax error in an LP file at: %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []]}}, {"caml-name": "ERR_LP_EXPECTED_NUMBER", "name": "err_lp_expected_number", "brief": "Expected a number in LP file", "value": "1158", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected a number, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_READ_LP_MISSING_END_TAG", "name": "err_read_lp_missing_end_tag", "brief": "Syntax error in LP fil. Possibly missing End tag.", "desc": "Syntax error in LP file. Possibly missing End tag.", "value": "1159", "msg": "Syntax error in LP file on line: %{arg0}. Missing End tag?", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LP_INDICATOR_VAR", "name": "err_lp_indicator_var", "brief": "An indicator variable was not declared binary", "value": "1160", "msg": "The indicator variable '%{arg0}' (%{arg1}) was not declared binary.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "U", []]}}, {"caml-name": "ERR_LP_EXPECTED_OBJECTIVE", "name": "err_lp_expected_objective", "brief": "Expected an objective section in LP file", "value": "1161", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected an objective section, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_LP_EXPECTED_CONSTRAINT_RELATION", "name": "err_lp_expected_constraint_relation", "brief": "Expected constraint relation", "value": "1162", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected a constraint relation, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND", "name": "err_lp_ambiguous_constraint_bound", "brief": "Constraint has ambiguous or invalid bound", "value": "1163", "msg": "Syntax error in LP file at %{l}:%{c}: Constraint '%{a2}' has ambiguous or invalid bound.", "args": {"l": ["l", "l", []], "c": ["c", "l", []], "a2": ["a2", "s", []]}}, {"caml-name": "ERR_LP_DUPLICATE_SECTION", "name": "err_lp_duplicate_section", "brief": "Duplicate section", "value": "1164", "msg": "Syntax error in LP file at %{l}:%{c}: Duplicate section '%{a0}'.", "args": {"l": ["l", "L", []], "c": ["c", "L", []], "a0": ["a0", "s", []]}}, {"caml-name": "ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED", "name": "err_read_lp_delayed_rows_not_supported", "brief": "Duplicate section", "value": "1165", "msg": "Syntax error in LP file at %{l}:%{c}: Delayed rows not supported.", "args": {"l": ["l", "L", []], "c": ["c", "L", []]}}, {"caml-name": "ERR_WRITING_FILE", "name": "err_writing_file", "brief": "An error occurred while writing file", "value": "1166", "msg": "An error occurred while writing the file", "args": {}}, {"caml-name": "ERR_INVALID_NAME_IN_SOL_FILE", "name": "err_invalid_name_in_sol_file", "brief": "An invalid name occurred in a solution file.", "value": "1170", "msg": "The name '%{arg0}' is an invalid name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_JSON_SYNTAX", "name": "err_json_syntax", "brief": "Syntax error in an JSON data", "value": "1175", "msg": "Syntax error at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_STRING", "name": "err_json_string", "brief": "Error in JSON string.", "value": "1176", "msg": "Error in JSON string at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_NUMBER_OVERFLOW", "name": "err_json_number_overflow", "brief": "Invalid number entry - wrong type or value overflow.", "value": "1177", "msg": "Invalid number entry at %{row}:%{column} - wrong type or value overflow.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_FORMAT", "name": "err_json_format", "brief": "Error in an JSON Task file", "value": "1178", "msg": "Error in JSON Task file at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_DATA", "name": "err_json_data", "brief": "Inconsistent data in JSON Task file", "value": "1179", "msg": "Inconsistent data in JSON Task in section \\\"%{item}\\\"", "args": {"item": ["item", "s", []]}}, {"caml-name": "ERR_JSON_MISSING_DATA", "name": "err_json_missing_data", "brief": "Missing data section in JSON task file.", "value": "1180", "msg": "Missing required entry \\\"%{item}\\\" in section \\\"%{sect}\\\" in JSON task file.", "args": {"item": ["item", "s", []], "sect": ["sect", "s", []]}}, {"caml-name": "ERR_PTF_INCOMPATIBILITY", "name": "err_ptf_incompatibility", "brief": "Incompatible item", "value": "1181", "msg": "Incompatible item '%{arg0}' in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_UNDEFINED_ITEM", "name": "err_ptf_undefined_item", "brief": "Undefined symbol referenced", "value": "1182", "msg": "Undefined symbol '%{arg0}' referenced in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_INCONSISTENCY", "name": "err_ptf_inconsistency", "brief": "Inconsistent size of item", "value": "1183", "msg": "Inconsistent size of '%{arg0}' in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_FORMAT", "name": "err_ptf_format", "brief": "Syntax error in an PTF file", "value": "1184", "msg": "Syntax error in an PTF file: %{arg0}:%{arg1}: %{msg}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "msg": ["msg", "s", []]}}, {"caml-name": "ERR_ARGUMENT_LENNEQ", "name": "err_argument_lenneq", "brief": "Incorrect length of arguments.", "value": "1197", "msg": "Incorrect argument length. The arguments %{arg0} are expected to be of equal length. The length of the arguments was %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARGUMENT_TYPE", "name": "err_argument_type", "brief": "Incorrect argument type.", "value": "1198", "msg": "Incorrect type in %{arg0} argument number: '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NUM_ARGUMENTS", "name": "err_num_arguments", "brief": "Incorrect number of function arguments.", "value": "1199", "msg": "Incorrect number of %{arg0} arguments. Got %{arg1} expected %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_IN_ARGUMENT", "name": "err_in_argument", "brief": "A function argument is incorrect.", "value": "1200", "msg": "The argument '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_ARGUMENT_DIMENSION", "name": "err_argument_dimension", "brief": "A function argument is of incorrect dimension.", "value": "1201", "msg": "The argument '%{arg0}' is of incorrect dimension.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_SHAPE_IS_TOO_LARGE", "name": "err_shape_is_too_large", "brief": "The size of the n-dimensional shape is too large.", "value": "1202", "msg": "The size of the shape in argument '%{arg1}' is too large.", "args": {"arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_TOO_SMALL", "name": "err_index_is_too_small", "brief": "An index in an argument is too small.", "value": "1203", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_TOO_LARGE", "name": "err_index_is_too_large", "brief": "An index in an argument is too large.", "value": "1204", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_NOT_UNIQUE", "name": "err_index_is_not_unique", "brief": "An index in an argument is is unique.", "value": "1205", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is not unique.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_NAME", "name": "err_param_name", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct.", "value": "1206", "msg": "The parameter name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_DOU", "name": "err_param_name_dou", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for a double parameter.", "value": "1207", "msg": "The parameter name '%{arg0}' is invalid for a double parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_INT", "name": "err_param_name_int", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for an integer parameter.", "value": "1208", "msg": "The parameter name '%{arg0}' is invalid for an int parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_STR", "name": "err_param_name_str", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for a string parameter.", "value": "1209", "msg": "The parameter name '%{arg0}' is invalid for a string parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_INDEX", "name": "err_param_index", "brief": "Parameter index is out of range.", "value": "1210", "msg": "The parameter index %{arg0} is invalid for a parameter of type %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_IS_TOO_LARGE", "name": "err_param_is_too_large", "brief": "A parameter value is too large.", "desc": "The parameter value is too large.", "value": "1215", "msg": "The parameter value %{arg0} is too large for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_IS_TOO_SMALL", "name": "err_param_is_too_small", "brief": "A parameter value is too small.", "desc": "The parameter value is too small.", "value": "1216", "msg": "The parameter value %{arg0} is too small for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_VALUE_STR", "name": "err_param_value_str", "brief": "A parameter value string is incorrect.", "desc": "The parameter value string is incorrect.", "value": "1217", "msg": "The parameter value string '%{arg0}' for parameter %{arg1} is incorrect.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_TYPE", "name": "err_param_type", "brief": "A parameter type is invalid.", "desc": "The parameter type is invalid.", "value": "1218", "msg": "The parameter type %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_DOU_INDEX", "name": "err_inf_dou_index", "brief": "A double information index is out of range for the specified type.", "value": "1219", "msg": "The double information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_INT_INDEX", "name": "err_inf_int_index", "brief": "An integer information index is out of range for the specified type.", "value": "1220", "msg": "The integer information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INDEX_ARR_IS_TOO_SMALL", "name": "err_index_arr_is_too_small", "brief": "An index in an array argument is too small.", "value": "1221", "msg": "The index value %{arg0} occurring in argument '%{arg1}[%{arg2}]' is too small(>=%{arg3}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INDEX_ARR_IS_TOO_LARGE", "name": "err_index_arr_is_too_large", "brief": "An index in an array argument is too large.", "value": "1222", "msg": "The index value %{arg0} occurring in argument '%{arg1}[%{arg2}]' is too large(<%{arg3}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INF_LINT_INDEX", "name": "err_inf_lint_index", "brief": "A long integer information index is out of range for the specified type.", "value": "1225", "msg": "The long integer information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_ARG_IS_TOO_SMALL", "name": "err_arg_is_too_small", "brief": "The value of a argument is too small.", "value": "1226", "msg": "The value %{arg0} of argument %{arg1} is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARG_IS_TOO_LARGE", "name": "err_arg_is_too_large", "brief": "The value of a argument is too large.", "value": "1227", "msg": "The value %{arg0} of argument %{arg1} is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INVALID_WHICHSOL", "name": "err_invalid_whichsol", "brief": "whichsol is invalid.", "desc": "``whichsol`` is invalid.", "value": "1228", "msg": "The code %{arg0} is an invalid value for whichsol.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_DOU_NAME", "name": "err_inf_dou_name", "brief": "A double information name is invalid.", "value": "1230", "msg": "The  double information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_INT_NAME", "name": "err_inf_int_name", "brief": "An integer information name is invalid.", "value": "1231", "msg": "The  integer information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_TYPE", "name": "err_inf_type", "brief": "The information type is invalid.", "value": "1232", "msg": "The information type %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_LINT_NAME", "name": "err_inf_lint_name", "brief": "A long integer information name is invalid.", "value": "1234", "msg": "The long integer information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INDEX", "name": "err_index", "brief": "An index is out of range.", "value": "1235", "msg": "An index is out of range.", "args": {}}, {"caml-name": "ERR_WHICHSOL", "name": "err_whichsol", "brief": "The solution defined by whichsol does not exists.", "desc": "The solution defined by ``whichsol`` does not exists.", "value": "1236", "msg": "%{arg0} is not a valid solution code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SOLITEM", "name": "err_solitem", "brief": "The solution number  solemn does not exists.", "desc": "The solution item number ``solitem`` is invalid. Please note that :msk:const:`solitem.snx` is invalid for the basic solution.", "value": "1237", "msg": "%{arg0} is not a valid solution item code for solution %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_WHICHITEM_NOT_ALLOWED", "name": "err_whichitem_not_allowed", "brief": "whichitem is unacceptable.", "desc": "``whichitem`` is unacceptable.", "value": "1238", "msg": "%{arg0} is an unacceptable whichitem.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MAXNUMCON", "name": "err_maxnumcon", "brief": "Invalid maximum number of constraints specified.", "desc": "The maximum number of constraints specified is smaller than the number of\nconstraints in the task.", "value": "1240", "msg": "Maximum number of constraints of '%{arg0}' is smaller than the number of constraints '%{arg1}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMVAR", "name": "err_maxnumvar", "brief": "The maximum number of variables limit is too small.", "desc": "The maximum number of variables specified is smaller than the number of\nvariables in the task.", "value": "1241", "msg": "Too small maximum number of variables %{arg0} is specified. Currently, the number of variables is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMBARVAR", "name": "err_maxnumbarvar", "brief": "The maximum number of semidefinite variables limit is too small.", "desc": "The maximum number of semidefinite variables specified is smaller than the number of semidefinite variables in the task.", "value": "1242", "msg": "Too small maximum number of semidefinite variables %{arg0} is specified. Currently, the number of semidefinite variables is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMQNZ", "name": "err_maxnumqnz", "brief": "Too small maximum number of non-zeros for the Q matrices is specified.", "desc": "The maximum number of non-zeros specified for the :math:`Q` matrices is smaller than the number of non-zeros in the current :math:`Q` matrices.", "value": "1243", "msg": "Too small maximum number of non-zeros for the Q matrices is specified.", "args": {}}, {"caml-name": "ERR_TOO_SMALL_MAX_NUM_NZ", "name": "err_too_small_max_num_nz", "brief": "The maximum number of non-zeros specified is too small.", "value": "1245", "msg": "The maximum number of non-zeros %{arg0} is too small. It must be at least %{arg1}.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_INVALID_IDX", "name": "err_invalid_idx", "brief": "A specified index is invalid.", "value": "1246", "msg": "The index value %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INVALID_MAX_NUM", "name": "err_invalid_max_num", "brief": "A specified index is invalid.", "value": "1247", "msg": "The maximum number value %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_UNALLOWED_WHICHSOL", "name": "err_unallowed_whichsol", "brief": "The value of whichsol is not allowed.", "desc": "The value od ``whichsol`` is not allowed.", "value": "1248", "msg": "The code %{arg0} is an unallowed value for whichsol.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NUMCONLIM", "name": "err_numconlim", "brief": "Maximum number of constraints limit is exceeded.", "value": "1250", "msg": "Maximum number of constraints limit is exceeded.", "args": {}}, {"caml-name": "ERR_NUMVARLIM", "name": "err_numvarlim", "brief": "Maximum number of variables limit is exceeded.", "value": "1251", "msg": "Maximum number of variables limit is exceeded.", "args": {}}, {"caml-name": "ERR_TOO_SMALL_MAXNUMANZ", "name": "err_too_small_maxnumanz", "brief": "Too small maximum number of non-zeros in A specified.", "desc": "The maximum number of non-zeros specified for :math:`A` is smaller than the number of non-zeros in the current :math:`A`.", "value": "1252", "msg": "Too small maximum number of non-zeros for %{arg0} A is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INV_APTRE", "name": "err_inv_aptre", "brief": "aptre[j] is strictly smaller than aptrb[j] for some j.", "desc": "``aptre[j]`` is strictly smaller than ``aptrb[j]`` for some ``j``.", "value": "1253", "msg": "aptre is strictly smaller than aptrb at position %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MUL_A_ELEMENT", "name": "err_mul_a_element", "brief": "An element in A is defined multiple times.", "desc": "An element in :math:`A` is defined multiple times.", "value": "1254", "msg": "Multiple elements in row %{arg0} of A at column %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_BK", "name": "err_inv_bk", "brief": "Invalid bound key.", "value": "1255", "msg": "%{arg0} is an invalid bound key.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_BKC", "name": "err_inv_bkc", "brief": "Invalid bound key is specified for a constraint.", "value": "1256", "msg": "An invalid bound key for a constraint value of %{arg0} in argument '%{arg1}' has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INV_BKX", "name": "err_inv_bkx", "brief": "An invalid bound key is specified for a variable.", "value": "1257", "msg": "An invalid bound key for variable of value of %{arg0} in argument '%{arg1}' has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INV_VAR_TYPE", "name": "err_inv_var_type", "brief": "An invalid variable type is specified for a variable.", "value": "1258", "msg": "An invalid type %{arg0} is specified for variable '%{arg1}' (%{arg2}) in argument '%{arg3}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "ERR_SOLVER_PROBTYPE", "name": "err_solver_probtype", "brief": "Problem type does not match the chosen optimizer.", "value": "1259", "msg": "Problem type does not match the chosen optimizer.", "args": {}}, {"caml-name": "ERR_OBJECTIVE_RANGE", "name": "err_objective_range", "brief": "Empty objective range.", "value": "1260", "msg": "Empty objective range.", "args": {}}, {"caml-name": "ERR_INV_RESCODE", "name": "err_inv_rescode", "brief": "Invalid response code.", "value": "1261", "msg": "%{arg0} is an invalid response code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_IINF", "name": "err_inv_iinf", "brief": "Invalid integer information item.", "value": "1262", "msg": "%{arg0} is an invalid integer information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_LIINF", "name": "err_inv_liinf", "brief": "Invalid long integer information item.", "value": "1263", "msg": "%{arg0} is an invalid long integer information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_DINF", "name": "err_inv_dinf", "brief": "Invalid double information item.", "value": "1264", "msg": "%{arg0} is an invalid double information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_BASIS", "name": "err_basis", "brief": "Invalid basis is specified.", "desc": "An invalid basis is specified. Either\ntoo many or too few basis variables are specified.", "value": "1266", "msg": "%{arg0} number of basis variables are specified. %{arg1} are expected.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_SKC", "name": "err_inv_skc", "brief": "Invalid value in skc encountered.", "desc": "Invalid value in ``skc``.", "value": "1267", "msg": "Invalid value at skc[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SKX", "name": "err_inv_skx", "brief": "Invalid value in skx encountered.", "desc": "Invalid value in ``skx``.", "value": "1268", "msg": "Invalid value at skx[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SKN", "name": "err_inv_skn", "brief": "Invalid value in skn encountered.", "desc": "Invalid value in ``skn``.", "value": "1274", "msg": "Invalid value at skn[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SK_STR", "name": "err_inv_sk_str", "brief": "Invalid status key string encountered.", "value": "1269", "msg": "'%{arg0}' is an invalid status key string.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INV_SK", "name": "err_inv_sk", "brief": "Invalid status key code encountered.", "desc": "Invalid status key code.", "value": "1270", "msg": "'%{arg0}' is an invalid status key code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_CONE_TYPE_STR", "name": "err_inv_cone_type_str", "brief": "Invalid cone type string encountered.", "value": "1271", "msg": "'%{arg0}' is an invalid cone type string.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INV_CONE_TYPE", "name": "err_inv_cone_type", "brief": "Invalid cone type code encountered.", "desc": "Invalid cone type code is encountered.", "value": "1272", "msg": "'%{arg0}' is an invalid cone type code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_SURPLUS", "name": "err_invalid_surplus", "brief": "Invalid surplus.", "value": "1275", "msg": "Invalid surplus.", "args": {}}, {"caml-name": "ERR_INV_NAME_ITEM", "name": "err_inv_name_item", "brief": "An invalid name item code is used.", "value": "1280", "msg": "'%{arg0}' is an invalid name item code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_PRO_ITEM", "name": "err_pro_item", "brief": "An invalid problem item is used.", "desc": "An invalid problem is used.", "value": "1281", "msg": "'%{arg0}' is an invalid problem item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_FORMAT_TYPE", "name": "err_invalid_format_type", "brief": "Invalid format type.", "value": "1283", "msg": "%{arg0} is an invalid format type.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_FIRSTI", "name": "err_firsti", "brief": "Invalid firsti.", "desc": "Invalid ``firsti``.", "value": "1285", "msg": "'%{arg0}' is an invalid value for firsti.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_LASTI", "name": "err_lasti", "brief": "Invalid lasti.", "desc": "Invalid ``lasti``.", "value": "1286", "msg": "'%{arg0}' is an invalid value for lasti.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_FIRSTJ", "name": "err_firstj", "brief": "Invalid firstj.", "desc": "Invalid ``firstj``.", "value": "1287", "msg": "'%{arg0}' is an invalid value for firstj.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LASTJ", "name": "err_lastj", "brief": "Invalid lastj.", "desc": "Invalid ``lastj``.", "value": "1288", "msg": "'%{arg0}' is an invalid value for lastj.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MAX_LEN_IS_TOO_SMALL", "name": "err_max_len_is_too_small", "brief": "A maximum length that is too small has been specified.", "value": "1289", "msg": "%{arg0} specified by '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_NONLINEAR_EQUALITY", "name": "err_nonlinear_equality", "brief": "The model contains a nonlinear equality.", "desc": "The model contains a nonlinear equality which defines a nonconvex set.", "value": "1290", "msg": "Nonconvex model detected. Constraint '%{arg0}'(%{arg1}) is a nonlinear equality.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NONCONVEX", "name": "err_nonconvex", "brief": "The optimization problem is nonconvex.", "value": "1291", "msg": "The optimization problem is nonconvex.", "args": {}}, {"caml-name": "ERR_NONLINEAR_RANGED", "name": "err_nonlinear_ranged", "brief": "The problem contains a nonlinear constraint with inite lower and upper bound.", "desc": "Nonlinear constraints with finite lower and upper bound always define a nonconvex feasible set.", "value": "1292", "msg": "Constraint '%{arg0}(%{arg1})' is nonlinear and ranged constraint i.e. it has finite lower and upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_CON_Q_NOT_PSD", "name": "err_con_q_not_psd", "brief": "The quadratic constraint matrix is not PSD.", "desc": "The quadratic constraint matrix is not positive semidefinite as expected for a constraint with finite upper bound. This results in a nonconvex problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1293", "msg": "Constraint '%{arg0}'(%{arg1}) is not convex. Q should be positive semidefinite in a constraint with finite upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_CON_Q_NOT_NSD", "name": "err_con_q_not_nsd", "brief": "The quadratic constraint matrix is not NSD.", "desc": "The quadratic constraint matrix is not negative semidefinite as expected for a constraint with finite lower bound. This results in a nonconvex problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1294", "msg": "The constraint '%{arg0}'(%{arg1}) is not convex. Q should be negative semidefinite for a constraint with finite lower bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OBJ_Q_NOT_PSD", "name": "err_obj_q_not_psd", "brief": "The quadratic coefficient matrix in the objective is not PSD.", "desc": "The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1295", "msg": "The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.", "args": {}}, {"caml-name": "ERR_OBJ_Q_NOT_NSD", "name": "err_obj_q_not_nsd", "brief": "The quadratic coefficient matrix in the objective is not NSD.", "desc": "The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1296", "msg": "The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem.", "args": {}}, {"caml-name": "ERR_ARGUMENT_PERM_ARRAY", "name": "err_argument_perm_array", "brief": "An invalid permutation array is specified.", "value": "1299", "msg": "An invalid permutation array named '%{arg0}' is supplied. Position %{arg1} has the invalid value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_CONE_INDEX", "name": "err_cone_index", "brief": "An index of a non-existing cone has been specified.", "value": "1300", "msg": "No cone has index '%{arg0}'.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_SIZE", "name": "err_cone_size", "brief": "A cone with incorrect number of members is specified.", "value": "1301", "msg": "Wrong number of variables in the cone. %{arg0} %{arg1} members are required for cones of type %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_CONE_OVERLAP", "name": "err_cone_overlap", "brief": "One or more of variables in the cone to be added is already member of another cone.", "desc": "One or more of the variables in the cone to be added is already member of another cone. Now assume the variable is :math:`x_j` then add a new variable say\n:math:`x_k` and the constraint\n\n.. math::\n   x_j = x_k\n\nand then let :math:`x_k` be member of the cone to be appended.", "value": "1302", "msg": "Variable '%{arg0}' (%{arg1}) is a member of cone '%{arg2}' (%{arg3}) and cone '%{arg4}' (%{arg5}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "s", []], "arg5": ["arg5", "i", []]}}, {"caml-name": "ERR_CONE_REP_VAR", "name": "err_cone_rep_var", "brief": "A variable is included multiple times in the cone.", "value": "1303", "msg": "Variable '%{arg0}' (%{arg1}) are included multiple times in a cone.).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMCONE", "name": "err_maxnumcone", "brief": "The value specified for maxnumcone is too small.", "desc": "The value specified for ``maxnumcone`` is too small.", "value": "1304", "msg": "The value %{arg0} specified for maxnumcone is too small.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_TYPE", "name": "err_cone_type", "brief": "Invalid cone type specified.", "value": "1305", "msg": "%{arg0} is an invalid cone type specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_TYPE_STR", "name": "err_cone_type_str", "brief": "Invalid cone type specified.", "value": "1306", "msg": "%{arg0} is an invalid cone type specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_OVERLAP_APPEND", "name": "err_cone_overlap_append", "brief": "The cone to be appended has one variable which is already member of another cone.", "value": "1307", "msg": "Variable '%{arg0}' (%{arg1}) is a member of cone '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_REMOVE_CONE_VARIABLE", "name": "err_remove_cone_variable", "brief": "A variable cannot be removed because it will make a cone invalid.", "value": "1310", "msg": "If variable %{arg0} ('%{arg1}') is removed, then cone %{arg2} ('%{arg3}') will be invalid.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "ERR_APPENDING_TOO_BIG_CONE", "name": "err_appending_too_big_cone", "brief": "Trying to append a too big cone.", "value": "1311", "msg": "Tyring to append a too big cone.", "args": {}}, {"caml-name": "ERR_CONE_PARAMETER", "name": "err_cone_parameter", "brief": "An invalid cone parameter.", "value": "1320", "msg": "An invalid cone parameter value of %{arg0} is specified.", "args": {"arg0": ["arg0", "e", []]}}, {"caml-name": "ERR_SOL_FILE_INVALID_NUMBER", "name": "err_sol_file_invalid_number", "brief": "An invalid number is specified in a solution file.", "value": "1350", "msg": "The invalid number '%{arg0}' is specified in a solution file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_HUGE_C", "name": "err_huge_c", "brief": "A huge value in absolute size is specified for an objective coefficient.", "desc": "A huge value in absolute size is specified for one :math:`c_j`.", "value": "1375", "msg": "A large value of %{arg0} has been specified in cx for variable '%{arg1}' (%{arg2}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_HUGE_AIJ", "name": "err_huge_aij", "brief": "A numerically huge value is specified for an element in A.", "desc": "A numerically huge value is specified for an :math:`a_{i,j}` element in :math:`A`.  The parameter  :msk:dparam:`data_tol_aij_huge` controls when an :math:`a_{i,j}` is considered huge.", "value": "1380", "msg": "The A matrix contains a huge value of %{arg0} in constraint '%{arg1}' (%{arg2}) at variable '%{arg3}' (%{arg4}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "ERR_DUPLICATE_AIJ", "name": "err_duplicate_aij", "brief": "An element in the A matrix is specified twice.", "value": "1385", "msg": "The A matrix element at constraint '%{arg1}' (%{arg2}), variable '%{arg3}' (%{arg4}) is specfied twice.", "args": {"arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "ERR_LOWER_BOUND_IS_A_NAN", "name": "err_lower_bound_is_a_nan", "brief": "The lower bound specified is not a number (nan).", "value": "1390", "msg": "The lower bound specified is not a number (nan).", "args": {}}, {"caml-name": "ERR_UPPER_BOUND_IS_A_NAN", "name": "err_upper_bound_is_a_nan", "brief": "The upper bound specified is not a number (nan).", "value": "1391", "msg": "The upper bound specified is not a number (nan).", "args": {}}, {"caml-name": "ERR_INFINITE_BOUND", "name": "err_infinite_bound", "brief": "A numerically huge bound value is specified.", "value": "1400", "msg": "A numerically huge bound value is specified.", "args": {}}, {"caml-name": "ERR_INV_QOBJ_SUBI", "name": "err_inv_qobj_subi", "brief": "Invalid value %d at qosubi.", "desc": "Invalid value in ``qosubi``.", "value": "1401", "msg": "Invalid value %{arg0} at qosubi[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QOBJ_SUBJ", "name": "err_inv_qobj_subj", "brief": "Invalid value in qosubj.", "desc": "Invalid value in ``qosubj``.", "value": "1402", "msg": "Invalid value %{arg0} at qosubj[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QOBJ_VAL", "name": "err_inv_qobj_val", "brief": "Invalid value in qoval.", "desc": "Invalid value in ``qoval``.", "value": "1403", "msg": "Invalid value %{arg0} at qoval[%{arg1}].", "args": {"arg0": ["arg0", "e", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBK", "name": "err_inv_qcon_subk", "brief": "Invalid value in qcsubk.", "desc": "Invalid value in ``qcsubk``.", "value": "1404", "msg": "Invalid value %{arg0} at qcsubk[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBI", "name": "err_inv_qcon_subi", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1405", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBJ", "name": "err_inv_qcon_subj", "brief": "Invalid value in qcsubj.", "desc": "Invalid value in ``qcsubj``.", "value": "1406", "msg": "Invalid value %{arg0} at qcsubj[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_VAL", "name": "err_inv_qcon_val", "brief": "Invalid value in qcval.", "desc": "Invalid value in ``qcval``.", "value": "1407", "msg": "Invalid value (inf or nan) in constraint %{arg0}, quadratic element (%{arg1},%{arg2}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QCON_SUBI_TOO_SMALL", "name": "err_qcon_subi_too_small", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1408", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}]. It should be >= %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QCON_SUBI_TOO_LARGE", "name": "err_qcon_subi_too_large", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1409", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}]. It should be < %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QOBJ_UPPER_TRIANGLE", "name": "err_qobj_upper_triangle", "brief": "An element in the upper triangle of the quadratic term in the objective is specified.", "desc": "An element in the upper triangle of :math:`Q^o` is specified. Only elements in the lower triangle should be specified.", "value": "1415", "msg": "Only elements in the lower triangle of the quadratic term in the objective should be specified. The element q[%{arg0},%{arg1}] is in the upper triangle.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_QCON_UPPER_TRIANGLE", "name": "err_qcon_upper_triangle", "brief": "An element in the upper triangle of the quadratic term in a constraint.", "desc": "An element in the upper triangle of a :math:`Q^k` is specified. Only elements in the lower triangle should be specified.", "value": "1417", "msg": "Only elements in the lower triangle of the quadratic terms should be specified. The element q[%{arg0},%{arg1}] is in the upper triangle of %{arg2}th constraint is specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_FIXED_BOUND_VALUES", "name": "err_fixed_bound_values", "brief": "A fixed constraint/variable has been specified using the bound keys but the numerical bounds are different.", "desc": "A fixed constraint/variable has been specified using the bound keys but the numerical value of the lower and upper\nbound is different.", "value": "1420", "msg": "For a fixed constraint/variable the specified lower bound %{arg0} and upper bound %{arg1} are different.", "args": {"arg0": ["arg0", "e", ["w=24", "j=r", "p=16"]], "arg1": ["arg1", "e", ["w=24", "j=r", "p=16"]]}}, {"caml-name": "ERR_TOO_SMALL_A_TRUNCATION_VALUE", "name": "err_too_small_a_truncation_value", "brief": "A too small value for the A trucation value is specified.", "value": "1421", "msg": "A truncation value of %{arg0} is too small. It greater or equal to %{arg1}.", "args": {"arg0": ["arg0", "e", []], "arg1": ["arg1", "e", []]}}, {"caml-name": "ERR_INVALID_OBJECTIVE_SENSE", "name": "err_invalid_objective_sense", "brief": "An invalid objective sense is specified.", "value": "1445", "msg": "%{arg0} is an invalid objective sense code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_UNDEFINED_OBJECTIVE_SENSE", "name": "err_undefined_objective_sense", "brief": "The objective sense has not been specified before the optimization.", "value": "1446", "msg": "The objective sense has not been specified before the optimization.", "args": {}}, {"caml-name": "ERR_Y_IS_UNDEFINED", "name": "err_y_is_undefined", "brief": "The solution item y is undefined.", "desc": "The solution item :math:`y` is undefined.", "value": "1449", "msg": "The solution term y is undefined.", "args": {}}, {"caml-name": "ERR_NAN_IN_DOUBLE_DATA", "name": "err_nan_in_double_data", "brief": "An invalid floating value was used in some double data.", "desc": "An invalid floating point value was used in some double data.", "value": "1450", "msg": "The parameter '%{arg0}' contained an invalid floating value.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_IN_DOUBLE_DATA", "name": "err_inf_in_double_data", "brief": "An infinite floating value was used in some double data.", "desc": "An infinite floating point value was used in some double data.", "value": "1451", "msg": "The parameter '%{arg0}' contained an infinite floating value.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_NAN_IN_BLC", "name": "err_nan_in_blc", "brief": "blc contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`l^c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1461", "msg": "The bound vector blc contains an invalid value for constraint '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BUC", "name": "err_nan_in_buc", "brief": "buc contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`u^c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1462", "msg": "The bound vector buc contains an invalid value for constraint '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_CFIX", "name": "err_invalid_cfix", "brief": "An invalid fixed term in the objective is speficied.", "value": "1469", "msg": "An invalid fixed term in the objective is speficied.", "args": {}}, {"caml-name": "ERR_NAN_IN_C", "name": "err_nan_in_c", "brief": "c contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1470", "msg": "The objective vector c contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BLX", "name": "err_nan_in_blx", "brief": "blx contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`l^x` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1471", "msg": "The bound vector blx contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BUX", "name": "err_nan_in_bux", "brief": "bux contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`u^x` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1472", "msg": "The bound vector bux contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_AIJ", "name": "err_invalid_aij", "brief": "a[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`a_{i,j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1473", "msg": "The value of the A matrix element in constraint '%{arg0}' (%{arg1}) for variable '%{arg2}' (%{arg3}) is invalid.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INVALID_CJ", "name": "err_invalid_cj", "brief": "c[j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`c_{j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1474", "msg": "The value of the c elementforvariablet '%{arg0}' (%{arg1}) is invalid.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID", "name": "err_sym_mat_invalid", "brief": "A symmetric matrix contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": "A symmetric matrix contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1480", "msg": "Position [%{arg0},'%{arg1}'] is an invalid floating point value.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_HUGE", "name": "err_sym_mat_huge", "brief": "A numerically huge value is specified for an element in E.", "desc": "A symmetric matrix contains a huge value in absolute size. The parameter  :msk:dparam:`data_sym_mat_tol_huge` controls when an :math:`e_{i,j}` is considered huge.", "value": "1482", "msg": "Position [%{arg1},%{arg2}] = %{arg0} is huge in absolute size.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_INV_PROBLEM", "name": "err_inv_problem", "brief": "Invalid problem type.", "desc": "Invalid problem type. Probably a nonconvex problem has been specified.", "value": "1500", "msg": "Invalid problem type.", "args": {}}, {"caml-name": "ERR_MIXED_CONIC_AND_NL", "name": "err_mixed_conic_and_nl", "brief": "The problem contains both conic and nonlinear constraints.", "desc": "The problem contains nonlinear terms conic constraints. The requested operation cannot be applied to this type of problem.", "value": "1501", "msg": "The problem contains both conic and nonlinear constraints.", "args": {}}, {"caml-name": "ERR_GLOBAL_INV_CONIC_PROBLEM", "name": "err_global_inv_conic_problem", "brief": "The global optimizer can only be applied to problems without semidefinite variables.", "value": "1503", "msg": "The global optimizer can only be applied to problems without semidefinite variables. This usually means the user tried to solve a mixed-integer semidefinite problem.", "args": {}}, {"caml-name": "ERR_INV_OPTIMIZER", "name": "err_inv_optimizer", "brief": "An invalid optimizer has been chosen for the problem.", "value": "1550", "msg": "An invalid optimizer (index=%{arg0}) has been chosen for the problem.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MIO_NO_OPTIMIZER", "name": "err_mio_no_optimizer", "brief": "No optimizer is available for the current class of integer optimization problems.", "value": "1551", "msg": "No integer optimizer is available for the optimization problem.", "args": {}}, {"caml-name": "ERR_NO_OPTIMIZER_VAR_TYPE", "name": "err_no_optimizer_var_type", "brief": "No optimizer is available for this class of optimization problems.", "value": "1552", "msg": "No optimizer is available for optimization problems containing variables of type '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FINAL_SOLUTION", "name": "err_final_solution", "brief": "An error occurred during the solution finalization.", "value": "1560", "msg": "An error occurred during the solution finalization.", "args": {}}, {"caml-name": "ERR_FIRST", "name": "err_first", "brief": "Invalid first.", "desc": "Invalid ``first``.", "value": "1570", "msg": "Invalid index first. A given index as out of expected range, first was %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LAST", "name": "err_last", "brief": "Invalid last.", "desc": "Invalid index ``last``. A given index was out of expected range.", "value": "1571", "msg": "Invalid index last. A given index was out of expected range, last was %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SLICE_SIZE", "name": "err_slice_size", "brief": "Invalid slice size specified.", "value": "1572", "msg": "The value %{arg0} of is an invalid slice size.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_NEGATIVE_SURPLUS", "name": "err_negative_surplus", "brief": "Negative surplus.", "value": "1573", "msg": "Negative surplus.", "args": {}}, {"caml-name": "ERR_NEGATIVE_APPEND", "name": "err_negative_append", "brief": "Cannot append a negative number.", "value": "1578", "msg": "Cannot append %{arg0} of %{arg1}. The number must be nonnegative.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_POSTSOLVE", "name": "err_postsolve", "brief": "An error occurred during the postsolve.", "desc": "An error occurred during the postsolve. Please contact |mosek| support.", "value": "1580", "msg": "An error occurred during the postsolve.", "args": {}}, {"caml-name": "ERR_OVERFLOW", "name": "err_overflow", "brief": "A computation produced an overflow.", "desc": "A computation produced an overflow i.e. a very large number.", "value": "1590", "msg": "A computation produced an overflow.", "args": {}}, {"caml-name": "ERR_NO_BASIS_SOL", "name": "err_no_basis_sol", "brief": "No basic solution is defined.", "value": "1600", "msg": "No basic solution is defined.", "args": {}}, {"caml-name": "ERR_BASIS_FACTOR", "name": "err_basis_factor", "brief": "The factorization of the basis is invalid.", "value": "1610", "msg": "The factorization of the basis is invalid.", "args": {}}, {"caml-name": "ERR_BASIS_SINGULAR", "name": "err_basis_singular", "brief": "The basis is singular.", "desc": "The basis is singular and hence cannot be factored.", "value": "1615", "msg": "The basis is singular.", "args": {}}, {"caml-name": "ERR_FACTOR", "name": "err_factor", "brief": "An error occurred while factorizing a matrix.", "value": "1650", "msg": "An error occurred while factorizing a matrix.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_CANNOT_RELAX", "name": "err_feasrepair_cannot_relax", "brief": "An optimization problem cannot be relaxed.", "value": "1700", "msg": "An optimization problem cannot be relaxed.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_SOLVING_RELAXED", "name": "err_feasrepair_solving_relaxed", "brief": "The relaxed problem could not be solved to optimality.", "desc": "The relaxed problem could not be solved to optimality. Please consult the log file for further details.", "value": "1701", "msg": "The relaxed problem could not be solved to optimality.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_INCONSISTENT_BOUND", "name": "err_feasrepair_inconsistent_bound", "brief": "The upper bound is less than the lower bound for a variable or a constraint.", "desc": "The upper bound is less than the lower bound for a variable or a constraint.\nPlease correct this before running the feasibility repair.", "value": "1702", "msg": "The %{arg0} '%{arg1}' with index '%{arg2}' has lower bound larger than upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_REPAIR_INVALID_PROBLEM", "name": "err_repair_invalid_problem", "brief": "The feasibility repair does not support the specified problem type.", "value": "1710", "msg": "The feasibility repair does not support to the specified problem type.", "args": {}}, {"caml-name": "ERR_REPAIR_OPTIMIZATION_FAILED", "name": "err_repair_optimization_failed", "brief": "Computation the optimal relaxation failed.", "desc": "Computation the optimal relaxation failed. The cause may have been numerical problems.", "value": "1711", "msg": "Computation the optimal relaxation failed.", "args": {}}, {"caml-name": "ERR_NAME_MAX_LEN", "name": "err_name_max_len", "brief": "A name is longer than the buffer that is supposed to hold it.", "value": "1750", "msg": "A name('%{arg0}') of length %{arg1} is longer than the buffer of length %{arg2} that is supposed to hold it.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_NAME_IS_NULL", "name": "err_name_is_null", "brief": "The name buffer is a null pointer.", "desc": "The name buffer is a |null| pointer.", "value": "1760", "msg": "The name buffer is a null pointer.", "args": {}}, {"caml-name": "ERR_INVALID_COMPRESSION", "name": "err_invalid_compression", "brief": "Invalid compression type.", "value": "1800", "msg": "%{arg0} is an invalid compression type.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_IOMODE", "name": "err_invalid_iomode", "brief": "Invalid io mode.", "value": "1801", "msg": "%{arg0} is an io mode.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_PRIMAL_INFEAS_CER", "name": "err_no_primal_infeas_cer", "brief": "A certificate of primal infeasibility is not available.", "value": "2000", "msg": "A certificate of primal infeasibility is not available.", "args": {}}, {"caml-name": "ERR_NO_DUAL_INFEAS_CER", "name": "err_no_dual_infeas_cer", "brief": "A certificate of dual infeasibility is not available.", "desc": "A certificate of infeasibility is not available.", "value": "2001", "msg": "A certificate of dual infeasibility is not available.", "args": {}}, {"caml-name": "ERR_NO_SOLUTION_IN_CALLBACK", "name": "err_no_solution_in_callback", "brief": "The required solution is not available.", "value": "2500", "msg": "The required solution is not available.", "args": {}}, {"caml-name": "ERR_INV_MARKI", "name": "err_inv_marki", "brief": "Invalid value in marki.", "value": "2501", "msg": "Invalid value in marki[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_MARKJ", "name": "err_inv_markj", "brief": "Invalid value in markj.", "value": "2502", "msg": "Invalid value in markj[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_NUMI", "name": "err_inv_numi", "brief": "Invalid numi.", "value": "2503", "msg": "Invalid numi.", "args": {}}, {"caml-name": "ERR_INV_NUMJ", "name": "err_inv_numj", "brief": "Invalid numj.", "value": "2504", "msg": "Invalid numj.", "args": {}}, {"caml-name": "ERR_TASK_INCOMPATIBLE", "name": "err_task_incompatible", "brief": "The Task file is incompatible with this platform.", "desc": "The Task file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.", "value": "2560", "msg": "The Task file is incompatible with this platform.", "args": {}}, {"caml-name": "ERR_TASK_INVALID", "name": "err_task_invalid", "brief": "The Task file is invalid.", "value": "2561", "msg": "The Task file is invalid.", "args": {}}, {"caml-name": "ERR_TASK_WRITE", "name": "err_task_write", "brief": "Failed to write the task file.", "value": "2562", "msg": "Failed to write the task file.", "args": {}}, {"caml-name": "ERR_LU_MAX_NUM_TRIES", "name": "err_lu_max_num_tries", "brief": "Could not compute the LU factors of the matrix within the maximum number of allowed tries.", "value": "2800", "msg": "Could not compute the LU factors of the matrix within the maximum number of allowed tries.", "args": {}}, {"caml-name": "ERR_INVALID_UTF8", "name": "err_invalid_utf8", "brief": "An invalid UTF8 string is encountered.", "value": "2900", "msg": "An invalid UTF8 string is encountered.", "args": {}}, {"caml-name": "ERR_INVALID_WCHAR", "name": "err_invalid_wchar", "brief": "An invalid wchar string is encountered.", "desc": "An invalid ``wchar`` string is encountered.", "value": "2901", "msg": "An invalid wchar string is encountered.", "args": {}}, {"caml-name": "ERR_NO_DUAL_FOR_ITG_SOL", "name": "err_no_dual_for_itg_sol", "brief": "No dual information is available for the integer solution.", "value": "2950", "msg": "No dual information is available for the integer solution.", "args": {}}, {"caml-name": "ERR_NO_SNX_FOR_BAS_SOL", "name": "err_no_snx_for_bas_sol", "brief": "snx is not available for the basis solution.", "desc": ":math:`s_n^x` is not available for the basis solution.", "value": "2953", "msg": "snx is not available the basis solution.", "args": {}}, {"caml-name": "ERR_INTERNAL", "name": "err_internal", "brief": "An internal error occurred.", "desc": "An internal error occurred. Please report this problem.", "value": "3000", "msg": "An internal error occurred '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_API_ARRAY_TOO_SMALL", "name": "err_api_array_too_small", "brief": "An input array was too short.", "value": "3001", "msg": "The input array '%{arg0}' is too short in call to '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_API_CB_CONNECT", "name": "err_api_cb_connect", "brief": "Failed to connect a callback object.", "value": "3002", "msg": "Failed to connect a callback object.", "args": {}}, {"caml-name": "ERR_API_FATAL_ERROR", "name": "err_api_fatal_error", "brief": "An internal error occurred in the API. Please report this problem.", "value": "3005", "msg": "An internal error occurred in the %{arg0} API: %{arg1}", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_API_INTERNAL", "name": "err_api_internal", "brief": "An internal fatal error occurred in an interface function.", "value": "3999", "msg": "An internal fatal error occurred in an interface function", "args": {}}, {"caml-name": "ERR_SEN_FORMAT", "name": "err_sen_format", "brief": "Syntax error in sensitivity analysis file.", "value": "3050", "msg": "Syntax error in sensitivity analysis file at line number: %{arg0}. %{arg1}", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_SEN_UNDEF_NAME", "name": "err_sen_undef_name", "brief": "An undefined name was encountered in the sensitivity analysis file.", "value": "3051", "msg": "Name '%{arg0}' on line %{arg1} not defined.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_INDEX_RANGE", "name": "err_sen_index_range", "brief": "Index out of range in the sensitivity analysis file.", "value": "3052", "msg": "Index '%{arg0}' out of range at line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_BOUND_INVALID_UP", "name": "err_sen_bound_invalid_up", "brief": "Analysis of upper bound requested for an index, where no upper bound exists.", "value": "3053", "msg": "No upper bound for index '%{arg0}' given in line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_BOUND_INVALID_LO", "name": "err_sen_bound_invalid_lo", "brief": "Analysis of lower bound requested for an index, where no lower bound exists.", "value": "3054", "msg": "No lower bound for index '%{arg0}' given in line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_INDEX_INVALID", "name": "err_sen_index_invalid", "brief": "Invalid range given in the sensitivity file.", "value": "3055", "msg": "The index range %{arg0}-%{arg1} in line %{arg2} is invalid.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SEN_INVALID_REGEXP", "name": "err_sen_invalid_regexp", "brief": "Syntax error in regexp or regexp longer than 1024.", "value": "3056", "msg": "Syntax error in regexp on line %{arg0}: %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_SEN_SOLUTION_STATUS", "name": "err_sen_solution_status", "brief": "No optimal solution found to the original problem given for sensitivity analysis.", "value": "3057", "msg": "No optimal solution found to the original problem given for sensitivity analysis. Solution status = %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SEN_NUMERICAL", "name": "err_sen_numerical", "brief": "Numerical difficulties encountered performing the sensitivity analysis.", "value": "3058", "msg": "Numerical difficulties encountered performing the sensitivity analysis.", "args": {}}, {"caml-name": "ERR_SEN_UNHANDLED_PROBLEM_TYPE", "name": "err_sen_unhandled_problem_type", "brief": "Sensitivity analysis cannot be performed for the specified problem.", "desc": "Sensitivity analysis cannot be performed for the specified problem. Sensitivity analysis is only possible for linear problems.", "value": "3080", "msg": "Sensitivity analysis cannot be performed for the specified problem.", "args": {}}, {"caml-name": "ERR_UNB_STEP_SIZE", "name": "err_unb_step_size", "brief": "A step-size in an optimizer was unexpectedly unbounded.", "desc": "A step size in an optimizer was unexpectedly unbounded. For instance, if the step-size becomes unbounded in phase 1 of the simplex algorithm then an error occurs. Normally this will happen only if the problem is badly formulated. Please contact |mosek| support if this error occurs.", "value": "3100", "msg": "A step-size in an optimizer was unexpectedly unbounded.", "args": {}}, {"caml-name": "ERR_IDENTICAL_TASKS", "name": "err_identical_tasks", "brief": "Some tasks related to this function call were identical. Unique tasks were expected.", "value": "3101", "msg": "Some tasks related to this function call were identical. Unique tasks were expected.", "args": {}}, {"caml-name": "ERR_AD_INVALID_CODELIST", "name": "err_ad_invalid_codelist", "brief": "The code list data was invalid.", "value": "3102", "msg": "Invalid code list data.", "args": {}}, {"caml-name": "ERR_INTERNAL_TEST_FAILED", "name": "err_internal_test_failed", "brief": "An internal unit test function failed.", "value": "3500", "msg": "Internal unit test function failed.", "args": {}}, {"caml-name": "ERR_XML_INVALID_PROBLEM_TYPE", "name": "err_xml_invalid_problem_type", "brief": "The problem type is not supported by the XML format.", "value": "3600", "msg": "The problem type %{arg0} is not supported by the XML format.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_AMPL_STUB", "name": "err_invalid_ampl_stub", "brief": "Invalid AMPL stub.", "value": "3700", "msg": "Invalid AMPL stub.", "args": {}}, {"caml-name": "ERR_INT64_TO_INT32_CAST", "name": "err_int64_to_int32_cast", "brief": "A 64 bit integer could not be cast to a 32 bit integer.", "value": "3800", "msg": "A 64 bit integer could not be cast to a 32 bit integer.", "args": {}}, {"caml-name": "ERR_SIZE_LICENSE_NUMCORES", "name": "err_size_license_numcores", "brief": "The computer contains more cpu cores than the license allows for.", "value": "3900", "msg": "The number of cpu cores detected is '%{arg0}', the license allows for only '%{arg1}' cpu cores for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_INFEAS_UNDEFINED", "name": "err_infeas_undefined", "brief": "The requested value is not defined for this solution type.", "value": "3910", "msg": "The requested value '%{arg0}' is not defined for this solution type.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_NO_BARX_FOR_SOLUTION", "name": "err_no_barx_for_solution", "brief": "There is no barx available for the solution specified.", "desc": "There is no :math:`\\barX` available for the solution specified. In particular note there are no :math:`\\barX` defined for the basic and integer solutions.", "value": "3915", "msg": "There is no barx available for the solution type %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_BARS_FOR_SOLUTION", "name": "err_no_bars_for_solution", "brief": "There is no bars available for the solution specified.", "desc": "There is no :math:`\\bar{s}` available for the solution specified. In particular note there are no :math:`\\bar{s}` defined for the basic and integer solutions.", "value": "3916", "msg": "There is no bars available for the solution type %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_BAR_VAR_DIM", "name": "err_bar_var_dim", "brief": "The dimension of a symmetric matrix variable has to be greater than 0.", "value": "3920", "msg": "The dimension %{arg0} for a symmetric matrix variable is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_ROW_INDEX", "name": "err_sym_mat_invalid_row_index", "brief": "A row index specified for sparse symmetric matrix is invalid.", "value": "3940", "msg": "The row index %{arg0} specified for sparse symmetric is invalid. The valid range is [%{arg1},%{arg2}[.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_COL_INDEX", "name": "err_sym_mat_invalid_col_index", "brief": "A column index specified for sparse symmetric matrix is invalid.", "value": "3941", "msg": "The column index %{arg0} specified for sparse symmetric matrix is invalid. The valid range is [%{arg1},%{arg2}[.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SYM_MAT_NOT_LOWER_TRINGULAR", "name": "err_sym_mat_not_lower_tringular", "brief": "Only the lower triangular part of sparse symmetric matrix should be specified.", "value": "3942", "msg": "An element in the upper triangular part at row %{arg0} in column %{arg1} has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_VALUE", "name": "err_sym_mat_invalid_value", "brief": "The numerical value specified in a sparse symmetric matrix is not a floating point value.", "value": "3943", "msg": "The value specified in row %{arg0} at column %{arg1} is not a valid floaing value.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_DUPLICATE", "name": "err_sym_mat_duplicate", "brief": "A value in a symmetric matric as been specified more than once.", "value": "3944", "msg": "The value (%{arg0},%{arg1}) in a sparse symmetric has been specified twice at position %{arg2} and position %{arg3}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "l", []], "arg3": ["arg3", "l", []]}}, {"caml-name": "ERR_INVALID_SYM_MAT_DIM", "name": "err_invalid_sym_mat_dim", "brief": "A sparse symmetric matrix of invalid dimension is specified.", "value": "3950", "msg": "Expected a symmetric matrix of dimension %{arg0} but the specified dimension is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT", "name": "err_invalid_file_format_for_sym_mat", "brief": "The file format does not support a problem with symmetric matrix variables.", "value": "4000", "msg": "The specified file format does not support a problem with symmetric matrix variables.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_CFIX", "name": "err_invalid_file_format_for_cfix", "brief": "The file format does not support a problem with nonzero fixed term in c.", "value": "4001", "msg": "The specified file format does not support a problem with  nonzero fixed term in c.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS", "name": "err_invalid_file_format_for_ranged_constraints", "brief": "The file format does not support a problem with ranged constraints.", "value": "4002", "msg": "The specified file format does not support a problem with ranged constraints.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS", "name": "err_invalid_file_format_for_free_constraints", "brief": "The file format does not support a problem with free constraints.", "value": "4003", "msg": "The specified file format does not support a problem with free constraints.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_CONES", "name": "err_invalid_file_format_for_cones", "brief": "The file format does not support a problem with the simple cones (deprecated).", "value": "4005", "msg": "The specified file format does not support a problem with the simple cones (deprecated).", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS", "name": "err_invalid_file_format_for_quadratic_terms", "brief": "The file format does not support a problem with quadratic terms.", "value": "4006", "msg": "The specified file format does not support a problem with quadratic terms (QO, QCQO).", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR", "name": "err_invalid_file_format_for_nonlinear", "brief": "The file format does not support a problem with nonlinear terms.", "value": "4010", "msg": "The specified file format does not support a problem with nonlinear terms.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS", "name": "err_invalid_file_format_for_disjunctive_constraints", "brief": "The file format does not support a problem with disjunctive constraints.", "value": "4011", "msg": "The file format does not support a problem with disjunctive constraints. Use the PTF format instead.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS", "name": "err_invalid_file_format_for_affine_conic_constraints", "brief": "The file format does not support a problem with affine conic constraints.", "value": "4012", "msg": "The file format does not support a problem with affine conic constraints. Use the PTF format instead.", "args": {}}, {"caml-name": "ERR_DUPLICATE_CONSTRAINT_NAMES", "name": "err_duplicate_constraint_names", "brief": "Two constraint names are identical.", "value": "4500", "msg": "Constraint number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_VARIABLE_NAMES", "name": "err_duplicate_variable_names", "brief": "Two variable names are identical.", "value": "4501", "msg": "Variable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_BARVARIABLE_NAMES", "name": "err_duplicate_barvariable_names", "brief": "Two barvariable names are identical.", "value": "4502", "msg": "Barvariable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_CONE_NAMES", "name": "err_duplicate_cone_names", "brief": "Two cone names are identical.", "value": "4503", "msg": "Cones number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_DOMAIN_NAMES", "name": "err_duplicate_domain_names", "brief": "Two domain names are identical.", "value": "4504", "msg": "Domains number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_DJC_NAMES", "name": "err_duplicate_djc_names", "brief": "Two disjunctive constraint names are identical.", "value": "4505", "msg": "Disjunctive constraints number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_NON_UNIQUE_ARRAY", "name": "err_non_unique_array", "brief": "An array does not contain unique elements.", "value": "5000", "msg": "Array '%{arg0}' is not unique.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_ARGUMENT_IS_TOO_SMALL", "name": "err_argument_is_too_small", "brief": "The value of a function argument is too small.", "value": "5004", "msg": "The value %{arg0} of argument '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARGUMENT_IS_TOO_LARGE", "name": "err_argument_is_too_large", "brief": "The value of a function argument is too large.", "value": "5005", "msg": "The value %{arg0} of argument '%{arg1}' is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MIO_INTERNAL", "name": "err_mio_internal", "brief": "A fatal error occurred in the mixed integer optimizer.  Please contact MOSEK support.", "desc": "A fatal error occurred in the mixed integer optimizer. Please contact |mosek| support.", "value": "5010", "msg": "A fatal error occurred in the mixed integer optimizer. Please contact MOSEK support.", "args": {}}, {"caml-name": "ERR_INVALID_PROBLEM_TYPE", "name": "err_invalid_problem_type", "brief": "An invalid problem type.", "value": "6000", "msg": "An invalid problem type.", "args": {}}, {"caml-name": "ERR_UNHANDLED_SOLUTION_STATUS", "name": "err_unhandled_solution_status", "brief": "Unhandled solution status.", "value": "6010", "msg": "%{arg0} is handled solution status.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_UPPER_TRIANGLE", "name": "err_upper_triangle", "brief": "An element in the upper triangle of a lower triangular matrix is specified.", "value": "6020", "msg": "Only elements in the lower triangle should be specified however an element in position (%arg0,%arg1) is specfied.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_LAU_SINGULAR_MATRIX", "name": "err_lau_singular_matrix", "brief": "A matrix is singular.", "value": "7000", "msg": "A matrix is singular.", "args": {}}, {"caml-name": "ERR_LAU_NOT_POSITIVE_DEFINITE", "name": "err_lau_not_positive_definite", "brief": "A matrix is not positive definite.", "value": "7001", "msg": "A matrix is singular.", "args": {}}, {"caml-name": "ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX", "name": "err_lau_invalid_lower_triangular_matrix", "brief": "An invalid lower triangular matrix.", "value": "7002", "msg": "An invalid lower triangular matrix.", "args": {}}, {"caml-name": "ERR_LAU_UNKNOWN", "name": "err_lau_unknown", "brief": "An unknown error.", "value": "7005", "msg": "An unknown error.", "args": {}}, {"caml-name": "ERR_LAU_ARG_M", "name": "err_lau_arg_m", "brief": "Invalid argument m.", "value": "7010", "msg": "Invalid argument m.", "args": {}}, {"caml-name": "ERR_LAU_ARG_N", "name": "err_lau_arg_n", "brief": "Invalid argument n.", "value": "7011", "msg": "Invalid argument n.", "args": {}}, {"caml-name": "ERR_LAU_ARG_K", "name": "err_lau_arg_k", "brief": "Invalid argument k.", "value": "7012", "msg": "Invalid argument k.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANSA", "name": "err_lau_arg_transa", "brief": "Invalid argument transa.", "value": "7015", "msg": "Invalid argument transa.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANSB", "name": "err_lau_arg_transb", "brief": "Invalid argument transb.", "value": "7016", "msg": "Invalid argument transb.", "args": {}}, {"caml-name": "ERR_LAU_ARG_UPLO", "name": "err_lau_arg_uplo", "brief": "Invalid argument uplo.", "value": "7017", "msg": "Invalid argument uplo.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANS", "name": "err_lau_arg_trans", "brief": "Invalid argument trans.", "value": "7018", "msg": "Invalid argument trans.", "args": {}}, {"caml-name": "ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX", "name": "err_lau_invalid_sparse_symmetric_matrix", "brief": "An invalid sparse symmetric matrix is specfified.", "desc": "An invalid sparse symmetric matrix is specfified. Note only the lower triangular part with no duplicates is specifed.", "value": "7019", "msg": "An invalid sparse symmetric matrix is specfified.", "args": {}}, {"caml-name": "ERR_CBF_PARSE", "name": "err_cbf_parse", "brief": "An error occurred while parsing an CBF file.", "value": "7100", "msg": "(line=%{arg0}) Parse error.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_OBJ_SENSE", "name": "err_cbf_obj_sense", "brief": "An invalid objective sense is specified.", "value": "7101", "msg": "(line=%{arg0}) An invalid objective sense is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_NO_VARIABLES", "name": "err_cbf_no_variables", "brief": "An invalid objective sense is specified.", "desc": "No variables are specified.", "value": "7102", "msg": "(line=%{arg0}) An invalid objective sense is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_CONSTRAINTS", "name": "err_cbf_too_many_constraints", "brief": "Too many constraints specified.", "value": "7103", "msg": "(line=%{arg0}) Too many constraints specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_VARIABLES", "name": "err_cbf_too_many_variables", "brief": "Too many variables specified.", "value": "7104", "msg": "(line=%{arg0}) Too many variables specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_NO_VERSION_SPECIFIED", "name": "err_cbf_no_version_specified", "brief": "No version specified.", "value": "7105", "msg": "No version specified.", "args": {}}, {"caml-name": "ERR_CBF_SYNTAX", "name": "err_cbf_syntax", "brief": "Invalid syntax.", "value": "7106", "msg": "(line=%{arg0}) Invalid syntax.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_OBJ", "name": "err_cbf_duplicate_obj", "brief": "Duplicate OBJ keyword.", "value": "7107", "msg": "(line=%{arg0}) Duplicate OBJ keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_CON", "name": "err_cbf_duplicate_con", "brief": "Duplicate CON keyword.", "value": "7108", "msg": "(line=%{arg0}) Duplicate CON keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_VAR", "name": "err_cbf_duplicate_var", "brief": "Duplicate VAR keyword.", "value": "7110", "msg": "(line=%{arg0}) Duplicate VAR keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_INT", "name": "err_cbf_duplicate_int", "brief": "Duplicate INT keyword.", "value": "7111", "msg": "(line=%{arg0}) Duplicate INT keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_VAR_TYPE", "name": "err_cbf_invalid_var_type", "brief": "Invalid variable type.", "value": "7112", "msg": "(line=%{arg0}) Invalid variable type.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_CON_TYPE", "name": "err_cbf_invalid_con_type", "brief": "Invalid constraint type.", "value": "7113", "msg": "(line=%{arg0}) Invalid constraint type.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_DOMAIN_DIMENSION", "name": "err_cbf_invalid_domain_dimension", "brief": "Invalid domain dimension.", "value": "7114", "msg": "(line=%{arg0}) Invalid domain dimension.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_OBJACOORD", "name": "err_cbf_duplicate_objacoord", "brief": "Duplicate index in OBJCOORD.", "value": "7115", "msg": "Index %{arg0} is duplicate in OBJACORD.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_BCOORD", "name": "err_cbf_duplicate_bcoord", "brief": "Duplicate index in BCOORD.", "value": "7116", "msg": "Index %{arg0} is duplicate in BCOORD.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_ACOORD", "name": "err_cbf_duplicate_acoord", "brief": "Duplicate index in ACOORD.", "value": "7117", "msg": "The element in row %{i} and column %{j} is duplicate in ACOORD.", "args": {"i": ["i", "i", []], "j": ["j", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_VARIABLES", "name": "err_cbf_too_few_variables", "brief": "Too few variables defined.", "value": "7118", "msg": "Expected %{expected} but got only %{got} variables.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_CONSTRAINTS", "name": "err_cbf_too_few_constraints", "brief": "Too few constraints defined.", "value": "7119", "msg": "Expected %{expected} but got only %{got} constraints.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_INTS", "name": "err_cbf_too_few_ints", "brief": "Too ints specified.", "desc": "Too few ints are specified.", "value": "7120", "msg": "Expected %{expected} ints but got %{got}.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_INTS", "name": "err_cbf_too_many_ints", "brief": "Too ints specified.", "desc": "Too many ints are specified.", "value": "7121", "msg": "Expected %{expected} ints but got %{got}.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_INT_INDEX", "name": "err_cbf_invalid_int_index", "brief": "Invalid INT index.", "value": "7122", "msg": "(line=%{lineno}) %{index} is an invalid int index.", "args": {"lineno": ["lineno", "l", []], "index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNSUPPORTED", "name": "err_cbf_unsupported", "brief": "Unsupported feature is present.", "value": "7123", "msg": "(line=%{lineno}) An unsupported feature is present.", "args": {"lineno": ["lineno", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_PSDVAR", "name": "err_cbf_duplicate_psdvar", "brief": "Duplicate PSDVAR keyword.", "value": "7124", "msg": "(line=%{arg0}) Duplicate PSDVAR keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDVAR_DIMENSION", "name": "err_cbf_invalid_psdvar_dimension", "brief": "Invalid PSDVAR dimension.", "value": "7125", "msg": "(line=%{arg0}) %{arg1} is an invalid dimension for a PSDVAR variable.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_PSDVAR", "name": "err_cbf_too_few_psdvar", "brief": "Too few variables defined.", "value": "7126", "msg": "Expected %{expected} but got only %{got} PSD variables.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_EXP_DIMENSION", "name": "err_cbf_invalid_exp_dimension", "brief": "Invalid dimension of a exponential cone.", "value": "7127", "msg": "Invalid dimension of a exponential cone.", "args": {}}, {"caml-name": "ERR_CBF_DUPLICATE_POW_CONES", "name": "err_cbf_duplicate_pow_cones", "brief": "Multiple POWCONES specified.", "value": "7130", "msg": "Multiple POWCONES specified.", "args": {}}, {"caml-name": "ERR_CBF_DUPLICATE_POW_STAR_CONES", "name": "err_cbf_duplicate_pow_star_cones", "brief": "Multiple POW*CONES specified.", "value": "7131", "msg": "Multiple POW*CONES specified.", "args": {}}, {"caml-name": "ERR_CBF_INVALID_POWER", "name": "err_cbf_invalid_power", "brief": "Invalid power specified.", "value": "7132", "msg": "%{alpha} is an invalid power.", "args": {"alpha": ["alpha", "e", []]}}, {"caml-name": "ERR_CBF_POWER_CONE_IS_TOO_LONG", "name": "err_cbf_power_cone_is_too_long", "brief": "Power cone is too long.", "value": "7133", "msg": "Power cone is too long.", "args": {}}, {"caml-name": "ERR_CBF_INVALID_POWER_CONE_INDEX", "name": "err_cbf_invalid_power_cone_index", "brief": "Invalid power cone index.", "value": "7134", "msg": "%{index} is an invald power cone index.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_POWER_STAR_CONE_INDEX", "name": "err_cbf_invalid_power_star_cone_index", "brief": "Invalid power star cone index.", "value": "7135", "msg": "%{index} is an invald power star cone index.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNHANDLED_POWER_CONE_TYPE", "name": "err_cbf_unhandled_power_cone_type", "brief": "An unhandled power cone type.", "value": "7136", "msg": "POWCONES #%{index} is an unhandled power cone type.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE", "name": "err_cbf_unhandled_power_star_cone_type", "brief": "An unhandled power star cone type.", "value": "7137", "msg": "POW*CONES #%{index} is an unhandled power star cone type.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_POWER_CONE_MISMATCH", "name": "err_cbf_power_cone_mismatch", "brief": "The power cone does not match with it definition.", "value": "7138", "msg": "The power cone does not match POWCONES #%{index}.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_POWER_STAR_CONE_MISMATCH", "name": "err_cbf_power_star_cone_mismatch", "brief": "The power star cone does not match with it definition.", "value": "7139", "msg": "The power star cone does not match POW*CONES #%{index}.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_NUMBER_OF_CONES", "name": "err_cbf_invalid_number_of_cones", "brief": "Invalid number of cones.", "value": "7140", "msg": "%{number} is an invalid number of cones.", "args": {"number": ["number", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_DIMENSION_OF_CONES", "name": "err_cbf_invalid_dimension_of_cones", "brief": "Invalid number of cones.", "value": "7141", "msg": "%{number} is an invalid number of cones.", "args": {"number": ["number", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_OBJACOORD", "name": "err_cbf_invalid_num_objacoord", "brief": "Invalid number of OBJACOORD.", "value": "7150", "msg": "(line=%{arg0}) Invalid number of OBJACOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_OBJFCOORD", "name": "err_cbf_invalid_num_objfcoord", "brief": "Invalid number of OBJFCOORD.", "value": "7151", "msg": "(line=%{arg0}) Invalid number of OBJFCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_ACOORD", "name": "err_cbf_invalid_num_acoord", "brief": "Invalid number of ACOORD.", "value": "7152", "msg": "(line=%{arg0}) Invalid number of ACOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_BCOORD", "name": "err_cbf_invalid_num_bcoord", "brief": "Invalid number of BCOORD.", "value": "7153", "msg": "(line=%{arg0}) Invalid number of BCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_FCOORD", "name": "err_cbf_invalid_num_fcoord", "brief": "Invalid number of FCOORD.", "value": "7155", "msg": "(line=%{arg0}) Invalid number of FCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_HCOORD", "name": "err_cbf_invalid_num_hcoord", "brief": "Invalid number of HCOORD.", "value": "7156", "msg": "(line=%{arg0}) Invalid number of HCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_DCOORD", "name": "err_cbf_invalid_num_dcoord", "brief": "Invalid number of DCOORD.", "value": "7157", "msg": "(line=%{arg0}) Invalid number of DCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_EXPECTED_A_KEYWORD", "name": "err_cbf_expected_a_keyword", "brief": "Expected a key word.", "value": "7158", "msg": "(line=%{arg0}) Expected a keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_PSDCON", "name": "err_cbf_invalid_num_psdcon", "brief": "Invalid number of PSDCON.", "value": "7200", "msg": "(line=%{arg0}) Invalid number of PSDCON.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_PSDCON", "name": "err_cbf_duplicate_psdcon", "brief": "Duplicate CON keyword.", "value": "7201", "msg": "(line=%{arg0}) Duplicate PSDCON keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_DIMENSION_OF_PSDCON", "name": "err_cbf_invalid_dimension_of_psdcon", "brief": "Invalid PSDCON dimension.", "value": "7202", "msg": "(line=%{arg0}) Invalid PSDCON dimmension.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_INDEX", "name": "err_cbf_invalid_psdcon_index", "brief": "Invalid PSDCON index.", "value": "7203", "msg": "Invalid PSDCON of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX", "name": "err_cbf_invalid_psdcon_variable_index", "brief": "Invalid PSDCON index.", "value": "7204", "msg": "Invalid PSDCON variable index of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_BLOCK_INDEX", "name": "err_cbf_invalid_psdcon_block_index", "brief": "Invalid PSDCON index.", "value": "7205", "msg": "Invalid PSDCON block index of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_UNSUPPORTED_CHANGE", "name": "err_cbf_unsupported_change", "brief": "The CHANGE section is not supported.", "value": "7210", "msg": "The CHANGE section is not supported.", "args": {}}, {"caml-name": "ERR_MIO_INVALID_ROOT_OPTIMIZER", "name": "err_mio_invalid_root_optimizer", "brief": "An invalid root optimizer was selected for the problem type.", "value": "7700", "msg": "An invalid root optimizer was selected for the problem type.", "args": {}}, {"caml-name": "ERR_MIO_INVALID_NODE_OPTIMIZER", "name": "err_mio_invalid_node_optimizer", "brief": "An invalid node optimizer was selected for the problem type.", "value": "7701", "msg": "An invalid node optimizer was selected for the problem type.", "args": {}}, {"caml-name": "ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE", "name": "err_mps_write_cplex_invalid_cone_type", "brief": "An invalid cone type occurs when writing a CPLEX formatted MPS file.", "value": "7750", "msg": "An invalid cone type ('%{arg0}') occurs when writing a CPLEX formatted MPS file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_TOCONIC_CONSTR_Q_NOT_PSD", "name": "err_toconic_constr_q_not_psd", "brief": "The matrix defining the quadratric part of constraint is not positive semidefinite.", "value": "7800", "msg": "(constraint=%{constrno}) : The matrix defining the quadratric part of constraint is not positive semidefinite.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTRAINT_FX", "name": "err_toconic_constraint_fx", "brief": "The quadratic constraint is an equality, thus not convex.", "value": "7801", "msg": "(constraint=%{constrno}) : The quadratic constraint is an equality, thus not convex.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTRAINT_RA", "name": "err_toconic_constraint_ra", "brief": "The quadratic constraint has finite lower and upper bound, and therefore it is not convex.", "value": "7802", "msg": "(constraint=%{constrno}) : The quadratic constraint has finite lower and upper bound, and therefore it is not convex.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTR_NOT_CONIC", "name": "err_toconic_constr_not_conic", "brief": "The constraint is not conic representable.", "value": "7803", "msg": "(constraint=%{constrno}) : The constraint is not conic representable.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_OBJECTIVE_NOT_PSD", "name": "err_toconic_objective_not_psd", "brief": "The matrix defining the quadratric part of the objective function is not positive semidefinite.", "value": "7804", "msg": "The objective function can not not be converted in conic form.", "args": {}}, {"caml-name": "ERR_SERVER_CONNECT", "name": "err_server_connect", "brief": "Failed to connect to remote solver server.", "desc": "Failed to connect to remote solver server. The server\nstring or the port string were invalid, or the server\ndid not accept connection.", "value": "8000", "msg": "Failed to connect to remote solver server (%{server}:%{port}).", "args": {"server": ["server", "s", []], "port": ["port", "s", []]}}, {"caml-name": "ERR_SERVER_PROTOCOL", "name": "err_server_protocol", "brief": "Unexpected message or data from solver server.", "value": "8001", "msg": "Unexpected message or data from solver server.", "args": {}}, {"caml-name": "ERR_SERVER_STATUS", "name": "err_server_status", "brief": "Server returned non-ok status code", "desc": "Server returned non-ok HTTP status code", "value": "8002", "msg": "Server returned status: %{status} %{reason}.", "args": {"status": ["status", "i", []], "reason": ["reason", "s", []]}}, {"caml-name": "ERR_SERVER_TOKEN", "name": "err_server_token", "brief": "Invalid job ID", "desc": "The job ID specified is incorrect or invalid", "value": "8003", "msg": "Invalid job ID %{token}.", "args": {"token": ["token", "s", []]}}, {"caml-name": "ERR_SERVER_ADDRESS", "name": "err_server_address", "brief": "Invalid address", "desc": "Invalid address string", "value": "8004", "msg": "Invalid address string '%{addr}'", "args": {"addr": ["addr", "s", []]}}, {"caml-name": "ERR_SERVER_CERTIFICATE", "name": "err_server_certificate", "brief": "Invalid TLS certificate format or path", "value": "8005", "msg": "Invalid TLS certificate format or path.", "args": {}}, {"caml-name": "ERR_SERVER_TLS_CLIENT", "name": "err_server_tls_client", "brief": "Failed to create TLS client", "desc": "Failed to create TLS cleint", "value": "8006", "msg": "Failed to create TLS client", "args": {}}, {"caml-name": "ERR_SERVER_ACCESS_TOKEN", "name": "err_server_access_token", "brief": "Invalid access token", "value": "8007", "msg": "Invalid access token", "args": {}}, {"caml-name": "ERR_SERVER_PROBLEM_SIZE", "name": "err_server_problem_size", "brief": "The problem is too large.", "desc": "The size of the problem exceeds the dimensions permitted by the instance of the |optserver| where it was run.", "value": "8008", "msg": "The problem is too large", "args": {}}, {"caml-name": "ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX", "name": "err_duplicate_index_in_a_sparse_matrix", "brief": "An element in a sparse matrix is specified twice.", "value": "20050", "msg": "The the element in row '%{arg1}'and column '%{arg2}' is specfied twice.", "args": {"arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST", "name": "err_duplicate_index_in_afeidx_list", "brief": "An index is specified twice in an affine expression list.", "value": "20060", "msg": "the index  '%{arg1}' is specified twice in an affine expression list.", "args": {"arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_DUPLICATE_FIJ", "name": "err_duplicate_fij", "brief": "An element in the F matrix is specified twice.", "value": "20100", "msg": "The F matrix element at at row %{arg0} and column %{arg1} is specified twice.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_INVALID_FIJ", "name": "err_invalid_fij", "brief": "f[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`f_{i,j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20101", "msg": "The value of the f[%{arg0},%{arg1}] is invalid.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_HUGE_FIJ", "name": "err_huge_fij", "brief": "A numerically huge value is specified for an element in F.", "desc": "A numerically huge value is specified for an :math:`f_{i,j}` element in :math:`F`.  The parameter  :msk:dparam:`data_tol_aij_huge` controls when an :math:`f_{i,j}` is considered huge.", "value": "20102", "msg": "The F matrix contains a huge value of %{arg0} in row %{arg1} and column %{arg2}.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "l", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_INVALID_G", "name": "err_invalid_g", "brief": "g contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`g` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20103", "msg": "The value of g in position %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INVALID_B", "name": "err_invalid_b", "brief": "b contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`b` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20150", "msg": "The value of b in position %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_INVALID_INDEX", "name": "err_domain_invalid_index", "brief": "A domain index is invalid.", "value": "20400", "msg": "The domain index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_DOMAIN_DIMENSION", "name": "err_domain_dimension", "brief": "A domain dimension is invalid.", "value": "20401", "msg": "The dimension %{arg0} is invalid for this domain. It should be %{arg1} %{arg2}.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_DOMAIN_DIMENSION_PSD", "name": "err_domain_dimension_psd", "brief": "A PSD domain dimension is invalid.", "value": "20402", "msg": "The dimension %{arg0} is invalid for a positive semi-definite cone domain.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_NOT_POWER_DOMAIN", "name": "err_not_power_domain", "brief": "The function is only applicable to primal and dual power cone domains.", "value": "20403", "msg": "The domain %{arg0} is not a power cone domain.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_INVALID_ALPHA", "name": "err_domain_power_invalid_alpha", "brief": "Alpha contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": "Alpha contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20404", "msg": "The value of alpha[%{arg0}] is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_NEGATIVE_ALPHA", "name": "err_domain_power_negative_alpha", "brief": "Alpha contains a negative value or zero.", "value": "20405", "msg": "The value of alpha[%{arg0}] not strictly positive.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_NLEFT", "name": "err_domain_power_nleft", "brief": "The value of nleft is too small or too large.", "desc": "The value of :math:`n_\\mathrm{left}` is not in :math:`[1, n-1]` where :math:`n` is the dimension.", "value": "20406", "msg": "The left dimension '%{arg0}' is invalid. It should belong to the range [1,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_AFE_INVALID_INDEX", "name": "err_afe_invalid_index", "brief": "An affine expression index is invalid.", "value": "20500", "msg": "The affine expression index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_ACC_INVALID_INDEX", "name": "err_acc_invalid_index", "brief": "A affine conic constraint index is invalid.", "value": "20600", "msg": "The affine conic constraint index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_ACC_INVALID_ENTRY_INDEX", "name": "err_acc_invalid_entry_index", "brief": "The index of an element in an affine conic constraint is invalid.", "value": "20601", "msg": "The element index '%{arg0}' is invalid for constraint '%{arg1}'. It should belong to the range [0,%{arg2}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_ACC_AFE_DOMAIN_MISMATCH", "name": "err_acc_afe_domain_mismatch", "brief": "There is a mismatch between between the number of affine expressions and total dimension of the domain(s).", "value": "20602", "msg": "The number affine expressions is %{numafe} and the total dimension of the domain(s) is %{n} which is mismatch.", "args": {"numafe": ["numafe", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_INVALID_INDEX", "name": "err_djc_invalid_index", "brief": "A disjunctive constraint index is invalid.", "value": "20700", "msg": "The disjunctive constraint index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_DJC_UNSUPPORTED_DOMAIN_TYPE", "name": "err_djc_unsupported_domain_type", "brief": "An unsupported domain type has been used in a disjunctive constraint.", "value": "20701", "msg": "Domain type '%{arg0}' is unsupported in a disjunctive constraint.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DJC_AFE_DOMAIN_MISMATCH", "name": "err_djc_afe_domain_mismatch", "brief": "There is a mismatch between the number of affine expressions and total dimension of the domain(s).", "value": "20702", "msg": "The number affine expressions is %{numafe} and the total dimension of the domain(s) is %{n} which is mismatch.", "args": {"numafe": ["numafe", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_INVALID_TERM_SIZE", "name": "err_djc_invalid_term_size", "brief": "A termize is invalid.", "value": "20703", "msg": "The term size '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DJC_DOMAIN_TERMSIZE_MISMATCH", "name": "err_djc_domain_termsize_mismatch", "brief": "There is a mismatch between the number of domains and the term sizes.", "value": "20704", "msg": "The number of domains is %{numdom} and the total term size is %{n} which is mismatch.", "args": {"numdom": ["numdom", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_TOTAL_NUM_TERMS_MISMATCH", "name": "err_djc_total_num_terms_mismatch", "brief": "There total number of terms in all domains does not match.", "value": "20705", "msg": "The number of terms is %{numterm} and the sum per domain gives %{n} which is mismatch.", "args": {"numterm": ["numterm", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_UNDEF_SOLUTION", "name": "err_undef_solution", "brief": "The required solution is not defined.", "desc": "|mosek| has the following solution types:\n\n* an interior-point solution,\n* a basic solution,\n* and an integer solution.\n\nEach optimizer may set one or more of these solutions; e.g by default a successful optimization with the interior-point optimizer defines the interior-point solution and, for linear problems, also the basic  solution. This error occurs when asking for a solution  or for information about a solution that is not defined.", "value": "22000", "msg": "The solution with code %{arg0} is not defined.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_DOTY", "name": "err_no_doty", "brief": "No doty is available.", "desc": "No doty is available", "value": "22010", "msg": "A doty is not available for the solution with code %{arg0} is not defined.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "TRM_MAX_ITERATIONS", "name": "trm_max_iterations", "brief": "The optimizer terminated at the maximum number of iterations.", "value": "100000", "msg": "Maximum number of iterations is exceeded.", "args": {}}, {"caml-name": "TRM_MAX_TIME", "name": "trm_max_time", "brief": "The optimizer terminated at the maximum amount of time.", "value": "100001", "msg": "Maximum amount of time exceeded.", "args": {}}, {"caml-name": "TRM_OBJECTIVE_RANGE", "name": "trm_objective_range", "brief": "The optimizer terminated with an objective value outside the objective range.", "value": "100002", "msg": "The optimal solution has an objective value outside the objective range.", "args": {}}, {"caml-name": "TRM_MIO_NUM_RELAXS", "name": "trm_mio_num_relaxs", "brief": "The mixed-integer optimizer terminated as the maximum number of relaxations was reached.", "value": "100008", "msg": "The mixed-integer optimizer terminated as the maximum number of relaxations was reached.", "args": {}}, {"caml-name": "TRM_MIO_NUM_BRANCHES", "name": "trm_mio_num_branches", "brief": "The mixed-integer optimizer terminated as the maximum number of branches was reached.", "value": "100009", "msg": "The mixed-integer optimizer terminated as the maximum number of branches was reached.", "args": {}}, {"caml-name": "TRM_NUM_MAX_NUM_INT_SOLUTIONS", "name": "trm_num_max_num_int_solutions", "brief": "The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.", "value": "100015", "msg": "The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.", "args": {}}, {"caml-name": "TRM_STALL", "name": "trm_stall", "brief": "The optimizer is terminated due to slow progress.", "desc": "The optimizer is terminated due to slow progress.\n\nStalling means that numerical problems prevent the optimizer from\nmaking reasonable progress and that it makes no sense to continue.\nIn many cases this happens if the problem is badly scaled or\notherwise ill-conditioned. There is no guarantee that the\nsolution will be feasible or optimal. However, often\nstalling happens near the optimum, and the returned solution may\nbe of good quality. Therefore, it is recommended to check the\nstatus of the solution. If the solution status is optimal the solution is\nmost likely good enough for most practical purposes.\n\nPlease note that if a linear optimization problem is solved using\nthe interior-point optimizer with basis identification turned on,\nthe returned basic solution likely to have high accuracy, even though\nthe optimizer stalled.\n\nSome common causes of stalling are a) badly scaled models, b)\nnear feasible or near infeasible problems.", "value": "100006", "msg": "The optimizer is terminated due to slow progress.", "args": {}}, {"caml-name": "TRM_USER_CALLBACK", "name": "trm_user_callback", "brief": "The user-defined progress callback function terminated the optimization.", "desc": "The optimizer terminated due to the return of\nthe user-defined callback function.", "value": "100007", "msg": "The user-defined progress callback function terminated the optimization.", "args": {}}, {"caml-name": "TRM_MAX_NUM_SETBACKS", "name": "trm_max_num_setbacks", "brief": "The optimizer terminated as the maximum number of set-backs was reached.", "desc": "The optimizer terminated as the maximum number of set-backs was reached.\nThis indicates serious numerical problems and a possibly badly formulated problem.", "value": "100020", "msg": "The optimizer terminated as the maximum number of set-backs was reached.", "args": {}}, {"caml-name": "TRM_NUMERICAL_PROBLEM", "name": "trm_numerical_problem", "brief": "The optimizer terminated due to a numerical problem.", "desc": "The optimizer terminated due to numerical problems.", "value": "100025", "msg": "The optimizer terminated due to a numerical problem.", "args": {}}, {"caml-name": "TRM_LOST_RACE", "name": "trm_lost_race", "brief": "Lost a race.", "value": "100027", "msg": "Lost a race.", "args": {}}, {"caml-name": "TRM_INTERNAL", "name": "trm_internal", "brief": "The optimizer terminated due to some internal reason.", "desc": "The optimizer terminated due to some internal reason. Please contact |mosek| support.", "value": "100030", "msg": "The optimizer terminated due to some internal reason.", "args": {}}, {"caml-name": "TRM_INTERNAL_STOP", "name": "trm_internal_stop", "brief": "The optimizer terminated for internal reasons.", "desc": "The optimizer terminated for internal reasons. Please contact |mosek| support.", "value": "100031", "msg": "The optimizer terminated for internal reasons.", "args": {}}]}, "rescodetype": {"name": "rescodetype", "brief": "Response code type", "is-enumerable": true, "prefix": "RESPONSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "OK", "name": "ok", "brief": "The response code is OK.", "value": "0"}, {"caml-name": "WRN", "name": "wrn", "brief": "The response code is a warning.", "value": "1"}, {"caml-name": "TRM", "name": "trm", "brief": "The response code is an optimizer termination status.", "value": "2"}, {"caml-name": "ERR", "name": "err", "brief": "The response code is an error.", "value": "3"}, {"caml-name": "UNK", "name": "unk", "brief": "The response code does not belong to any class.", "value": "4"}]}, "scalingtype": {"name": "scalingtype", "brief": "Scaling type", "is-enumerable": false, "prefix": "SCALING_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the scaling heuristic.", "value": "0"}, {"caml-name": "NONE", "name": "none", "brief": "No scaling is performed.", "value": "1"}]}, "scalingmethod": {"name": "scalingmethod", "brief": "Scaling method", "is-enumerable": false, "prefix": "SCALING_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "POW2", "name": "pow2", "brief": "Scales only with power of 2 leaving the mantissa untouched.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the scaling heuristic.", "value": "1"}]}, "sensitivitytype": {"name": "sensitivitytype", "brief": "Sensitivity types", "is-enumerable": false, "prefix": "SENSITIVITY_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "BASIS", "name": "basis", "brief": "Basis sensitivity analysis is performed.", "value": "0"}]}, "simseltype": {"name": "simseltype", "brief": "Simplex selection strategy", "is-enumerable": false, "prefix": "SIM_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the pricing strategy.", "value": "0"}, {"caml-name": "FULL", "name": "full", "brief": "The optimizer uses full pricing.", "value": "1"}, {"caml-name": "ASE", "name": "ase", "brief": "The optimizer uses approximate steepest-edge pricing.", "value": "2"}, {"caml-name": "DEVEX", "name": "devex", "brief": "The optimizer uses devex steepest-edge pricing.", "desc": "The optimizer uses devex steepest-edge pricing (or if it is not available an approximate steep-edge selection).", "value": "3"}, {"caml-name": "SE", "name": "se", "brief": "The optimizer uses steepest-edge selection.", "desc": "The optimizer uses steepest-edge selection (or if it is not available an approximate steep-edge selection).", "value": "4"}, {"caml-name": "PARTIAL", "name": "partial", "brief": "The optimizer uses a partial selection approach.", "desc": "The optimizer uses a partial selection approach. The approach is usually beneficial if the number of variables is much larger than  the number of constraints.", "value": "5"}]}, "solitem": {"name": "solitem", "brief": "Solution items", "is-enumerable": true, "prefix": "SOL_ITEM_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "XC", "name": "xc", "brief": "Solution for the constraints.", "value": "0"}, {"caml-name": "XX", "name": "xx", "brief": "Variable solution.", "value": "1"}, {"caml-name": "Y", "name": "y", "brief": "Lagrange multipliers for equations.", "value": "2"}, {"caml-name": "SLC", "name": "slc", "brief": "Lagrange multipliers for lower bounds on the constraints.", "value": "3"}, {"caml-name": "SUC", "name": "suc", "brief": "Lagrange multipliers for upper bounds on the constraints.", "value": "4"}, {"caml-name": "SLX", "name": "slx", "brief": "Lagrange multipliers for lower bounds on the variables.", "value": "5"}, {"caml-name": "SUX", "name": "sux", "brief": "Lagrange multipliers for upper bounds on the variables.", "value": "6"}, {"caml-name": "SNX", "name": "snx", "brief": "Lagrange multipliers corresponding to the conic constraints on the variables.", "value": "7"}]}, "solsta": {"name": "solsta", "brief": "Solution status keys", "is-enumerable": true, "prefix": "SOL_STA_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNKNOWN", "name": "unknown", "brief": "Status of the solution is unknown.", "value": "0"}, {"caml-name": "OPTIMAL", "name": "optimal", "brief": "The solution is optimal.", "value": "1"}, {"caml-name": "PRIM_FEAS", "name": "prim_feas", "brief": "The solution is primal feasible.", "value": "2"}, {"caml-name": "DUAL_FEAS", "name": "dual_feas", "brief": "The solution is dual feasible.", "value": "3"}, {"caml-name": "PRIM_AND_DUAL_FEAS", "name": "prim_and_dual_feas", "brief": "The solution is both primal and dual feasible.", "value": "4"}, {"caml-name": "PRIM_INFEAS_CER", "name": "prim_infeas_cer", "brief": "The solution is a certificate of primal infeasibility.", "value": "5"}, {"caml-name": "DUAL_INFEAS_CER", "name": "dual_infeas_cer", "brief": "The solution is a certificate of dual infeasibility.", "value": "6"}, {"caml-name": "PRIM_ILLPOSED_CER", "name": "prim_illposed_cer", "brief": "The solution is a certificate that the primal problem is illposed.", "value": "7"}, {"caml-name": "DUAL_ILLPOSED_CER", "name": "dual_illposed_cer", "brief": "The solution is a certificate that the dual problem is illposed.", "value": "8"}, {"caml-name": "INTEGER_OPTIMAL", "name": "integer_optimal", "brief": "The primal solution is integer optimal.", "value": "9"}]}, "soltype": {"name": "soltype", "brief": "Solution types", "is-enumerable": true, "prefix": "SOL_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "BAS", "name": "bas", "brief": "The basic solution.", "value": "1"}, {"caml-name": "ITR", "name": "itr", "brief": "The interior solution.", "value": "0"}, {"caml-name": "ITG", "name": "itg", "brief": "The integer solution.", "value": "2"}]}, "solveform": {"name": "solveform", "brief": "Solve primal or dual form", "is-enumerable": false, "prefix": "SOLVE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer is free to solve either the primal or the dual problem.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The optimizer should solve the primal problem.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The optimizer should solve the dual problem.", "value": "2"}]}, "sparam": {"name": "sparam", "brief": "String parameters", "desc": "The enumeration type containing all string parameters.", "is-enumerable": true, "prefix": "SPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "DATA_FILE_NAME", "name": "data_file_name", "brief": "Data are read and written to this file.", "value": "1", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_READ_FILE_NAME", "name": "param_read_file_name", "brief": "Modifications to the parameter database is read from this file.", "value": "7", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_WRITE_FILE_NAME", "name": "param_write_file_name", "brief": "The parameter database is written to this file.", "value": "8", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_COMMENT_SIGN", "name": "param_comment_sign", "brief": "Solution file comment character.", "desc": "Only the first character in this string is\nused. It is considered as a start of comment sign\nin the |mosek| parameter file. Spaces are ignored\nin the string.", "value": "6", "default": "%%", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "DEBUG_FILE_NAME", "name": "debug_file_name", "brief": "MOSEK debug file.", "desc": "|mosek| debug file.", "value": "2", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "BAS_SOL_FILE_NAME", "name": "bas_sol_file_name", "brief": "Name of the bas solution file.", "desc": "Name of the ``bas`` solution file.", "value": "0", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "ITR_SOL_FILE_NAME", "name": "itr_sol_file_name", "brief": "Name of the itr solution file.", "desc": "Name of the ``itr`` solution file.", "value": "4", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "INT_SOL_FILE_NAME", "name": "int_sol_file_name", "brief": "Name of the int solution file.", "desc": "Name of the ``int`` solution file.", "value": "3", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XC_LOW", "name": "sol_filter_xc_low", "brief": "Solution file filter.", "desc": "A filter used to determine which constraints should be listed in the solution file. A value of :math:`0.5` means that all constraints having  ``xc[i]>0.5`` should be listed, whereas ``+0.5`` means that all constraints having ``xc[i]>=blc[i]+0.5`` should be listed. An empty filter means that no filter is applied.", "value": "18", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XC_UPR", "name": "sol_filter_xc_upr", "brief": "Solution file filter.", "desc": "A filter  used to determine which constraints should be listed in the solution file. A value of ``0.5`` means that all constraints having ``xc[i]<0.5`` should be listed, whereas ``-0.5`` means all constraints having ``xc[i]<=buc[i]-0.5`` should be listed. An empty filter means that no filter is applied.", "value": "19", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XX_LOW", "name": "sol_filter_xx_low", "brief": "Solution file filter.", "desc": "A filter  used to determine which variables should be listed in the solution file. A value of \"0.5\" means that all constraints having ``xx[j]>=0.5`` should be listed, whereas \"+0.5\" means that all constraints having ``xx[j]>=blx[j]+0.5`` should be listed. An empty filter means no filter is applied.", "value": "20", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XX_UPR", "name": "sol_filter_xx_upr", "brief": "Solution file filter.", "desc": "A filter  used to determine which variables should be listed in the solution file. A value of \"0.5\" means that all constraints having ``xx[j]<0.5`` should be printed, whereas \"-0.5\" means all constraints having ``xx[j]<=bux[j]-0.5`` should be listed. An empty filter means no filter is applied.", "value": "21", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "READ_MPS_OBJ_NAME", "name": "read_mps_obj_name", "brief": "Objective name in the MPS file.", "desc": "Name of the free constraint used as objective function.\nAn empty name means that the first constraint is used as objective function.", "value": "10", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_RAN_NAME", "name": "read_mps_ran_name", "brief": "Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.", "value": "11", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_RHS_NAME", "name": "read_mps_rhs_name", "brief": "Name of the RHS used. An empty name means that the first RHS vector is used.", "value": "12", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_BOU_NAME", "name": "read_mps_bou_name", "brief": "Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.", "value": "9", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "STAT_NAME", "name": "stat_name", "brief": "Name used when writing the statistics file.", "value": "23", "default": "", "references": [], "status": "api", "valuescomment": "Any valid XML string.", "member-of": ["dataio-param"]}, {"caml-name": "STAT_KEY", "name": "stat_key", "brief": "Key used when writing the summary file.", "value": "22", "default": "", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "WRITE_LP_GEN_VAR_NAME", "name": "write_lp_gen_var_name", "brief": "Added variable names in the LP files.", "desc": "Sometimes when an LP file is written additional variables must be inserted.\nThey will have the prefix denoted by this parameter.", "value": "24", "default": "xmskgen", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "SENSITIVITY_RES_FILE_NAME", "name": "sensitivity_res_file_name", "brief": "Name of the sensitivity report output file.", "desc": ".. msk_only:: cmdtools\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If this is a nonempty string, then :msk:func:`task.sensitivityreport` writes results to this file.", "value": "17", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "SENSITIVITY_FILE_NAME", "name": "sensitivity_file_name", "brief": "Sensitivity report file name.", "desc": ".. msk_only:: cmdtools\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If defined :msk:func:`task.sensitivityreport` reads this file as\n   a sensitivity analysis data file specifying the type of analysis to be done.\n\n.. msk_only:: (not optimizer) and (not cmdtools)\n\n   If defined, |mosek| reads this file as\n   a sensitivity analysis data file specifying the type of analysis to be done.", "value": "16", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "MIO_DEBUG_STRING", "name": "mio_debug_string", "brief": "For internal debugging purposes.", "value": "5", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "REMOTE_OPTSERVER_HOST", "name": "remote_optserver_host", "brief": "URL of the remote optimization server.", "desc": "URL of the remote optimization server in the format ``(http|https)://server:port``. If set, all subsequent calls to any |mosek| function that involves synchronous optimization will be sent to the specified |optserver| instead of being executed locally. Passing empty string deactivates this redirection.", "value": "13", "default": "", "references": [], "status": "api", "valuescomment": "Any valid URL.", "member-of": ["system-param"]}, {"caml-name": "REMOTE_TLS_CERT_PATH", "name": "remote_tls_cert_path", "brief": "Path to known server certificates in PEM format", "desc": "Path to known server certificates in PEM format.", "value": "15", "default": "", "references": [], "status": "api", "valuescomment": "Any valid path.", "member-of": ["system-param"]}, {"caml-name": "REMOTE_TLS_CERT", "name": "remote_tls_cert", "brief": "Known server certificates in PEM format", "desc": "List of known server certificates in PEM format.", "value": "14", "default": "", "references": [], "status": "api", "valuescomment": "PEM files separated by new-lines.", "member-of": ["system-param"]}], "type": "string"}, "stakey": {"name": "stakey", "brief": "Status keys", "is-enumerable": true, "prefix": "SK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNK", "name": "unk", "brief": "The status for the constraint or variable is unknown.", "value": "0"}, {"caml-name": "BAS", "name": "bas", "brief": "The constraint or variable is in the basis.", "value": "1"}, {"caml-name": "SUPBAS", "name": "supbas", "brief": "The constraint or variable is super basic.", "value": "2"}, {"caml-name": "LOW", "name": "low", "brief": "The constraint or variable is at its lower bound.", "value": "3"}, {"caml-name": "UPR", "name": "upr", "brief": "The constraint or variable is at its upper bound.", "value": "4"}, {"caml-name": "FIX", "name": "fix", "brief": "The constraint or variable is fixed.", "value": "5"}, {"caml-name": "INF", "name": "inf", "brief": "The constraint or variable is infeasible in the bounds.", "value": "6"}]}, "startpointtype": {"name": "startpointtype", "brief": "Starting point types", "is-enumerable": false, "prefix": "STARTING_POINT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The starting point is chosen automatically.", "value": "0"}, {"caml-name": "GUESS", "name": "guess", "brief": "The optimizer guesses a starting point.", "value": "1"}, {"caml-name": "CONSTANT", "name": "constant", "brief": "The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.", "value": "2"}]}, "streamtype": {"name": "streamtype", "brief": "Stream types", "is-enumerable": true, "prefix": "STREAM_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LOG", "name": "log", "brief": "Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.", "value": "0"}, {"caml-name": "MSG", "name": "msg", "brief": "Message stream. Log information relating to performance and progress of the optimization is written to this stream.", "value": "1"}, {"caml-name": "ERR", "name": "err", "brief": "Error stream. Error messages are written to this stream.", "value": "2"}, {"caml-name": "WRN", "name": "wrn", "brief": "Warning stream. Warning messages are written to this stream.", "value": "3"}]}, "value": {"name": "value", "brief": "Integer values", "is-enumerable": false, "prefix": "", "value-type": "int", "values-asgn": "arbitrary", "api-class": "api", "members": [{"caml-name": "MAX_STR_LEN", "name": "max_str_len", "brief": "Maximum string length allowed in MOSEK.", "desc": "Maximum string length allowed in |mosek|.", "value": "1024"}, {"caml-name": "LICENSE_BUFFER_LENGTH", "name": "license_buffer_length", "brief": "The length of a license key buffer.", "value": "21"}]}, "variabletype": {"name": "variabletype", "brief": "Variable types", "is-enumerable": true, "prefix": "VAR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "TYPE_CONT", "name": "type_cont", "brief": "Is a continuous variable.", "value": "0"}, {"caml-name": "TYPE_INT", "name": "type_int", "brief": "Is an integer variable.", "value": "1"}]}}, "consts": {"language": {"name": "language", "brief": "Language selection constants", "is-enumerable": true, "prefix": "LANG_", "value-type": "int", "values-asgn": "sequential", "api-class": "internal", "members": [{"caml-name": "ENG", "name": "eng", "brief": "English language selection", "value": "0"}, {"caml-name": "DAN", "name": "dan", "brief": "Danish language selection", "value": "1"}]}, "basindtype": {"name": "basindtype", "brief": "Basis identification", "is-enumerable": false, "prefix": "BI_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NEVER", "name": "never", "brief": "Never do basis identification.", "value": "0"}, {"caml-name": "ALWAYS", "name": "always", "brief": "Basis identification is always performed even if the interior-point optimizer terminates abnormally.", "value": "1"}, {"caml-name": "NO_ERROR", "name": "no_error", "brief": "Basis identification is performed if the interior-point optimizer terminates without an error.", "value": "2"}, {"caml-name": "IF_FEASIBLE", "name": "if_feasible", "brief": "Basis identification is not performed if the interior-point optimizer terminates with a problem status saying that the problem is primal or dual infeasible.", "value": "3"}, {"caml-name": "RESERVERED", "name": "reservered", "brief": "Not currently in use.", "value": "4"}]}, "boundkey": {"name": "boundkey", "brief": "Bound keys", "is-enumerable": true, "prefix": "BK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The constraint or variable has a finite lower bound and an infinite upper bound.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The constraint or variable has an infinite lower bound and an finite upper bound.", "value": "1"}, {"caml-name": "FX", "name": "fx", "brief": "The constraint or variable is fixed.", "value": "2"}, {"caml-name": "FR", "name": "fr", "brief": "The constraint or variable is free.", "value": "3"}, {"caml-name": "RA", "name": "ra", "brief": "The constraint or variable is ranged.", "value": "4"}]}, "mark": {"name": "mark", "brief": "Mark", "is-enumerable": true, "prefix": "MARK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The lower bound is selected for sensitivity analysis.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The upper bound is selected for sensitivity analysis.", "value": "1"}]}, "simdegen": {"name": "simdegen", "brief": "Degeneracy strategies", "is-enumerable": true, "prefix": "SIM_DEGEN_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The simplex optimizer should use no degeneration strategy.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer chooses the degeneration strategy.", "value": "1"}, {"caml-name": "AGGRESSIVE", "name": "aggressive", "brief": "The simplex optimizer should use an aggressive degeneration strategy.", "value": "2"}, {"caml-name": "MODERATE", "name": "moderate", "brief": "The simplex optimizer should use a moderate degeneration strategy.", "value": "3"}, {"caml-name": "MINIMUM", "name": "minimum", "brief": "The simplex optimizer should use a minimum degeneration strategy.", "value": "4"}]}, "transpose": {"name": "transpose", "brief": "Transposed matrix.", "is-enumerable": true, "prefix": "TRANSPOSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NO", "name": "no", "brief": "No transpose is applied.", "value": "0"}, {"caml-name": "YES", "name": "yes", "brief": "A transpose is applied.", "value": "1"}]}, "uplo": {"name": "uplo", "brief": "Triangular part of a symmetric matrix.", "is-enumerable": true, "prefix": "UPLO_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "Lower part.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "Upper part.", "value": "1"}]}, "simreform": {"name": "simreform", "brief": "Problem reformulation.", "is-enumerable": true, "prefix": "SIM_REFORMULATION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Allow the simplex optimizer to reformulate the problem.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Disallow the simplex optimizer to reformulate the problem.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer can choose freely.", "value": "2"}, {"caml-name": "AGGRESSIVE", "name": "aggressive", "brief": "The simplex optimizer should use an aggressive reformulation strategy.", "value": "3"}]}, "simdupvec": {"name": "simdupvec", "brief": "Exploit duplicate columns.", "is-enumerable": true, "prefix": "SIM_EXPLOIT_DUPVEC_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Allow the simplex optimizer to exploit duplicated columns.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Disallow the simplex optimizer to exploit duplicated columns.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimizer can choose freely.", "value": "2"}]}, "simhotstart": {"name": "simhotstart", "brief": "Hot-start type employed by the simplex optimizer", "is-enumerable": true, "prefix": "SIM_HOTSTART_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The simplex optimizer performs a coldstart.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The simplex optimize chooses the hot-start type.", "value": "1"}, {"caml-name": "STATUS_KEYS", "name": "status_keys", "brief": "Only the status keys of the constraints and variables are used to choose the type of hot-start.", "value": "2"}]}, "intpnthotstart": {"name": "intpnthotstart", "brief": "Hot-start type employed by the interior-point optimizers.", "is-enumerable": true, "prefix": "INTPNT_HOTSTART_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The interior-point optimizer performs a coldstart.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The interior-point optimizer exploits the primal solution only.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The interior-point optimizer exploits the dual solution only.", "value": "2"}, {"caml-name": "PRIMAL_DUAL", "name": "primal_dual", "brief": "The interior-point optimizer exploits both the primal and dual solution.", "value": "3"}]}, "purify": {"name": "purify", "brief": "Solution purification employed optimizer.", "is-enumerable": true, "prefix": "PURIFY_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "The optimizer performs no solution purification.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The optimizer purifies the primal solution.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The optimizer purifies the dual solution.", "value": "2"}, {"caml-name": "PRIMAL_DUAL", "name": "primal_dual", "brief": "The optimizer purifies both the primal and dual solution.", "value": "3"}, {"caml-name": "AUTO", "name": "auto", "brief": "TBD", "value": "4"}]}, "callbackcode": {"name": "callbackcode", "brief": "Progress callback codes", "is-enumerable": true, "prefix": "CALLBACK_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "BEGIN_ROOT_CUTGEN", "name": "begin_root_cutgen", "brief": "The callback function is called when root cut generation is started.", "value": "21"}, {"caml-name": "IM_ROOT_CUTGEN", "name": "im_root_cutgen", "brief": "The callback is called from within root cut generation at an intermediate stage.", "value": "75"}, {"caml-name": "END_ROOT_CUTGEN", "name": "end_root_cutgen", "brief": "The callback function is called when root cut generation is terminated.", "value": "50"}, {"caml-name": "BEGIN_SOLVE_ROOT_RELAX", "name": "begin_solve_root_relax", "brief": "The callback function is called when solution of root relaxation is started.", "value": "24"}, {"caml-name": "END_SOLVE_ROOT_RELAX", "name": "end_solve_root_relax", "brief": "The callback function is called when solution of root relaxation is terminated.", "value": "53"}, {"caml-name": "BEGIN_OPTIMIZER", "name": "begin_optimizer", "brief": "The callback function is called when the optimizer is started.", "value": "11"}, {"caml-name": "END_OPTIMIZER", "name": "end_optimizer", "brief": "The callback function is called when the optimizer is terminated.", "value": "40"}, {"caml-name": "BEGIN_PRESOLVE", "name": "begin_presolve", "brief": "The callback function is called when the presolve is started.", "value": "12"}, {"caml-name": "UPDATE_PRESOLVE", "name": "update_presolve", "brief": "The callback function is called from within the presolve procedure.", "value": "88"}, {"caml-name": "IM_PRESOLVE", "name": "im_presolve", "brief": "The callback function is called from within the presolve procedure at an intermediate stage.", "value": "69"}, {"caml-name": "END_PRESOLVE", "name": "end_presolve", "brief": "The callback function is called when the presolve is completed.", "value": "41"}, {"caml-name": "BEGIN_INTPNT", "name": "begin_intpnt", "brief": "The callback function is called when the interior-point optimizer is started.", "value": "8"}, {"caml-name": "INTPNT", "name": "intpnt", "brief": "The callback function is called from within the interior-point optimizer after the information database has been updated.", "value": "78"}, {"caml-name": "IM_INTPNT", "name": "im_intpnt", "brief": "The callback function is called at an intermediate stage within the interior-point optimizer where the information database has not been updated.", "value": "61"}, {"caml-name": "END_INTPNT", "name": "end_intpnt", "brief": "The callback function is called when the interior-point optimizer is terminated.", "value": "37"}, {"caml-name": "BEGIN_CONIC", "name": "begin_conic", "brief": "The callback function is called when the conic optimizer is started.", "value": "1"}, {"caml-name": "CONIC", "name": "conic", "brief": "The callback function is called from within the conic optimizer after the information database has been updated.", "value": "27"}, {"caml-name": "IM_CONIC", "name": "im_conic", "brief": "The callback function is called at an intermediate stage within the conic optimizer where the information database has not been updated.", "value": "57"}, {"caml-name": "END_CONIC", "name": "end_conic", "brief": "The callback function is called when the conic optimizer is terminated.", "value": "30"}, {"caml-name": "PRIMAL_SIMPLEX", "name": "primal_simplex", "brief": "The callback function is called from within the primal simplex optimizer.", "value": "80"}, {"caml-name": "DUAL_SIMPLEX", "name": "dual_simplex", "brief": "The callback function is called from within the dual simplex optimizer.", "value": "28"}, {"caml-name": "BEGIN_BI", "name": "begin_bi", "brief": "The basis identification procedure has been started.", "value": "0"}, {"caml-name": "IM_BI", "name": "im_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point.", "value": "56"}, {"caml-name": "END_BI", "name": "end_bi", "brief": "The callback function is called when the basis identification procedure is terminated.", "value": "29"}, {"caml-name": "BEGIN_PRIMAL_BI", "name": "begin_primal_bi", "brief": "The callback function is called from within the basis identification procedure when the primal phase is started.", "value": "13"}, {"caml-name": "IM_PRIMAL_BI", "name": "im_primal_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.", "value": "70"}, {"caml-name": "UPDATE_PRIMAL_BI", "name": "update_primal_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal phase.", "value": "89"}, {"caml-name": "END_PRIMAL_BI", "name": "end_primal_bi", "brief": "The callback function is called from within the basis identification procedure when the primal phase is terminated.", "value": "42"}, {"caml-name": "BEGIN_DUAL_BI", "name": "begin_dual_bi", "brief": "The callback function is called from within the basis identification procedure when the dual phase is started.", "value": "2"}, {"caml-name": "IM_DUAL_BI", "name": "im_dual_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.", "value": "58"}, {"caml-name": "UPDATE_DUAL_BI", "name": "update_dual_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual phase.", "value": "85"}, {"caml-name": "END_DUAL_BI", "name": "end_dual_bi", "brief": "The callback function is called from within the basis identification procedure when the dual phase is terminated.", "value": "31"}, {"caml-name": "BEGIN_SIMPLEX_BI", "name": "begin_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the simplex clean-up phase is started.", "value": "23"}, {"caml-name": "IM_SIMPLEX_BI", "name": "im_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the simplex clean-up phase.", "desc": "The callback function is called\nfrom within the basis identification procedure\nat an intermediate point in the simplex clean-up phase.\nThe frequency of the callbacks is controlled by the\n:msk:iparam:`log_sim_freq` parameter.", "value": "77"}, {"caml-name": "BEGIN_PRIMAL_SIMPLEX_BI", "name": "begin_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the primal simplex clean-up phase is started.", "value": "18"}, {"caml-name": "UPDATE_PRIMAL_SIMPLEX_BI", "name": "update_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the primal simplex clean-up phase.", "desc": "The callback function is called\nfrom within the basis identification procedure\nat an intermediate point in the primal simplex clean-up phase.\nThe frequency of the callbacks is controlled by the\n:msk:iparam:`log_sim_freq` parameter.", "value": "91"}, {"caml-name": "END_PRIMAL_SIMPLEX_BI", "name": "end_primal_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the primal clean-up phase is terminated.", "value": "47"}, {"caml-name": "BEGIN_DUAL_SIMPLEX_BI", "name": "begin_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the dual simplex clean-up phase is started.", "value": "6"}, {"caml-name": "UPDATE_DUAL_SIMPLEX_BI", "name": "update_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.", "desc": "The callback function is called from within the basis identification procedure at an intermediate point in the dual simplex clean-up phase.\nThe frequency of the callbacks is controlled by the :msk:iparam:`log_sim_freq` parameter.", "value": "87"}, {"caml-name": "END_DUAL_SIMPLEX_BI", "name": "end_dual_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the dual clean-up phase is terminated.", "value": "35"}, {"caml-name": "END_SIMPLEX_BI", "name": "end_simplex_bi", "brief": "The callback function is called from within the basis identification procedure when the simplex clean-up phase is terminated.", "value": "52"}, {"caml-name": "BEGIN_MIO", "name": "begin_mio", "brief": "The callback function is called when the mixed-integer optimizer is started.", "value": "10"}, {"caml-name": "IM_MIO", "name": "im_mio", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer.", "value": "64"}, {"caml-name": "NEW_INT_MIO", "name": "new_int_mio", "brief": "The callback function is called after a new integer solution has been located by the mixed-integer optimizer.", "value": "79"}, {"caml-name": "END_MIO", "name": "end_mio", "brief": "The callback function is called when the mixed-integer optimizer is terminated.", "value": "39"}, {"caml-name": "RESTART_MIO", "name": "restart_mio", "brief": "The callback function is called when the mixed-integer optimizer is restarted.", "value": "83"}, {"caml-name": "BEGIN_SIMPLEX", "name": "begin_simplex", "brief": "The callback function is called when the simplex optimizer is started.", "value": "22"}, {"caml-name": "IM_SIMPLEX", "name": "im_simplex", "brief": "The callback function is called from within the simplex optimizer at an intermediate point.", "value": "76"}, {"caml-name": "UPDATE_SIMPLEX", "name": "update_simplex", "brief": "The callback function is called from simplex optimizer.", "value": "92"}, {"caml-name": "BEGIN_DUAL_SIMPLEX", "name": "begin_dual_simplex", "brief": "The callback function is called when the dual simplex optimizer started.", "value": "5"}, {"caml-name": "IM_DUAL_SIMPLEX", "name": "im_dual_simplex", "brief": "The callback function is called at an intermediate point in the dual simplex optimizer.", "value": "60"}, {"caml-name": "UPDATE_DUAL_SIMPLEX", "name": "update_dual_simplex", "brief": "The callback function is called in the dual simplex optimizer.", "value": "86"}, {"caml-name": "END_DUAL_SIMPLEX", "name": "end_dual_simplex", "brief": "The callback function is called when the dual simplex optimizer is terminated.", "value": "34"}, {"caml-name": "BEGIN_PRIMAL_SIMPLEX", "name": "begin_primal_simplex", "brief": "The callback function is called when the primal simplex optimizer is started.", "value": "17"}, {"caml-name": "IM_PRIMAL_SIMPLEX", "name": "im_primal_simplex", "brief": "The callback function is called at an intermediate point in the primal simplex optimizer.", "value": "72"}, {"caml-name": "UPDATE_PRIMAL_SIMPLEX", "name": "update_primal_simplex", "brief": "The callback function is called  in the primal simplex optimizer.", "value": "90"}, {"caml-name": "END_PRIMAL_SIMPLEX", "name": "end_primal_simplex", "brief": "The callback function is called when the primal simplex optimizer is terminated.", "value": "46"}, {"caml-name": "END_SIMPLEX", "name": "end_simplex", "brief": "The callback function is called when the simplex optimizer is terminated.", "value": "51"}, {"caml-name": "BEGIN_INFEAS_ANA", "name": "begin_infeas_ana", "brief": "The callback function is called when the infeasibility analyzer is started.", "value": "7"}, {"caml-name": "END_INFEAS_ANA", "name": "end_infeas_ana", "brief": "The callback function is called when the infeasibility analyzer is terminated.", "value": "36"}, {"caml-name": "IM_PRIMAL_SENSIVITY", "name": "im_primal_sensivity", "brief": "The callback function is called at an intermediate stage of the primal sensitivity analysis.", "value": "71"}, {"caml-name": "IM_DUAL_SENSIVITY", "name": "im_dual_sensivity", "brief": "The callback function is called at an intermediate stage of the dual sensitivity analysis.", "value": "59"}, {"caml-name": "IM_MIO_INTPNT", "name": "im_mio_intpnt", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the interior-point optimizer.", "value": "66"}, {"caml-name": "IM_MIO_PRIMAL_SIMPLEX", "name": "im_mio_primal_simplex", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the primal simplex optimizer.", "value": "67"}, {"caml-name": "IM_MIO_DUAL_SIMPLEX", "name": "im_mio_dual_simplex", "brief": "The callback function is called at an intermediate point in the mixed-integer optimizer while running the dual simplex optimizer.", "value": "65"}, {"caml-name": "BEGIN_PRIMAL_SETUP_BI", "name": "begin_primal_setup_bi", "brief": "The callback function is called when the primal BI setup is started.", "value": "16"}, {"caml-name": "END_PRIMAL_SETUP_BI", "name": "end_primal_setup_bi", "brief": "The callback function is called when the primal BI setup is terminated.", "value": "45"}, {"caml-name": "BEGIN_DUAL_SETUP_BI", "name": "begin_dual_setup_bi", "brief": "The callback function is called when the dual BI phase is started.", "value": "4"}, {"caml-name": "END_DUAL_SETUP_BI", "name": "end_dual_setup_bi", "brief": "The callback function is called when the dual BI phase is terminated.", "value": "33"}, {"caml-name": "BEGIN_PRIMAL_SENSITIVITY", "name": "begin_primal_sensitivity", "brief": "Primal sensitivity analysis is started.", "value": "15"}, {"caml-name": "END_PRIMAL_SENSITIVITY", "name": "end_primal_sensitivity", "brief": "Primal sensitivity analysis is terminated.", "value": "44"}, {"caml-name": "BEGIN_DUAL_SENSITIVITY", "name": "begin_dual_sensitivity", "brief": "Dual sensitivity analysis is started.", "value": "3"}, {"caml-name": "END_DUAL_SENSITIVITY", "name": "end_dual_sensitivity", "brief": "Dual sensitivity analysis is terminated.", "value": "32"}, {"caml-name": "BEGIN_LICENSE_WAIT", "name": "begin_license_wait", "brief": "Begin waiting for license.", "value": "9"}, {"caml-name": "END_LICENSE_WAIT", "name": "end_license_wait", "brief": "End waiting for license.", "value": "38"}, {"caml-name": "IM_LICENSE_WAIT", "name": "im_license_wait", "brief": "MOSEK is waiting for a license.", "desc": "|mosek| is waiting for a license.", "value": "62"}, {"caml-name": "BEGIN_QCQO_REFORMULATE", "name": "begin_qcqo_reformulate", "brief": "Begin QCQO reformulation.", "value": "19"}, {"caml-name": "END_QCQO_REFORMULATE", "name": "end_qcqo_reformulate", "brief": "End QCQO reformulation.", "value": "48"}, {"caml-name": "IM_QO_REFORMULATE", "name": "im_qo_reformulate", "brief": "The callback function is called at an intermediate stage of the conic quadratic reformulation.", "value": "73"}, {"caml-name": "BEGIN_TO_CONIC", "name": "begin_to_conic", "brief": "Begin conic reformulation.", "value": "25"}, {"caml-name": "END_TO_CONIC", "name": "end_to_conic", "brief": "End conic reformulation.", "value": "54"}, {"caml-name": "BEGIN_PRIMAL_REPAIR", "name": "begin_primal_repair", "brief": "Begin primal feasibility repair.", "value": "14"}, {"caml-name": "END_PRIMAL_REPAIR", "name": "end_primal_repair", "brief": "End primal feasibility repair.", "value": "43"}, {"caml-name": "BEGIN_READ", "name": "begin_read", "brief": "MOSEK has started reading a problem file.", "desc": "|mosek| has started reading a problem file.", "value": "20"}, {"caml-name": "IM_READ", "name": "im_read", "brief": "Intermediate stage in reading.", "value": "74"}, {"caml-name": "END_READ", "name": "end_read", "brief": "MOSEK has finished reading a problem file.", "desc": "|mosek| has finished reading a problem file.", "value": "49"}, {"caml-name": "BEGIN_WRITE", "name": "begin_write", "brief": "MOSEK has started writing a problem file.", "desc": "|mosek| has started writing a problem file.", "value": "26"}, {"caml-name": "END_WRITE", "name": "end_write", "brief": "MOSEK has finished writing a problem file.", "desc": "|mosek| has finished writing a problem file.", "value": "55"}, {"caml-name": "READ_OPF_SECTION", "name": "read_opf_section", "brief": "A chunk of Q non-zeros has been read from a problem file.", "desc": "A chunk of :math:`Q` non-zeros has been read from a problem file.", "value": "82"}, {"caml-name": "IM_LU", "name": "im_lu", "brief": "The callback function is called from within the LU factorization procedure at an intermediate point.", "value": "63"}, {"caml-name": "IM_ORDER", "name": "im_order", "brief": "The callback function is called from within the matrix ordering procedure at an intermediate point.", "value": "68"}, {"caml-name": "READ_OPF", "name": "read_opf", "brief": "The callback function is called from the OPF reader.", "value": "81"}, {"caml-name": "WRITE_OPF", "name": "write_opf", "brief": "The callback function is called from the OPF writer.", "value": "93"}, {"caml-name": "SOLVING_REMOTE", "name": "solving_remote", "brief": "The callback function is called while the task is being solved on a remote server.", "value": "84"}]}, "compresstype": {"name": "compresstype", "brief": "Compression types", "is-enumerable": true, "prefix": "COMPRESS_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No compression is used.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The type of compression used is chosen automatically.", "value": "1"}, {"caml-name": "GZIP", "name": "gzip", "brief": "The type of compression used is gzip compatible.", "value": "2"}, {"caml-name": "ZSTD", "name": "zstd", "brief": "The type of compression used is zstd compatible.", "value": "3"}]}, "conetype": {"name": "conetype", "brief": "Cone types", "is-enumerable": true, "prefix": "CT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "QUAD", "name": "quad", "brief": "The cone is a quadratic cone.", "value": "0"}, {"caml-name": "RQUAD", "name": "rquad", "brief": "The cone is a rotated quadratic cone.", "value": "1"}, {"caml-name": "PEXP", "name": "pexp", "brief": "A primal exponential cone.", "value": "2"}, {"caml-name": "DEXP", "name": "dexp", "brief": "A dual exponential cone.", "value": "3"}, {"caml-name": "PPOW", "name": "ppow", "brief": "A primal power cone.", "value": "4"}, {"caml-name": "DPOW", "name": "dpow", "brief": "A dual power cone.", "value": "5"}, {"caml-name": "ZERO", "name": "zero", "brief": "The zero cone.", "value": "6"}]}, "domaintype": {"name": "domaintype", "brief": "Cone types", "is-enumerable": true, "prefix": "DOMAIN_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "R", "name": "r", "brief": "R.", "value": "0"}, {"caml-name": "RZERO", "name": "rzero", "brief": "The zero vector.", "value": "1"}, {"caml-name": "RPLUS", "name": "rplus", "brief": "The positive orthant.", "value": "2"}, {"caml-name": "RMINUS", "name": "rminus", "brief": "The negative orthant.", "value": "3"}, {"caml-name": "QUADRATIC_CONE", "name": "quadratic_cone", "brief": "The quadratic cone.", "value": "4"}, {"caml-name": "RQUADRATIC_CONE", "name": "rquadratic_cone", "brief": "The rotated quadratic cone.", "value": "5"}, {"caml-name": "PRIMAL_EXP_CONE", "name": "primal_exp_cone", "brief": "The primal exponential cone.", "value": "6"}, {"caml-name": "DUAL_EXP_CONE", "name": "dual_exp_cone", "brief": "The dual exponential cone.", "value": "7"}, {"caml-name": "PRIMAL_POWER_CONE", "name": "primal_power_cone", "brief": "The primal power cone.", "value": "8"}, {"caml-name": "DUAL_POWER_CONE", "name": "dual_power_cone", "brief": "The dual power cone.", "value": "9"}, {"caml-name": "PRIMAL_GEO_MEAN_CONE", "name": "primal_geo_mean_cone", "brief": "The primal geometric mean cone.", "value": "10"}, {"caml-name": "DUAL_GEO_MEAN_CONE", "name": "dual_geo_mean_cone", "brief": "The dual geometric mean cone.", "value": "11"}, {"caml-name": "SVEC_PSD_CONE", "name": "svec_psd_cone", "brief": "The vectorized positive semidefinite cone.", "value": "12"}]}, "nametype": {"name": "nametype", "brief": "Name types", "is-enumerable": true, "prefix": "NAME_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "GEN", "name": "gen", "brief": "General names. However, no duplicate and blank names are allowed.", "value": "0"}, {"caml-name": "MPS", "name": "mps", "brief": "MPS type names.", "value": "1"}, {"caml-name": "LP", "name": "lp", "brief": "LP type names.", "value": "2"}]}, "symmattype": {"name": "symmattype", "brief": "Cone types", "is-enumerable": true, "prefix": "SYMMAT_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "SPARSE", "name": "sparse", "brief": "Sparse symmetric matrix.", "value": "0"}]}, "dataformat": {"name": "dataformat", "brief": "Data format types", "is-enumerable": true, "prefix": "DATA_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "EXTENSION", "name": "extension", "brief": "The file extension is used to determine the data file format.", "value": "0"}, {"caml-name": "MPS", "name": "mps", "brief": "The data file is MPS formatted.", "value": "1"}, {"caml-name": "LP", "name": "lp", "brief": "The data file is LP formatted.", "value": "2"}, {"caml-name": "OP", "name": "op", "brief": "The data file is an optimization problem formatted file.", "value": "3"}, {"caml-name": "FREE_MPS", "name": "free_mps", "brief": "The data a free MPS formatted file.", "value": "4"}, {"caml-name": "TASK", "name": "task", "brief": "Generic task dump file.", "value": "5"}, {"caml-name": "PTF", "name": "ptf", "brief": "(P)retty (T)ext (F)format.", "value": "6"}, {"caml-name": "CB", "name": "cb", "brief": "Conic benchmark format,", "value": "7"}, {"caml-name": "JSON_TASK", "name": "json_task", "brief": "JSON based task format.", "value": "8"}]}, "solformat": {"name": "solformat", "brief": "Data format types", "is-enumerable": true, "prefix": "SOL_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "EXTENSION", "name": "extension", "brief": "The file extension is used to determine the data file format.", "value": "0"}, {"caml-name": "B", "name": "b", "brief": "Simple binary format", "value": "1"}, {"caml-name": "TASK", "name": "task", "brief": "Tar based format.", "value": "2"}, {"caml-name": "JSON_TASK", "name": "json_task", "brief": "JSON based format.", "value": "3"}]}, "dinfitem": {"name": "dinfitem", "brief": "Double information items", "is-enumerable": true, "prefix": "DINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_DENSITY", "name": "ana_pro_scalarized_constraint_matrix_density", "brief": "Density percentage of the scalarized constraint matrix.", "value": "0"}, {"caml-name": "BI_TIME", "name": "bi_time", "brief": "Time spent within the basis identification procedure since its invocation.", "value": "6"}, {"caml-name": "BI_PRIMAL_TIME", "name": "bi_primal_time", "brief": "Time  spent within the primal phase of the basis identification procedure since its invocation.", "value": "5"}, {"caml-name": "BI_DUAL_TIME", "name": "bi_dual_time", "brief": "Time spent within the dual phase basis identification procedure since its invocation.", "value": "4"}, {"caml-name": "BI_CLEAN_TIME", "name": "bi_clean_time", "brief": "Time spent within the clean-up phase of the basis identification procedure since its invocation.", "value": "3"}, {"caml-name": "BI_CLEAN_PRIMAL_TIME", "name": "bi_clean_primal_time", "brief": "Time spent within the primal clean-up optimizer of the basis identification procedure since its invocation.", "value": "2"}, {"caml-name": "BI_CLEAN_DUAL_TIME", "name": "bi_clean_dual_time", "brief": "Time  spent within the dual clean-up optimizer of the basis identification procedure since its invocation.", "value": "1"}, {"caml-name": "INTPNT_TIME", "name": "intpnt_time", "brief": "Time spent within the interior-point optimizer since its invocation.", "value": "14"}, {"caml-name": "INTPNT_ORDER_TIME", "name": "intpnt_order_time", "brief": "Order time (in seconds).", "value": "11"}, {"caml-name": "INTPNT_PRIMAL_OBJ", "name": "intpnt_primal_obj", "brief": "Primal objective value reported by the interior-point optimizer.", "value": "13"}, {"caml-name": "INTPNT_DUAL_OBJ", "name": "intpnt_dual_obj", "brief": "Dual objective value reported by the interior-point optimizer.", "value": "8"}, {"caml-name": "INTPNT_PRIMAL_FEAS", "name": "intpnt_primal_feas", "brief": "Primal feasibility measure reported by the interior-point optimizer.", "desc": "Primal feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed).", "value": "12"}, {"caml-name": "INTPNT_DUAL_FEAS", "name": "intpnt_dual_feas", "brief": "Dual feasibility measure reported by the interior-point optimizer.", "desc": "Dual feasibility measure reported by the interior-point optimizer. (For the interior-point optimizer this measure is not directly related to the original problem because a homogeneous model is employed.)", "value": "7"}, {"caml-name": "INTPNT_OPT_STATUS", "name": "intpnt_opt_status", "brief": "A measure of optimality of the solution.", "desc": "A measure of optimality of the solution. It should converge to :math:`+1` if the problem has a primal-dual optimal solution, and converge to :math:`-1` if the problem is (strictly) primal or dual infeasible. If the measure converges to another constant, or fails to settle, the problem is usually ill-posed.", "value": "10"}, {"caml-name": "SIM_TIME", "name": "sim_time", "brief": "Time spent in the simplex optimizer since invoking it.", "value": "61"}, {"caml-name": "SIM_PRIMAL_TIME", "name": "sim_primal_time", "brief": "Time spent in the primal simplex optimizer since invoking it.", "value": "60"}, {"caml-name": "SIM_DUAL_TIME", "name": "sim_dual_time", "brief": "Time spent in the dual simplex optimizer since invoking it.", "value": "57"}, {"caml-name": "SIM_OBJ", "name": "sim_obj", "brief": "Objective value reported by the simplex optimizer.", "value": "59"}, {"caml-name": "SIM_FEAS", "name": "sim_feas", "brief": "Feasibility measure reported by the simplex optimizer.", "value": "58"}, {"caml-name": "MIO_TIME", "name": "mio_time", "brief": "Time spent in the mixed-integer optimizer.", "value": "42"}, {"caml-name": "MIO_ROOT_PRESOLVE_TIME", "name": "mio_root_presolve_time", "brief": "Time spent presolving the problem at the root node.", "value": "38"}, {"caml-name": "MIO_ROOT_OPTIMIZER_TIME", "name": "mio_root_optimizer_time", "brief": "Time spent in the contiuous optimizer while processing the root node relaxation.", "value": "37"}, {"caml-name": "MIO_ROOT_TIME", "name": "mio_root_time", "brief": "Time spent processing the root node.", "value": "39"}, {"caml-name": "TO_CONIC_TIME", "name": "to_conic_time", "brief": "Time spent in the last to conic reformulation.", "value": "109"}, {"caml-name": "MIO_CONSTRUCT_SOLUTION_OBJ", "name": "mio_construct_solution_obj", "brief": "Optimal objective value corresponding to the feasible solution.", "desc": "If |mosek| has successfully constructed an integer feasible solution, then this item contains the optimal objective value corresponding to the feasible solution.", "value": "19"}, {"caml-name": "MIO_INITIAL_FEASIBLE_SOLUTION_OBJ", "name": "mio_initial_feasible_solution_obj", "brief": "Optimal objective value corresponding to the user provided initial solution.", "desc": "If the user provided solution was found to be feasible this information item contains it's objective value.", "value": "25"}, {"caml-name": "MIO_OBJ_INT", "name": "mio_obj_int", "brief": "The primal objective value corresponding to the best integer feasible solution.", "desc": "The primal objective value corresponding to the best integer feasible solution. Please note that at least one integer feasible solution must have been located i.e. check :msk:const:`iinfitem.mio_num_int_solutions`.", "value": "32"}, {"caml-name": "MIO_OBJ_BOUND", "name": "mio_obj_bound", "brief": "The best bound on the objective value known.", "desc": "The best known bound on the objective function. This value is undefined until at least\none relaxation has been solved: To see if this is the case check that :msk:const:`iinfitem.mio_num_relax` is\nstrictly positive.", "value": "31"}, {"caml-name": "MIO_OBJ_REL_GAP", "name": "mio_obj_rel_gap", "brief": "If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the relative gap.", "desc": "Given that the mixed-integer optimizer has computed a feasible solution and a bound\non the optimal objective value, then this item contains the relative gap defined by\n\n.. math:: \\frac{| \\mbox{(objective value of feasible solution)}-\\mbox{(objective bound)} | }{\\max(\\delta,|\\mbox{(objective value of feasible solution)}|)}.\n\nwhere :math:`\\delta` is given by the parameter :msk:dparam:`mio_rel_gap_const`. Otherwise it has the value :math:`-1.0`.", "value": "33"}, {"caml-name": "MIO_OBJ_ABS_GAP", "name": "mio_obj_abs_gap", "brief": "If the mixed-integer optimizer has computed a feasible solution and a bound, this contains the absolute gap.", "desc": "Given the mixed-integer optimizer has computed a feasible solution and a bound on the optimal objective value, then this item contains the absolute gap defined by\n\n.. math::  |\\mbox{(objective value of feasible solution)}-\\mbox{(objective bound)}|.\n\nOtherwise it has the value -1.0.", "value": "30"}, {"caml-name": "MIO_USER_OBJ_CUT", "name": "mio_user_obj_cut", "brief": "If the objective cut is used, then this information item has the value of the cut.", "value": "43"}, {"caml-name": "MIO_CMIR_SEPARATION_TIME", "name": "mio_cmir_separation_time", "brief": "Separation time for CMIR cuts.", "value": "18"}, {"caml-name": "MIO_CLIQUE_SEPARATION_TIME", "name": "mio_clique_separation_time", "brief": "Separation time for clique cuts.", "value": "16"}, {"caml-name": "MIO_KNAPSACK_COVER_SEPARATION_TIME", "name": "mio_knapsack_cover_separation_time", "brief": "Separation time for knapsack cover.", "value": "27"}, {"caml-name": "MIO_GMI_SEPARATION_TIME", "name": "mio_gmi_separation_time", "brief": "Separation time for GMI cuts.", "value": "22"}, {"caml-name": "MIO_IMPLIED_BOUND_SEPARATION_TIME", "name": "mio_implied_bound_separation_time", "brief": "Separation time for implied bound cuts.", "value": "24"}, {"caml-name": "MIO_LIPRO_SEPARATION_TIME", "name": "mio_lipro_separation_time", "brief": "Separation time for lift-and-project cuts.", "value": "29"}, {"caml-name": "MIO_ROOT_CUT_SEPARATION_TIME", "name": "mio_root_cut_separation_time", "brief": "Total time for cut separation.", "value": "36"}, {"caml-name": "MIO_CMIR_SELECTION_TIME", "name": "mio_cmir_selection_time", "brief": "Selection time for CMIR cuts.", "value": "17"}, {"caml-name": "MIO_CLIQUE_SELECTION_TIME", "name": "mio_clique_selection_time", "brief": "Selection time for clique cuts.", "value": "15"}, {"caml-name": "MIO_KNAPSACK_COVER_SELECTION_TIME", "name": "mio_knapsack_cover_selection_time", "brief": "Selection time for knapsack cover.", "value": "26"}, {"caml-name": "MIO_GMI_SELECTION_TIME", "name": "mio_gmi_selection_time", "brief": "Selection time for GMI cuts.", "value": "21"}, {"caml-name": "MIO_IMPLIED_BOUND_SELECTION_TIME", "name": "mio_implied_bound_selection_time", "brief": "Selection time for implied bound cuts.", "value": "23"}, {"caml-name": "MIO_LIPRO_SELECTION_TIME", "name": "mio_lipro_selection_time", "brief": "Selection time for lift-and-project cuts.", "value": "28"}, {"caml-name": "MIO_ROOT_CUT_SELECTION_TIME", "name": "mio_root_cut_selection_time", "brief": "Total time for cut selection.", "value": "35"}, {"caml-name": "MIO_PROBING_TIME", "name": "mio_probing_time", "brief": "Total time for probing.", "value": "34"}, {"caml-name": "MIO_SYMMETRY_DETECTION_TIME", "name": "mio_symmetry_detection_time", "brief": "Total time for symmetry detection.", "value": "40"}, {"caml-name": "OPTIMIZER_TIME", "name": "optimizer_time", "brief": "Total time spent in the optimizer since it was invoked.", "value": "45"}, {"caml-name": "OPTIMIZER_TICKS", "name": "optimizer_ticks", "brief": "Total number of ticks spent in the optimizer since it was invoked. It is strictly negative if it is not available.", "value": "44"}, {"caml-name": "PRESOLVE_TIME", "name": "presolve_time", "brief": "Total time (in seconds) spent in the presolve since it was invoked.", "value": "48"}, {"caml-name": "MIO_SYMMETRY_FACTOR", "name": "mio_symmetry_factor", "brief": "Degree to which the problem is affected by detected symmetry.", "value": "41"}, {"caml-name": "MIO_DUAL_BOUND_AFTER_PRESOLVE", "name": "mio_dual_bound_after_presolve", "brief": "Value of the dual bound after presolve but before cut generation.", "value": "20"}, {"caml-name": "PRESOLVE_ELI_TIME", "name": "presolve_eli_time", "brief": "Total time spent in the eliminator since the presolve was invoked.", "value": "46"}, {"caml-name": "PRESOLVE_LINDEP_TIME", "name": "presolve_lindep_time", "brief": "Total time spent  in the linear dependency checker since the presolve was invoked.", "value": "47"}, {"caml-name": "READ_DATA_TIME", "name": "read_data_time", "brief": "Time spent reading the data file.", "value": "55"}, {"caml-name": "WRITE_DATA_TIME", "name": "write_data_time", "brief": "Time spent writing the data file.", "value": "110"}, {"caml-name": "SOL_ITR_PRIMAL_OBJ", "name": "sol_itr_primal_obj", "brief": "Primal objective value of the interior-point solution.", "desc": "Primal objective value of the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "103"}, {"caml-name": "SOL_ITR_PVIOLCON", "name": "sol_itr_pviolcon", "brief": "Maximal primal bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "106"}, {"caml-name": "SOL_ITR_PVIOLVAR", "name": "sol_itr_pviolvar", "brief": "Maximal primal bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "108"}, {"caml-name": "SOL_ITR_PVIOLBARVAR", "name": "sol_itr_pviolbarvar", "brief": "Maximal primal bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`\\barX` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "105"}, {"caml-name": "SOL_ITR_PVIOLCONES", "name": "sol_itr_pviolcones", "brief": "Maximal primal violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "107"}, {"caml-name": "SOL_ITR_PVIOLACC", "name": "sol_itr_pviolacc", "brief": "Maximal primal violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for affine conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "104"}, {"caml-name": "SOL_ITR_DUAL_OBJ", "name": "sol_itr_dual_obj", "brief": "Dual objective value of the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Dual objective value of the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "87"}, {"caml-name": "SOL_ITR_DVIOLCON", "name": "sol_itr_dviolcon", "brief": "Maximal dual bound violation for xc in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^c` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "90"}, {"caml-name": "SOL_ITR_DVIOLVAR", "name": "sol_itr_dviolvar", "brief": "Maximal dual bound violation for xx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^x` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "92"}, {"caml-name": "SOL_ITR_DVIOLBARVAR", "name": "sol_itr_dviolbarvar", "brief": "Maximal dual bound violation for barx in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`\\barX` in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "89"}, {"caml-name": "SOL_ITR_DVIOLCONES", "name": "sol_itr_dviolcones", "brief": "Maximal dual violation for conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual violation for conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "91"}, {"caml-name": "SOL_ITR_DVIOLACC", "name": "sol_itr_dviolacc", "brief": "Maximal dual violation for affine conic constraints in the interior-point solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual violation for the affine conic constraints in the interior-point solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "88"}, {"caml-name": "SOL_ITR_NRM_XC", "name": "sol_itr_nrm_xc", "brief": "Infinity norm of xc in the interior-point solution.", "desc": "Infinity norm of :math:`x^c` in the interior-point solution.", "value": "100"}, {"caml-name": "SOL_ITR_NRM_XX", "name": "sol_itr_nrm_xx", "brief": "Infinity norm of xx in the interior-point solution.", "desc": "Infinity norm of :math:`x^x` in the interior-point solution.", "value": "101"}, {"caml-name": "SOL_ITR_NRM_BARX", "name": "sol_itr_nrm_barx", "brief": "Infinity norm of barx in the interior-point solution.", "desc": "Infinity norm of :math:`\\barX` in the interior-point solution.", "value": "94"}, {"caml-name": "SOL_ITR_NRM_Y", "name": "sol_itr_nrm_y", "brief": "Infinity norm of Y in the interior-point solution.", "desc": "Infinity norm of :math:`y` in the interior-point solution.", "value": "102"}, {"caml-name": "SOL_ITR_NRM_SLC", "name": "sol_itr_nrm_slc", "brief": "Infinity norm of slc in the interior-point solution.", "desc": "Infinity norm of :math:`s_l^c` in the interior-point solution.", "value": "95"}, {"caml-name": "SOL_ITR_NRM_SUC", "name": "sol_itr_nrm_suc", "brief": "Infinity norm of suc in the interior-point solution.", "desc": "Infinity norm of :math:`s_u^c` in the interior-point solution.", "value": "98"}, {"caml-name": "SOL_ITR_NRM_SLX", "name": "sol_itr_nrm_slx", "brief": "Infinity norm of slx in the interior-point solution.", "desc": "Infinity norm of :math:`s_l^x` in the interior-point solution.", "value": "96"}, {"caml-name": "SOL_ITR_NRM_SUX", "name": "sol_itr_nrm_sux", "brief": "Infinity norm of sux in the interior-point solution.", "desc": "Infinity norm of :math:`s_u^X` in the interior-point solution.", "value": "99"}, {"caml-name": "SOL_ITR_NRM_SNX", "name": "sol_itr_nrm_snx", "brief": "Infinity norm of snx in the interior-point solution.", "desc": "Infinity norm of :math:`s_n^x` in the interior-point solution.", "value": "97"}, {"caml-name": "SOL_ITR_NRM_BARS", "name": "sol_itr_nrm_bars", "brief": "Infinity norm of bars in the interior-point solution.", "desc": "Infinity norm of :math:`\\barS` in the interior-point solution.", "value": "93"}, {"caml-name": "SOL_BAS_PRIMAL_OBJ", "name": "sol_bas_primal_obj", "brief": "Primal objective value of the basic solution. Updated by the function updatesolutioninfo.", "desc": "Primal objective value of the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "73"}, {"caml-name": "SOL_BAS_PVIOLCON", "name": "sol_bas_pviolcon", "brief": "Maximal primal bound violation for xc in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "74"}, {"caml-name": "SOL_BAS_PVIOLVAR", "name": "sol_bas_pviolvar", "brief": "Maximal primal bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "75"}, {"caml-name": "SOL_BAS_DUAL_OBJ", "name": "sol_bas_dual_obj", "brief": "Dual objective value of the basic solution. Updated by the function updatesolutioninfo.", "desc": "Dual objective value of the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "62"}, {"caml-name": "SOL_BAS_DVIOLCON", "name": "sol_bas_dviolcon", "brief": "Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^c` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "63"}, {"caml-name": "SOL_BAS_DVIOLVAR", "name": "sol_bas_dviolvar", "brief": "Maximal dual bound violation for xx in the basic solution. Updated by the function updatesolutioninfo.", "desc": "Maximal dual bound violation for :math:`x^x` in the basic solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "64"}, {"caml-name": "SOL_BAS_NRM_XC", "name": "sol_bas_nrm_xc", "brief": "Infinity norm of xc in the basic solution.", "desc": "Infinity norm of :math:`x^c` in the basic solution.", "value": "70"}, {"caml-name": "SOL_BAS_NRM_XX", "name": "sol_bas_nrm_xx", "brief": "Infinity norm of xx in the basic solution.", "desc": "Infinity norm of :math:`x^x` in the basic solution.", "value": "71"}, {"caml-name": "SOL_BAS_NRM_BARX", "name": "sol_bas_nrm_barx", "brief": "Infinity norm of barx in the basic solution.", "desc": "Infinity norm of :math:`\\barX` in the basic solution.", "value": "65"}, {"caml-name": "SOL_BAS_NRM_Y", "name": "sol_bas_nrm_y", "brief": "Infinity norm of Y in the basic solution.", "desc": "Infinity norm of :math:`y` in the basic solution.", "value": "72"}, {"caml-name": "SOL_BAS_NRM_SLC", "name": "sol_bas_nrm_slc", "brief": "Infinity norm of slc in the basic solution.", "desc": "Infinity norm of :math:`s_l^c` in the basic solution.", "value": "66"}, {"caml-name": "SOL_BAS_NRM_SUC", "name": "sol_bas_nrm_suc", "brief": "Infinity norm of suc in the basic solution.", "desc": "Infinity norm of :math:`s_u^c` in the basic solution.", "value": "68"}, {"caml-name": "SOL_BAS_NRM_SLX", "name": "sol_bas_nrm_slx", "brief": "Infinity norm of slx in the basic solution.", "desc": "Infinity norm of :math:`s_l^x` in the basic solution.", "value": "67"}, {"caml-name": "SOL_BAS_NRM_SUX", "name": "sol_bas_nrm_sux", "brief": "Infinity norm of sux in the basic solution.", "desc": "Infinity norm of :math:`s_u^X` in the basic solution.", "value": "69"}, {"caml-name": "SOL_ITG_PRIMAL_OBJ", "name": "sol_itg_primal_obj", "brief": "Primal objective value of the integer solution. Updated by the function updatesolutioninfo.", "desc": "Primal objective value of the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "79"}, {"caml-name": "SOL_ITG_PVIOLCON", "name": "sol_itg_pviolcon", "brief": "Maximal primal bound violation for xc in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^c` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "82"}, {"caml-name": "SOL_ITG_PVIOLVAR", "name": "sol_itg_pviolvar", "brief": "Maximal primal bound violation for xx in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`x^x` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "86"}, {"caml-name": "SOL_ITG_PVIOLBARVAR", "name": "sol_itg_pviolbarvar", "brief": "Maximal primal bound violation for barx in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal bound violation for :math:`\\barX` in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "81"}, {"caml-name": "SOL_ITG_PVIOLCONES", "name": "sol_itg_pviolcones", "brief": "Maximal primal violation for primal conic constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for primal conic constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "83"}, {"caml-name": "SOL_ITG_PVIOLACC", "name": "sol_itg_pviolacc", "brief": "Maximal primal violation for affine conic constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for affine conic constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "80"}, {"caml-name": "SOL_ITG_PVIOLITG", "name": "sol_itg_pviolitg", "brief": "Maximal violation for the integer constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal violation for the integer constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "85"}, {"caml-name": "SOL_ITG_PVIOLDJC", "name": "sol_itg_pvioldjc", "brief": "Maximal primal violation for disjunctive constraints in the integer solution. Updated by the function updatesolutioninfo.", "desc": "Maximal primal violation for disjunctive constraints in the integer solution.\nUpdated if :msk:iparam:`AUTO_UPDATE_SOL_INFO` is set MSK_ONLY[optimizer]|or by the method :msk:func:`task.updatesolutioninfo`|.", "value": "84"}, {"caml-name": "SOL_ITG_NRM_XC", "name": "sol_itg_nrm_xc", "brief": "Infinity norm of xc in the integer solution.", "desc": "Infinity norm of :math:`x^c` in the integer solution.", "value": "77"}, {"caml-name": "SOL_ITG_NRM_XX", "name": "sol_itg_nrm_xx", "brief": "Infinity norm of xx in the integer solution.", "desc": "Infinity norm of :math:`x^x` in the integer solution.", "value": "78"}, {"caml-name": "SOL_ITG_NRM_BARX", "name": "sol_itg_nrm_barx", "brief": "Infinity norm of barx in the integer solution.", "desc": "Infinity norm of :math:`\\barX` in the integer solution.", "value": "76"}, {"caml-name": "PRESOLVE_TOTAL_PRIMAL_PERTURBATION", "name": "presolve_total_primal_perturbation", "brief": "Total perturbation of the bounds of the primal problem.", "value": "49"}, {"caml-name": "INTPNT_FACTOR_NUM_FLOPS", "name": "intpnt_factor_num_flops", "brief": "An estimate of the number of flops used in the factorization.", "value": "9"}, {"caml-name": "QCQO_REFORMULATE_TIME", "name": "qcqo_reformulate_time", "brief": "Time spent with conic quadratic reformulation.", "value": "52"}, {"caml-name": "QCQO_REFORMULATE_MAX_PERTURBATION", "name": "qcqo_reformulate_max_perturbation", "brief": "Maximum absolute diagonal perturbation occurring during the QCQO reformulation.", "value": "51"}, {"caml-name": "QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING", "name": "qcqo_reformulate_worst_cholesky_diag_scaling", "brief": "Worst Cholesky diagonal scaling.", "value": "54"}, {"caml-name": "QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING", "name": "qcqo_reformulate_worst_cholesky_column_scaling", "brief": "Worst Cholesky column scaling.", "value": "53"}, {"caml-name": "PRIMAL_REPAIR_PENALTY_OBJ", "name": "primal_repair_penalty_obj", "brief": "The optimal objective value of the penalty function.", "value": "50"}, {"caml-name": "REMOTE_TIME", "name": "remote_time", "brief": "The total real time in seconds spent when optimizing on a server by the process performing the optimization on the server", "value": "56"}]}, "feature": {"name": "feature", "brief": "License feature", "is-enumerable": true, "prefix": "FEATURE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "PTS", "name": "pts", "brief": "Base system.", "value": "0"}, {"caml-name": "PTON", "name": "pton", "brief": "Conic extension.", "value": "1"}]}, "liinfitem": {"name": "liinfitem", "brief": "Long integer information items.", "is-enumerable": true, "prefix": "LIINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_ROWS", "name": "ana_pro_scalarized_constraint_matrix_num_rows", "brief": "Number of rows in the scalarized constraint matrix.", "value": "2"}, {"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_COLUMNS", "name": "ana_pro_scalarized_constraint_matrix_num_columns", "brief": "Number of columns in the scalarized constraint matrix.", "value": "0"}, {"caml-name": "ANA_PRO_SCALARIZED_CONSTRAINT_MATRIX_NUM_NZ", "name": "ana_pro_scalarized_constraint_matrix_num_nz", "brief": "Number of non-zero entries in the scalarized constraint matrix.", "value": "1"}, {"caml-name": "MIO_ANZ", "name": "mio_anz", "brief": "Number of non-zero entries in the constraint matrix of the problem to be solved by the mixed-integer optimizer.", "value": "10"}, {"caml-name": "MIO_PRESOLVED_ANZ", "name": "mio_presolved_anz", "brief": "Number of non-zero entries in the constraint matrix of the problem after the mixed-integer optimizer's presolve.", "value": "14"}, {"caml-name": "MIO_SIMPLEX_ITER", "name": "mio_simplex_iter", "brief": "Number of simplex iterations performed by the mixed-integer optimizer.", "value": "15"}, {"caml-name": "MIO_INTPNT_ITER", "name": "mio_intpnt_iter", "brief": "Number of interior-point iterations performed by the mixed-integer optimizer.", "value": "11"}, {"caml-name": "MIO_NUM_PRIM_ILLPOSED_CER", "name": "mio_num_prim_illposed_cer", "brief": "Number of primal illposed certificates encountered by the mixed-integer optimizer.", "value": "13"}, {"caml-name": "MIO_NUM_DUAL_ILLPOSED_CER", "name": "mio_num_dual_illposed_cer", "brief": "Number of dual illposed certificates encountered by the mixed-integer optimizer.", "value": "12"}, {"caml-name": "BI_PRIMAL_ITER", "name": "bi_primal_iter", "brief": "Number of primal pivots performed in the basis identification.", "value": "8"}, {"caml-name": "BI_DUAL_ITER", "name": "bi_dual_iter", "brief": "Number of dual pivots performed in the basis identification.", "value": "7"}, {"caml-name": "BI_CLEAN_PRIMAL_ITER", "name": "bi_clean_primal_iter", "brief": "Number of primal clean iterations performed in the basis identification.", "value": "6"}, {"caml-name": "BI_CLEAN_DUAL_ITER", "name": "bi_clean_dual_iter", "brief": "Number of dual clean iterations performed in the basis identification.", "value": "4"}, {"caml-name": "BI_CLEAN_PRIMAL_DEG_ITER", "name": "bi_clean_primal_deg_iter", "brief": "Number of primal degenerate clean iterations performed in the basis identification.", "value": "5"}, {"caml-name": "BI_CLEAN_DUAL_DEG_ITER", "name": "bi_clean_dual_deg_iter", "brief": "Number of dual degenerate clean iterations performed in the basis identification.", "value": "3"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ", "name": "intpnt_factor_num_nz", "brief": "Number of non-zeros in factorization.", "value": "9"}, {"caml-name": "RD_NUMACC", "name": "rd_numacc", "brief": "Number of affince conic constraints.", "value": "16"}, {"caml-name": "RD_NUMDJC", "name": "rd_numdjc", "brief": "Number of disjuncive constraints.", "value": "18"}, {"caml-name": "RD_NUMANZ", "name": "rd_numanz", "brief": "Number of non-zeros in A that is read.", "value": "17"}, {"caml-name": "RD_NUMQNZ", "name": "rd_numqnz", "brief": "Number of Q non-zeros.", "value": "19"}, {"caml-name": "SIMPLEX_ITER", "name": "simplex_iter", "brief": "Number of iterations performed by the simplex optimizer.", "value": "20"}]}, "internal_liinf": {"name": "internal_liinf", "is-enumerable": true, "prefix": "LIINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "INTPNT_LENBARVAR", "name": "intpnt_lenbarvar", "value": "3"}, {"caml-name": "PRESOLVE_STACK_SIZE", "name": "presolve_stack_size", "value": "4"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ_BEFORE", "name": "intpnt_factor_num_nz_before", "value": "2"}, {"caml-name": "INTPNT_FACTOR_NUM_NZ_AFTER", "name": "intpnt_factor_num_nz_after", "value": "1"}, {"caml-name": "INTPNT_FACTOR_GP_ORDER_SAVED_NZS", "name": "intpnt_factor_gp_order_saved_nzs", "value": "0"}, {"caml-name": "SIMPLEX_PRIMAL_ITER", "name": "simplex_primal_iter", "value": "15"}, {"caml-name": "SIMPLEX_DUAL_ITER", "name": "simplex_dual_iter", "value": "5"}, {"caml-name": "SIMPLEX_PRIMAL_NUM_TICKS", "name": "simplex_primal_num_ticks", "value": "16"}, {"caml-name": "SIMPLEX_DUAL_NUM_TICKS", "name": "simplex_dual_num_ticks", "value": "6"}, {"caml-name": "SIMPLEX_NUM_DUAL_ILLPOSED_CER", "name": "simplex_num_dual_illposed_cer", "value": "10"}, {"caml-name": "SIMPLEX_NUM_CAND", "name": "simplex_num_cand", "value": "9"}, {"caml-name": "SIMPLEX_NUM_PROGRESS_STALL", "name": "simplex_num_progress_stall", "value": "13"}, {"caml-name": "SIMPLEX_NUM_SINGULAR_BASES", "name": "simplex_num_singular_bases", "value": "14"}, {"caml-name": "SIMPLEX_NUM_FATAL_FEASIBILITY_LOSS", "name": "simplex_num_fatal_feasibility_loss", "value": "11"}, {"caml-name": "SIMPLEX_NUM_FATAL_GRADIENT_STALL", "name": "simplex_num_fatal_gradient_stall", "value": "12"}, {"caml-name": "SIMPLEX_LU_FACTOR_NUM_TICKS", "name": "simplex_lu_factor_num_ticks", "value": "7"}, {"caml-name": "SIMPLEX_LU_SOLVE_NUM_TICKS", "name": "simplex_lu_solve_num_ticks", "value": "8"}]}, "iinfitem": {"name": "iinfitem", "brief": "Integer information items.", "is-enumerable": true, "prefix": "IINF_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "ANA_PRO_NUM_CON", "name": "ana_pro_num_con", "brief": "Number of constraints in the problem.", "desc": "Number of constraints in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "0"}, {"caml-name": "ANA_PRO_NUM_CON_LO", "name": "ana_pro_num_con_lo", "brief": "Number of constraints with a lower bound and an infinite upper bound.", "desc": "Number of constraints with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "3"}, {"caml-name": "ANA_PRO_NUM_CON_UP", "name": "ana_pro_num_con_up", "brief": "Number of constraints with an upper bound and an infinite lower bound.", "desc": "Number of constraints with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "5"}, {"caml-name": "ANA_PRO_NUM_CON_RA", "name": "ana_pro_num_con_ra", "brief": "Number of constraints with finite lower and upper bounds.", "desc": "Number of constraints with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "4"}, {"caml-name": "ANA_PRO_NUM_CON_EQ", "name": "ana_pro_num_con_eq", "brief": "Number of equality constraints.", "desc": "Number of equality constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "1"}, {"caml-name": "ANA_PRO_NUM_CON_FR", "name": "ana_pro_num_con_fr", "brief": "Number of unbounded constraints.", "desc": "Number of unbounded constraints. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "2"}, {"caml-name": "ANA_PRO_NUM_VAR", "name": "ana_pro_num_var", "brief": "Number of variables in the problem.", "desc": "Number of variables in the problem. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "6"}, {"caml-name": "ANA_PRO_NUM_VAR_LO", "name": "ana_pro_num_var_lo", "brief": "Number of variables with a lower bound and an infinite upper bound.", "desc": "Number of variables with a lower bound and an infinite upper bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "12"}, {"caml-name": "ANA_PRO_NUM_VAR_UP", "name": "ana_pro_num_var_up", "brief": "Number of variables with an upper bound and an infinite lower bound.", "desc": "Number of variables with an upper bound and an infinite lower bound. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "14"}, {"caml-name": "ANA_PRO_NUM_VAR_RA", "name": "ana_pro_num_var_ra", "brief": "Number of variables with finite lower and upper bounds.", "desc": "Number of variables with finite lower and upper bounds. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "13"}, {"caml-name": "ANA_PRO_NUM_VAR_EQ", "name": "ana_pro_num_var_eq", "brief": "Number of fixed variables.", "desc": "Number of fixed variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "9"}, {"caml-name": "ANA_PRO_NUM_VAR_FR", "name": "ana_pro_num_var_fr", "brief": "Number of unbounded constraints.", "desc": "Number of free variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "10"}, {"caml-name": "ANA_PRO_NUM_VAR_CONT", "name": "ana_pro_num_var_cont", "brief": "Number of continuous variables.", "desc": "Number of continuous variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "8"}, {"caml-name": "ANA_PRO_NUM_VAR_BIN", "name": "ana_pro_num_var_bin", "brief": "Number of binary variables.", "desc": "Number of binary (0-1) variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "7"}, {"caml-name": "ANA_PRO_NUM_VAR_INT", "name": "ana_pro_num_var_int", "brief": "Number of general integer variables.", "desc": "Number of general integer variables. MSK_ONLY[optimizer]|This value is set by :msk:func:`task.analyzeproblem`.|", "value": "11"}, {"caml-name": "OPTIMIZE_RESPONSE", "name": "optimize_response", "brief": "The response code returned by optimize.", "value": "86"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_PERTURBATIONS", "name": "presolve_num_primal_perturbations", "brief": "Number perturbations to thhe bounds of the primal problem.", "value": "87"}, {"caml-name": "INTPNT_ITER", "name": "intpnt_iter", "brief": "Number of interior-point iterations since invoking the interior-point optimizer.", "value": "16"}, {"caml-name": "INTPNT_FACTOR_DIM_DENSE", "name": "intpnt_factor_dim_dense", "brief": "Dimension of the dense sub system in factorization.", "value": "15"}, {"caml-name": "INTPNT_SOLVE_DUAL", "name": "intpnt_solve_dual", "brief": "Non-zero if the interior-point optimizer is solving the dual problem.", "value": "18"}, {"caml-name": "MIO_NODE_DEPTH", "name": "mio_node_depth", "brief": "Depth of the last node solved.", "value": "23"}, {"caml-name": "MIO_NUMVAR", "name": "mio_numvar", "brief": "Number of variables in the problem to be solved by the mixed-integer optimizer.", "value": "61"}, {"caml-name": "MIO_NUMBIN", "name": "mio_numbin", "brief": "Number of binary variables in the problem to be solved by the mixed-integer optimizer.", "value": "45"}, {"caml-name": "MIO_NUMINT", "name": "mio_numint", "brief": "Number of integer variables in the problem to be solved by the mixed-integer optimizer.", "value": "55"}, {"caml-name": "MIO_NUMCONT", "name": "mio_numcont", "brief": "Number of continuous variables in the problem to be solved by the mixed-integer optimizer.", "value": "50"}, {"caml-name": "MIO_NUMCON", "name": "mio_numcon", "brief": "Number of constraints in the problem to be solved by the mixed-integer optimizer.", "value": "47"}, {"caml-name": "MIO_NUMCONE", "name": "mio_numcone", "brief": "Number of cones in the problem to be solved by the mixed-integer optimizer.", "value": "48"}, {"caml-name": "MIO_NUMQCONES", "name": "mio_numqcones", "brief": "Number of quadratic cones in the problem to be solved by the mixed-integer optimizer.", "value": "59"}, {"caml-name": "MIO_NUMRQCONES", "name": "mio_numrqcones", "brief": "Number of rotated quadratic cones in the problem to be solved by the mixed-integer optimizer.", "value": "60"}, {"caml-name": "MIO_NUMPEXPCONES", "name": "mio_numpexpcones", "brief": "Number of primal exponential cones in the problem to be solved by the mixed-integer optimizer.", "value": "57"}, {"caml-name": "MIO_NUMDEXPCONES", "name": "mio_numdexpcones", "brief": "Number of dual exponential cones in the problem to be solved by the mixed-integer optimizer.", "value": "52"}, {"caml-name": "MIO_NUMPPOWCONES", "name": "mio_numppowcones", "brief": "Number of primal power cones in the problem to be solved by the mixed-integer optimizer.", "value": "58"}, {"caml-name": "MIO_NUMDPOWCONES", "name": "mio_numdpowcones", "brief": "Number of dual power cones in the problem to be solved by the mixed-integer optimizer.", "value": "54"}, {"caml-name": "MIO_NUMCONEVAR", "name": "mio_numconevar", "brief": "Number of cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "49"}, {"caml-name": "MIO_NUMBINCONEVAR", "name": "mio_numbinconevar", "brief": "Number of binary cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "46"}, {"caml-name": "MIO_NUMINTCONEVAR", "name": "mio_numintconevar", "brief": "Number of integer cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "56"}, {"caml-name": "MIO_NUMCONTCONEVAR", "name": "mio_numcontconevar", "brief": "Number of continuous cone variables in the problem to be solved by the mixed-integer optimizer.", "value": "51"}, {"caml-name": "MIO_NUMDJC", "name": "mio_numdjc", "brief": "Number of disjunctive constraints in the problem to be solved by the mixed-integer optimizer.", "value": "53"}, {"caml-name": "MIO_PRESOLVED_NUMVAR", "name": "mio_presolved_numvar", "brief": "Number of variables in the problem after the mixed-integer optimizer's presolve.", "value": "79"}, {"caml-name": "MIO_PRESOLVED_NUMBIN", "name": "mio_presolved_numbin", "brief": "Number of binary variables in the problem after the mixed-integer optimizer's presolve.", "value": "63"}, {"caml-name": "MIO_PRESOLVED_NUMINT", "name": "mio_presolved_numint", "brief": "Number of integer variables in the problem after the mixed-integer optimizer's presolve.", "value": "73"}, {"caml-name": "MIO_PRESOLVED_NUMCONT", "name": "mio_presolved_numcont", "brief": "Number of continuous variables in the problem after the mixed-integer optimizer's presolve.", "value": "68"}, {"caml-name": "MIO_PRESOLVED_NUMCON", "name": "mio_presolved_numcon", "brief": "Number of constraints in the problem after the mixed-integer optimizer's presolve.", "value": "65"}, {"caml-name": "MIO_PRESOLVED_NUMCONE", "name": "mio_presolved_numcone", "brief": "Number of cones in the problem after the mixed-integer optimizer's presolve.", "value": "66"}, {"caml-name": "MIO_PRESOLVED_NUMQCONES", "name": "mio_presolved_numqcones", "brief": "Number of quadratic cones in the problem after the mixed-integer optimizer's presolve.", "value": "77"}, {"caml-name": "MIO_PRESOLVED_NUMRQCONES", "name": "mio_presolved_numrqcones", "brief": "Number of rotated quadratic cones in the problem after the mixed-integer optimizer's presolve.", "value": "78"}, {"caml-name": "MIO_PRESOLVED_NUMPEXPCONES", "name": "mio_presolved_numpexpcones", "brief": "Number of primal exponential cones in the problem after the mixed-integer optimizer's presolve.", "value": "75"}, {"caml-name": "MIO_PRESOLVED_NUMDEXPCONES", "name": "mio_presolved_numdexpcones", "brief": "Number of dual exponential cones in the problem after the mixed-integer optimizer's presolve.", "value": "70"}, {"caml-name": "MIO_PRESOLVED_NUMPPOWCONES", "name": "mio_presolved_numppowcones", "brief": "Number of primal power cones in the problem after the mixed-integer optimizer's presolve.", "value": "76"}, {"caml-name": "MIO_PRESOLVED_NUMDPOWCONES", "name": "mio_presolved_numdpowcones", "brief": "Number of dual power cones in the problem after the mixed-integer optimizer's presolve.", "value": "72"}, {"caml-name": "MIO_PRESOLVED_NUMCONEVAR", "name": "mio_presolved_numconevar", "brief": "Number of cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "67"}, {"caml-name": "MIO_PRESOLVED_NUMBINCONEVAR", "name": "mio_presolved_numbinconevar", "brief": "Number of binary cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "64"}, {"caml-name": "MIO_PRESOLVED_NUMINTCONEVAR", "name": "mio_presolved_numintconevar", "brief": "Number of integer cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "74"}, {"caml-name": "MIO_PRESOLVED_NUMCONTCONEVAR", "name": "mio_presolved_numcontconevar", "brief": "Number of continuous cone variables in the problem after the mixed-integer optimizer's presolve.", "value": "69"}, {"caml-name": "MIO_PRESOLVED_NUMDJC", "name": "mio_presolved_numdjc", "brief": "Number of disjunctive constraints in the problem after the mixed-integer optimizer's presolve.", "value": "71"}, {"caml-name": "MIO_CLIQUE_TABLE_SIZE", "name": "mio_clique_table_size", "brief": "Size of the clique table.", "value": "20"}, {"caml-name": "MIO_CONSTRUCT_SOLUTION", "name": "mio_construct_solution", "brief": "Informs if MOSEK successfully constructed an initial integer feasible solution.", "desc": "This item informs if |mosek| constructed an initial integer feasible solution.\n\n* -1: tried, but failed,\n* 0: no partial solution supplied by the user,\n* 1: constructed feasible solution.", "value": "21"}, {"caml-name": "MIO_INITIAL_FEASIBLE_SOLUTION", "name": "mio_initial_feasible_solution", "brief": "Informs if MOSEK found the solution provided by the user to be feasible", "desc": "This item informs if |mosek| found the solution provided by the user to be feasible\n\n* 0: solution provided by the user was not found to be feasible for the current problem,\n* 1: user provided solution was found to be feasible.", "value": "22"}, {"caml-name": "MIO_NUM_INT_SOLUTIONS", "name": "mio_num_int_solutions", "brief": "Number of integer feasible solutions that have been found.", "value": "27"}, {"caml-name": "MIO_OBJ_BOUND_DEFINED", "name": "mio_obj_bound_defined", "brief": "Non-zero if a valid objective bound has been found, otherwise zero.", "value": "62"}, {"caml-name": "MIO_NUM_ACTIVE_NODES", "name": "mio_num_active_nodes", "brief": "Number of active branch and bound nodes.", "value": "24"}, {"caml-name": "MIO_NUM_RELAX", "name": "mio_num_relax", "brief": "Number of relaxations solved during the optimization.", "value": "28"}, {"caml-name": "MIO_NUM_SOLVED_NODES", "name": "mio_num_solved_nodes", "brief": "Number of branch and bounds nodes solved in the main branch and bound tree.", "value": "44"}, {"caml-name": "MIO_NUM_BRANCH", "name": "mio_num_branch", "brief": "Number of branches performed during the optimization.", "value": "26"}, {"caml-name": "MIO_NUM_RESTARTS", "name": "mio_num_restarts", "brief": "Number of restarts performed during the optimization.", "value": "30"}, {"caml-name": "MIO_NUM_ROOT_CUT_ROUNDS", "name": "mio_num_root_cut_rounds", "brief": "Number of cut separation rounds at the root node of the mixed-integer optimizer.", "value": "31"}, {"caml-name": "MIO_NUM_ACTIVE_ROOT_CUTS", "name": "mio_num_active_root_cuts", "brief": "Number of active cuts in the final relaxation after the mixed-integer optimizer's root cut generation.", "value": "25"}, {"caml-name": "MIO_TOTAL_NUM_SELECTED_CUTS", "name": "mio_total_num_selected_cuts", "brief": "Total number of cuts selected to be included in the relaxation by the mixed-integer optimizer.", "value": "81"}, {"caml-name": "MIO_NUM_SELECTED_CMIR_CUTS", "name": "mio_num_selected_cmir_cuts", "brief": "Number of Complemented Mixed Integer Rounding (CMIR) cuts selected to be included in the relaxation.", "value": "33"}, {"caml-name": "MIO_NUM_SELECTED_CLIQUE_CUTS", "name": "mio_num_selected_clique_cuts", "brief": "Number of clique cuts selected to be included in the relaxation.", "value": "32"}, {"caml-name": "MIO_NUM_SELECTED_IMPLIED_BOUND_CUTS", "name": "mio_num_selected_implied_bound_cuts", "brief": "Number of implied bound cuts selected to be included in the relaxation.", "value": "35"}, {"caml-name": "MIO_NUM_SELECTED_KNAPSACK_COVER_CUTS", "name": "mio_num_selected_knapsack_cover_cuts", "brief": "Number of clique cuts selected to be included in the relaxation.", "value": "36"}, {"caml-name": "MIO_NUM_SELECTED_GOMORY_CUTS", "name": "mio_num_selected_gomory_cuts", "brief": "Number of Gomory cuts selected to be included in the relaxation.", "value": "34"}, {"caml-name": "MIO_NUM_SELECTED_LIPRO_CUTS", "name": "mio_num_selected_lipro_cuts", "brief": "Number of lift-and-project cuts selected to be included in the relaxation.", "value": "37"}, {"caml-name": "MIO_TOTAL_NUM_SEPARATED_CUTS", "name": "mio_total_num_separated_cuts", "brief": "Total number of cuts separated by the mixed-integer optimizer.", "value": "82"}, {"caml-name": "MIO_NUM_SEPARATED_CMIR_CUTS", "name": "mio_num_separated_cmir_cuts", "brief": "Number of separated Complemented Mixed Integer Rounding (CMIR) cuts.", "value": "39"}, {"caml-name": "MIO_NUM_SEPARATED_CLIQUE_CUTS", "name": "mio_num_separated_clique_cuts", "brief": "Number of separated clique cuts.", "value": "38"}, {"caml-name": "MIO_NUM_SEPARATED_IMPLIED_BOUND_CUTS", "name": "mio_num_separated_implied_bound_cuts", "brief": "Number of separated implied bound cuts.", "value": "41"}, {"caml-name": "MIO_NUM_SEPARATED_KNAPSACK_COVER_CUTS", "name": "mio_num_separated_knapsack_cover_cuts", "brief": "Number of separated clique cuts.", "value": "42"}, {"caml-name": "MIO_NUM_SEPARATED_GOMORY_CUTS", "name": "mio_num_separated_gomory_cuts", "brief": "Number of separated Gomory cuts.", "value": "40"}, {"caml-name": "MIO_NUM_SEPARATED_LIPRO_CUTS", "name": "mio_num_separated_lipro_cuts", "brief": "Number of separated lift-and-project cuts.", "value": "43"}, {"caml-name": "MIO_NUM_REPEATED_PRESOLVE", "name": "mio_num_repeated_presolve", "brief": "Number of times presolve was repeated at root.", "value": "29"}, {"caml-name": "MIO_USER_OBJ_CUT", "name": "mio_user_obj_cut", "brief": "If it is non-zero, then the objective cut is used.", "value": "83"}, {"caml-name": "MIO_RELGAP_SATISFIED", "name": "mio_relgap_satisfied", "brief": "Non-zero if relative gap is within tolerances.", "value": "80"}, {"caml-name": "MIO_ABSGAP_SATISFIED", "name": "mio_absgap_satisfied", "brief": "Non-zero if absolute gap is within tolerances.", "value": "19"}, {"caml-name": "RD_PROTYPE", "name": "rd_protype", "brief": "Problem type.", "value": "96"}, {"caml-name": "RD_NUMCON", "name": "rd_numcon", "brief": "Number of constraints read.", "value": "91"}, {"caml-name": "RD_NUMVAR", "name": "rd_numvar", "brief": "Number of variables read.", "value": "95"}, {"caml-name": "RD_NUMBARVAR", "name": "rd_numbarvar", "brief": "Number of symmetric variables read.", "value": "90"}, {"caml-name": "RD_NUMINTVAR", "name": "rd_numintvar", "brief": "Number of integer-constrained variables read.", "value": "93"}, {"caml-name": "RD_NUMQ", "name": "rd_numq", "brief": "Number of nonempty Q matrices read.", "value": "94"}, {"caml-name": "SIM_DUAL_DEG_ITER", "name": "sim_dual_deg_iter", "brief": "The number of dual degenerate iterations.", "value": "97"}, {"caml-name": "SIM_DUAL_INF_ITER", "name": "sim_dual_inf_iter", "brief": "The number of iterations taken with dual infeasibility.", "value": "100"}, {"caml-name": "SIM_DUAL_HOTSTART_LU", "name": "sim_dual_hotstart_lu", "brief": "If 1 then a valid basis factorization of full rank was located and used by the dual simplex algorithm.", "value": "99"}, {"caml-name": "SIM_PRIMAL_ITER", "name": "sim_primal_iter", "brief": "Number of primal simplex iterations during the last optimization.", "value": "108"}, {"caml-name": "SIM_DUAL_ITER", "name": "sim_dual_iter", "brief": "Number of dual simplex iterations during the last optimization.", "value": "101"}, {"caml-name": "INTPNT_NUM_THREADS", "name": "intpnt_num_threads", "brief": "Number of threads that the interior-point optimizer is using.", "value": "17"}, {"caml-name": "SIM_PRIMAL_INF_ITER", "name": "sim_primal_inf_iter", "brief": "The number of iterations taken with primal infeasibility.", "value": "107"}, {"caml-name": "SIM_PRIMAL_DEG_ITER", "name": "sim_primal_deg_iter", "brief": "The number of primal degenerate iterations.", "value": "104"}, {"caml-name": "SIM_PRIMAL_HOTSTART", "name": "sim_primal_hotstart", "brief": "If 1 then the primal simplex algorithm is solving from an advanced basis.", "value": "105"}, {"caml-name": "SIM_PRIMAL_HOTSTART_LU", "name": "sim_primal_hotstart_lu", "brief": "If 1 then a valid basis factorization of full rank was located and used by the primal simplex algorithm.", "value": "106"}, {"caml-name": "SIM_DUAL_HOTSTART", "name": "sim_dual_hotstart", "brief": "If 1 then the dual simplex algorithm is solving from an advanced basis.", "value": "98"}, {"caml-name": "SOL_ITR_PROSTA", "name": "sol_itr_prosta", "brief": "Problem status of the interior-point solution. Updated after each optimization.", "value": "114"}, {"caml-name": "SOL_ITR_SOLSTA", "name": "sol_itr_solsta", "brief": "Solution status of the interior-point solution. Updated after each optimization.", "value": "115"}, {"caml-name": "SOL_BAS_PROSTA", "name": "sol_bas_prosta", "brief": "Problem status of the basic solution. Updated after each optimization.", "value": "110"}, {"caml-name": "SOL_BAS_SOLSTA", "name": "sol_bas_solsta", "brief": "Solution status of the basic solution. Updated after each optimization.", "value": "111"}, {"caml-name": "SOL_ITG_PROSTA", "name": "sol_itg_prosta", "brief": "Problem status of the integer solution. Updated after each optimization.", "value": "112"}, {"caml-name": "SOL_ITG_SOLSTA", "name": "sol_itg_solsta", "brief": "Solution status of the integer solution. Updated after each optimization.", "value": "113"}, {"caml-name": "SIM_NUMCON", "name": "sim_numcon", "brief": "Number of constraints in the problem solved by the simplex optimizer.", "value": "102"}, {"caml-name": "SIM_NUMVAR", "name": "sim_numvar", "brief": "Number of variables in the problem solved by the simplex optimizer.", "value": "103"}, {"caml-name": "OPT_NUMCON", "name": "opt_numcon", "brief": "Number of constraints in the problem solved when the optimizer is called.", "value": "84"}, {"caml-name": "OPT_NUMVAR", "name": "opt_numvar", "brief": "Number of variables in the problem solved when the optimizer is called", "value": "85"}, {"caml-name": "STO_NUM_A_REALLOC", "name": "sto_num_a_realloc", "brief": "Number of times the storage for storing the linear coefficient matrix has been changed.", "desc": "Number of times the storage for storing :math:`A` has been changed.\nA large value may indicates that memory fragmentation may occur.", "value": "116"}, {"caml-name": "RD_NUMCONE", "name": "rd_numcone", "brief": "Number of conic constraints read.", "value": "92"}, {"caml-name": "SIM_SOLVE_DUAL", "name": "sim_solve_dual", "brief": "Is non-zero if dual problem is solved.", "value": "109"}, {"caml-name": "PURIFY_PRIMAL_SUCCESS", "name": "purify_primal_success", "brief": "Is nonzero if the primal solution is purified.", "value": "89"}, {"caml-name": "PURIFY_DUAL_SUCCESS", "name": "purify_dual_success", "brief": "Is nonzero if the dual solution is purified.", "value": "88"}]}, "inftype": {"name": "inftype", "brief": "Information item types", "is-enumerable": true, "prefix": "INF_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "DOU_TYPE", "name": "dou_type", "brief": "Is a double information type.", "value": "0"}, {"caml-name": "INT_TYPE", "name": "int_type", "brief": "Is an integer.", "value": "1"}, {"caml-name": "LINT_TYPE", "name": "lint_type", "brief": "Is a long integer.", "value": "2"}]}, "internal_dinf": {"name": "internal_dinf", "is-enumerable": true, "prefix": "DINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "SENSITIVITY_PRIMAL_TIME", "name": "sensitivity_primal_time", "value": "92"}, {"caml-name": "SENSITIVITY_DUAL_TIME", "name": "sensitivity_dual_time", "value": "91"}, {"caml-name": "INTPNT_GFEAS", "name": "intpnt_gfeas", "value": "67"}, {"caml-name": "INTPNT_MU", "name": "intpnt_mu", "value": "74"}, {"caml-name": "INTPNT_INIT_ITER_TIME", "name": "intpnt_init_iter_time", "value": "69"}, {"caml-name": "INTPNT_FACTOR_TIME", "name": "intpnt_factor_time", "value": "65"}, {"caml-name": "INTPNT_INIT_SEARCH_TIME", "name": "intpnt_init_search_time", "value": "70"}, {"caml-name": "INTPNT_FORM_SEARCH_TIME", "name": "intpnt_form_search_time", "value": "66"}, {"caml-name": "INTPNT_CORRECTOR_TIME", "name": "intpnt_corrector_time", "value": "12"}, {"caml-name": "INTPNT_UPDATE_TIME", "name": "intpnt_update_time", "value": "79"}, {"caml-name": "INTPNT_FACTOR_SETUP_TIME", "name": "intpnt_factor_setup_time", "value": "58"}, {"caml-name": "INTPNT_FACTOR_SCHUR_TIME", "name": "intpnt_factor_schur_time", "value": "51"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_TIME", "name": "intpnt_factor_hat_schur_time", "value": "48"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PUSH_TIME", "name": "intpnt_factor_hat_schur_push_time", "value": "47"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PULL_TIME", "name": "intpnt_factor_hat_schur_pull_time", "value": "45"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_TIME", "name": "intpnt_factor_bar_schur_time", "value": "17"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_DE_TAB_TIME", "name": "intpnt_factor_bar_schur_de_tab_time", "value": "13"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_SP_TAB_TIME", "name": "intpnt_factor_bar_schur_sp_tab_time", "value": "16"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_TIME", "name": "intpnt_factor_sparse_l_time", "value": "62"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_UPDATE_LAST_TIME", "name": "intpnt_factor_sparse_l_update_last_time", "value": "64"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FACTOR_LAST_TIME", "name": "intpnt_factor_sparse_l_factor_last_time", "value": "60"}, {"caml-name": "INTPNT_FACTOR_DENSE_L_TIME", "name": "intpnt_factor_dense_l_time", "value": "40"}, {"caml-name": "INTPNT_FACTOR_DENSE_TIME", "name": "intpnt_factor_dense_time", "value": "41"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_TIME", "name": "intpnt_factor_dense_dota_time", "value": "28"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_SOLVE_TIME", "name": "intpnt_factor_dense_dota_solve_time", "value": "27"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTATDOTA_TIME", "name": "intpnt_factor_dense_dotatdota_time", "value": "30"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_INIT_TIME", "name": "intpnt_factor_dense_dotl_init_time", "value": "37"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR_TIME", "name": "intpnt_factor_dense_dotl_factor_time", "value": "36"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_TIME", "name": "intpnt_factor_bar_schur_update_time", "value": "25"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_COMPRESSED_E_TIME", "name": "intpnt_factor_bar_schur_update_compressed_e_time", "value": "18"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_TIME", "name": "intpnt_factor_bar_schur_update_sparse_time", "value": "24"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_SYR2K_TIME", "name": "intpnt_factor_bar_schur_update_sparse_syr2k_time", "value": "23"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_SPARSE_DOT_TIME", "name": "intpnt_factor_bar_schur_update_sparse_dot_time", "value": "22"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_TIME", "name": "intpnt_factor_bar_schur_update_dense_time", "value": "21"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_SYR2K_TIME", "name": "intpnt_factor_bar_schur_update_dense_syr2k_time", "value": "20"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_UPDATE_DENSE_DOT_TIME", "name": "intpnt_factor_bar_schur_update_dense_dot_time", "value": "19"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_PUSH_TIME", "name": "intpnt_factor_bar_schur_push_time", "value": "15"}, {"caml-name": "INTPNT_ITER_NON_CORRECTOR_FLOPS", "name": "intpnt_iter_non_corrector_flops", "value": "71"}, {"caml-name": "INTPNT_ITER_ONE_CORRECTOR_FLOPS", "name": "intpnt_iter_one_corrector_flops", "value": "72"}, {"caml-name": "INTPNT_SOLVE_TIME", "name": "intpnt_solve_time", "value": "78"}, {"caml-name": "INTPNT_ITER_REF_TIME", "name": "intpnt_iter_ref_time", "value": "73"}, {"caml-name": "INTPNT_SOLVE_SPARSE_L_TIME", "name": "intpnt_solve_sparse_l_time", "value": "77"}, {"caml-name": "INTPNT_SOLVE_DENSE_L_TIME", "name": "intpnt_solve_dense_l_time", "value": "76"}, {"caml-name": "INTPNT_FACTOR_SETUP_FLOPS", "name": "intpnt_factor_setup_flops", "value": "53"}, {"caml-name": "INTPNT_FACTOR_SETUP_HAT_SCHUR_FLOPS", "name": "intpnt_factor_setup_hat_schur_flops", "value": "56"}, {"caml-name": "INTPNT_FACTOR_SCHUR_FLOPS", "name": "intpnt_factor_schur_flops", "value": "50"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_FLOPS", "name": "intpnt_factor_hat_schur_flops", "value": "43"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PUSH_FLOPS", "name": "intpnt_factor_hat_schur_push_flops", "value": "46"}, {"caml-name": "INTPNT_FACTOR_HAT_SCHUR_PULL_FLOPS", "name": "intpnt_factor_hat_schur_pull_flops", "value": "44"}, {"caml-name": "INTPNT_FACTOR_BAR_SCHUR_FLOPS", "name": "intpnt_factor_bar_schur_flops", "value": "14"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FLOPS", "name": "intpnt_factor_sparse_l_flops", "value": "61"}, {"caml-name": "INTPNT_FACTOR_ML_ORDER_SPARSE_L_FLOPS", "name": "intpnt_factor_ml_order_sparse_l_flops", "value": "49"}, {"caml-name": "INTPNT_FACTOR_GP_ORDER_SPARSE_L_FLOPS", "name": "intpnt_factor_gp_order_sparse_l_flops", "value": "42"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_UPDATE_LAST_FLOPS", "name": "intpnt_factor_sparse_l_update_last_flops", "value": "63"}, {"caml-name": "INTPNT_FACTOR_SPARSE_L_FACTOR_LAST_FLOPS", "name": "intpnt_factor_sparse_l_factor_last_flops", "value": "59"}, {"caml-name": "INTPNT_FACTOR_DENSE_L_FLOPS", "name": "intpnt_factor_dense_l_flops", "value": "39"}, {"caml-name": "INTPNT_FACTOR_DENSE_FLOPS", "name": "intpnt_factor_dense_flops", "value": "38"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTA_FLOPS", "name": "intpnt_factor_dense_dota_flops", "value": "26"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTATDOTA_FLOPS", "name": "intpnt_factor_dense_dotatdota_flops", "value": "29"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR__INIT_FLOPS", "name": "intpnt_factor_dense_dotl_factor__init_flops", "value": "34"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl_factor_flops", "value": "35"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL11_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl11_factor_flops", "value": "31"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL21_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl21_factor_flops", "value": "32"}, {"caml-name": "INTPNT_FACTOR_DENSE_DOTL22_FACTOR_FLOPS", "name": "intpnt_factor_dense_dotl22_factor_flops", "value": "33"}, {"caml-name": "PRESOLVE_PRIMAL_LIN_DEP_TIME", "name": "presolve_primal_lin_dep_time", "value": "86"}, {"caml-name": "PRESOLVE_DUAL_LIN_DEP_TIME", "name": "presolve_dual_lin_dep_time", "value": "82"}, {"caml-name": "PRESOLVE_ACOLT_TIME", "name": "presolve_acolt_time", "value": "80"}, {"caml-name": "PRESOLVE_SETUP_TIME", "name": "presolve_setup_time", "value": "87"}, {"caml-name": "PRESOLVE_CHECKPRO_TIME", "name": "presolve_checkpro_time", "value": "81"}, {"caml-name": "PRESOLVE_DUPCON_TIME", "name": "presolve_dupcon_time", "value": "83"}, {"caml-name": "PRESOLVE_DUPVAR_TIME", "name": "presolve_dupvar_time", "value": "84"}, {"caml-name": "PRESOLVE_FINAL_TIME", "name": "presolve_final_time", "value": "85"}, {"caml-name": "PRESOLVE_SUB_DOMVAR_TIME", "name": "presolve_sub_domvar_time", "value": "88"}, {"caml-name": "PRESOLVE_SUB_RELAX_TIME", "name": "presolve_sub_relax_time", "value": "89"}, {"caml-name": "PRIMAL_SIMPLEX_INFTIME", "name": "primal_simplex_inftime", "value": "90"}, {"caml-name": "DUAL_SIMPLEX_INFTIME", "name": "dual_simplex_inftime", "value": "11"}, {"caml-name": "INTPNT_GP_ORDER_SAVED_FLOPS", "name": "intpnt_gp_order_saved_flops", "value": "68"}, {"caml-name": "INTPNT_FACTOR_SETUP_DETECT_DENSE_TIME", "name": "intpnt_factor_setup_detect_dense_time", "value": "52"}, {"caml-name": "INTPNT_FACTOR_SETUP_ML_ORDER_TIME", "name": "intpnt_factor_setup_ml_order_time", "value": "57"}, {"caml-name": "INTPNT_FACTOR_SETUP_GP_ORDER_TIME", "name": "intpnt_factor_setup_gp_order_time", "value": "55"}, {"caml-name": "INTPNT_FACTOR_SETUP_GP_ORDER_POST_TIME", "name": "intpnt_factor_setup_gp_order_post_time", "value": "54"}, {"caml-name": "BI_CRASH_TIME", "name": "bi_crash_time", "value": "1"}, {"caml-name": "BI_CRASH_LU_TIME", "name": "bi_crash_lu_time", "value": "0"}, {"caml-name": "BI_FACTOR_TIME", "name": "bi_factor_time", "value": "5"}, {"caml-name": "BI_FACTOR_WORK", "name": "bi_factor_work", "value": "6"}, {"caml-name": "BI_PRIMAL_DONE", "name": "bi_primal_done", "value": "8"}, {"caml-name": "BI_DUAL_DONE", "name": "bi_dual_done", "value": "2"}, {"caml-name": "SIMPLEX_BASISCONDITION", "name": "simplex_basiscondition", "value": "93"}, {"caml-name": "SIMPLEX_PRIMAL_OBJ", "name": "simplex_primal_obj", "value": "97"}, {"caml-name": "SIMPLEX_PRIMAL_FEAS", "name": "simplex_primal_feas", "value": "96"}, {"caml-name": "SIMPLEX_DUAL_OBJ", "name": "simplex_dual_obj", "value": "95"}, {"caml-name": "SIMPLEX_DUAL_FEAS", "name": "simplex_dual_feas", "value": "94"}, {"caml-name": "BI_INITIAL_BASIS_COND", "name": "bi_initial_basis_cond", "value": "7"}, {"caml-name": "BI_PRIMAL_OBJ", "name": "bi_primal_obj", "value": "10"}, {"caml-name": "BI_DUAL_OBJ", "name": "bi_dual_obj", "value": "4"}, {"caml-name": "BI_PRIMAL_FEAS", "name": "bi_primal_feas", "value": "9"}, {"caml-name": "BI_DUAL_FEAS", "name": "bi_dual_feas", "value": "3"}, {"caml-name": "INTPNT_PURIFY_TIME", "name": "intpnt_purify_time", "value": "75"}]}, "internal_iinf": {"name": "internal_iinf", "is-enumerable": true, "prefix": "IINF_PRIVATE_", "value-type": "int", "values-asgn": "implicit", "api-class": "internal", "members": [{"caml-name": "VERSION_MAJOR", "name": "version_major", "value": "124"}, {"caml-name": "VERSION_MINOR", "name": "version_minor", "value": "125"}, {"caml-name": "VERSION_REVISION", "name": "version_revision", "value": "126"}, {"caml-name": "PRESOLVE_LINDEP_WORK", "name": "presolve_lindep_work", "value": "68"}, {"caml-name": "PRESOLVE_LINDEP_PIVOTS", "name": "presolve_lindep_pivots", "value": "66"}, {"caml-name": "PRESOLVE_LINDEP_SKIPPED", "name": "presolve_lindep_skipped", "brief": "The linear dependency check was skipped due to numerical problems or because the computational cost was too high.", "value": "67"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEP_ATTEMPTS", "name": "presolve_num_primal_lin_dep_attempts", "brief": "Number of times the primal linear dependency check was attempted.", "value": "74"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEP_SUCCESS_ATTEMPTS", "name": "presolve_num_primal_lin_dep_success_attempts", "brief": "Number successful the primal linear dependency check attempts.", "value": "75"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEP_ATTEMPTS", "name": "presolve_num_dual_lin_dep_attempts", "brief": "Number of times the dual linear dependency check was attempted.", "value": "70"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEP_SUCCESS_ATTEMPTS", "name": "presolve_num_dual_lin_dep_success_attempts", "brief": "Number successful the dual linear dependency check attempts.", "value": "71"}, {"caml-name": "PRESOLVE_OUTOFSPACE", "name": "presolve_outofspace", "brief": "The presolve terminated with of space.", "value": "93"}, {"caml-name": "OPT_OBJECTIVE_SENSE", "name": "opt_objective_sense", "value": "38"}, {"caml-name": "OPTIMIZER", "name": "optimizer", "value": "39"}, {"caml-name": "INTPNT_FIR_REF_ITER", "name": "intpnt_fir_ref_iter", "value": "17"}, {"caml-name": "INTPNT_NUM_REF_STEPS", "name": "intpnt_num_ref_steps", "value": "22"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_DUP", "name": "intpnt_factor_schur_num_dup", "value": "15"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_BLK", "name": "intpnt_factor_schur_num_blk", "value": "14"}, {"caml-name": "INTPNT_FACTOR_SCHUR_MIN_BLK_DIM", "name": "intpnt_factor_schur_min_blk_dim", "value": "13"}, {"caml-name": "INTPNT_FACTOR_SCHUR_MAX_BLK_DIM", "name": "intpnt_factor_schur_max_blk_dim", "value": "12"}, {"caml-name": "INTPNT_FACTOR_SCHUR_NUM_SINGULAR", "name": "intpnt_factor_schur_num_singular", "value": "16"}, {"caml-name": "INTPNT_FACTOR_DIM", "name": "intpnt_factor_dim", "value": "2"}, {"caml-name": "INTPNT_FACTOR_L_DIM", "name": "intpnt_factor_l_dim", "value": "3"}, {"caml-name": "INTPNT_FACTOR_ORDER_ML_L_NUM_DENSE", "name": "intpnt_factor_order_ml_l_num_dense", "value": "11"}, {"caml-name": "INTPNT_FACTOR_ORDER_ML_L_MAX_HEIGHT", "name": "intpnt_factor_order_ml_l_max_height", "value": "10"}, {"caml-name": "INTPNT_FACTOR_ORDER_GP_L_MAX_HEIGHT", "name": "intpnt_factor_order_gp_l_max_height", "value": "9"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_A", "name": "intpnt_factor_num_dense_a", "value": "5"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_A_DUP", "name": "intpnt_factor_num_dense_a_dup", "value": "6"}, {"caml-name": "INTPNT_FACTOR_NUM_DENSE_W", "name": "intpnt_factor_num_dense_w", "value": "7"}, {"caml-name": "INTPNT_NUMCON", "name": "intpnt_numcon", "value": "29"}, {"caml-name": "INTPNT_NUMVAR", "name": "intpnt_numvar", "value": "36"}, {"caml-name": "INTPNT_NUMBARVAR", "name": "intpnt_numbarvar", "value": "23"}, {"caml-name": "INTPNT_NUMBLO", "name": "intpnt_numblo", "value": "26"}, {"caml-name": "INTPNT_NUMBUP", "name": "intpnt_numbup", "value": "28"}, {"caml-name": "INTPNT_NUMBFR", "name": "intpnt_numbfr", "value": "24"}, {"caml-name": "INTPNT_NUMBFX", "name": "intpnt_numbfx", "value": "25"}, {"caml-name": "INTPNT_NUMCONE", "name": "intpnt_numcone", "value": "30"}, {"caml-name": "INTPNT_NUMCONEVAR", "name": "intpnt_numconevar", "value": "31"}, {"caml-name": "INTPNT_NUMBNDCONE", "name": "intpnt_numbndcone", "value": "27"}, {"caml-name": "INTPNT_NUMRQCONES", "name": "intpnt_numrqcones", "value": "35"}, {"caml-name": "INTPNT_NUMQCONES", "name": "intpnt_numqcones", "value": "34"}, {"caml-name": "INTPNT_NUMPEXPCONES", "name": "intpnt_numpexpcones", "value": "32"}, {"caml-name": "INTPNT_NUMPPOWCONES", "name": "intpnt_numppowcones", "value": "33"}, {"caml-name": "INTPNT_MINCONEDIM", "name": "intpnt_minconedim", "value": "21"}, {"caml-name": "INTPNT_MAXCONEDIM", "name": "intpnt_maxconedim", "value": "20"}, {"caml-name": "INTPNT_MAXBARVARDIM", "name": "intpnt_maxbarvardim", "value": "19"}, {"caml-name": "PRESOLVE_NUMCON", "name": "presolve_numcon", "value": "82"}, {"caml-name": "PRESOLVE_NUMCFR", "name": "presolve_numcfr", "value": "78"}, {"caml-name": "PRESOLVE_NUMCFX", "name": "presolve_numcfx", "value": "79"}, {"caml-name": "PRESOLVE_NUMCLO", "name": "presolve_numclo", "value": "80"}, {"caml-name": "PRESOLVE_NUMCUP", "name": "presolve_numcup", "value": "84"}, {"caml-name": "PRESOLVE_NUMCRA", "name": "presolve_numcra", "value": "83"}, {"caml-name": "PRESOLVE_NUMCNL", "name": "presolve_numcnl", "value": "81"}, {"caml-name": "PRESOLVE_NUMVAR", "name": "presolve_numvar", "value": "86"}, {"caml-name": "PRESOLVE_NUMVFR", "name": "presolve_numvfr", "value": "87"}, {"caml-name": "PRESOLVE_NUMVFX", "name": "presolve_numvfx", "value": "88"}, {"caml-name": "PRESOLVE_NUMVLO", "name": "presolve_numvlo", "value": "89"}, {"caml-name": "PRESOLVE_NUMVUP", "name": "presolve_numvup", "value": "92"}, {"caml-name": "PRESOLVE_NUMVRA", "name": "presolve_numvra", "value": "91"}, {"caml-name": "PRESOLVE_NUMVNL", "name": "presolve_numvnl", "value": "90"}, {"caml-name": "PRESOLVE_NUMNZA", "name": "presolve_numnza", "value": "85"}, {"caml-name": "PRESOLVE_FNUMCON", "name": "presolve_fnumcon", "value": "49"}, {"caml-name": "PRESOLVE_FNUMCFR", "name": "presolve_fnumcfr", "value": "45"}, {"caml-name": "PRESOLVE_FNUMCFX", "name": "presolve_fnumcfx", "value": "46"}, {"caml-name": "PRESOLVE_FNUMCLO", "name": "presolve_fnumclo", "value": "47"}, {"caml-name": "PRESOLVE_FNUMCUP", "name": "presolve_fnumcup", "value": "51"}, {"caml-name": "PRESOLVE_FNUMCRA", "name": "presolve_fnumcra", "value": "50"}, {"caml-name": "PRESOLVE_FNUMCNL", "name": "presolve_fnumcnl", "value": "48"}, {"caml-name": "PRESOLVE_FNUMVAR", "name": "presolve_fnumvar", "value": "53"}, {"caml-name": "PRESOLVE_FNUMVFR", "name": "presolve_fnumvfr", "value": "54"}, {"caml-name": "PRESOLVE_FNUMVFX", "name": "presolve_fnumvfx", "value": "55"}, {"caml-name": "PRESOLVE_FNUMVLO", "name": "presolve_fnumvlo", "value": "56"}, {"caml-name": "PRESOLVE_FNUMVUP", "name": "presolve_fnumvup", "value": "59"}, {"caml-name": "PRESOLVE_FNUMVRA", "name": "presolve_fnumvra", "value": "58"}, {"caml-name": "PRESOLVE_FNUMVNL", "name": "presolve_fnumvnl", "value": "57"}, {"caml-name": "PRESOLVE_FNUMNZA", "name": "presolve_fnumnza", "value": "52"}, {"caml-name": "PRESOLVE_NUM_ELIMNS", "name": "presolve_num_elimns", "value": "73"}, {"caml-name": "PRESOLVE_ELI_NUM_TRIES", "name": "presolve_eli_num_tries", "value": "44"}, {"caml-name": "PRESOLVE_ELI_NUM_FREED_CON", "name": "presolve_eli_num_freed_con", "value": "42"}, {"caml-name": "PRESOLVE_ELI_NUM_FREED_CON_TOTAL", "name": "presolve_eli_num_freed_con_total", "value": "43"}, {"caml-name": "PRESOLVE_LINDEP_NUM_TRIES", "name": "presolve_lindep_num_tries", "value": "64"}, {"caml-name": "PRESOLVE_NUM_PRIMAL_LIN_DEPS", "name": "presolve_num_primal_lin_deps", "value": "76"}, {"caml-name": "PRESOLVE_NUM_DUAL_LIN_DEPS", "name": "presolve_num_dual_lin_deps", "value": "72"}, {"caml-name": "PRESOLVE_FORCE_CON_NUM", "name": "presolve_force_con_num", "value": "60"}, {"caml-name": "PRESOLVE_FORCE_CON_NUM_VAR", "name": "presolve_force_con_num_var", "value": "61"}, {"caml-name": "PRESOLVE_FORCE_VAR_NUM", "name": "presolve_force_var_num", "value": "62"}, {"caml-name": "PRESOLVE_FORCE_VAR_NUM_CON", "name": "presolve_force_var_num_con", "value": "63"}, {"caml-name": "PRESOLVE_PIV_ON_CON_NUM", "name": "presolve_piv_on_con_num", "value": "94"}, {"caml-name": "PRESOLVE_NUM_DOU_BLOCKS", "name": "presolve_num_dou_blocks", "value": "69"}, {"caml-name": "PRESOLVE_NUM_SIMPLIFIED_DOU_BLOCKS", "name": "presolve_num_simplified_dou_blocks", "value": "77"}, {"caml-name": "PRESOLVE_SIZE_SIMPLIFIED_DOU_BLOCKS", "name": "presolve_size_simplified_dou_blocks", "value": "95"}, {"caml-name": "PRESOLVE_ACC_NUM_DUP_VAR_IN_NRMTWO", "name": "presolve_acc_num_dup_var_in_nrmtwo", "value": "41"}, {"caml-name": "PRESOLVE_ACC_NUM_DOUBLETON_CHAIN_IN_NRMTWO", "name": "presolve_acc_num_doubleton_chain_in_nrmtwo", "value": "40"}, {"caml-name": "INTPNT_FACTOR_NUM", "name": "intpnt_factor_num", "value": "4"}, {"caml-name": "INTPNT_FACTOR_NUM_SOLVE", "name": "intpnt_factor_num_solve", "value": "8"}, {"caml-name": "SIMPLEX_PRIMAL_HOTSTART_NUM_BASICS", "name": "simplex_primal_hotstart_num_basics", "value": "114"}, {"caml-name": "SIMPLEX_PRIMAL_HOTSTART_BASIS_RANK", "name": "simplex_primal_hotstart_basis_rank", "value": "113"}, {"caml-name": "SIMPLEX_DUAL_HOTSTART_NUM_BASICS", "name": "simplex_dual_hotstart_num_basics", "value": "109"}, {"caml-name": "SIMPLEX_DUAL_HOTSTART_BASIS_RANK", "name": "simplex_dual_hotstart_basis_rank", "value": "108"}, {"caml-name": "INTPNT_GP_ORDER_EMPLOYED", "name": "intpnt_gp_order_employed", "value": "18"}, {"caml-name": "NUM_LU_FACTORIZATIONS", "name": "num_lu_factorizations", "value": "37"}, {"caml-name": "SIMPLEX_PWL_NUM_POTENTIAL", "name": "simplex_pwl_num_potential", "value": "120"}, {"caml-name": "SIMPLEX_PWL_NUM_USED", "name": "simplex_pwl_num_used", "value": "121"}, {"caml-name": "SIMPLEX_PWL_NUM_VARIABLES", "name": "simplex_pwl_num_variables", "value": "122"}, {"caml-name": "SIMPLEX_PWL_MIN_NUM_BREAKPOINTS", "name": "simplex_pwl_min_num_breakpoints", "value": "119"}, {"caml-name": "SIMPLEX_PWL_MAX_NUM_BREAKPOINTS", "name": "simplex_pwl_max_num_breakpoints", "value": "117"}, {"caml-name": "SIMPLEX_PWL_MAX_NZ", "name": "simplex_pwl_max_nz", "value": "118"}, {"caml-name": "SIMPLEX_PWL_NZ_REDUCTION", "name": "simplex_pwl_nz_reduction", "value": "123"}, {"caml-name": "SIMPLEX_PRIMAL_NUM_SETBACKS", "name": "simplex_primal_num_setbacks", "value": "115"}, {"caml-name": "SIMPLEX_DUAL_NUM_SETBACKS", "name": "simplex_dual_num_setbacks", "value": "110"}, {"caml-name": "SIMPLEX_PRIMAL_FEAS_NA", "name": "simplex_primal_feas_na", "value": "112"}, {"caml-name": "SIMPLEX_DUAL_FEAS_NA", "name": "simplex_dual_feas_na", "value": "107"}, {"caml-name": "SIMPLEX_PRIMAL_OBJ_NA", "name": "simplex_primal_obj_na", "value": "116"}, {"caml-name": "SIMPLEX_DUAL_OBJ_NA", "name": "simplex_dual_obj_na", "value": "111"}, {"caml-name": "SIM_NUM_PRIMAL_BOUNDSWAPS", "name": "sim_num_primal_boundswaps", "brief": "Boundswaps performed in the primal simplex optimizer due to linear duplicated columns.", "value": "106"}, {"caml-name": "SIM_NUM_DUAL_BOUNDSWAPS", "name": "sim_num_dual_boundswaps", "brief": "Boundswaps performed in the dual simplex optimizer.", "value": "104"}, {"caml-name": "SIM_NUM_DUAL_INTEGER_PIVOTS", "name": "sim_num_dual_integer_pivots", "brief": "Numbers of iterations where dual simplex made the entering variable integer.", "value": "105"}, {"caml-name": "PURIFY_NUM_ROW", "name": "purify_num_row", "value": "101"}, {"caml-name": "PURIFY_P_NUM_NULL_ROW", "name": "purify_p_num_null_row", "value": "102"}, {"caml-name": "PURIFY_P_NUM_SINGLETON_COL", "name": "purify_p_num_singleton_col", "value": "103"}, {"caml-name": "PURIFY_CRASH_L11_NUM_ROW", "name": "purify_crash_l11_num_row", "value": "96"}, {"caml-name": "PURIFY_CRASH_L22_NUM_ROW", "name": "purify_crash_l22_num_row", "value": "97"}, {"caml-name": "PURIFY_CRASH_L33_NUM_ROW", "name": "purify_crash_l33_num_row", "value": "99"}, {"caml-name": "PURIFY_CRASH_L33_NUM_COL", "name": "purify_crash_l33_num_col", "value": "98"}, {"caml-name": "PURIFY_CRASH_SINGULARITY", "name": "purify_crash_singularity", "value": "100"}, {"caml-name": "BI_PRIMAL_INFO", "name": "bi_primal_info", "value": "1"}, {"caml-name": "BI_DUAL_INFO", "name": "bi_dual_info", "value": "0"}, {"caml-name": "PRESOLVE_LINDEP_NUM_TRUNC_TRIES", "name": "presolve_lindep_num_trunc_tries", "value": "65"}]}, "iomode": {"name": "iomode", "brief": "Input/output modes", "is-enumerable": false, "prefix": "IOMODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "READ", "name": "read", "brief": "The file is read-only.", "value": "0"}, {"caml-name": "WRITE", "name": "write", "brief": "The file is write-only. If the file exists then it is truncated when it is opened. Otherwise it is created when it is opened.", "value": "1"}, {"caml-name": "READWRITE", "name": "readwrite", "brief": "The file is to read and write.", "value": "2"}]}, "branchdir": {"name": "branchdir", "brief": "Specifies the branching direction.", "is-enumerable": false, "prefix": "BRANCH_DIR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The mixed-integer optimizer decides which branch to choose.", "value": "0"}, {"caml-name": "UP", "name": "up", "brief": "The mixed-integer optimizer always chooses the up branch first.", "value": "1"}, {"caml-name": "DOWN", "name": "down", "brief": "The mixed-integer optimizer always chooses the down branch first.", "value": "2"}, {"caml-name": "NEAR", "name": "near", "brief": "Branch in direction nearest to selected fractional variable.", "value": "3"}, {"caml-name": "FAR", "name": "far", "brief": "Branch in direction farthest from selected fractional variable.", "value": "4"}, {"caml-name": "ROOT_LP", "name": "root_lp", "brief": "Chose direction based on root lp value of selected variable.", "value": "5"}, {"caml-name": "GUIDED", "name": "guided", "brief": "Branch in direction of current incumbent.", "value": "6"}, {"caml-name": "PSEUDOCOST", "name": "pseudocost", "brief": "Branch based on the pseudocost of the variable.", "value": "7"}]}, "miqcqoreformmethod": {"name": "miqcqoreformmethod", "brief": "Specifies the reformulation method for mixed-integer quadratic problems.", "is-enumerable": false, "prefix": "MIO_QCQO_REFORMULATION_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The mixed-integer optimizer decides which reformulation method to apply.", "value": "0"}, {"caml-name": "NONE", "name": "none", "brief": "No reformulation method is applied.", "value": "1"}, {"caml-name": "LINEARIZATION", "name": "linearization", "brief": "A reformulation via linearization is applied.", "value": "2"}, {"caml-name": "EIGEN_VAL_METHOD", "name": "eigen_val_method", "brief": "The eigenvalue method is applied.", "value": "3"}, {"caml-name": "DIAG_SDP", "name": "diag_sdp", "brief": "A perturbation of matrix diagonals via the solution of SDPs is applied.", "value": "4"}, {"caml-name": "RELAX_SDP", "name": "relax_sdp", "brief": "A Reformulation based on the solution of an SDP-relaxation of the problem is applied.", "value": "5"}]}, "miodatapermmethod": {"name": "miodatapermmethod", "brief": "Specifies the problem data permutation method for mixed-integer problems.", "is-enumerable": false, "prefix": "MIO_DATA_PERMUTATION_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No problem data permutation is applied.", "value": "0"}, {"caml-name": "CYCLIC_SHIFT", "name": "cyclic_shift", "brief": "A random cyclic shift is applied to permute the problem data.", "value": "1"}, {"caml-name": "RANDOM", "name": "random", "brief": "A random permutation is applied to the problem data.", "value": "2"}]}, "miocontsoltype": {"name": "miocontsoltype", "brief": "Continuous mixed-integer solution type", "is-enumerable": false, "prefix": "MIO_CONT_SOL_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "NONE", "name": "none", "brief": "No interior-point or basic solution.", "desc": "No interior-point or basic solution are reported when the mixed-integer optimizer is used.", "value": "0"}, {"caml-name": "ROOT", "name": "root", "brief": "Solutions to the root node problem.", "desc": "The reported interior-point and basic solutions are a solution to the root node problem when mixed-integer optimizer is used.", "value": "1"}, {"caml-name": "ITG", "name": "itg", "brief": "A feasible primal solution.", "desc": "The reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. A solution is only reported in case the problem has a primal feasible solution.", "value": "2"}, {"caml-name": "ITG_REL", "name": "itg_rel", "brief": "A feasible primal solution or a root node solution if the problem is infeasible.", "desc": "In case the problem is primal feasible then the reported interior-point and basic solutions are a solution to the problem with all integer variables fixed at the value they have in the integer solution. If the problem is primal infeasible, then the solution to the root node problem is reported.", "value": "3"}]}, "miomode": {"name": "miomode", "brief": "Integer restrictions", "is-enumerable": false, "prefix": "MIO_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "IGNORED", "name": "ignored", "brief": "The integer constraints are ignored and the problem is solved as a continuous problem.", "value": "0"}, {"caml-name": "SATISFIED", "name": "satisfied", "brief": "Integer restrictions should be satisfied.", "value": "1"}]}, "mionodeseltype": {"name": "mionodeseltype", "brief": "Mixed-integer node selection types", "is-enumerable": false, "prefix": "MIO_NODE_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer decides the node selection strategy.", "value": "0"}, {"caml-name": "FIRST", "name": "first", "brief": "The optimizer employs a depth first node selection strategy.", "value": "1"}, {"caml-name": "BEST", "name": "best", "brief": "The optimizer employs a best bound node selection strategy.", "value": "2"}, {"caml-name": "PSEUDO", "name": "pseudo", "brief": "The optimizer employs selects the node based on a pseudo cost estimate.", "value": "3"}]}, "miovarseltype": {"name": "miovarseltype", "brief": "Mixed-integer variable selection types", "is-enumerable": false, "prefix": "MIO_VAR_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer decides the variable selection strategy.", "value": "0"}, {"caml-name": "PSEUDOCOST", "name": "pseudocost", "brief": "The optimizer employs pseudocost variable selection.", "value": "1"}, {"caml-name": "STRONG", "name": "strong", "brief": "The optimizer employs strong branching variable selection.", "value": "2"}]}, "mpsformat": {"name": "mpsformat", "brief": "MPS file format type", "is-enumerable": false, "prefix": "MPS_FORMAT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "STRICT", "name": "strict", "brief": "It is assumed that the input file satisfies the MPS format strictly.", "value": "0"}, {"caml-name": "RELAXED", "name": "relaxed", "brief": "It is assumed that the input file satisfies a slightly relaxed version of the MPS format.", "value": "1"}, {"caml-name": "FREE", "name": "free", "brief": "It is assumed that the input file satisfies the free MPS format. This implies that spaces are not allowed in names. Otherwise the format is free.", "value": "2"}, {"caml-name": "CPLEX", "name": "cplex", "brief": "The CPLEX compatible version of the MPS format is employed.", "value": "3"}]}, "objsense": {"name": "objsense", "brief": "Objective sense types", "is-enumerable": true, "prefix": "OBJECTIVE_SENSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "MINIMIZE", "name": "minimize", "brief": "The problem should be minimized.", "value": "0"}, {"caml-name": "MAXIMIZE", "name": "maximize", "brief": "The problem should be maximized.", "value": "1"}]}, "onoffkey": {"name": "onoffkey", "brief": "On/off", "is-enumerable": false, "prefix": "", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ON", "name": "on", "brief": "Switch the option on.", "value": "1"}, {"caml-name": "OFF", "name": "off", "brief": "Switch the option off.", "value": "0"}]}, "optimizertype": {"name": "optimizertype", "brief": "Optimizer types", "is-enumerable": false, "prefix": "OPTIMIZER_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer is chosen automatically.", "value": "2"}, {"caml-name": "INTPNT", "name": "intpnt", "brief": "The interior-point optimizer is used.", "value": "4"}, {"caml-name": "CONIC", "name": "conic", "brief": "The optimizer for problems having conic constraints.", "value": "0"}, {"caml-name": "PRIMAL_SIMPLEX", "name": "primal_simplex", "brief": "The primal simplex optimizer is used.", "value": "6"}, {"caml-name": "DUAL_SIMPLEX", "name": "dual_simplex", "brief": "The dual simplex optimizer is used.", "value": "1"}, {"caml-name": "FREE_SIMPLEX", "name": "free_simplex", "brief": "One of the simplex optimizers is used.", "value": "3"}, {"caml-name": "MIXED_INT", "name": "mixed_int", "brief": "The mixed-integer optimizer.", "value": "5"}]}, "orderingtype": {"name": "orderingtype", "brief": "Ordering strategies", "is-enumerable": false, "prefix": "ORDER_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The ordering method is chosen automatically.", "value": "0"}, {"caml-name": "APPMINLOC", "name": "appminloc", "brief": "Approximate minimum local fill-in ordering is employed.", "value": "1"}, {"caml-name": "EXPERIMENTAL", "name": "experimental", "brief": "This option should not be used.", "value": "2"}, {"caml-name": "TRY_GRAPHPAR", "name": "try_graphpar", "brief": "Always try the graph partitioning based ordering.", "value": "3"}, {"caml-name": "FORCE_GRAPHPAR", "name": "force_graphpar", "brief": "Always use the graph partitioning based ordering even if it is worse than the approximate minimum local fill ordering.", "value": "4"}, {"caml-name": "NONE", "name": "none", "brief": "No ordering is used. Note using this value almost always leads to a significantly slow down.", "value": "5"}]}, "presolvemode": {"name": "presolvemode", "brief": "Presolve method.", "is-enumerable": false, "prefix": "PRESOLVE_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "OFF", "name": "off", "brief": "The problem is not presolved before it is optimized.", "value": "0"}, {"caml-name": "ON", "name": "on", "brief": "The problem is presolved before it is optimized.", "value": "1"}, {"caml-name": "FREE", "name": "free", "brief": "It is decided automatically whether to presolve before the problem is optimized.", "value": "2"}]}, "parametertype": {"name": "parametertype", "brief": "Parameter type", "is-enumerable": true, "prefix": "PAR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "INVALID_TYPE", "name": "invalid_type", "brief": "Not a valid parameter.", "value": "0"}, {"caml-name": "DOU_TYPE", "name": "dou_type", "brief": "Is a double parameter.", "value": "1"}, {"caml-name": "INT_TYPE", "name": "int_type", "brief": "Is an integer parameter.", "value": "2"}, {"caml-name": "STR_TYPE", "name": "str_type", "brief": "Is a string parameter.", "value": "3"}]}, "problemitem": {"name": "problemitem", "brief": "Problem data items", "is-enumerable": true, "prefix": "PI_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "VAR", "name": "var", "brief": "Item is a variable.", "value": "0"}, {"caml-name": "CON", "name": "con", "brief": "Item is a constraint.", "value": "1"}, {"caml-name": "CONE", "name": "cone", "brief": "Item is a cone.", "value": "2"}]}, "problemtype": {"name": "problemtype", "brief": "Problem types", "is-enumerable": true, "prefix": "PROBTYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LO", "name": "lo", "brief": "The problem is a linear optimization problem.", "value": "0"}, {"caml-name": "QO", "name": "qo", "brief": "The problem is a quadratic optimization problem.", "value": "1"}, {"caml-name": "QCQO", "name": "qcqo", "brief": "The problem is a quadratically constrained optimization problem.", "value": "2"}, {"caml-name": "CONIC", "name": "conic", "brief": "A conic optimization.", "value": "3"}, {"caml-name": "MIXED", "name": "mixed", "brief": "General nonlinear constraints and conic constraints. This combination can not be solved by MOSEK.", "desc": "General nonlinear constraints and conic constraints. This combination can not be solved by |mosek|.", "value": "4"}]}, "prosta": {"name": "prosta", "brief": "Problem status keys", "is-enumerable": true, "prefix": "PRO_STA_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNKNOWN", "name": "unknown", "brief": "Unknown problem status.", "value": "0"}, {"caml-name": "PRIM_AND_DUAL_FEAS", "name": "prim_and_dual_feas", "brief": "The problem is primal and dual feasible.", "value": "1"}, {"caml-name": "PRIM_FEAS", "name": "prim_feas", "brief": "The problem is primal feasible.", "value": "2"}, {"caml-name": "DUAL_FEAS", "name": "dual_feas", "brief": "The problem is dual feasible.", "value": "3"}, {"caml-name": "PRIM_INFEAS", "name": "prim_infeas", "brief": "The problem is primal infeasible.", "value": "4"}, {"caml-name": "DUAL_INFEAS", "name": "dual_infeas", "brief": "The problem is dual infeasible.", "value": "5"}, {"caml-name": "PRIM_AND_DUAL_INFEAS", "name": "prim_and_dual_infeas", "brief": "The problem is primal and dual infeasible.", "value": "6"}, {"caml-name": "ILL_POSED", "name": "ill_posed", "brief": "The problem is ill-posed. For example, it may be primal and dual feasible but have a positive duality gap.", "value": "7"}, {"caml-name": "PRIM_INFEAS_OR_UNBOUNDED", "name": "prim_infeas_or_unbounded", "brief": "The problem is either primal infeasible or unbounded. This may occur for mixed-integer problems.", "value": "8"}]}, "xmlwriteroutputtype": {"name": "xmlwriteroutputtype", "brief": "XML writer output mode", "is-enumerable": true, "prefix": "WRITE_XML_MODE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "ROW", "name": "row", "brief": "Write in row order.", "value": "0"}, {"caml-name": "COL", "name": "col", "brief": "Write in column order.", "value": "1"}]}, "rescodetype": {"name": "rescodetype", "brief": "Response code type", "is-enumerable": true, "prefix": "RESPONSE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "OK", "name": "ok", "brief": "The response code is OK.", "value": "0"}, {"caml-name": "WRN", "name": "wrn", "brief": "The response code is a warning.", "value": "1"}, {"caml-name": "TRM", "name": "trm", "brief": "The response code is an optimizer termination status.", "value": "2"}, {"caml-name": "ERR", "name": "err", "brief": "The response code is an error.", "value": "3"}, {"caml-name": "UNK", "name": "unk", "brief": "The response code does not belong to any class.", "value": "4"}]}, "scalingtype": {"name": "scalingtype", "brief": "Scaling type", "is-enumerable": false, "prefix": "SCALING_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the scaling heuristic.", "value": "0"}, {"caml-name": "NONE", "name": "none", "brief": "No scaling is performed.", "value": "1"}]}, "scalingmethod": {"name": "scalingmethod", "brief": "Scaling method", "is-enumerable": false, "prefix": "SCALING_METHOD_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "POW2", "name": "pow2", "brief": "Scales only with power of 2 leaving the mantissa untouched.", "value": "0"}, {"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the scaling heuristic.", "value": "1"}]}, "sensitivitytype": {"name": "sensitivitytype", "brief": "Sensitivity types", "is-enumerable": false, "prefix": "SENSITIVITY_TYPE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "BASIS", "name": "basis", "brief": "Basis sensitivity analysis is performed.", "value": "0"}]}, "simseltype": {"name": "simseltype", "brief": "Simplex selection strategy", "is-enumerable": false, "prefix": "SIM_SELECTION_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer chooses the pricing strategy.", "value": "0"}, {"caml-name": "FULL", "name": "full", "brief": "The optimizer uses full pricing.", "value": "1"}, {"caml-name": "ASE", "name": "ase", "brief": "The optimizer uses approximate steepest-edge pricing.", "value": "2"}, {"caml-name": "DEVEX", "name": "devex", "brief": "The optimizer uses devex steepest-edge pricing.", "desc": "The optimizer uses devex steepest-edge pricing (or if it is not available an approximate steep-edge selection).", "value": "3"}, {"caml-name": "SE", "name": "se", "brief": "The optimizer uses steepest-edge selection.", "desc": "The optimizer uses steepest-edge selection (or if it is not available an approximate steep-edge selection).", "value": "4"}, {"caml-name": "PARTIAL", "name": "partial", "brief": "The optimizer uses a partial selection approach.", "desc": "The optimizer uses a partial selection approach. The approach is usually beneficial if the number of variables is much larger than  the number of constraints.", "value": "5"}]}, "solitem": {"name": "solitem", "brief": "Solution items", "is-enumerable": true, "prefix": "SOL_ITEM_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "XC", "name": "xc", "brief": "Solution for the constraints.", "value": "0"}, {"caml-name": "XX", "name": "xx", "brief": "Variable solution.", "value": "1"}, {"caml-name": "Y", "name": "y", "brief": "Lagrange multipliers for equations.", "value": "2"}, {"caml-name": "SLC", "name": "slc", "brief": "Lagrange multipliers for lower bounds on the constraints.", "value": "3"}, {"caml-name": "SUC", "name": "suc", "brief": "Lagrange multipliers for upper bounds on the constraints.", "value": "4"}, {"caml-name": "SLX", "name": "slx", "brief": "Lagrange multipliers for lower bounds on the variables.", "value": "5"}, {"caml-name": "SUX", "name": "sux", "brief": "Lagrange multipliers for upper bounds on the variables.", "value": "6"}, {"caml-name": "SNX", "name": "snx", "brief": "Lagrange multipliers corresponding to the conic constraints on the variables.", "value": "7"}]}, "solsta": {"name": "solsta", "brief": "Solution status keys", "is-enumerable": true, "prefix": "SOL_STA_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNKNOWN", "name": "unknown", "brief": "Status of the solution is unknown.", "value": "0"}, {"caml-name": "OPTIMAL", "name": "optimal", "brief": "The solution is optimal.", "value": "1"}, {"caml-name": "PRIM_FEAS", "name": "prim_feas", "brief": "The solution is primal feasible.", "value": "2"}, {"caml-name": "DUAL_FEAS", "name": "dual_feas", "brief": "The solution is dual feasible.", "value": "3"}, {"caml-name": "PRIM_AND_DUAL_FEAS", "name": "prim_and_dual_feas", "brief": "The solution is both primal and dual feasible.", "value": "4"}, {"caml-name": "PRIM_INFEAS_CER", "name": "prim_infeas_cer", "brief": "The solution is a certificate of primal infeasibility.", "value": "5"}, {"caml-name": "DUAL_INFEAS_CER", "name": "dual_infeas_cer", "brief": "The solution is a certificate of dual infeasibility.", "value": "6"}, {"caml-name": "PRIM_ILLPOSED_CER", "name": "prim_illposed_cer", "brief": "The solution is a certificate that the primal problem is illposed.", "value": "7"}, {"caml-name": "DUAL_ILLPOSED_CER", "name": "dual_illposed_cer", "brief": "The solution is a certificate that the dual problem is illposed.", "value": "8"}, {"caml-name": "INTEGER_OPTIMAL", "name": "integer_optimal", "brief": "The primal solution is integer optimal.", "value": "9"}]}, "soltype": {"name": "soltype", "brief": "Solution types", "is-enumerable": true, "prefix": "SOL_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "BAS", "name": "bas", "brief": "The basic solution.", "value": "1"}, {"caml-name": "ITR", "name": "itr", "brief": "The interior solution.", "value": "0"}, {"caml-name": "ITG", "name": "itg", "brief": "The integer solution.", "value": "2"}]}, "solveform": {"name": "solveform", "brief": "Solve primal or dual form", "is-enumerable": false, "prefix": "SOLVE_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The optimizer is free to solve either the primal or the dual problem.", "value": "0"}, {"caml-name": "PRIMAL", "name": "primal", "brief": "The optimizer should solve the primal problem.", "value": "1"}, {"caml-name": "DUAL", "name": "dual", "brief": "The optimizer should solve the dual problem.", "value": "2"}]}, "stakey": {"name": "stakey", "brief": "Status keys", "is-enumerable": true, "prefix": "SK_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "UNK", "name": "unk", "brief": "The status for the constraint or variable is unknown.", "value": "0"}, {"caml-name": "BAS", "name": "bas", "brief": "The constraint or variable is in the basis.", "value": "1"}, {"caml-name": "SUPBAS", "name": "supbas", "brief": "The constraint or variable is super basic.", "value": "2"}, {"caml-name": "LOW", "name": "low", "brief": "The constraint or variable is at its lower bound.", "value": "3"}, {"caml-name": "UPR", "name": "upr", "brief": "The constraint or variable is at its upper bound.", "value": "4"}, {"caml-name": "FIX", "name": "fix", "brief": "The constraint or variable is fixed.", "value": "5"}, {"caml-name": "INF", "name": "inf", "brief": "The constraint or variable is infeasible in the bounds.", "value": "6"}]}, "startpointtype": {"name": "startpointtype", "brief": "Starting point types", "is-enumerable": false, "prefix": "STARTING_POINT_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "FREE", "name": "free", "brief": "The starting point is chosen automatically.", "value": "0"}, {"caml-name": "GUESS", "name": "guess", "brief": "The optimizer guesses a starting point.", "value": "1"}, {"caml-name": "CONSTANT", "name": "constant", "brief": "The optimizer constructs a starting point by assigning a constant value to all primal and dual variables. This starting point is normally robust.", "value": "2"}]}, "streamtype": {"name": "streamtype", "brief": "Stream types", "is-enumerable": true, "prefix": "STREAM_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "LOG", "name": "log", "brief": "Log stream. Contains the aggregated contents of all other streams. This means that a message written to any other stream will also be written to this stream.", "value": "0"}, {"caml-name": "MSG", "name": "msg", "brief": "Message stream. Log information relating to performance and progress of the optimization is written to this stream.", "value": "1"}, {"caml-name": "ERR", "name": "err", "brief": "Error stream. Error messages are written to this stream.", "value": "2"}, {"caml-name": "WRN", "name": "wrn", "brief": "Warning stream. Warning messages are written to this stream.", "value": "3"}]}, "value": {"name": "value", "brief": "Integer values", "is-enumerable": false, "prefix": "", "value-type": "int", "values-asgn": "arbitrary", "api-class": "api", "members": [{"caml-name": "MAX_STR_LEN", "name": "max_str_len", "brief": "Maximum string length allowed in MOSEK.", "desc": "Maximum string length allowed in |mosek|.", "value": "1024"}, {"caml-name": "LICENSE_BUFFER_LENGTH", "name": "license_buffer_length", "brief": "The length of a license key buffer.", "value": "21"}]}, "variabletype": {"name": "variabletype", "brief": "Variable types", "is-enumerable": true, "prefix": "VAR_", "value-type": "int", "values-asgn": "sequential", "api-class": "api", "members": [{"caml-name": "TYPE_CONT", "name": "type_cont", "brief": "Is a continuous variable.", "value": "0"}, {"caml-name": "TYPE_INT", "name": "type_int", "brief": "Is an integer variable.", "value": "1"}]}}, "parameters": {"dparam": {"name": "dparam", "brief": "Double parameters", "desc": "The enumeration type containing all double parameters.", "is-enumerable": true, "prefix": "DPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "DATA_TOL_CJ_LARGE", "name": "data_tol_cj_large", "brief": "Data tolerance threshold.", "desc": "An element in :math:`c` which is larger than this value in absolute terms causes a warning message to be printed.", "value": "13", "default": "1.0e8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_C_HUGE", "name": "data_tol_c_huge", "brief": "Data tolerance threshold.", "desc": "An element in :math:`c` which is larger than the value of this parameter in absolute terms is considered to be huge and generates an error.", "value": "12", "default": "1.0e16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_AIJ_LARGE", "name": "data_tol_aij_large", "brief": "Data tolerance threshold.", "desc": "An element in :math:`A` which is larger than this value in absolute size causes a warning message to be printed.", "value": "9", "default": "1.0e10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_AIJ_HUGE", "name": "data_tol_aij_huge", "brief": "Data tolerance threshold.", "desc": "An element in :math:`A` which is larger than this value in absolute size causes an error.", "value": "8", "default": "1.0e20", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL", "name": "data_sym_mat_tol", "brief": "Zero tolerance threshold for symmetric matrices.", "desc": "Absolute zero tolerance for elements in in symmetric matrices. If any value in a symmetric matrix is smaller than this parameter in absolute terms |mosek| will treat the values as zero and generate a warning.", "value": "5", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL_LARGE", "name": "data_sym_mat_tol_large", "brief": "Data tolerance threshold.", "desc": "An element in a symmetric matrix which is larger than this value in absolute size causes a warning message to be printed.", "value": "7", "default": "1.0e10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_SYM_MAT_TOL_HUGE", "name": "data_sym_mat_tol_huge", "brief": "Data tolerance threshold.", "desc": "An element in a symmetric matrix which is larger than this value in absolute size causes an error.", "value": "6", "default": "1.0e20", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_BOUND_INF", "name": "data_tol_bound_inf", "brief": "Data tolerance threshold.", "desc": "Any bound which in absolute value\nis greater than this parameter is\nconsidered infinite.", "value": "10", "default": "1.0e16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_BOUND_WRN", "name": "data_tol_bound_wrn", "brief": "Data tolerance threshold.", "desc": "If a bound value is larger than this value\nin absolute size, then a warning message is issued.", "value": "11", "default": "1.0e8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_QIJ", "name": "data_tol_qij", "brief": "Data tolerance threshold.", "desc": "Absolute zero tolerance for elements in :math:`Q` matrices.", "value": "14", "default": "1.0e-16", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "DATA_TOL_X", "name": "data_tol_x", "brief": "Data tolerance threshold.", "desc": "Zero tolerance for constraints and variables i.e.\nif the distance between the lower and upper bound\nis less than this value, then the lower and upper\nbound is considered identical.", "value": "15", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "SEMIDEFINITE_TOL_APPROX", "name": "semidefinite_tol_approx", "brief": "Tolerance to define a matrix to be positive semidefinite.", "value": "57", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["datacheck-param"]}, {"caml-name": "OPTIMIZER_MAX_TIME", "name": "optimizer_max_time", "brief": "Solver time limit.", "desc": "Maximum amount of time the optimizer is allowed to spent on the optimization.\nA negative number means infinity.", "value": "49", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "OPTIMIZER_MAX_TICKS", "name": "optimizer_max_ticks", "brief": "Solver ticks limit.", "desc": "CURRENTLY NOT IN USE.\n\nMaximum amount of ticks the optimizer is allowed to spent on the optimization.\nA negative number means infinity.", "value": "48", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "LOWER_OBJ_CUT", "name": "lower_obj_cut", "brief": "Objective bound.", "desc": "If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.", "value": "38", "default": "-1.0e30", "references": [{"type": "constant", "item": ["mosek", "dparam", "lower_obj_cut_finite_trh"]}], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "UPPER_OBJ_CUT", "name": "upper_obj_cut", "brief": "Objective bound.", "desc": "If either a primal or dual feasible solution is found proving that the optimal objective value is outside the interval :math:`[` :msk:dparam:`lower_obj_cut`, :msk:dparam:`upper_obj_cut` :math:`]`, then |mosek| is terminated.", "value": "60", "default": "1.0e30", "references": [{"type": "constant", "item": ["mosek", "dparam", "upper_obj_cut_finite_trh"]}], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "UPPER_OBJ_CUT_FINITE_TRH", "name": "upper_obj_cut_finite_trh", "brief": "Objective bound.", "desc": "If the upper objective cut is greater than the value of this parameter, then the\nupper objective cut :msk:dparam:`upper_obj_cut` is treated as :math:`\\infty`.", "value": "61", "default": "0.5e30", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "LOWER_OBJ_CUT_FINITE_TRH", "name": "lower_obj_cut_finite_trh", "brief": "Objective bound.", "desc": "If the lower objective cut is less than the value of this parameter value, then the lower objective cut i.e. :msk:dparam:`lower_obj_cut`  is treated as :math:`-\\infty`.", "value": "39", "default": "-0.5e30", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param"]}, {"caml-name": "INTPNT_TOL_REL_GAP", "name": "intpnt_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for linear problems.", "value": "35", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["termination-param", "intpnt-param"]}, {"caml-name": "INTPNT_TOL_STEP_SIZE", "name": "intpnt_tol_step_size", "brief": "Minimal step size tolerance for the interior-point optimizer.", "desc": "Minimal step size tolerance. If the step size falls below the value of this parameter, then the interior-point optimizer assumes that it is stalled. In other words the interior-point optimizer does not make any progress and therefore it is better to stop.", "value": "37", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "SIM_LU_TOL_REL_PIV", "name": "sim_lu_tol_rel_piv", "brief": "Relative pivot tolerance employed when computing the LU factorization of the basis matrix.", "desc": "Relative pivot tolerance employed when computing the LU factorization\nof the basis in the simplex optimizers and in the basis identification procedure.\nA value closer to 1.0 generally improves numerical stability but typically also implies an\nincrease in the computational work.", "value": "58", "default": "0.01", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "simplex-param"]}, {"caml-name": "INTPNT_TOL_REL_STEP", "name": "intpnt_tol_rel_step", "brief": "Relative step size to the boundary for linear and quadratic optimization problems.", "value": "36", "default": "0.9999", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_PATH", "name": "intpnt_tol_path", "brief": "Interior-point centering aggressiveness.", "desc": "Controls how close\nthe interior-point optimizer follows the central path. A large\nvalue of this parameter means the central path is\nfollowed very closely. On numerically unstable\nproblems it may be worthwhile to increase this\nparameter.", "value": "32", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_PFEAS", "name": "intpnt_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for linear problems.", "value": "33", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_DFEAS", "name": "intpnt_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for linear problems.", "value": "28", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_MU_RED", "name": "intpnt_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for linear problems.", "value": "31", "default": "1.0e-16", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_INFEAS", "name": "intpnt_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for linear problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for linear problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "30", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_CO_TOL_REL_GAP", "name": "intpnt_co_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for conic problems.", "value": "21", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_PFEAS", "name": "intpnt_co_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for conic problems.", "value": "20", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_DFEAS", "name": "intpnt_co_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for conic problems.", "value": "16", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_co_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_MU_RED", "name": "intpnt_co_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for conic problems.", "value": "18", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_NEAR_REL", "name": "intpnt_co_tol_near_rel", "brief": "Optimality tolerance used by the interior-point optimizer for conic problems.", "desc": "Optimality tolerance used by the interior-point optimizer for conic problems.\nIf |mosek| cannot compute a solution that has the prescribed accuracy then\nit will check if the solution found satisfies the termination criteria with all tolerances\nmultiplied by the value of this parameter. If yes, then the solution is also declared optimal.", "value": "19", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_CO_TOL_INFEAS", "name": "intpnt_co_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for conic problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for conic problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "17", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param", "conic-param"]}, {"caml-name": "INTPNT_QO_TOL_REL_GAP", "name": "intpnt_qo_tol_rel_gap", "brief": "Relative gap termination tolerance used by the interior-point optimizer for quadratic problems.", "value": "27", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_PFEAS", "name": "intpnt_qo_tol_pfeas", "brief": "Primal feasibility tolerance used by the interior-point optimizer for quadratic problems.", "value": "26", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_DFEAS", "name": "intpnt_qo_tol_dfeas", "brief": "Dual feasibility tolerance used by the interior-point optimizer for quadratic problems.", "value": "22", "default": "1.0e-8", "references": [{"type": "constant", "item": ["mosek", "dparam", "intpnt_qo_tol_near_rel"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_MU_RED", "name": "intpnt_qo_tol_mu_red", "brief": "Relative complementarity gap tolerance used by the interior-point optimizer for quadratic problems.", "value": "24", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_NEAR_REL", "name": "intpnt_qo_tol_near_rel", "brief": "Optimality tolerance used by the interior-point optimizer for quadratic problems.", "desc": "Optimality tolerance used by the interior-point optimizer for quadratic problems.\nIf |mosek| cannot compute a solution that has the prescribed accuracy then\nit will check if the solution found satisfies the termination criteria with all tolerances\nmultiplied by the value of this parameter. If yes, then the solution is also declared optimal.", "value": "25", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_QO_TOL_INFEAS", "name": "intpnt_qo_tol_infeas", "brief": "Infeasibility tolerance used by the interior-point optimizer for quadratic problems.", "desc": "Infeasibility tolerance used by the interior-point optimizer for quadratic problems.\nControls when the interior-point optimizer declares\nthe model primal or dual infeasible. A small number means the optimizer\ngets more conservative about declaring the model infeasible.", "value": "23", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"]}, {"caml-name": "INTPNT_TOL_PSAFE", "name": "intpnt_tol_psafe", "brief": "Controls the interior-point primal starting point.", "desc": "Controls the initial primal starting point used by\nthe interior-point optimizer. If the interior-point optimizer\nconverges slowly and/or the constraint or variable bounds are very\nlarge, then it may be worthwhile to increase this value.", "value": "34", "default": "1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "INTPNT_TOL_DSAFE", "name": "intpnt_tol_dsafe", "brief": "Controls the interior-point dual starting point.", "desc": "Controls the initial dual starting point used by\nthe interior-point optimizer. If the interior-point optimizer\nconverges slowly and/or the constraint or variable bounds are very large,\nthen it might be worthwhile to increase this value.", "value": "29", "default": "1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "MIO_MAX_TIME", "name": "mio_max_time", "brief": "Time limit for the mixed-integer optimizer.", "desc": "This parameter limits the maximum time spent by the mixed-integer optimizer.\nA negative number means infinity.", "value": "41", "default": "-1.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_REL_GAP_CONST", "name": "mio_rel_gap_const", "brief": "This value is used to compute the relative gap for the solution to an integer optimization problem.", "value": "42", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_TOL_REL_GAP", "name": "mio_tol_rel_gap", "brief": "Relative optimality tolerance employed by the mixed-integer optimizer.", "value": "47", "default": "1.0e-4", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"]}, {"caml-name": "MIO_TOL_ABS_GAP", "name": "mio_tol_abs_gap", "brief": "Absolute optimality tolerance employed by the mixed-integer optimizer.", "value": "43", "default": "0.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "MIO_TOL_ABS_RELAX_INT", "name": "mio_tol_abs_relax_int", "brief": "Integer feasibility tolerance.", "desc": "Absolute integer feasibility tolerance. If the distance to the nearest integer is less than this tolerance\nthen an integer constraint is assumed to be satisfied.", "value": "44", "default": "1.0e-5", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "MIO_DJC_MAX_BIGM", "name": "mio_djc_max_bigm", "brief": "Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints.", "desc": "Maximum allowed big-M value when reformulating disjunctive constraints to linear constraints. Higher\nvalues make it more likely that a disjunction is reformulated to linear constraints, but also\nincrease the risk of numerical problems.", "value": "40", "default": "1.0e6", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "BASIS_TOL_X", "name": "basis_tol_x", "brief": "Maximum absolute primal bound violation allowed in an optimal basic solution.", "value": "3", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "BASIS_TOL_S", "name": "basis_tol_s", "brief": "Maximum absolute dual bound violation in an optimal basic solution.", "value": "2", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "BASIS_REL_TOL_S", "name": "basis_rel_tol_s", "brief": "Maximum relative dual bound violation allowed in an optimal basic solution.", "value": "1", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"]}, {"caml-name": "PRESOLVE_TOL_X", "name": "presolve_tol_x", "brief": "Absolute zero tolerance employed for variables in the presolve.", "desc": "Absolute zero tolerance employed for :math:`x_j` in the presolve.", "value": "55", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_PRIMAL_INFEAS_PERTURBATION", "name": "presolve_tol_primal_infeas_perturbation", "brief": "The presolve is allowed to perturb a bound on a constraint or variable by this amount if it removes an infeasibility.", "value": "52", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_S", "name": "presolve_tol_s", "brief": "Absolute zero tolerance employed for slack variables in the presolve.", "desc": "Absolute zero tolerance employed for :math:`s_i` in the presolve.", "value": "54", "default": "1.0e-8", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_AIJ", "name": "presolve_tol_aij", "brief": "Absolute zero tolerance employed for constraint coefficients in the presolve.", "desc": "Absolute zero tolerance employed for :math:`a_{ij}` in the presolve.", "value": "51", "default": "1.0e-12", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_ABS_LINDEP", "name": "presolve_tol_abs_lindep", "brief": "Absolute tolerance employed by the linear dependency checker.", "value": "50", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "PRESOLVE_TOL_REL_LINDEP", "name": "presolve_tol_rel_lindep", "brief": "Relative tolerance employed by the linear dependency checker.", "value": "53", "default": "1.0e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"]}, {"caml-name": "SIMPLEX_ABS_TOL_PIV", "name": "simplex_abs_tol_piv", "brief": "Absolute pivot tolerance employed by the simplex optimizers.", "value": "59", "default": "1.0e-7", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"]}, {"caml-name": "MIO_TOL_FEAS", "name": "mio_tol_feas", "brief": "Feasibility tolerance for mixed integer solver.", "value": "45", "default": "1.0e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}, {"caml-name": "ANA_SOL_INFEAS_TOL", "name": "ana_sol_infeas_tol", "brief": "If a constraint violates its bound with an amount larger than this value, the constraint name, index and violation will be printed by the solution analyzer.", "value": "0", "default": "1e-6", "references": [], "status": "api", "valuescomment": null, "member-of": ["ana-param"]}, {"caml-name": "CHECK_CONVEXITY_REL_TOL", "name": "check_convexity_rel_tol", "brief": "Convexity check tolerance.", "desc": "This parameter controls when the full convexity check declares a problem to be non-convex.\nIncreasing this tolerance relaxes the criteria for declaring the problem non-convex.\n\nA problem is declared non-convex if negative (positive) pivot elements are detected in the Cholesky factor of a matrix\nwhich is required to be PSD (NSD). This parameter controls how much this non-negativity requirement may be violated.\n\nIf :math:`d_i` is the pivot element for column :math:`i`, then the matrix :math:`Q` is considered to not be PSD if:\n\n.. math::  d_i \\leq - |Q_{ii}|  \\mathtt{check\\_convexity\\_rel\\_tol}", "value": "4", "default": "1e-10", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "QCQO_REFORMULATE_REL_DROP_TOL", "name": "qcqo_reformulate_rel_drop_tol", "brief": "This parameter determines when columns are dropped in incomplete Cholesky factorization during reformulation of quadratic problems.", "value": "56", "default": "1e-15", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"]}, {"caml-name": "MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT", "name": "mio_tol_rel_dual_bound_improvement", "brief": "Controls cut generation for mixed-integer optimizer.", "desc": "If the relative improvement of the dual bound is smaller than this value, the solver will terminate the root cut generation.\nA value of 0.0 means that the value is selected automatically.", "value": "46", "default": "0.0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"]}], "type": "double"}, "iparam": {"name": "iparam", "brief": "Integer parameters", "desc": "The enumeration type containing all integer parameters.", "is-enumerable": true, "prefix": "IPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "AUTO_UPDATE_SOL_INFO", "name": "auto_update_sol_info", "brief": "Controls whether the solution information items are automatically updated after an optimization is performed.", "value": "3", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "REMOVE_UNUSED_SOLUTIONS", "name": "remove_unused_solutions", "brief": "Removes unused solutions before the optimization is performed.", "value": "130", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_HOTSTART", "name": "intpnt_hotstart", "brief": "Currently not in use.", "value": "17", "default": "none", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "intpnthotstart"]}}, {"caml-name": "INTPNT_PURIFY", "name": "intpnt_purify", "brief": "Currently not in use.", "value": "24", "default": "none", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "purify"]}}, {"caml-name": "NUM_THREADS", "name": "num_threads", "brief": "The number of threads employed by the optimizer.", "desc": "Controls the number of threads employed by the optimizer. If set to 0 the number of threads used will be equal to the number of cores detected on the machine.", "value": "97", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "TIMING_LEVEL", "name": "timing_level", "brief": "Controls the amount of timing performed inside MOSEK.", "desc": "Controls the amount of timing performed inside |mosek|.", "value": "165", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MT_SPINCOUNT", "name": "mt_spincount", "brief": "Set the number of iterations to spin before sleeping.", "value": "95", "default": "0", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["system-param"], "bounds": {"lower": "0", "upper": "1000000000"}}, {"caml-name": "MAX_NUM_WARNINGS", "name": "max_num_warnings", "brief": "Each warning is shown a limited number of times controlled by this parameter. A negative value is identical to infinite number of times.", "value": "57", "default": "10", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "OPTIMIZER", "name": "optimizer", "brief": "Controls which optimizer is used to optimize the task.", "desc": "The parameter controls which optimizer is used to optimize the task.", "value": "107", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "BI_MAX_ITERATIONS", "name": "bi_max_iterations", "brief": "Maximum number of iterations after basis identification.", "desc": "Controls the maximum number of\nsimplex iterations allowed to optimize\na basis after the basis identification.", "value": "8", "default": "1000000", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LICENSE_TRH_EXPIRY_WRN", "name": "license_trh_expiry_wrn", "brief": "Controls when expiry warnings are issued.", "desc": "If a license feature expires in a numbers of days less than the value of this parameter then a warning will be issued.", "value": "32", "default": "7", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_INCLUDE_SUMMARY", "name": "log_include_summary", "brief": "Controls whether solution summary should be printed by the optimizer.", "desc": ".. msk_only:: optimizer\n\n   If on, then the solution summary will be printed by :msk:func:`task.optimize`, so a separate call to :msk:func:`task.solutionsummary` is not necessary.\n\n.. msk_only:: not optimizer\n\n   Not relevant for this API.", "value": "42", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_CUT_SECOND_OPT", "name": "log_cut_second_opt", "brief": "Controls the reduction in the log levels for the second and any subsequent optimizations.", "desc": "If a task is employed to solve a sequence of optimization problems, then the value of the log levels is reduced by the value\nof this parameter. E.g :msk:iparam:`log` and :msk:iparam:`log_sim` are reduced by the value of this parameter\nfor the second and any subsequent optimizations.", "value": "38", "default": "1", "references": [{"type": "constant", "item": ["mosek", "iparam", "log"]}, {"type": "constant", "item": ["mosek", "iparam", "log_intpnt"]}, {"type": "constant", "item": ["mosek", "iparam", "log_mio"]}, {"type": "constant", "item": ["mosek", "iparam", "log_sim"]}], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_ANA_PRO", "name": "log_ana_pro", "brief": "Controls amount of output from the problem analyzer.", "value": "35", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["ana-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_RESPONSE", "name": "log_response", "brief": "Controls amount of output printed when response codes are reported. A higher level implies that more information is logged.", "value": "50", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_LOCAL_INFO", "name": "log_local_info", "brief": "Control whether local identifying information is printed to the log.", "desc": "Controls whether local identifying information like\nenvironment variables, filenames, IP addresses\netc. are printed to the log.\n\nNote that this will only affect some functions. Some\nfunctions that specifically emit system information\nwill not be affected.", "value": "45", "default": "on", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_BI", "name": "log_bi", "brief": "Controls the amount of output printed by the basis identification procedure. A higher level implies that more information is logged.", "value": "36", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_BI_FREQ", "name": "log_bi_freq", "brief": "Controls the logging frequency.", "desc": "Controls how frequently the optimizer\noutputs information about the basis identification\nand how frequent the user-defined callback function\nis called.", "value": "37", "default": "2500", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "BI_CLEAN_OPTIMIZER", "name": "bi_clean_optimizer", "brief": "Controls which simplex optimizer is used in the clean-up phase.", "desc": "Controls which simplex optimizer is used in the clean-up phase. Anything else than :msk:const:`optimizertype.primal_simplex` or :msk:const:`optimizertype.dual_simplex` is equivalent to :msk:const:`optimizertype.free_simplex`.", "value": "5", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["bi-param", "solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "INTPNT_MAX_NUM_REFINEMENT_STEPS", "name": "intpnt_max_num_refinement_steps", "brief": "Maximum number of steps to be used by the iterative search direction refinement.", "desc": "Maximum number of steps to be used by the iterative\nrefinement of the search direction. A negative value\nimplies that the optimizer chooses the maximum number\nof iterative refinement steps.", "value": "20", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "INTPNT_STARTING_POINT", "name": "intpnt_starting_point", "brief": "Starting point used by the interior-point optimizer.", "value": "28", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "startpointtype"]}}, {"caml-name": "INTPNT_DIFF_STEP", "name": "intpnt_diff_step", "brief": "Controls whether different step sizes are allowed in the primal and dual space.", "value": "16", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_SCALING", "name": "intpnt_scaling", "brief": "Controls how the problem is scaled before the interior-point optimizer is used.", "value": "26", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "scalingtype"]}}, {"caml-name": "INTPNT_SOLVE_FORM", "name": "intpnt_solve_form", "brief": "Controls whether the primal or the dual problem is solved.", "value": "27", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "solveform"]}}, {"caml-name": "LOG_INTPNT", "name": "log_intpnt", "brief": "Controls the amount of log information from the interior-point optimizers.", "desc": "Controls amount of output printed\nby the interior-point optimizer. A higher level implies that more information is logged.", "value": "44", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_MAX_ITERATIONS", "name": "intpnt_max_iterations", "brief": "Controls the maximum number of iterations allowed in the interior-point optimizer.", "value": "18", "default": "400", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_OFF_COL_TRH", "name": "intpnt_off_col_trh", "brief": "Controls the aggressiveness of the offending column detection.", "desc": "Controls how many offending columns are detected in the Jacobian of the constraint matrix.\n\n+----------+-----------------------------------------------+\n|:math:`0` |  no detection                                 |\n+----------+-----------------------------------------------+\n|:math:`1` |  aggressive detection                         |\n+----------+-----------------------------------------------+\n|:math:`>1`|  higher values mean less aggressive detection |\n+----------+-----------------------------------------------+", "value": "21", "default": "40", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_ORDER_METHOD", "name": "intpnt_order_method", "brief": "Controls the ordering strategy.", "desc": "Controls the ordering strategy used by the interior-point\noptimizer when factorizing the Newton\nequation system.", "value": "23", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "orderingtype"]}}, {"caml-name": "INTPNT_ORDER_GP_NUM_SEEDS", "name": "intpnt_order_gp_num_seeds", "brief": "This parameter controls the number of random seeds tried.", "desc": "The GP ordering is dependent on a random seed. Therefore, trying several random seeds may lead to a better ordering.\nThis parameter controls the number of random seeds tried.\n\nA value of 0 means that MOSEK makes the choice.", "value": "22", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INTPNT_BASIS", "name": "intpnt_basis", "brief": "Controls whether basis identification is performed.", "desc": "Controls whether the interior-point optimizer also\ncomputes an optimal basis.", "value": "15", "default": "ALWAYS", "references": [{"type": "constant", "item": ["mosek", "iparam", "bi_ignore_max_iter"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_ignore_num_error"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_max_iterations"]}, {"type": "constant", "item": ["mosek", "iparam", "bi_clean_optimizer"]}], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "basindtype"]}}, {"caml-name": "BI_IGNORE_MAX_ITER", "name": "bi_ignore_max_iter", "brief": "Turns on basis identification in case the interior-point optimizer is terminated due to maximum number of iterations.", "desc": "If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to maximum number of iterations, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.", "value": "6", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "BI_IGNORE_NUM_ERROR", "name": "bi_ignore_num_error", "brief": "Turns on basis identification in case the interior-point optimizer is terminated due to a numerical problem.", "desc": "If the parameter :msk:iparam:`intpnt_basis` has the value :msk:const:`basindtype.no_error` and the interior-point optimizer has terminated due to a numerical problem, then basis identification is performed if this parameter has the value :msk:const:`onoffkey.on`.", "value": "7", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param", "bi-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_MAX_NUM_COR", "name": "intpnt_max_num_cor", "brief": "Maximum number of correction steps.", "desc": "Controls the maximum number of correctors allowed by the multiple corrector procedure. A negative value means that |mosek| is making the choice.", "value": "19", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "bounds": {"lower": "-1", "upper": "+inf"}}, {"caml-name": "PRESOLVE_USE", "name": "presolve_use", "brief": "Controls whether the presolve is applied to a problem before it is optimized.", "value": "119", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "valuesfrom": {"from": ["mosek", "presolvemode"]}}, {"caml-name": "PRESOLVE_LEVEL", "name": "presolve_level", "brief": "Currently not used.", "value": "112", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "LOG_PRESOLVE", "name": "log_presolve", "brief": "Controls amount of output printed by the presolve procedure. A higher level implies that more information is logged.", "value": "49", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "PRESOLVE_LINDEP_USE", "name": "presolve_lindep_use", "brief": "Controls whether the linear constraints are checked for linear dependencies.", "value": "116", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_LINDEP_NEW", "name": "presolve_lindep_new", "brief": "Controls whether whether a new experimental linear dependency checker is employed.", "value": "114", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_MAX_NUM_PASS", "name": "presolve_max_num_pass", "brief": "Control the maximum number of times presolve passes over the problem.", "desc": "Control the maximum number of times presolve passes over the problem. A negative value implies |mosek| decides.", "value": "117", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_ELIMINATOR_MAX_NUM_TRIES", "name": "presolve_eliminator_max_num_tries", "brief": "Control the maximum number of times the eliminator is tried.", "desc": "Control the maximum number of times the eliminator is tried. A negative value implies |mosek| decides.", "value": "111", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_ELIMINATOR_MAX_FILL", "name": "presolve_eliminator_max_fill", "brief": "Maximum amount of fill-in created in one pivot during the elimination phase.", "desc": "Controls the maximum amount of fill-in that can be created by one pivot in the elimination phase\nof the presolve. A negative value means the parameter value is selected automatically.", "value": "110", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_MAX_NUM_REDUCTIONS", "name": "presolve_max_num_reductions", "brief": "Controls the maximum number of reductions performed by the presolve.", "desc": "Controls the maximum number of reductions performed by the\npresolve. The value of the parameter is normally only changed\nin connection with debugging. A negative value implies that an\ninfinite number of reductions are allowed.", "value": "118", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SIM_DETECT_PWL", "name": "sim_detect_pwl", "brief": "Not in use.", "value": "136", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_STABILITY_PRIORITY", "name": "sim_stability_priority", "brief": "Controls how high priority the numerical stability should be given.", "value": "158", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_PRIMAL_CRASH", "name": "sim_primal_crash", "brief": "Controls the simplex crash.", "desc": "Controls whether crashing is performed in the primal simplex optimizer.\nIn general, if a basis consists of more than (100-this parameter value)\\%\nfixed variables, then a crash will be performed.", "value": "147", "default": "90", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM", "name": "log_sim", "brief": "Controls the amount of log information from the simplex optimizers.", "desc": "Controls amount of output printed by the simplex optimizer. A higher level implies that more information is logged.", "value": "53", "default": "4", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM_MINOR", "name": "log_sim_minor", "brief": "Currently not in use.", "value": "55", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SIM_FREQ", "name": "log_sim_freq", "brief": "Controls simplex logging frequency.", "desc": "Controls how frequent the simplex optimizer\noutputs information about the optimization\nand how frequent the user-defined callback function\nis called.", "value": "54", "default": "1000", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_PRIMAL_RESTRICT_SELECTION", "name": "sim_primal_restrict_selection", "brief": "Controls how aggressively restricted selection is used.", "desc": "The primal simplex optimizer can use a so-called restricted selection/pricing strategy to\nchoose the outgoing variable. Hence, if restricted selection is applied, then the primal simplex optimizer first\nchoose a subset of all the potential incoming variables. Next, for some time it will choose the incoming\nvariable only among the subset. From time to time the subset is redefined.\nA larger value of this parameter implies that the optimizer will be more aggressive in its\nrestriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.", "value": "149", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_PRIMAL_SELECTION", "name": "sim_primal_selection", "brief": "Controls the primal simplex strategy.", "desc": "Controls the choice of the incoming variable,\nknown as the selection strategy, in the primal\nsimplex optimizer.", "value": "150", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["psimplex-param"], "valuesfrom": {"from": ["mosek", "simseltype"]}}, {"caml-name": "SIM_DUAL_RESTRICT_SELECTION", "name": "sim_dual_restrict_selection", "brief": "Controls how aggressively restricted selection is used.", "desc": "The dual simplex optimizer can use a so-called restricted selection/pricing strategy to\nchoose the outgoing variable. Hence, if restricted selection is applied, then the dual simplex optimizer first\nchoose a subset of all the potential outgoing variables. Next, for some time it will choose the outgoing\nvariable only among the subset. From time to time the subset is redefined.\nA larger value of this parameter implies that the optimizer will be more aggressive in its\nrestriction strategy, i.e. a value of 0 implies that the restriction strategy is not applied at all.", "value": "139", "default": "50", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "bounds": {"lower": "0", "upper": "100"}}, {"caml-name": "SIM_DUAL_SELECTION", "name": "sim_dual_selection", "brief": "Controls the dual simplex strategy.", "desc": "Controls the choice of the incoming variable,\nknown as the selection strategy, in the dual\nsimplex optimizer.", "value": "140", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "valuesfrom": {"from": ["mosek", "simseltype"]}}, {"caml-name": "SIM_MAX_ITERATIONS", "name": "sim_max_iterations", "brief": "Maximum number of iterations that can be used by a simplex optimizer.", "value": "144", "default": "10000000", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_HOTSTART_LU", "name": "sim_hotstart_lu", "brief": "Determines if the simplex optimizer should exploit the initial factorization.", "value": "143", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_REFACTOR_FREQ", "name": "sim_refactor_freq", "brief": "Controls the basis refactoring frequency.", "desc": "Controls how frequent the basis is refactorized.\nThe value 0 means that the optimizer determines\nthe best point of refactorization.\nIt is strongly recommended NOT to change this parameter.", "value": "151", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_SEED", "name": "sim_seed", "brief": "Sets the random seed used for randomization in the simplex optimizers.", "value": "156", "default": "23456", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "32749"}}, {"caml-name": "MIO_MODE", "name": "mio_mode", "brief": "Turns on/off the mixed-integer mode.", "desc": "Controls whether the optimizer includes\nthe integer restrictions and disjunctive constraints when solving a\n(mixed) integer optimization problem.", "value": "79", "default": "SATISFIED", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "miomode"]}}, {"caml-name": "LOG_MIO", "name": "log_mio", "brief": "Controls the amount of log information from the mixed-integer optimizers.", "desc": "Controls the log level for the mixed-integer optimizer. A higher level implies that more information is logged.", "value": "46", "default": "4", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_MIO_FREQ", "name": "log_mio_freq", "brief": "The mixed-integer optimizer logging frequency.", "desc": "Controls how frequent the mixed-integer optimizer prints the log line. It\nwill print line every time :msk:iparam:`log_mio_freq` relaxations have been solved.", "value": "47", "default": "10", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "info-param", "log-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_RELAXS", "name": "mio_max_num_relaxs", "brief": "Maximum number of relaxations in branch and bound search.", "desc": "Maximum number of relaxations allowed during the branch and bound search. A negative\nvalue means infinite.", "value": "73", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_BRANCHES", "name": "mio_max_num_branches", "brief": "Maximum number of branches allowed during the branch and bound search.", "desc": "Maximum number of branches allowed during the branch and bound search. A negative\nvalue means infinite.", "value": "72", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_RESTARTS", "name": "mio_max_num_restarts", "brief": "Maximum number of restarts allowed during the branch and bound search.", "value": "74", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_ROOT_CUT_ROUNDS", "name": "mio_max_num_root_cut_rounds", "brief": "Maximum number of cut separation rounds at the root node.", "value": "75", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_MAX_NUM_SOLUTIONS", "name": "mio_max_num_solutions", "brief": "Controls how many feasible solutions the mixed-integer optimizer investigates.", "desc": "The mixed-integer optimizer can be terminated after a certain number of different feasible\nsolutions has been located. If this parameter has the value :math:`n>0`, then the mixed-integer optimizer\nwill be terminated when :math:`n` feasible solutions have been located.", "value": "76", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param", "termination-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_NODE_SELECTION", "name": "mio_node_selection", "brief": "Controls the node selection strategy employed by the mixed-integer optimizer.", "value": "81", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "mionodeseltype"]}}, {"caml-name": "MIO_VAR_SELECTION", "name": "mio_var_selection", "brief": "Controls the variable selection strategy employed by the mixed-integer optimizer.", "value": "93", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miovarseltype"]}}, {"caml-name": "MIO_MIN_REL", "name": "mio_min_rel", "brief": "Number of times a variable must have been branched on for its pseudocost to be considered reliable.", "value": "78", "default": "5", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_HEURISTIC_LEVEL", "name": "mio_heuristic_level", "brief": "Controls the heuristic employed by the mixed-integer optimizer to locate an initial integer feasible solution.", "desc": "Controls the heuristic employed by the mixed-integer\noptimizer to locate an initial good integer feasible\nsolution.  A value of zero means the heuristic is not used\nat all. A larger value than :math:`0` means that a gradually more\nsophisticated heuristic is used which is computationally\nmore expensive. A negative value implies that the optimizer\nchooses the heuristic. Normally a value around :math:`3` to :math:`5`\nshould be optimal.", "value": "71", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "MIO_PROBING_LEVEL", "name": "mio_probing_level", "brief": "Controls the amount of probing employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of probing employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of probing employed\n* :math:`0`. Probing is disabled\n* :math:`1`. A low amount of probing is employed\n* :math:`2`. A medium amount of probing is employed\n* :math:`3`. A high amount of probing is employed", "value": "85", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "3"}}, {"caml-name": "MIO_SYMMETRY_LEVEL", "name": "mio_symmetry_level", "brief": "Controls the amount of symmetry detection and handling employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of symmetry detection and handling employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of symmetry detection and handling employed\n* :math:`0`. Symmetry detection and handling is disabled\n* :math:`1`. A low amount of symmetry detection and handling is employed\n* :math:`2`. A medium amount of symmetry detection and handling is employed\n* :math:`3`. A high amount of symmetry detection and handling is employed\n* :math:`4`. An extremely high amount of symmetry detection and handling is employed", "value": "92", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "4"}}, {"caml-name": "MIO_DUAL_RAY_ANALYSIS_LEVEL", "name": "mio_dual_ray_analysis_level", "brief": "Controls the amount of dual ray analysis employed by the mixed-integer optimizer in presolve.", "desc": "Controls the amount of symmetry detection and handling employed by the mixed-integer\noptimizer in presolve.\n\n* :math:`-1`. The optimizer chooses the level of dual ray analysis employed\n* :math:`0`. Dual ray analysis is disabled\n* :math:`1`. A lower amount of dual ray analysis is employed\n* :math:`2`. A higher amount of dual ray analysis is employed", "value": "69", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "2"}}, {"caml-name": "MIO_PRESOLVE_AGGREGATOR_USE", "name": "mio_presolve_aggregator_use", "brief": "Controls if the aggregator should be used.", "value": "84", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_NUMERICAL_EMPHASIS_LEVEL", "name": "mio_numerical_emphasis_level", "brief": "Controls how much emphasis is put on reducing numerical problems", "desc": "Controls how much emphasis is put on reducing numerical problems possibly at the expense of solution\nspeed.\n\n* :math:`0`. The optimizer chooses\n* :math:`1`. More emphasis is put on reducing numerical problems\n* :math:`2`. Even more emphasis", "value": "82", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+2"}}, {"caml-name": "MIO_MEMORY_EMPHASIS_LEVEL", "name": "mio_memory_emphasis_level", "brief": "Controls how much emphasis is put on reducing memory usage.", "desc": "Controls how much emphasis is put on reducing memory usage. Being more conservative about memory\nusage may come at the cost of decreased solution speed.\n\n* :math:`0`. The optimizer chooses\n* :math:`1`. More emphasis is put on reducing memory usage and less on speed", "value": "77", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+1"}}, {"caml-name": "MIO_CUT_SELECTION_LEVEL", "name": "mio_cut_selection_level", "brief": "Controls how aggressively generated cuts are selected to be included in the relaxation.", "desc": "Controls how aggressively generated cuts are selected to be included in the relaxation.\n\n* :math:`-1`. The optimizer chooses the level of cut selection\n* :math:`0`. Generated cuts less likely to be added to the relaxation\n* :math:`1`. Cuts are more aggressively selected to be included in the relaxation", "value": "67", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+1"}}, {"caml-name": "MIO_VB_DETECTION_LEVEL", "name": "mio_vb_detection_level", "brief": "Controls how much effort is put into detecting variable bounds.", "desc": "Controls how much effort is put into detecting variable bounds.\n\n* :math:`-1`. The optimizer chooses\n* :math:`0`. No variable bounds are detected\n* :math:`1`. Only detect variable bounds that are directly represented in the problem\n* :math:`2`. Detect variable bounds in probing", "value": "94", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+2"}}, {"caml-name": "MIO_BRANCH_DIR", "name": "mio_branch_dir", "brief": "Controls whether the mixed-integer optimizer is branching up or down by default.", "value": "58", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "branchdir"]}}, {"caml-name": "MIO_ROOT_OPTIMIZER", "name": "mio_root_optimizer", "brief": "Controls which optimizer is employed at the root node in the mixed-integer optimizer.", "value": "89", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_NODE_OPTIMIZER", "name": "mio_node_optimizer", "brief": "Controls which optimizer is employed at the non-root nodes in the mixed-integer optimizer.", "value": "80", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_PERSPECTIVE_REFORMULATE", "name": "mio_perspective_reformulate", "brief": "Enables or disables perspective reformulation in presolve.", "value": "83", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_PROPAGATE_OBJECTIVE_CONSTRAINT", "name": "mio_propagate_objective_constraint", "brief": "Use objective domain propagation.", "value": "86", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_SEED", "name": "mio_seed", "brief": "Sets the random seed used for randomization in the mixed integer optimizer.", "desc": "Sets the random seed used for randomization in the mixed integer optimizer.\nSelecting a different seed can change the path the optimizer takes to the optimal solution.", "value": "91", "default": "42", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "MIO_CONIC_OUTER_APPROXIMATION", "name": "mio_conic_outer_approximation", "brief": "Toggles outer approximation for conic problems.", "desc": "If this option is turned on outer approximation is used when solving relaxations of conic problems; otherwise interior point is used.", "value": "59", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_QCQO_REFORMULATION_METHOD", "name": "mio_qcqo_reformulation_method", "brief": "Controls what reformulation method is applied to mixed-integer quadratic problems.", "value": "87", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miqcqoreformmethod"]}}, {"caml-name": "MIO_DATA_PERMUTATION_METHOD", "name": "mio_data_permutation_method", "brief": "Controls what problem data permutation method is appplied to mixed-integer problems.", "value": "68", "default": "NONE", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "miodatapermmethod"]}}, {"caml-name": "READ_KEEP_FREE_CON", "name": "read_keep_free_con", "brief": "Controls whether the free constraints are included in the problem.", "value": "125", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "READ_MPS_FORMAT", "name": "read_mps_format", "brief": "Controls how strictly the MPS file reader interprets the MPS format.", "value": "126", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "mpsformat"]}}, {"caml-name": "WRITE_MPS_FORMAT", "name": "write_mps_format", "brief": "Controls in which format the MPS is written.", "value": "181", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "mpsformat"]}}, {"caml-name": "READ_MPS_WIDTH", "name": "read_mps_width", "brief": "Controls the maximal number of characters allowed in one line of the MPS file.", "value": "127", "default": "1024", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "80", "upper": "+inf"}}, {"caml-name": "READ_DEBUG", "name": "read_debug", "brief": "Turns on additional debugging information when reading files.", "value": "124", "default": "off", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_DATA_PARAM", "name": "write_data_param", "brief": "Controls output file data.", "desc": "If this option is turned on the parameter settings are written to the\ndata file as parameters.", "value": "170", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_FREE_CON", "name": "write_free_con", "brief": "Controls the output file data.", "desc": "Controls whether the free\nconstraints are written to the\ndata file.", "value": "171", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_GENERIC_NAMES", "name": "write_generic_names", "brief": "Controls the output file data.", "desc": "Controls whether generic names should be used instead of user-defined names when writing to the data file.", "value": "172", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_GENERIC_NAMES_IO", "name": "write_generic_names_io", "brief": "Index origin used in  generic names.", "value": "173", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "WRITE_COMPRESSION", "name": "write_compression", "brief": "Controls output file compression.", "desc": "Controls whether the data file is compressed while it is written.\n0 means no compression while higher values mean more compression.", "value": "169", "default": "9", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "WRITE_MPS_INT", "name": "write_mps_int", "brief": "Controls the output file data.", "desc": "Controls if  marker records are written to the MPS file\nto indicate whether variables are integer restricted.", "value": "182", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_LP_LINE_WIDTH", "name": "write_lp_line_width", "brief": "Controls the LP output file format.", "desc": "Maximum width of line in an LP file written by |mosek|.", "value": "180", "default": "80", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "40", "upper": "+inf"}}, {"caml-name": "WRITE_LP_FULL_OBJ", "name": "write_lp_full_obj", "brief": "Write full linear objective", "desc": "Write all variables, including the ones with 0-coefficients, in the objective.", "value": "179", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_JSON_INDENTATION", "name": "write_json_indentation", "brief": "When set, the JSON task and solution files are written with indentation for better readability.", "value": "178", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_IGNORE_INVALID_NAMES", "name": "write_sol_ignore_invalid_names", "brief": "Controls whether the user specified names are employed even if they are invalid names.", "desc": "Even if the names are invalid MPS names, then they are employed when writing the solution file.", "value": "186", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_HEAD", "name": "write_sol_head", "brief": "Controls solution file format.", "desc": "Controls whether the header section is written to the\nsolution file.", "value": "185", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_CONSTRAINTS", "name": "write_sol_constraints", "brief": "Controls the solution file format.", "desc": "Controls whether the constraint section is written to the\nsolution file.", "value": "184", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_VARIABLES", "name": "write_sol_variables", "brief": "Controls the solution file format.", "desc": "Controls whether the variables section is written to the\nsolution file.", "value": "187", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_SOL_BARVARIABLES", "name": "write_sol_barvariables", "brief": "Controls the solution file format.", "desc": "Controls whether the symmetric matrix variables section is written to the\nsolution file.", "value": "183", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_HEAD", "name": "write_bas_head", "brief": "Controls the basic solution file format.", "desc": "Controls whether the header section is written to the\nbasic solution file.", "value": "167", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_CONSTRAINTS", "name": "write_bas_constraints", "brief": "Controls the basic solution file format.", "desc": "Controls whether the constraint section is written to the\nbasic solution file.", "value": "166", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_BAS_VARIABLES", "name": "write_bas_variables", "brief": "Controls the basic solution file format.", "desc": "Controls whether the variables section is written to the\nbasic solution file.", "value": "168", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_HEAD", "name": "write_int_head", "brief": "Controls the integer solution file format.", "desc": "Controls whether the header section is written to the\ninteger solution file.", "value": "176", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_CONSTRAINTS", "name": "write_int_constraints", "brief": "Controls the integer solution file format.", "desc": "Controls whether the constraint section is written to the\ninteger solution file.", "value": "175", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_INT_VARIABLES", "name": "write_int_variables", "brief": "Controls the integer solution file format.", "desc": "Controls whether the variables section is written to the\ninteger solution file.", "value": "177", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_READ_NAME_WIDTH", "name": "sol_read_name_width", "brief": "Controls the input solution file format.", "desc": "When a solution is read by |mosek| and some constraint, variable or cone names contain blanks, then a maximum name width much be specified. A negative value implies that no name contain blanks.", "value": "162", "default": "-1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SOL_READ_WIDTH", "name": "sol_read_width", "brief": "Controls the input solution file format.", "desc": "Controls the maximal acceptable width of line in the solutions when read by |mosek|.", "value": "163", "default": "1024", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "bounds": {"lower": "80", "upper": "+inf"}}, {"caml-name": "INFEAS_REPORT_AUTO", "name": "infeas_report_auto", "brief": "Turns the feasibility report on or off.", "desc": "Controls whether an infeasibility report is automatically\nproduced after the optimization if the problem is primal or dual\ninfeasible.", "value": "13", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param", "solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INFEAS_REPORT_LEVEL", "name": "infeas_report_level", "brief": "Controls the contents of the infeasibility report.", "desc": "Controls the amount of information presented in an infeasibility report.\nHigher values imply more information.", "value": "14", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["infeas-param", "info-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INFEAS_GENERIC_NAMES", "name": "infeas_generic_names", "brief": "Controls the contents of the infeasibility report.", "desc": "Controls whether generic names are used when an infeasible subproblem is created.", "value": "11", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["infeas-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_INFEAS_ANA", "name": "log_infeas_ana", "brief": "Controls log level for the infeasibility analyzer.", "desc": "Controls amount of output printed by the infeasibility analyzer procedures. A higher level implies that more information is logged.", "value": "43", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["infeas-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LICENSE_WAIT", "name": "license_wait", "brief": "Controls if MOSEK should queue for a license if none is available.", "desc": "If all licenses are in use |mosek| returns with an error code.\nHowever, by turning on this parameter |mosek| will wait for an available license.", "value": "33", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param", "system-param", "lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LICENSE_SUPPRESS_EXPIRE_WRNS", "name": "license_suppress_expire_wrns", "brief": "Controls license manager client behavior.", "desc": "Controls whether license features expire warnings are suppressed.", "value": "31", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param", "info-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LICENSE_PAUSE_TIME", "name": "license_pause_time", "brief": "Controls license manager client behavior.", "desc": "If :msk:iparam:`license_wait` is :msk:const:`onoffkey.on` and no license is available, then |mosek| sleeps a number\nof milliseconds between each check of whether a license has become free.", "value": "30", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "bounds": {"lower": "0", "upper": "1000000"}}, {"caml-name": "LICENSE_DEBUG", "name": "license_debug", "brief": "Controls the license manager client debugging behavior.", "desc": "This option is used to turn on debugging of the license manager.", "value": "29", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_FILTER_KEEP_BASIC", "name": "sol_filter_keep_basic", "brief": "Control the contents of the solution files.", "desc": "If turned on, then basic and super basic constraints and variables\nare written to the solution file independent of the filter setting.", "value": "160", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOL_FILTER_KEEP_RANGED", "name": "sol_filter_keep_ranged", "brief": "Control the contents of the solution files.", "desc": "If turned on, then ranged constraints and variables are written to the solution file\nindependent of the filter setting.", "value": "161", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG", "name": "log", "brief": "Controls the amount of log information.", "desc": "Controls the amount of log information. The value 0 implies that all log information is suppressed. A higher level implies that more information is logged.\n\nPlease note that if a task is employed to solve a sequence of optimization problems the value of this parameter is reduced by the value of :msk:iparam:`log_cut_second_opt` for the second and any subsequent optimizations.", "value": "34", "default": "10", "references": [{"type": "constant", "item": ["mosek", "iparam", "log_cut_second_opt"]}], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_EXPAND", "name": "log_expand", "brief": "Controls the amount of logging when a data item such as the maximum number constrains is expanded.", "value": "39", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_FILE", "name": "log_file", "brief": "If turned on, then some log info is printed when a file is written or read.", "value": "41", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["dataio-param", "info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_ORDER", "name": "log_order", "brief": "If turned on, then factor lines are added to the log.", "value": "48", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SENSITIVITY", "name": "log_sensitivity", "brief": "Control logging in sensitivity analyzer.", "desc": "Controls the amount of logging during the sensitivity analysis.\n\n* :math:`0`. Means no logging information is produced.\n* :math:`1`. Timing information is printed.\n* :math:`2`. Sensitivity results are printed.", "value": "51", "default": "1", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_SENSITIVITY_OPT", "name": "log_sensitivity_opt", "brief": "Control logging in sensitivity analyzer.", "desc": "Controls the amount of logging from the optimizers employed during the sensitivity analysis.\n0 means no logging information is produced.", "value": "52", "default": "0", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "READ_TASK_IGNORE_PARAM", "name": "read_task_ignore_param", "brief": "Controls what information is used from the task files.", "desc": "Controls whether |mosek| should ignore the parameter setting defined in the task file and use the default parameter setting instead.", "value": "128", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_TASK_INC_SOL", "name": "write_task_inc_sol", "brief": "Controls whether the solutions are stored in the task file too.", "value": "188", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PARAM_READ_CASE_NAME", "name": "param_read_case_name", "brief": "If turned on, then names in the parameter file are case sensitive.", "value": "108", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PARAM_READ_IGN_ERROR", "name": "param_read_ign_error", "brief": "If turned on, then errors in parameter settings is ignored.", "value": "109", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SOLUTION_CALLBACK", "name": "solution_callback", "brief": "Indicates whether solution callbacks will be performed during the optimization.", "value": "164", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["callback-param", "solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_SCALING", "name": "sim_scaling", "brief": "Controls how much effort is used in scaling the problem before a simplex optimizer is used.", "value": "154", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "scalingtype"]}}, {"caml-name": "SIM_SCALING_METHOD", "name": "sim_scaling_method", "brief": "Controls how the problem is scaled before a simplex optimizer is used.", "value": "155", "default": "POW2", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "scalingmethod"]}}, {"caml-name": "SIM_PRIMAL_PHASEONE_METHOD", "name": "sim_primal_phaseone_method", "brief": "An experimental feature.", "value": "148", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "10"}}, {"caml-name": "SIM_DUAL_PHASEONE_METHOD", "name": "sim_dual_phaseone_method", "brief": "An experimental feature.", "value": "138", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "10"}}, {"caml-name": "SIM_MAX_NUM_SETBACKS", "name": "sim_max_num_setbacks", "brief": "Controls how many set-backs that are allowed within a simplex optimizer.", "desc": "Controls how many set-backs are allowed within a simplex\noptimizer. A set-back is an event where the optimizer moves in\nthe wrong direction. This is impossible in theory but may happen due\nto numerical problems.", "value": "145", "default": "250", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "SIM_HOTSTART", "name": "sim_hotstart", "brief": "Controls the type of hot-start that the simplex optimizer perform.", "value": "142", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simhotstart"]}}, {"caml-name": "SIM_BASIS_FACTOR_USE", "name": "sim_basis_factor_use", "brief": "Controls whether an LU factorization of the basis is used in a hot-start.", "desc": "Controls whether an LU factorization of the basis is used in a hot-start. Forcing a refactorization sometimes improves the stability of the simplex optimizers, but in most cases there is a performance penalty.", "value": "134", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_DEGEN", "name": "sim_degen", "brief": "Controls how aggressively degeneration is handled.", "value": "135", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simdegen"]}}, {"caml-name": "SIM_REFORMULATION", "name": "sim_reformulation", "brief": "Controls if the simplex optimizers are allowed to reformulate the problem.", "value": "152", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simreform"]}}, {"caml-name": "SIM_EXPLOIT_DUPVEC", "name": "sim_exploit_dupvec", "brief": "Controls if the simplex optimizers are allowed to exploit duplicated columns.", "value": "141", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "simdupvec"]}}, {"caml-name": "SIM_SAVE_LU", "name": "sim_save_lu", "brief": "Controls if the LU factorization stored should be replaced with the LU factorization corresponding to the initial basis.", "value": "153", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_NON_SINGULAR", "name": "sim_non_singular", "brief": "Controls if the simplex optimizer ensures a non-singular basis, if possible.", "value": "146", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_DUAL_CRASH", "name": "sim_dual_crash", "brief": "Controls whether crashing is performed in the dual simplex optimizer.", "desc": "Controls whether crashing is performed in the dual simplex optimizer. If this parameter is set to :math:`x`, then a crash will be performed if a basis consists of more than :math:`(100-x)\\mod f_v` entries, where :math:`f_v` is the number of fixed variables.", "value": "137", "default": "90", "references": [], "status": "api", "valuescomment": null, "member-of": ["dsimplex-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "LOG_STORAGE", "name": "log_storage", "brief": "Controls the memory related log information.", "desc": "When turned on, |mosek| prints messages regarding the storage usage and allocation.", "value": "56", "default": "0", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "system-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "INFEAS_PREFER_PRIMAL", "name": "infeas_prefer_primal", "brief": "Controls which certificate is used if both primal- and dual- certificate of infeasibility is available.", "desc": "If both certificates of primal and dual infeasibility are supplied then\nonly the primal is used when this option is turned on.", "value": "12", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_LINE_LENGTH", "name": "opf_write_line_length", "brief": "Aim to keep lines in OPF files not much longer than this.", "value": "100", "default": "80", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "OPF_WRITE_HINTS", "name": "opf_write_hints", "brief": "Write a hint section with problem dimensions in the beginning of an OPF file.", "value": "99", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_PARAMETERS", "name": "opf_write_parameters", "brief": "Write a parameter section in an OPF file.", "value": "101", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_PROBLEM", "name": "opf_write_problem", "brief": "Write objective, constraints, bounds etc. to an OPF file.", "value": "102", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_HEADER", "name": "opf_write_header", "brief": "Write a text header with date and MOSEK version in an OPF file.", "desc": "Write a text header with date and |mosek| version in an OPF file.", "value": "98", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOLUTIONS", "name": "opf_write_solutions", "brief": "Enable inclusion of solutions in the OPF files.", "value": "106", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_BAS", "name": "opf_write_sol_bas", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and a basic solution is defined, include the basic solution in OPF files.", "value": "103", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_ITG", "name": "opf_write_sol_itg", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an integer solution is defined, write the integer solution in OPF files.", "value": "104", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "OPF_WRITE_SOL_ITR", "name": "opf_write_sol_itr", "brief": "Controls what is written to the OPF files.", "desc": "If :msk:iparam:`opf_write_solutions` is :msk:const:`onoffkey.on` and an interior solution is defined, write the interior  solution in OPF files.", "value": "105", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_TRANSFORM", "name": "ptf_write_transform", "brief": "Controls if simple transformation are done when writing PTF files.", "desc": "If :msk:iparam:`ptf_write_transform` is\n:msk:const:`onoffkey.on`, constraint blocks with\nidentifiable conic slacks are transformed into conic\nconstraints and the slacks are eliminated.", "value": "123", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_SOLUTIONS", "name": "ptf_write_solutions", "brief": "Controls whether solution section is written in PTF files.", "desc": "If :msk:iparam:`ptf_write_solutions` is\n:msk:const:`onoffkey.on`, the solution section is\nwritten if any solutions are available, otherwise\nsolution section is not written even if solutions\nare available.", "value": "122", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PTF_WRITE_PARAMETERS", "name": "ptf_write_parameters", "brief": "Controls whether parameters section is written in PTF files.", "desc": "If :msk:iparam:`ptf_write_parameters` is\n:msk:const:`onoffkey.on`, the parameters section is\nwritten.", "value": "121", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRIMAL_REPAIR_OPTIMIZER", "name": "primal_repair_optimizer", "brief": "Controls which optimizer that is used to find the optimal repair.", "value": "120", "default": "FREE", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "MIO_ROOT_REPEAT_PRESOLVE_LEVEL", "name": "mio_root_repeat_presolve_level", "brief": "Controls whether presolve can be repeated at root node.", "desc": "Controls whether presolve can be repeated at root node.\n\n* :math:`-1`. The optimizer chooses whether presolve is repeated\n* :math:`0`. Never repeat presolve\n* :math:`1`. Always repeat presolve", "value": "90", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "1"}}, {"caml-name": "MIO_CUT_CMIR", "name": "mio_cut_cmir", "brief": "Controls whether mixed integer rounding cuts should be generated.", "value": "62", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_CLIQUE", "name": "mio_cut_clique", "brief": "Controls whether clique cuts should be generated.", "value": "61", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_IMPLIED_BOUND", "name": "mio_cut_implied_bound", "brief": "Controls whether implied bound cuts should be generated.", "value": "64", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_KNAPSACK_COVER", "name": "mio_cut_knapsack_cover", "brief": "Controls whether knapsack cover cuts should be generated.", "value": "65", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_GMI", "name": "mio_cut_gmi", "brief": "Controls whether GMI cuts should be generated.", "value": "63", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_CUT_LIPRO", "name": "mio_cut_lipro", "brief": "Controls whether lift-and-project cuts should be generated.", "value": "66", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SENSITIVITY_TYPE", "name": "sensitivity_type", "brief": "Controls which type of sensitivity analysis is to be performed.", "value": "133", "default": "BASIS", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "sensitivitytype"]}}, {"caml-name": "MIO_CONSTRUCT_SOL", "name": "mio_construct_sol", "brief": "Controls if an initial mixed integer solution should be constructed from the values of the integer variables.", "desc": "If set to :msk:const:`onoffkey.on` and all integer variables have been given a\nvalue for which a feasible mixed integer solution exists, then |mosek|\ngenerates an initial solution to the mixed integer problem by fixing all integer\nvalues and solving the remaining problem.", "value": "60", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "PRESOLVE_LINDEP_REL_WORK_TRH", "name": "presolve_lindep_rel_work_trh", "brief": "Controls linear dependency check in presolve.", "desc": "Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.", "value": "115", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "PRESOLVE_LINDEP_ABS_WORK_TRH", "name": "presolve_lindep_abs_work_trh", "brief": "Controls linear dependency check in presolve.", "desc": "Controls linear dependency check in presolve. The linear dependency check is potentially computationally expensive.", "value": "113", "default": "100", "references": [], "status": "api", "valuescomment": null, "member-of": ["presolve-param"], "bounds": {"lower": "-inf", "upper": "+inf"}}, {"caml-name": "SENSITIVITY_ALL", "name": "sensitivity_all", "brief": "Controls sensitivity report behavior.", "desc": ".. msk_only:: not optimizer\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If set to :msk:const:`onoffkey.on`, then :msk:func:`task.sensitivityreport` analyzes all\n   bounds and variables instead of reading a specification from the file.", "value": "131", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "LOG_FEAS_REPAIR", "name": "log_feas_repair", "brief": "Controls the amount of output printed when performing feasibility repair. A value higher than one means extensive logging.", "value": "40", "default": "1", "references": [], "status": "api", "valuescomment": null, "member-of": ["info-param", "log-param"], "bounds": {"lower": "0", "upper": "+inf"}}, {"caml-name": "CACHE_LICENSE", "name": "cache_license", "brief": "Control license caching.", "desc": "Specifies if the license is kept checked out for the\nlifetime of the |mosek| environment/model/process (:msk:const:`onoffkey.on`) or\nreturned to the server immediately after the\noptimization (:msk:const:`onoffkey.off`).\n\n.. msk_only:: optimizer\n\n   By default the license is checked out for the lifetime of the |mosek| environment by the first call to :msk:func:`task.optimize`.\n\n.. msk_only:: fusion\n\n   By default the license is checked out for the lifetime of the process by the first call to :msk:func:`model.solve`.\n\n.. msk_only:: matlab or rmosek\n\n   By default the license is checked out for the lifetime of the session at the start of first optimization.\n\nCheck-in and check-out of licenses have an\noverhead. Frequent communication with the license\nserver should be avoided.", "value": "9", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["lic-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "INTPNT_REGULARIZATION_USE", "name": "intpnt_regularization_use", "brief": "Controls whether regularization is allowed.", "value": "25", "default": "ON", "references": [], "status": "api", "valuescomment": null, "member-of": ["intpnt-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SIM_SOLVE_FORM", "name": "sim_solve_form", "brief": "Controls whether the primal or the dual problem is solved by the primal-/dual-simplex optimizer.", "value": "157", "default": "FREE", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "solveform"]}}, {"caml-name": "SIM_SWITCH_OPTIMIZER", "name": "sim_switch_optimizer", "brief": "Controls the simplex behavior.", "desc": "The simplex optimizer sometimes chooses to solve the dual problem instead of the primal problem.\nThis implies that if you have chosen to use the dual simplex optimizer and the problem is dualized,\nthen it actually makes sense to use the primal simplex optimizer instead. If this parameter is on\nand the problem is dualized and furthermore the simplex optimizer is chosen to be the primal (dual) one,\nthen it is switched to the dual (primal).", "value": "159", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "WRITE_IGNORE_INCOMPATIBLE_ITEMS", "name": "write_ignore_incompatible_items", "brief": "Controls if the writer ignores incompatible problem items when writing files.", "value": "174", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "AUTO_SORT_A_BEFORE_OPT", "name": "auto_sort_a_before_opt", "brief": "Controls whether the elements in each column of A are sorted before an optimization is performed.", "desc": "Controls whether the elements in each column of :math:`A` are sorted before an optimization is performed.\nThis is not required but makes the optimization more deterministic.", "value": "2", "default": "OFF", "references": [], "status": "api", "valuescomment": null, "member-of": ["debug-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "SENSITIVITY_OPTIMIZER", "name": "sensitivity_optimizer", "brief": "Controls which optimizer is used for optimal partition sensitivity analysis.", "value": "132", "default": "FREE_SIMPLEX", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["solver-param", "simplex-param"], "valuesfrom": {"from": ["mosek", "optimizertype"]}}, {"caml-name": "WRITE_XML_MODE", "name": "write_xml_mode", "brief": "Controls if linear coefficients should be written by row or column when writing in the XML file format.", "value": "189", "default": "ROW", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["dataio-param"], "valuesfrom": {"from": ["mosek", "xmlwriteroutputtype"]}}, {"caml-name": "ANA_SOL_BASIS", "name": "ana_sol_basis", "brief": "Controls whether the basis matrix is analyzed in solution analyzer.", "value": "0", "default": "ON", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["ana-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "ANA_SOL_PRINT_VIOLATED", "name": "ana_sol_print_violated", "brief": "Controls whether a list of violated constraints is printed.", "desc": "A parameter of the problem analyzer. Controls whether a list of violated constraints is printed. All constraints violated by more than the value set by the parameter :msk:dparam:`ana_sol_infeas_tol` will be printed.", "value": "1", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["ana-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "BASIS_SOLVE_USE_PLUS_ONE", "name": "basis_solve_use_plus_one", "brief": "Controls the sign of the columns in the basis matrix corresponding to slack variables.", "desc": "If a slack variable is in the basis, then the corresponding column in the basis is a unit vector\nwith -1 in the right position. However, if this parameter is set to :msk:const:`onoffkey.on`, -1 is replaced by 1.\n\n.. msk_only:: optimizer\n\n   This has significance for the results returned by the :msk:func:`task.solvewithbasis` function.", "value": "4", "default": "OFF", "references": [], "status": "obscure", "valuescomment": null, "member-of": ["simplex-param"], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "COMPRESS_STATFILE", "name": "compress_statfile", "brief": "Control compression of stat files.", "value": "10", "default": "on", "references": [], "status": "obscure", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "MIO_RINS_MAX_NODES", "name": "mio_rins_max_nodes", "brief": "Maximum number of nodes in each call to RINS.", "desc": "Controls the maximum number of nodes allowed in each call to the RINS heuristic. The default value of -1\nmeans that the value is determined automatically. A value of zero turns off the heuristic.", "value": "88", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "+inf"}}, {"caml-name": "MIO_FEASPUMP_LEVEL", "name": "mio_feaspump_level", "brief": "Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.", "desc": "Controls the way the Feasibility Pump heuristic is employed by the mixed-integer optimizer.\n\n* :math:`-1`. The optimizer chooses how the Feasibility Pump is used\n* :math:`0`. The Feasibility Pump is disabled\n* :math:`1`. The Feasibility Pump is enabled with an effort to improve solution quality\n* :math:`2`. The Feasibility Pump is enabled with an effort to reach feasibility early", "value": "70", "default": "-1", "references": [], "status": "api", "valuescomment": null, "member-of": ["mio-param"], "bounds": {"lower": "-1", "upper": "2"}}, {"caml-name": "NG", "name": "ng", "brief": "Not in use", "desc": "Not in use.", "value": "96", "default": "off", "references": [], "status": "api", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "onoffkey"]}}, {"caml-name": "REMOTE_USE_COMPRESSION", "name": "remote_use_compression", "brief": "Use compression when sending data to an optimization server", "desc": "Use compression when sending data to an optimization server.", "value": "129", "default": "zstd", "references": [], "status": "api", "valuescomment": null, "member-of": [], "valuesfrom": {"from": ["mosek", "compresstype"]}}], "type": "int"}, "sparam": {"name": "sparam", "brief": "String parameters", "desc": "The enumeration type containing all string parameters.", "is-enumerable": true, "prefix": "SPAR_", "value-type": "int", "values-asgn": "implicit", "api-class": "api", "members": [{"caml-name": "DATA_FILE_NAME", "name": "data_file_name", "brief": "Data are read and written to this file.", "value": "1", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_READ_FILE_NAME", "name": "param_read_file_name", "brief": "Modifications to the parameter database is read from this file.", "value": "7", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_WRITE_FILE_NAME", "name": "param_write_file_name", "brief": "The parameter database is written to this file.", "value": "8", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "PARAM_COMMENT_SIGN", "name": "param_comment_sign", "brief": "Solution file comment character.", "desc": "Only the first character in this string is\nused. It is considered as a start of comment sign\nin the |mosek| parameter file. Spaces are ignored\nin the string.", "value": "6", "default": "%%", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "DEBUG_FILE_NAME", "name": "debug_file_name", "brief": "MOSEK debug file.", "desc": "|mosek| debug file.", "value": "2", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param"]}, {"caml-name": "BAS_SOL_FILE_NAME", "name": "bas_sol_file_name", "brief": "Name of the bas solution file.", "desc": "Name of the ``bas`` solution file.", "value": "0", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "ITR_SOL_FILE_NAME", "name": "itr_sol_file_name", "brief": "Name of the itr solution file.", "desc": "Name of the ``itr`` solution file.", "value": "4", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "INT_SOL_FILE_NAME", "name": "int_sol_file_name", "brief": "Name of the int solution file.", "desc": "Name of the ``int`` solution file.", "value": "3", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XC_LOW", "name": "sol_filter_xc_low", "brief": "Solution file filter.", "desc": "A filter used to determine which constraints should be listed in the solution file. A value of :math:`0.5` means that all constraints having  ``xc[i]>0.5`` should be listed, whereas ``+0.5`` means that all constraints having ``xc[i]>=blc[i]+0.5`` should be listed. An empty filter means that no filter is applied.", "value": "18", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XC_UPR", "name": "sol_filter_xc_upr", "brief": "Solution file filter.", "desc": "A filter  used to determine which constraints should be listed in the solution file. A value of ``0.5`` means that all constraints having ``xc[i]<0.5`` should be listed, whereas ``-0.5`` means all constraints having ``xc[i]<=buc[i]-0.5`` should be listed. An empty filter means that no filter is applied.", "value": "19", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XX_LOW", "name": "sol_filter_xx_low", "brief": "Solution file filter.", "desc": "A filter  used to determine which variables should be listed in the solution file. A value of \"0.5\" means that all constraints having ``xx[j]>=0.5`` should be listed, whereas \"+0.5\" means that all constraints having ``xx[j]>=blx[j]+0.5`` should be listed. An empty filter means no filter is applied.", "value": "20", "default": "", "references": [], "status": "api", "valuescomment": "Any valid filter.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "SOL_FILTER_XX_UPR", "name": "sol_filter_xx_upr", "brief": "Solution file filter.", "desc": "A filter  used to determine which variables should be listed in the solution file. A value of \"0.5\" means that all constraints having ``xx[j]<0.5`` should be printed, whereas \"-0.5\" means all constraints having ``xx[j]<=bux[j]-0.5`` should be listed. An empty filter means no filter is applied.", "value": "21", "default": "", "references": [], "status": "api", "valuescomment": "Any valid file name.", "member-of": ["dataio-param", "solio-param"]}, {"caml-name": "READ_MPS_OBJ_NAME", "name": "read_mps_obj_name", "brief": "Objective name in the MPS file.", "desc": "Name of the free constraint used as objective function.\nAn empty name means that the first constraint is used as objective function.", "value": "10", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_RAN_NAME", "name": "read_mps_ran_name", "brief": "Name of the RANGE vector  used. An empty name means that the first RANGE vector is used.", "value": "11", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_RHS_NAME", "name": "read_mps_rhs_name", "brief": "Name of the RHS used. An empty name means that the first RHS vector is used.", "value": "12", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "READ_MPS_BOU_NAME", "name": "read_mps_bou_name", "brief": "Name of the BOUNDS vector used. An empty name means that the first BOUNDS vector is used.", "value": "9", "default": "", "references": [], "status": "api", "valuescomment": "Any valid MPS name.", "member-of": ["dataio-param"]}, {"caml-name": "STAT_NAME", "name": "stat_name", "brief": "Name used when writing the statistics file.", "value": "23", "default": "", "references": [], "status": "api", "valuescomment": "Any valid XML string.", "member-of": ["dataio-param"]}, {"caml-name": "STAT_KEY", "name": "stat_key", "brief": "Key used when writing the summary file.", "value": "22", "default": "", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "WRITE_LP_GEN_VAR_NAME", "name": "write_lp_gen_var_name", "brief": "Added variable names in the LP files.", "desc": "Sometimes when an LP file is written additional variables must be inserted.\nThey will have the prefix denoted by this parameter.", "value": "24", "default": "xmskgen", "references": [], "status": "api", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "SENSITIVITY_RES_FILE_NAME", "name": "sensitivity_res_file_name", "brief": "Name of the sensitivity report output file.", "desc": ".. msk_only:: cmdtools\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If this is a nonempty string, then :msk:func:`task.sensitivityreport` writes results to this file.", "value": "17", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "SENSITIVITY_FILE_NAME", "name": "sensitivity_file_name", "brief": "Sensitivity report file name.", "desc": ".. msk_only:: cmdtools\n\n   Not applicable.\n\n.. msk_only:: optimizer\n\n   If defined :msk:func:`task.sensitivityreport` reads this file as\n   a sensitivity analysis data file specifying the type of analysis to be done.\n\n.. msk_only:: (not optimizer) and (not cmdtools)\n\n   If defined, |mosek| reads this file as\n   a sensitivity analysis data file specifying the type of analysis to be done.", "value": "16", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "MIO_DEBUG_STRING", "name": "mio_debug_string", "brief": "For internal debugging purposes.", "value": "5", "default": "", "references": [], "status": "obscure", "valuescomment": "Any valid string.", "member-of": ["dataio-param"]}, {"caml-name": "REMOTE_OPTSERVER_HOST", "name": "remote_optserver_host", "brief": "URL of the remote optimization server.", "desc": "URL of the remote optimization server in the format ``(http|https)://server:port``. If set, all subsequent calls to any |mosek| function that involves synchronous optimization will be sent to the specified |optserver| instead of being executed locally. Passing empty string deactivates this redirection.", "value": "13", "default": "", "references": [], "status": "api", "valuescomment": "Any valid URL.", "member-of": ["system-param"]}, {"caml-name": "REMOTE_TLS_CERT_PATH", "name": "remote_tls_cert_path", "brief": "Path to known server certificates in PEM format", "desc": "Path to known server certificates in PEM format.", "value": "15", "default": "", "references": [], "status": "api", "valuescomment": "Any valid path.", "member-of": ["system-param"]}, {"caml-name": "REMOTE_TLS_CERT", "name": "remote_tls_cert", "brief": "Known server certificates in PEM format", "desc": "List of known server certificates in PEM format.", "value": "14", "default": "", "references": [], "status": "api", "valuescomment": "PEM files separated by new-lines.", "member-of": ["system-param"]}], "type": "string"}}, "rescodes": {"rescode": {"name": "rescode", "brief": "Response codes", "desc": "The enumeration type containing all response codes.", "is-enumerable": true, "prefix": "RES_", "value-type": "int", "values-asgn": "unique", "api-class": "api", "members": [{"caml-name": "OK", "name": "ok", "brief": "No error occurred.", "value": "0", "msg": "No error occurred.", "args": {}}, {"caml-name": "WRN_OPEN_PARAM_FILE", "name": "wrn_open_param_file", "brief": "The parameter file could not be opened.", "value": "50", "msg": "Could not open the parameter file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_LARGE_BOUND", "name": "wrn_large_bound", "brief": "A numerically large bound value is specified.", "value": "51", "msg": "A numerically large bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_LO_BOUND", "name": "wrn_large_lo_bound", "brief": "A numerically large lower bound value is specified.", "value": "52", "msg": "A numerically large lower bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_UP_BOUND", "name": "wrn_large_up_bound", "brief": "A numerically large upper bound value is specified.", "value": "53", "msg": "A numerically large upper bound value %{arg0} is specified for %{arg1} '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "WRN_LARGE_CON_FX", "name": "wrn_large_con_fx", "brief": "A equality constraint is fixed to numerically large value.", "desc": "An equality constraint is fixed to a numerically large value. This can cause numerical problems.", "value": "54", "msg": "The equality constraint '%{arg0}' (%{arg1}) is fixed to numerically large value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "e", ["w=8", "j=r", "p=1"]]}}, {"caml-name": "WRN_LARGE_CJ", "name": "wrn_large_cj", "brief": "A numerically large value is specified for one element in c.", "desc": "A numerically large value is specified for one :math:`c_{j}`.", "value": "57", "msg": "A large value of %{arg0} has been specified in c for variable '%{arg1}' (%{arg2}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "WRN_LARGE_AIJ", "name": "wrn_large_aij", "brief": "A numerically large value is specified for an element in A.", "desc": "A numerically large value is specified for an :math:`a_{i,j}` element in :math:`A`.\nThe parameter :msk:dparam:`data_tol_aij_large` controls when an :math:`a_{i,j}` is considered large.", "value": "62", "msg": "The A matrix contains a large value of %{arg0} in constraint '%{arg1}' (%{arg2}) at variable '%{arg3}' (%{arg4}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "WRN_ZERO_AIJ", "name": "wrn_zero_aij", "brief": "One or more zero elements are specified in A.", "value": "63", "msg": "%{arg0} zero element(s) in A are specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_NAME_MAX_LEN", "name": "wrn_name_max_len", "brief": "A name is longer than the buffer that is supposed to hold it.", "value": "65", "msg": "A name of length %{arg0} is longer than the buffer of length %{arg1} that is supposed to hold it.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "WRN_SPAR_MAX_LEN", "name": "wrn_spar_max_len", "brief": "A value for a string parameter is longer than the buffer that is supposed to hold it.", "value": "66", "msg": "A value for a string parameter is longer than the buffer that is supposed to hold it.", "args": {}}, {"caml-name": "WRN_MPS_SPLIT_RHS_VECTOR", "name": "wrn_mps_split_rhs_vector", "brief": "An RHS vector is split into several nonadjacent parts.", "desc": "An RHS vector is split into several nonadjacent parts in an MPS file.", "value": "70", "msg": "The RHS vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MPS_SPLIT_RAN_VECTOR", "name": "wrn_mps_split_ran_vector", "brief": "A RANGE vector is split into several nonadjacent parts in an MPS file.", "value": "71", "msg": "The RANGE vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MPS_SPLIT_BOU_VECTOR", "name": "wrn_mps_split_bou_vector", "brief": "A BOUNDS vector is split into several nonadjacent parts in an MPS file.", "value": "72", "msg": "The BOUNDS vector '%{arg0}' is split into several nonadjacent parts.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_LP_OLD_QUAD_FORMAT", "name": "wrn_lp_old_quad_format", "brief": "Missing '/2' after quadratic expressions in bound or objective.", "value": "80", "msg": "Missing '/2' after quadratic expressions in bound or objective.", "args": {}}, {"caml-name": "WRN_LP_DROP_VARIABLE", "name": "wrn_lp_drop_variable", "brief": "Ignore a variable because the variable was not previously defined.", "desc": "Ignored a variable because the variable was not previously defined.\nUsually this implies that a variable appears in the bound section but not in the objective or the constraints.", "value": "85", "msg": "The variable '%{arg0}' is ignored because the variable was not previously defined.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_NZ_IN_UPR_TRI", "name": "wrn_nz_in_upr_tri", "brief": "Non-zero elements specified in the upper triangle of a matrix were ignored.", "value": "200", "msg": "Non-zero elements in the upper triangle of variable '%{arg0}' are ignored.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_DROPPED_NZ_QOBJ", "name": "wrn_dropped_nz_qobj", "brief": "One or more non-zero elements were dropped in the Q matrix in the objective.", "value": "201", "msg": "'%{arg0}' non-zero element(s) are dropped in the Q matrix in the objective.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_IGNORE_INTEGER", "name": "wrn_ignore_integer", "brief": "Ignored integer constraints.", "value": "250", "msg": "Ignored integer constraints.", "args": {}}, {"caml-name": "WRN_NO_GLOBAL_OPTIMIZER", "name": "wrn_no_global_optimizer", "brief": "No global optimizer is available.", "value": "251", "msg": "No global optimizer is available (%{arg0}).", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_MIO_INFEASIBLE_FINAL", "name": "wrn_mio_infeasible_final", "brief": "The final mixed-integer problem with all the integer variables fixed at their optimal values is infeasible.", "value": "270", "msg": "The '%{arg0}' solution reports that final problem with all the integer variables fixed is infeasible while an integer solution has been found.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_SOL_FILTER", "name": "wrn_sol_filter", "brief": "Invalid solution filter is specified.", "value": "300", "msg": "'%{arg0}' is an invalid solution filter is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_UNDEF_SOL_FILE_NAME", "name": "wrn_undef_sol_file_name", "brief": "Undefined name occurred in a solution.", "value": "350", "msg": "'%{arg0}' is an undefined %{arg1} name.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_SOL_FILE_IGNORED_CON", "name": "wrn_sol_file_ignored_con", "brief": "One or more lines in the constraint section were ignored when reading a solution file.", "value": "351", "msg": "%{arg0} lines in the constraint section were ignored when reading a solution file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_SOL_FILE_IGNORED_VAR", "name": "wrn_sol_file_ignored_var", "brief": "One or more lines in the variable section were ignored when reading a solution file.", "value": "352", "msg": "%{arg0} lines in the variable section were ignored when reading a solution file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "WRN_TOO_FEW_BASIS_VARS", "name": "wrn_too_few_basis_vars", "brief": "An incomplete basis is specified.", "desc": "An incomplete basis has been specified. Too few basis variables are specified.", "value": "400", "msg": "%{arg1} basis variables are expected but only %{arg0} basis variables are specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "WRN_TOO_MANY_BASIS_VARS", "name": "wrn_too_many_basis_vars", "brief": "A basis with too many variables is specified.", "desc": "A basis with too many variables has been specified.", "value": "405", "msg": "%{arg0} basis variables are specified but %{arg1} are expected.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "WRN_LICENSE_EXPIRE", "name": "wrn_license_expire", "brief": "The license expires.", "value": "500", "msg": "The license expires in %{arg0} days.", "args": {"arg0": ["arg0", "I", []]}}, {"caml-name": "WRN_LICENSE_SERVER", "name": "wrn_license_server", "brief": "The license server is not responding.", "value": "501", "msg": "The license server is not responding.", "args": {}}, {"caml-name": "WRN_EMPTY_NAME", "name": "wrn_empty_name", "brief": "A variable or constraint name is empty. The output file may be invalid.", "value": "502", "msg": "A variable or constraint name is empty. The output file may be invalid.", "args": {}}, {"caml-name": "WRN_USING_GENERIC_NAMES", "name": "wrn_using_generic_names", "brief": "Generic names are used because a name is invalid for requested format.", "desc": "Generic names are used because a name invalid. For instance when writing an LP file the names must not contain blanks or start with a digit.\nAlso remeber to give the objective function a name.", "value": "503", "msg": "Generic names are used because a name is invalid.", "args": {}}, {"caml-name": "WRN_INVALID_MPS_NAME", "name": "wrn_invalid_mps_name", "brief": "A name e.g. a row name is not a valid MPS name.", "value": "504", "msg": "A name e.g. a row name is not a valid MPS name.", "args": {}}, {"caml-name": "WRN_INVALID_MPS_OBJ_NAME", "name": "wrn_invalid_mps_obj_name", "brief": "The objective name is not a valid MPS name.", "value": "505", "msg": "The objective name is not a valid MPS name.", "args": {}}, {"caml-name": "WRN_LICENSE_FEATURE_EXPIRE", "name": "wrn_license_feature_expire", "brief": "The license expires.", "value": "509", "msg": "The license feature '%{arg0}' expires in %{arg1} days.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "I", []]}}, {"caml-name": "WRN_PARAM_NAME_DOU", "name": "wrn_param_name_dou", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a double parameter.", "value": "510", "msg": "The parameter name '%{arg0}' is not recognized as a double parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_NAME_INT", "name": "wrn_param_name_int", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a integer parameter.", "value": "511", "msg": "The parameter name '%{arg0}' is not recognized as an integer parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_NAME_STR", "name": "wrn_param_name_str", "brief": "Parameter name not recognized.", "desc": "The parameter name is not recognized as a string parameter.", "value": "512", "msg": "The parameter name '%{arg0}' is not recognized as a string parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_PARAM_STR_VALUE", "name": "wrn_param_str_value", "brief": "A parameter value is not correct.", "desc": "The string is not recognized as a symbolic value for the parameter.", "value": "515", "msg": "The value '%{arg0}' is not valid for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_PARAM_IGNORED_CMIO", "name": "wrn_param_ignored_cmio", "brief": "A parameter was ignored by the conic mixed integer optimizer.", "value": "516", "msg": "The parameter '%{arg0}' was ignored by the conic mixed integer optimizer.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "WRN_ZEROS_IN_SPARSE_ROW", "name": "wrn_zeros_in_sparse_row", "brief": "One or more (near) zero elements are specified in a sparse row of a matrix.", "desc": "One or more (near) zero elements are specified in a sparse row of a matrix. Since, it\nis redundant to specify zero elements then it may indicate an error.", "value": "705", "msg": "%{arg0} (nearly) zero elements are specified in sparse row '%{arg1}'(%{arg2}) of matrix '%{arg3}'.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "WRN_ZEROS_IN_SPARSE_COL", "name": "wrn_zeros_in_sparse_col", "brief": "One or more (near) zero elements are specified in a sparse column of a matrix.", "desc": "One or more (near) zero elements are specified in a sparse column of a matrix.\nIt is redundant to specify zero elements. Hence, it may indicate an error.", "value": "710", "msg": "#%{arg0} (nearly) zero elements are specified in sparse col '%{arg1}' (%{arg2}) of matrix '%{arg3}'.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK", "name": "wrn_incomplete_linear_dependency_check", "brief": "The linear dependency check(s) is incomplete.", "desc": "The linear dependency check(s) is incomplete. Normally\nthis is not an important warning unless the optimization\nproblem has been formulated with linear\ndependencies. Linear dependencies may prevent |mosek| from\nsolving the problem.", "value": "800", "msg": "The linear dependency check(s) is incomplete. Either it was too costly or numerical problems prevented it.", "args": {}}, {"caml-name": "WRN_ELIMINATOR_SPACE", "name": "wrn_eliminator_space", "brief": "The eliminator is skipped at least once due to lack of space.", "value": "801", "msg": "The eliminator is skipped at least once due to lack of space.", "args": {}}, {"caml-name": "WRN_PRESOLVE_OUTOFSPACE", "name": "wrn_presolve_outofspace", "brief": "The presolve is incomplete due to lack of space.", "value": "802", "msg": "The presolve is incomplete due to lack of space.", "args": {}}, {"caml-name": "WRN_PRESOLVE_PRIMAL_PERTUBATIONS", "name": "wrn_presolve_primal_pertubations", "brief": "The presolve perturbed the bounds of the primal problem. This is an indication that the problem is nearly infeasible.", "value": "803", "msg": "The bounds of the constraints and variables was perturbed. The number of perturbations was %num and the total pertubation was %total.", "args": {"num": ["num", "i", []], "total": ["total", "e", ["p=2"]]}}, {"caml-name": "WRN_WRITE_CHANGED_NAMES", "name": "wrn_write_changed_names", "brief": "Some names were changed because they were invalid for the output file format.", "value": "830", "msg": "Some names were changed because they were invalid for the output file format.", "args": {}}, {"caml-name": "WRN_WRITE_DISCARDED_CFIX", "name": "wrn_write_discarded_cfix", "brief": "The fixed objective term was discarded in the output file.", "desc": "The fixed objective term could not be converted to a variable and was discarded in the output file.", "value": "831", "msg": "The fixed objective term was discarded in the output file.", "args": {}}, {"caml-name": "WRN_DUPLICATE_CONSTRAINT_NAMES", "name": "wrn_duplicate_constraint_names", "brief": "Two constraint names are identical.", "value": "850", "msg": "Constraint number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_VARIABLE_NAMES", "name": "wrn_duplicate_variable_names", "brief": "Two variable names are identical.", "value": "851", "msg": "Variable %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_BARVARIABLE_NAMES", "name": "wrn_duplicate_barvariable_names", "brief": "Two barvariable names are identical.", "value": "852", "msg": "Barvariable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_DUPLICATE_CONE_NAMES", "name": "wrn_duplicate_cone_names", "brief": "Two cone names are identical.", "value": "853", "msg": "Cone number %i and %j is given the same name '%name'.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_WRITE_LP_INVALID_VAR_NAMES", "name": "wrn_write_lp_invalid_var_names", "brief": "LP file will be written with generic variable names.", "value": "854", "msg": "Variable name '%name' (%i) is not a valid LP name: Writing generic variable names.", "args": {"name": ["name", "s", []], "i": ["i", "i", []]}}, {"caml-name": "WRN_WRITE_LP_DUPLICATE_VAR_NAMES", "name": "wrn_write_lp_duplicate_var_names", "brief": "LP file will be written with generic variable names.", "value": "855", "msg": "Variable %i and %j have the same name ('%name'): Writing generic variable names.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_WRITE_LP_INVALID_CON_NAMES", "name": "wrn_write_lp_invalid_con_names", "brief": "LP file will be written with generic constraint names.", "value": "856", "msg": "Constraint name '%name' (%i) is not a valid LP name: Writing generic constraint names.", "args": {"name": ["name", "s", []], "i": ["i", "i", []]}}, {"caml-name": "WRN_WRITE_LP_DUPLICATE_CON_NAMES", "name": "wrn_write_lp_duplicate_con_names", "brief": "LP file will be written with generic constraint names.", "value": "857", "msg": "Constraint %i and %j have the same name ('%name'): Writing generic constraint names.", "args": {"i": ["i", "i", []], "j": ["j", "i", []], "name": ["name", "s", []]}}, {"caml-name": "WRN_ANA_LARGE_BOUNDS", "name": "wrn_ana_large_bounds", "brief": "Warn against very large bounds.", "desc": "This warning is issued by the problem analyzer, if one or more constraint or variable bounds are very large.\nOne should consider omitting these bounds entirely by setting them to +inf or -inf.", "value": "900", "msg": "The problem analyzer found %{arg0} large %{arg1} bound%{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "WRN_ANA_C_ZERO", "name": "wrn_ana_c_zero", "brief": "Warn against all objective coefficients being zero.", "desc": "This warning is issued by the problem analyzer, if the coefficients in the linear part of the objective are all zero.", "value": "901", "msg": "The problem analyzer found all objective coefficients to be zero.", "args": {}}, {"caml-name": "WRN_ANA_EMPTY_COLS", "name": "wrn_ana_empty_cols", "brief": "Warn against empty columns.", "desc": "This warning is issued by the problem analyzer, if columns, in which all coefficients are zero, are found.", "value": "902", "msg": "The problem analyzer found %{arg0} empty column%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "WRN_ANA_CLOSE_BOUNDS", "name": "wrn_ana_close_bounds", "brief": "Warn against close bounds.", "desc": "This warning is issued by problem analyzer, if ranged\nconstraints or variables with very close upper and lower\nbounds are detected.  One should consider treating such\nconstraints as equalities and such variables as\nconstants.", "value": "903", "msg": "The problem analyzer found %{arg0} %{arg1} with upper and lower bounds differing less than %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "e", []]}}, {"caml-name": "WRN_ANA_ALMOST_INT_BOUNDS", "name": "wrn_ana_almost_int_bounds", "brief": "Warn against almost integral bounds.", "desc": "This warning is issued by the problem analyzer if a\nconstraint is bound nearly integral.", "value": "904", "msg": "The problem analyzer found %{arg0} constraint bounds differing less than %{arg1} from an integer.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "e", []]}}, {"caml-name": "WRN_NO_INFEASIBILITY_REPORT_WHEN_MATRIX_VARIABLES", "name": "wrn_no_infeasibility_report_when_matrix_variables", "brief": "An infeasibility report is not available when the problem contains matrix variables.", "value": "930", "msg": "An infeasibility report is not available when the problem contains matrix variables.", "args": {}}, {"caml-name": "WRN_NO_DUALIZER", "name": "wrn_no_dualizer", "brief": "No automatic dualizer is available for the specified problem.", "desc": "No automatic dualizer is available for the specified problem. The primal problem is solved.", "value": "950", "msg": "No automatic dualizer is available for the specified problem.", "args": {}}, {"caml-name": "WRN_SYM_MAT_LARGE", "name": "wrn_sym_mat_large", "brief": "A numerically large value is specified for an element in E.", "desc": "A numerically large value is specified for an :math:`e_{i,j}` element in :math:`E`.\nThe parameter :msk:dparam:`data_sym_mat_tol_large` controls when an :math:`e_{i,j}` is considered large.", "value": "960", "msg": "E[%{arg1},%{arg2}] = %{arg0} is large in absolute size.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "WRN_MODIFIED_DOUBLE_PARAMETER", "name": "wrn_modified_double_parameter", "brief": "A double parameter related to solver tolerances has a non-default value.", "value": "970", "msg": "The double parameter %{arg0} has value %{arg1} instead of default value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "e", ["j=r", "p=1"]], "arg2": ["arg2", "e", ["j=r", "p=1"]]}}, {"caml-name": "WRN_LARGE_FIJ", "name": "wrn_large_fij", "brief": "A numerically large value is specified for an element in F.", "desc": "A numerically large value is specified for an :math:`f_{i,j}` element in :math:`F`.\nThe parameter :msk:dparam:`data_tol_aij_large` controls when an :math:`f_{i,j}` is considered large.", "value": "980", "msg": "The F matrix contains a large value of %{arg0} in row %{arg1} and column %{arg2}.", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "l", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_LICENSE", "name": "err_license", "brief": "Invalid license.", "value": "1000", "msg": "Invalid license.", "args": {}}, {"caml-name": "ERR_LICENSE_EXPIRED", "name": "err_license_expired", "brief": "The license has expired.", "value": "1001", "msg": "The license has expired.", "args": {}}, {"caml-name": "ERR_LICENSE_VERSION", "name": "err_license_version", "brief": "Invalid license version.", "desc": "The license is valid for another version of |mosek|.", "value": "1002", "msg": "Feature %{arg0} version %{arg1} is not supported by the license file.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_LICENSE_OLD_SERVER_VERSION", "name": "err_license_old_server_version", "brief": "The license server version is too old.", "desc": "The version of the FlexLM license server is too old. You should upgrade the license server to one matching this version of |mosek|. It will support this and all older versions of |mosek|.\n\nThis error can appear if the client was updated to a new version which includes an upgrade of the licensing module, making it incompatible with a much older license server.", "value": "1003", "msg": "The license server version is too old to support this client. Upgrade the license server binaries using the latest Mosek distribution to fully support this and older Mosek versions.", "args": {}}, {"caml-name": "ERR_SIZE_LICENSE", "name": "err_size_license", "brief": "The problem is bigger than the license.", "value": "1005", "msg": "The problem is bigger than the license.", "args": {}}, {"caml-name": "ERR_PROB_LICENSE", "name": "err_prob_license", "brief": "The software is not licensed to solve the problem.", "value": "1006", "msg": "The software is not licensed to solve the problem.", "args": {}}, {"caml-name": "ERR_FILE_LICENSE", "name": "err_file_license", "brief": "Invalid license file.", "value": "1007", "msg": "Invalid license file.", "args": {}}, {"caml-name": "ERR_MISSING_LICENSE_FILE", "name": "err_missing_license_file", "brief": "A license cannot be located.", "desc": "|mosek| cannot find license file or a token server. See the |mosek| licensing manual for details.", "value": "1008", "msg": "License cannot be located. The default search path is '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_CON", "name": "err_size_license_con", "brief": "The problem has too many constraints.", "desc": "The problem has too many constraints to be solved with the available license.", "value": "1010", "msg": "The problem has %{arg0} constraint(s) but the license allows only %{arg1} constraint(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_VAR", "name": "err_size_license_var", "brief": "The problem has too many variables.", "desc": "The problem has too many variables to be solved with the available license.", "value": "1011", "msg": "The problem has %{arg0} scalar variable(s) but the license allows only %{arg1} scalar variable(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_SIZE_LICENSE_INTVAR", "name": "err_size_license_intvar", "brief": "The problem contains too many integer variables.", "desc": "The problem contains too many integer variables to be solved with the available license.", "value": "1012", "msg": "The problem contains %{arg0} integer variable(s) but the license allows only %{arg1} integer variable(s) for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_OPTIMIZER_LICENSE", "name": "err_optimizer_license", "brief": "The optimizer required is not licensed.", "value": "1013", "msg": "The optimizer required is not licensed.", "args": {}}, {"caml-name": "ERR_FLEXLM", "name": "err_flexlm", "brief": "The license manager reported an error.", "desc": "The |flexlm| license manager reported an error.", "value": "1014", "msg": "The license manager reported '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_SERVER", "name": "err_license_server", "brief": "The license server is not responding.", "value": "1015", "msg": "The license server is not responding.", "args": {}}, {"caml-name": "ERR_LICENSE_MAX", "name": "err_license_max", "brief": "Maximum number of licenses is reached.", "value": "1016", "msg": "Maximum number of licenses is reached for feature '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_MOSEKLM_DAEMON", "name": "err_license_moseklm_daemon", "brief": "The MOSEKLM license manager daemon is not up and running.", "value": "1017", "msg": "The MOSEKLM license manager daemon is not up and running.", "args": {}}, {"caml-name": "ERR_LICENSE_FEATURE", "name": "err_license_feature", "brief": "A requested feature is not available in the license file(s).", "desc": "A requested feature is not available in the license file(s). Most likely due to an incorrect license system setup.", "value": "1018", "msg": "The feature '%{arg0}' is not in license file. Consult the license manager error message.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PLATFORM_NOT_LICENSED", "name": "err_platform_not_licensed", "brief": "A requested license feature is not available for the required platform.", "value": "1019", "msg": "No license feature '%{arg0}' for the required platform is available.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_CANNOT_ALLOCATE", "name": "err_license_cannot_allocate", "brief": "The license system cannot allocate the memory required.", "value": "1020", "msg": "The license system cannot allocate the memory required.", "args": {}}, {"caml-name": "ERR_LICENSE_CANNOT_CONNECT", "name": "err_license_cannot_connect", "brief": "MOSEK cannot connect to the license server.", "desc": "|mosek| cannot connect to the license server.\nMost likely the license server is not up and running.", "value": "1021", "msg": "MOSEK cannot connect to the license server.", "args": {}}, {"caml-name": "ERR_LICENSE_INVALID_HOSTID", "name": "err_license_invalid_hostid", "brief": "The host ID specified in the license file does not match the host ID of the computer.", "value": "1025", "msg": "The host ID specified in the license file does not match the host ID of the computer.", "args": {}}, {"caml-name": "ERR_LICENSE_SERVER_VERSION", "name": "err_license_server_version", "brief": "The version specified in the checkout request is greater than the highest version number the daemon supports.", "value": "1026", "msg": "The version specified in the checkout request is greater than the highest version number the daemon supports. Please upgrade the license server to the same version distributed with the mosek version that your are running.", "args": {}}, {"caml-name": "ERR_LICENSE_NO_SERVER_SUPPORT", "name": "err_license_no_server_support", "brief": "The license server does not support the requested feature.", "desc": "The license server does not support the requested feature.\nPossible reasons for this error include:\n\n* The feature has expired.\n* The feature's start date is later than today's date.\n* The version requested is higher than feature's the highest supported version.\n* A corrupted license file.\n\nTry restarting the license and inspect the license server debug file, usually called ``lmgrd.log``.", "value": "1027", "msg": "The license server does not support the requested feature '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LICENSE_NO_SERVER_LINE", "name": "err_license_no_server_line", "brief": "No SERVER lines in license file.", "desc": "There is no ``SERVER`` line in the license file. All non-zero license count features need at least one ``SERVER`` line.", "value": "1028", "msg": "No SERVER lines in license file.", "args": {}}, {"caml-name": "ERR_OLDER_DLL", "name": "err_older_dll", "brief": "The dynamic link library is older than the specified version.", "value": "1035", "msg": "The dynamic link library version %{arg0}.%{arg1}.%{arg2}.%{arg3} is older than expected version %{arg4}.%{arg5}.%{arg6}.%{arg7}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "i", []], "arg5": ["arg5", "i", []], "arg6": ["arg6", "i", []], "arg7": ["arg7", "i", []]}}, {"caml-name": "ERR_NEWER_DLL", "name": "err_newer_dll", "brief": "The dynamic link library is newer than the specified version.", "value": "1036", "msg": "The dynamic link library version %{arg0}.%{arg1}.%{arg2}.%{arg3} is newer than version %{arg4}.%{arg5}.%{arg6}.%{arg7}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "i", []], "arg5": ["arg5", "i", []], "arg6": ["arg6", "i", []], "arg7": ["arg7", "i", []]}}, {"caml-name": "ERR_LINK_FILE_DLL", "name": "err_link_file_dll", "brief": "A file cannot be linked to a stream in the DLL version.", "value": "1040", "msg": "A file cannot be linked to a stream in the DLL version.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_INIT", "name": "err_thread_mutex_init", "brief": "Could not initialize a mutex.", "value": "1045", "msg": "Could not initialize a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_LOCK", "name": "err_thread_mutex_lock", "brief": "Could not lock a mutex.", "value": "1046", "msg": "Could not lock a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_MUTEX_UNLOCK", "name": "err_thread_mutex_unlock", "brief": "Could not unlock a mutex.", "value": "1047", "msg": "Could not unlock a mutex.", "args": {}}, {"caml-name": "ERR_THREAD_CREATE", "name": "err_thread_create", "brief": "Could not create a thread.", "desc": "Could not create a thread. This error may occur if a large\nnumber of environments are created and not deleted again.\nIn any case it is a good practice to minimize the number of\nenvironments created.", "value": "1048", "msg": "Could not create a thread. System error code: %{arg0}", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_THREAD_COND_INIT", "name": "err_thread_cond_init", "brief": "Could not initialize a condition.", "value": "1049", "msg": "Could not initialize a condition.", "args": {}}, {"caml-name": "ERR_UNKNOWN", "name": "err_unknown", "brief": "Unknown error.", "value": "1050", "msg": "Unknown error.", "args": {}}, {"caml-name": "ERR_SPACE", "name": "err_space", "brief": "Out of space.", "value": "1051", "msg": "A (potentially) large memory allocation has failed.", "args": {}}, {"caml-name": "ERR_FILE_OPEN", "name": "err_file_open", "brief": "An error occurred while opening a file.", "desc": "Error while opening a file.", "value": "1052", "msg": "An error occurred while opening file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FILE_READ", "name": "err_file_read", "brief": "An error occurred while reading file.", "desc": "File read error.", "value": "1053", "msg": "An error occurred while reading file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FILE_WRITE", "name": "err_file_write", "brief": "An error occurred while writing to a file.", "desc": "File write error.", "value": "1054", "msg": "An error occurred while writing to file '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_DATA_FILE_EXT", "name": "err_data_file_ext", "brief": "The data file format cannot be determined from the file name.", "value": "1055", "msg": "The data file format cannot be determined from the file name '%{arg0}'", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_FILE_NAME", "name": "err_invalid_file_name", "brief": "An invalid file name has been specified.", "value": "1056", "msg": "'%{arg0}' is an invalid file name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_SOL_FILE_NAME", "name": "err_invalid_sol_file_name", "brief": "An invalid file name has been specified.", "value": "1057", "msg": "'%{arg0}' is invalid solution file name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_END_OF_FILE", "name": "err_end_of_file", "brief": "End of file reached.", "value": "1059", "msg": "End of file reached.", "args": {}}, {"caml-name": "ERR_NULL_ENV", "name": "err_null_env", "brief": "env is a null pointer.", "desc": "``env`` is a |null| pointer.", "value": "1060", "msg": "env is a null pointer.", "args": {}}, {"caml-name": "ERR_NULL_TASK", "name": "err_null_task", "brief": "task is a null pointer.", "desc": "``task`` is a |null| pointer.", "value": "1061", "msg": "task is a null pointer.", "args": {}}, {"caml-name": "ERR_INVALID_STREAM", "name": "err_invalid_stream", "brief": "An invalid stream is referenced.", "value": "1062", "msg": "%{arg0} is an invalid stream.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_INIT_ENV", "name": "err_no_init_env", "brief": "Environment is not initialized.", "desc": "``env`` is not initialized.", "value": "1063", "msg": "Environment is not initialized.", "args": {}}, {"caml-name": "ERR_INVALID_TASK", "name": "err_invalid_task", "brief": "The task is invalid.", "desc": "The ``task`` is invalid.", "value": "1064", "msg": "The task is invalid.", "args": {}}, {"caml-name": "ERR_NULL_POINTER", "name": "err_null_pointer", "brief": "An argument to a function is unexpectedly a null pointer.", "desc": "An argument to a function is unexpectedly a |null| pointer.", "value": "1065", "msg": "Argument '%{arg0}' is unexpectedly a null pointer.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LIVING_TASKS", "name": "err_living_tasks", "brief": "Not all tasks associated with the environment have been deleted.", "desc": "All tasks associated with an enviroment must be deleted\nbefore the environment is deleted. There are still some undeleted tasks.", "value": "1066", "msg": "Not all tasks associated with the environment have been deleted.", "args": {}}, {"caml-name": "ERR_READ_GZIP", "name": "err_read_gzip", "brief": "Error encountered in GZIP stream.", "value": "1067", "msg": "Encountered error %{code} in GZIP stream", "args": {"code": ["code", "i", []]}}, {"caml-name": "ERR_READ_ZSTD", "name": "err_read_zstd", "brief": "Error encountered in ZSTD stream.", "value": "1068", "msg": "Encountered error %{code} in GZIP stream", "args": {"code": ["code", "i", []]}}, {"caml-name": "ERR_BLANK_NAME", "name": "err_blank_name", "brief": "An all blank name has been specified.", "value": "1070", "msg": "An all blank name has been specified.", "args": {}}, {"caml-name": "ERR_DUP_NAME", "name": "err_dup_name", "brief": "Duplicate names specified.", "desc": "The same name was used multiple times for the same problem item type.", "value": "1071", "msg": "Name '%{arg0}' is already assigned for an item %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_FORMAT_STRING", "name": "err_format_string", "brief": "The name format string is invalid.", "value": "1072", "msg": "The format string '%{fmt}' is invalid at position %{pos} in argument '%{arg}'.", "args": {"fmt": ["fmt", "s", []], "pos": ["pos", "i", []], "arg": ["arg", "s", []]}}, {"caml-name": "ERR_SPARSITY_SPECIFICATION", "name": "err_sparsity_specification", "brief": "The sparsity included an index that was out of bounds of the shape.", "value": "1073", "msg": "The sparsity specification is invalid.", "args": {}}, {"caml-name": "ERR_MISMATCHING_DIMENSION", "name": "err_mismatching_dimension", "brief": "Mismatching dimensions specified in arguments", "value": "1074", "msg": "Mismatching dimensions specified in %{arg0} and %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INVALID_OBJ_NAME", "name": "err_invalid_obj_name", "brief": "An invalid objective name is specified.", "value": "1075", "msg": "'%{arg0}' is an invalid objective name is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_CON_NAME", "name": "err_invalid_con_name", "brief": "An invalid constraint name is used.", "value": "1076", "msg": "'%{arg0}' is an invalid name for constraint number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_VAR_NAME", "name": "err_invalid_var_name", "brief": "An invalid variable name is used.", "value": "1077", "msg": "'%{arg0}' is an invalid name for variable number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_CONE_NAME", "name": "err_invalid_cone_name", "brief": "An invalid cone name is used.", "value": "1078", "msg": "'%{arg0}' is an invalid name for cone number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_BARVAR_NAME", "name": "err_invalid_barvar_name", "brief": "An invalid symmetric matrix variable name is used.", "value": "1079", "msg": "'%{arg0}' is an invalid name for symmetric matrix variable number %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SPACE_LEAKING", "name": "err_space_leaking", "brief": "MOSEK is leaking memory.", "desc": "|mosek| is leaking memory. This can be due to either an incorrect use of |mosek| or a bug.", "value": "1080", "msg": "MOSEK is leaking memory.", "args": {}}, {"caml-name": "ERR_SPACE_NO_INFO", "name": "err_space_no_info", "brief": "No available information about the space usage.", "value": "1081", "msg": "No available information about the space usage.", "args": {}}, {"caml-name": "ERR_DIMENSION_SPECIFICATION", "name": "err_dimension_specification", "brief": "Invalid dimension specification", "value": "1082", "msg": "Invalid dimension specification in %{arg}.", "args": {"arg": ["arg", "s", []]}}, {"caml-name": "ERR_AXIS_NAME_SPECIFICATION", "name": "err_axis_name_specification", "brief": "Invalid axis names specification", "value": "1083", "msg": "Invalid axis names specification.", "args": {}}, {"caml-name": "ERR_READ_FORMAT", "name": "err_read_format", "brief": "The specified format cannot be read.", "value": "1090", "msg": "The specified format cannot be read. The format code is %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_FILE", "name": "err_mps_file", "brief": "An error occurred while reading an MPS file.", "value": "1100", "msg": "An error occurred while reading an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_INV_FIELD", "name": "err_mps_inv_field", "brief": "Invalid field occurred while reading an MPS file.", "desc": "A field in the MPS file is invalid. Probably it is too wide.", "value": "1101", "msg": "Field number %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_INV_MARKER", "name": "err_mps_inv_marker", "brief": "An invalid marker has been specified in the MPS file.", "value": "1102", "msg": "An invalid marker has been specified in the MPS file.", "args": {}}, {"caml-name": "ERR_MPS_NULL_CON_NAME", "name": "err_mps_null_con_name", "brief": "An empty constraint name is used in an MPS file.", "value": "1103", "msg": "An empty constraint name is used in an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_NULL_VAR_NAME", "name": "err_mps_null_var_name", "brief": "An empty variable name is used in an MPS file.", "value": "1104", "msg": "An empty variable name is used in an MPS file.", "args": {}}, {"caml-name": "ERR_MPS_UNDEF_CON_NAME", "name": "err_mps_undef_con_name", "brief": "An undefined constraint name occurred in an MPS file.", "value": "1105", "msg": "'%{arg0}' is an undefined constraint name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_UNDEF_VAR_NAME", "name": "err_mps_undef_var_name", "brief": "An undefined variable name occurred in an MPS file.", "value": "1106", "msg": "'%{arg0}' is an undefined variable name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_CON_KEY", "name": "err_mps_invalid_con_key", "brief": "An invalid constraint key occurred in an MPS file.", "value": "1107", "msg": "'%{arg0}' is an invalid constraint key for constraint '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_BOUND_KEY", "name": "err_mps_invalid_bound_key", "brief": "An invalid bound key occurred in an MPS file.", "value": "1108", "msg": "'%{arg0}' is an invalid bound key.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_SEC_NAME", "name": "err_mps_invalid_sec_name", "brief": "An invalid section name occurred in an MPS file.", "value": "1109", "msg": "An invalid section name was used.", "args": {}}, {"caml-name": "ERR_MPS_NO_OBJECTIVE", "name": "err_mps_no_objective", "brief": "No objective is defined in an MPS file.", "value": "1110", "msg": "No objective was defined.", "args": {}}, {"caml-name": "ERR_MPS_SPLITTED_VAR", "name": "err_mps_splitted_var", "brief": "The non-zero elements in A corresponding to a variable in an MPS file must be specified consecutively.", "desc": "All elements in a column of the :math:`A` matrix must be specified consecutively.  Hence, it is illegal to specify non-zero elements in :math:`A` for variable 1, then for variable 2 and then variable 1 again.", "value": "1111", "msg": "The non-zero elements in a column of A for variable '%{arg0}' is not specified consecutively.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_CON_NAME", "name": "err_mps_mul_con_name", "brief": "A constraint name is specified multiple times in the ROWS section in an MPS file.", "desc": "A constraint name was specified multiple times in the ``ROWS`` section.", "value": "1112", "msg": "The constraint name '%{arg0}' was specified multiple times in the ROWS section.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_QSEC", "name": "err_mps_mul_qsec", "brief": "Multiple QSECTIONs are specified for a constraint.", "desc": "Multiple ``QSECTION``\\ s are specified for a constraint in the MPS data file.", "value": "1113", "msg": "Multiple QSECTIONs are specified for a constraint '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_QOBJ", "name": "err_mps_mul_qobj", "brief": "The Q term in the objective is specified multiple times.", "desc": "The Q term in the objective\nis specified multiple times in the MPS data file.", "value": "1114", "msg": "The Q term in the objective is specified multiple times.", "args": {}}, {"caml-name": "ERR_MPS_INV_SEC_ORDER", "name": "err_mps_inv_sec_order", "brief": "The sections in an MPS file is not in the correct order.", "desc": "The sections in the MPS data file\nare not in the correct order.", "value": "1115", "msg": "Section '%{arg0}' was not expected.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_MUL_CSEC", "name": "err_mps_mul_csec", "brief": "Multiple CSECTIONs are given the same name.", "desc": "Multiple ``CSECTION``\\ s are given the same name.", "value": "1116", "msg": "Multiple CSECTIONs are given the name '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_CONE_TYPE", "name": "err_mps_cone_type", "brief": "Invalid cone type specified in a  CSECTION.", "desc": "Invalid cone type specified in a ``CSECTION``\\ .", "value": "1117", "msg": "'%{arg0}' is an invalid cone type in a CSECTION.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_CONE_OVERLAP", "name": "err_mps_cone_overlap", "brief": "A variable is specified to be a member of several cones.", "value": "1118", "msg": "Variable '%{arg0}' is specified to be a member of CSECTION '%{arg1}' and CSECTION '%{arg2}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_MPS_CONE_REPEAT", "name": "err_mps_cone_repeat", "brief": "A variable is repeated within the CSECTION.", "desc": "A variable is repeated within the ``CSECTION``\\ .", "value": "1119", "msg": "Variable '%{arg0}' is repeated in CSECTION '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MPS_NON_SYMMETRIC_Q", "name": "err_mps_non_symmetric_q", "brief": "A non symmetric matrix has been speciefied.", "value": "1120", "msg": "A Q matrix is not symmetric at row '%{rowname}' and column '%{colname}'.", "args": {"rowname": ["rowname", "s", []], "colname": ["colname", "s", []]}}, {"caml-name": "ERR_MPS_DUPLICATE_Q_ELEMENT", "name": "err_mps_duplicate_q_element", "brief": "Duplicate elements is specified in a Q matrix.", "desc": "Duplicate elements is specfied in a :math:`Q` matrix.", "value": "1121", "msg": "An element at row '%{rowname}' and column '%{colname}' is specfied twice.", "args": {"rowname": ["rowname", "s", []], "colname": ["colname", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_OBJSENSE", "name": "err_mps_invalid_objsense", "brief": "An invalid objective sense is specified.", "value": "1122", "msg": "'%{arg0}' is an invalid objective sense.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD2", "name": "err_mps_tab_in_field2", "brief": "A tab char occurred in field 2.", "value": "1125", "msg": "A tab char occurred in field 2.", "args": {}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD3", "name": "err_mps_tab_in_field3", "brief": "A tab char occurred in field 3.", "value": "1126", "msg": "A tab char occurred in field 3.", "args": {}}, {"caml-name": "ERR_MPS_TAB_IN_FIELD5", "name": "err_mps_tab_in_field5", "brief": "A tab char occurred in field 5.", "value": "1127", "msg": "A tab char occurred in field 5.", "args": {}}, {"caml-name": "ERR_MPS_INVALID_OBJ_NAME", "name": "err_mps_invalid_obj_name", "brief": "An invalid objective name is specified.", "value": "1128", "msg": "'%{arg0}' is an invalid objective name is specified.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_KEY", "name": "err_mps_invalid_key", "brief": "An invalid indicator key occurred in an MPS file.", "value": "1129", "msg": "'%{arg0}' is an invalid indicator key.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_CONSTRAINT", "name": "err_mps_invalid_indicator_constraint", "brief": "An invalid indicator constraint is used. It must not be a ranged constraint.", "value": "1130", "msg": "Constraint '%{arg0}' is an invalid indicator constraint.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_VARIABLE", "name": "err_mps_invalid_indicator_variable", "brief": "An invalid indicator variable is specfied. It must be a binary variable.", "value": "1131", "msg": "Variable '%{arg0}' (index=%{arg1}) is an invalid indicator.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_VALUE", "name": "err_mps_invalid_indicator_value", "brief": "An invalid indicator value is specfied. It must be either 0 or 1.", "value": "1132", "msg": "'%{arg0}' is an invalid indicator value.", "args": {"arg0": ["arg0", "e", []]}}, {"caml-name": "ERR_MPS_INVALID_INDICATOR_QUADRATIC_CONSTRAINT", "name": "err_mps_invalid_indicator_quadratic_constraint", "brief": "A quadratic constraint can be be an indicator constraint.", "value": "1133", "msg": "Constraint '%{arg0}' is quadratic which is invalid for an indicator constraint.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_OPF_SYNTAX", "name": "err_opf_syntax", "brief": "Syntax error in an OPF file", "value": "1134", "msg": "Syntax error in an OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_PREMATURE_EOF", "name": "err_opf_premature_eof", "brief": "Premature end of file in an OPF file.", "value": "1136", "msg": "Premature end of file in an OPF file.", "args": {}}, {"caml-name": "ERR_OPF_MISMATCHED_TAG", "name": "err_opf_mismatched_tag", "brief": "Mismatched end-tag in OPF file", "value": "1137", "msg": "Mismatched end-tag in an OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_BOUND", "name": "err_opf_duplicate_bound", "brief": "Either upper or lower bound was specified twice in OPF file", "value": "1138", "msg": "Either upper or lower bound already specified at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_CONSTRAINT_NAME", "name": "err_opf_duplicate_constraint_name", "brief": "Duplicate constraint name in OPF File", "value": "1139", "msg": "Constraint name re-defined in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INVALID_CONE_TYPE", "name": "err_opf_invalid_cone_type", "brief": "Invalid cone type in OPF File", "value": "1140", "msg": "Invalid cone type in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INCORRECT_TAG_PARAM", "name": "err_opf_incorrect_tag_param", "brief": "Invalid number of parameters in start-tag in OPF File", "value": "1141", "msg": "Invalid number of parameters in start-tag in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_INVALID_TAG", "name": "err_opf_invalid_tag", "brief": "Invalid start-tag in OPF File", "value": "1142", "msg": "Invalid start-tag in OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_DUPLICATE_CONE_ENTRY", "name": "err_opf_duplicate_cone_entry", "brief": "Same variable appears in multiple cones in OPF File", "value": "1143", "msg": "Variable already member of a cone OPF at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OPF_TOO_LARGE", "name": "err_opf_too_large", "brief": "The problem is too large to be correctly loaded", "value": "1144", "msg": "The problem contains too many %{arg0} to load correctly.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_OPF_DUAL_INTEGER_SOLUTION", "name": "err_opf_dual_integer_solution", "brief": "Dual solution values are not allowed in OPF File", "value": "1146", "msg": "Dual solution values are not allowed in OPF file at : %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_LP_EMPTY", "name": "err_lp_empty", "brief": "The problem cannot be written to an LP formatted file.", "value": "1151", "msg": "A problem with no variables or constraints cannot be written to a LP formatted file.", "args": {}}, {"caml-name": "ERR_WRITE_MPS_INVALID_NAME", "name": "err_write_mps_invalid_name", "brief": "An invalid name is created while writing an MPS file.", "desc": "An invalid name is created while writing an MPS file. Usually this will make the MPS file unreadable.", "value": "1153", "msg": "The name '%{arg0}' is not a valid MPS name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_LP_INVALID_VAR_NAME", "name": "err_lp_invalid_var_name", "brief": "A variable name is invalid when used in an LP formatted file.", "value": "1154", "msg": "The variable name '%{arg0}' cannot be written to an LP formatted file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_WRITE_OPF_INVALID_VAR_NAME", "name": "err_write_opf_invalid_var_name", "brief": "Empty variable names cannot be written to OPF files.", "value": "1156", "msg": "Name of variable index %{arg0} is empty and cannot be written to an OPF file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LP_FILE_FORMAT", "name": "err_lp_file_format", "brief": "Syntax error in an LP file.", "value": "1157", "msg": "Syntax error in an LP file at: %{arg0}:%{arg1}.", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []]}}, {"caml-name": "ERR_LP_EXPECTED_NUMBER", "name": "err_lp_expected_number", "brief": "Expected a number in LP file", "value": "1158", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected a number, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_READ_LP_MISSING_END_TAG", "name": "err_read_lp_missing_end_tag", "brief": "Syntax error in LP fil. Possibly missing End tag.", "desc": "Syntax error in LP file. Possibly missing End tag.", "value": "1159", "msg": "Syntax error in LP file on line: %{arg0}. Missing End tag?", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LP_INDICATOR_VAR", "name": "err_lp_indicator_var", "brief": "An indicator variable was not declared binary", "value": "1160", "msg": "The indicator variable '%{arg0}' (%{arg1}) was not declared binary.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "U", []]}}, {"caml-name": "ERR_LP_EXPECTED_OBJECTIVE", "name": "err_lp_expected_objective", "brief": "Expected an objective section in LP file", "value": "1161", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected an objective section, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_LP_EXPECTED_CONSTRAINT_RELATION", "name": "err_lp_expected_constraint_relation", "brief": "Expected constraint relation", "value": "1162", "msg": "Syntax error in LP file at %{arg0}:%{arg1}: Expected a constraint relation, but got '%{arg2}'", "args": {"arg0": ["arg0", "L", []], "arg1": ["arg1", "L", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_LP_AMBIGUOUS_CONSTRAINT_BOUND", "name": "err_lp_ambiguous_constraint_bound", "brief": "Constraint has ambiguous or invalid bound", "value": "1163", "msg": "Syntax error in LP file at %{l}:%{c}: Constraint '%{a2}' has ambiguous or invalid bound.", "args": {"l": ["l", "l", []], "c": ["c", "l", []], "a2": ["a2", "s", []]}}, {"caml-name": "ERR_LP_DUPLICATE_SECTION", "name": "err_lp_duplicate_section", "brief": "Duplicate section", "value": "1164", "msg": "Syntax error in LP file at %{l}:%{c}: Duplicate section '%{a0}'.", "args": {"l": ["l", "L", []], "c": ["c", "L", []], "a0": ["a0", "s", []]}}, {"caml-name": "ERR_READ_LP_DELAYED_ROWS_NOT_SUPPORTED", "name": "err_read_lp_delayed_rows_not_supported", "brief": "Duplicate section", "value": "1165", "msg": "Syntax error in LP file at %{l}:%{c}: Delayed rows not supported.", "args": {"l": ["l", "L", []], "c": ["c", "L", []]}}, {"caml-name": "ERR_WRITING_FILE", "name": "err_writing_file", "brief": "An error occurred while writing file", "value": "1166", "msg": "An error occurred while writing the file", "args": {}}, {"caml-name": "ERR_INVALID_NAME_IN_SOL_FILE", "name": "err_invalid_name_in_sol_file", "brief": "An invalid name occurred in a solution file.", "value": "1170", "msg": "The name '%{arg0}' is an invalid name.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_JSON_SYNTAX", "name": "err_json_syntax", "brief": "Syntax error in an JSON data", "value": "1175", "msg": "Syntax error at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_STRING", "name": "err_json_string", "brief": "Error in JSON string.", "value": "1176", "msg": "Error in JSON string at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_NUMBER_OVERFLOW", "name": "err_json_number_overflow", "brief": "Invalid number entry - wrong type or value overflow.", "value": "1177", "msg": "Invalid number entry at %{row}:%{column} - wrong type or value overflow.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_FORMAT", "name": "err_json_format", "brief": "Error in an JSON Task file", "value": "1178", "msg": "Error in JSON Task file at %{row}:%{column}.", "args": {"row": ["row", "i", []], "column": ["column", "i", []]}}, {"caml-name": "ERR_JSON_DATA", "name": "err_json_data", "brief": "Inconsistent data in JSON Task file", "value": "1179", "msg": "Inconsistent data in JSON Task in section \\\"%{item}\\\"", "args": {"item": ["item", "s", []]}}, {"caml-name": "ERR_JSON_MISSING_DATA", "name": "err_json_missing_data", "brief": "Missing data section in JSON task file.", "value": "1180", "msg": "Missing required entry \\\"%{item}\\\" in section \\\"%{sect}\\\" in JSON task file.", "args": {"item": ["item", "s", []], "sect": ["sect", "s", []]}}, {"caml-name": "ERR_PTF_INCOMPATIBILITY", "name": "err_ptf_incompatibility", "brief": "Incompatible item", "value": "1181", "msg": "Incompatible item '%{arg0}' in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_UNDEFINED_ITEM", "name": "err_ptf_undefined_item", "brief": "Undefined symbol referenced", "value": "1182", "msg": "Undefined symbol '%{arg0}' referenced in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_INCONSISTENCY", "name": "err_ptf_inconsistency", "brief": "Inconsistent size of item", "value": "1183", "msg": "Inconsistent size of '%{arg0}' in PTF file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PTF_FORMAT", "name": "err_ptf_format", "brief": "Syntax error in an PTF file", "value": "1184", "msg": "Syntax error in an PTF file: %{arg0}:%{arg1}: %{msg}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "msg": ["msg", "s", []]}}, {"caml-name": "ERR_ARGUMENT_LENNEQ", "name": "err_argument_lenneq", "brief": "Incorrect length of arguments.", "value": "1197", "msg": "Incorrect argument length. The arguments %{arg0} are expected to be of equal length. The length of the arguments was %{arg1}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARGUMENT_TYPE", "name": "err_argument_type", "brief": "Incorrect argument type.", "value": "1198", "msg": "Incorrect type in %{arg0} argument number: '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NUM_ARGUMENTS", "name": "err_num_arguments", "brief": "Incorrect number of function arguments.", "value": "1199", "msg": "Incorrect number of %{arg0} arguments. Got %{arg1} expected %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_IN_ARGUMENT", "name": "err_in_argument", "brief": "A function argument is incorrect.", "value": "1200", "msg": "The argument '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_ARGUMENT_DIMENSION", "name": "err_argument_dimension", "brief": "A function argument is of incorrect dimension.", "value": "1201", "msg": "The argument '%{arg0}' is of incorrect dimension.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_SHAPE_IS_TOO_LARGE", "name": "err_shape_is_too_large", "brief": "The size of the n-dimensional shape is too large.", "value": "1202", "msg": "The size of the shape in argument '%{arg1}' is too large.", "args": {"arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_TOO_SMALL", "name": "err_index_is_too_small", "brief": "An index in an argument is too small.", "value": "1203", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_TOO_LARGE", "name": "err_index_is_too_large", "brief": "An index in an argument is too large.", "value": "1204", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INDEX_IS_NOT_UNIQUE", "name": "err_index_is_not_unique", "brief": "An index in an argument is is unique.", "value": "1205", "msg": "The index value %{arg0} occurring in argument '%{arg1}' is not unique.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_NAME", "name": "err_param_name", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct.", "value": "1206", "msg": "The parameter name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_DOU", "name": "err_param_name_dou", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for a double parameter.", "value": "1207", "msg": "The parameter name '%{arg0}' is invalid for a double parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_INT", "name": "err_param_name_int", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for an integer parameter.", "value": "1208", "msg": "The parameter name '%{arg0}' is invalid for an int parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_NAME_STR", "name": "err_param_name_str", "brief": "A parameter name is not correct.", "desc": "The parameter name is not correct for a string parameter.", "value": "1209", "msg": "The parameter name '%{arg0}' is invalid for a string parameter.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_PARAM_INDEX", "name": "err_param_index", "brief": "Parameter index is out of range.", "value": "1210", "msg": "The parameter index %{arg0} is invalid for a parameter of type %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_IS_TOO_LARGE", "name": "err_param_is_too_large", "brief": "A parameter value is too large.", "desc": "The parameter value is too large.", "value": "1215", "msg": "The parameter value %{arg0} is too large for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_IS_TOO_SMALL", "name": "err_param_is_too_small", "brief": "A parameter value is too small.", "desc": "The parameter value is too small.", "value": "1216", "msg": "The parameter value %{arg0} is too small for parameter '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_VALUE_STR", "name": "err_param_value_str", "brief": "A parameter value string is incorrect.", "desc": "The parameter value string is incorrect.", "value": "1217", "msg": "The parameter value string '%{arg0}' for parameter %{arg1} is incorrect.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_PARAM_TYPE", "name": "err_param_type", "brief": "A parameter type is invalid.", "desc": "The parameter type is invalid.", "value": "1218", "msg": "The parameter type %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_DOU_INDEX", "name": "err_inf_dou_index", "brief": "A double information index is out of range for the specified type.", "value": "1219", "msg": "The double information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_INT_INDEX", "name": "err_inf_int_index", "brief": "An integer information index is out of range for the specified type.", "value": "1220", "msg": "The integer information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INDEX_ARR_IS_TOO_SMALL", "name": "err_index_arr_is_too_small", "brief": "An index in an array argument is too small.", "value": "1221", "msg": "The index value %{arg0} occurring in argument '%{arg1}[%{arg2}]' is too small(>=%{arg3}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INDEX_ARR_IS_TOO_LARGE", "name": "err_index_arr_is_too_large", "brief": "An index in an array argument is too large.", "value": "1222", "msg": "The index value %{arg0} occurring in argument '%{arg1}[%{arg2}]' is too large(<%{arg3}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INF_LINT_INDEX", "name": "err_inf_lint_index", "brief": "A long integer information index is out of range for the specified type.", "value": "1225", "msg": "The long integer information index %{arg0} is out of range.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_ARG_IS_TOO_SMALL", "name": "err_arg_is_too_small", "brief": "The value of a argument is too small.", "value": "1226", "msg": "The value %{arg0} of argument %{arg1} is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARG_IS_TOO_LARGE", "name": "err_arg_is_too_large", "brief": "The value of a argument is too large.", "value": "1227", "msg": "The value %{arg0} of argument %{arg1} is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INVALID_WHICHSOL", "name": "err_invalid_whichsol", "brief": "whichsol is invalid.", "desc": "``whichsol`` is invalid.", "value": "1228", "msg": "The code %{arg0} is an invalid value for whichsol.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_DOU_NAME", "name": "err_inf_dou_name", "brief": "A double information name is invalid.", "value": "1230", "msg": "The  double information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_INT_NAME", "name": "err_inf_int_name", "brief": "An integer information name is invalid.", "value": "1231", "msg": "The  integer information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_TYPE", "name": "err_inf_type", "brief": "The information type is invalid.", "value": "1232", "msg": "The information type %{arg0} is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INF_LINT_NAME", "name": "err_inf_lint_name", "brief": "A long integer information name is invalid.", "value": "1234", "msg": "The long integer information name '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INDEX", "name": "err_index", "brief": "An index is out of range.", "value": "1235", "msg": "An index is out of range.", "args": {}}, {"caml-name": "ERR_WHICHSOL", "name": "err_whichsol", "brief": "The solution defined by whichsol does not exists.", "desc": "The solution defined by ``whichsol`` does not exists.", "value": "1236", "msg": "%{arg0} is not a valid solution code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SOLITEM", "name": "err_solitem", "brief": "The solution number  solemn does not exists.", "desc": "The solution item number ``solitem`` is invalid. Please note that :msk:const:`solitem.snx` is invalid for the basic solution.", "value": "1237", "msg": "%{arg0} is not a valid solution item code for solution %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_WHICHITEM_NOT_ALLOWED", "name": "err_whichitem_not_allowed", "brief": "whichitem is unacceptable.", "desc": "``whichitem`` is unacceptable.", "value": "1238", "msg": "%{arg0} is an unacceptable whichitem.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MAXNUMCON", "name": "err_maxnumcon", "brief": "Invalid maximum number of constraints specified.", "desc": "The maximum number of constraints specified is smaller than the number of\nconstraints in the task.", "value": "1240", "msg": "Maximum number of constraints of '%{arg0}' is smaller than the number of constraints '%{arg1}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMVAR", "name": "err_maxnumvar", "brief": "The maximum number of variables limit is too small.", "desc": "The maximum number of variables specified is smaller than the number of\nvariables in the task.", "value": "1241", "msg": "Too small maximum number of variables %{arg0} is specified. Currently, the number of variables is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMBARVAR", "name": "err_maxnumbarvar", "brief": "The maximum number of semidefinite variables limit is too small.", "desc": "The maximum number of semidefinite variables specified is smaller than the number of semidefinite variables in the task.", "value": "1242", "msg": "Too small maximum number of semidefinite variables %{arg0} is specified. Currently, the number of semidefinite variables is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMQNZ", "name": "err_maxnumqnz", "brief": "Too small maximum number of non-zeros for the Q matrices is specified.", "desc": "The maximum number of non-zeros specified for the :math:`Q` matrices is smaller than the number of non-zeros in the current :math:`Q` matrices.", "value": "1243", "msg": "Too small maximum number of non-zeros for the Q matrices is specified.", "args": {}}, {"caml-name": "ERR_TOO_SMALL_MAX_NUM_NZ", "name": "err_too_small_max_num_nz", "brief": "The maximum number of non-zeros specified is too small.", "value": "1245", "msg": "The maximum number of non-zeros %{arg0} is too small. It must be at least %{arg1}.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_INVALID_IDX", "name": "err_invalid_idx", "brief": "A specified index is invalid.", "value": "1246", "msg": "The index value %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INVALID_MAX_NUM", "name": "err_invalid_max_num", "brief": "A specified index is invalid.", "value": "1247", "msg": "The maximum number value %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_UNALLOWED_WHICHSOL", "name": "err_unallowed_whichsol", "brief": "The value of whichsol is not allowed.", "desc": "The value od ``whichsol`` is not allowed.", "value": "1248", "msg": "The code %{arg0} is an unallowed value for whichsol.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NUMCONLIM", "name": "err_numconlim", "brief": "Maximum number of constraints limit is exceeded.", "value": "1250", "msg": "Maximum number of constraints limit is exceeded.", "args": {}}, {"caml-name": "ERR_NUMVARLIM", "name": "err_numvarlim", "brief": "Maximum number of variables limit is exceeded.", "value": "1251", "msg": "Maximum number of variables limit is exceeded.", "args": {}}, {"caml-name": "ERR_TOO_SMALL_MAXNUMANZ", "name": "err_too_small_maxnumanz", "brief": "Too small maximum number of non-zeros in A specified.", "desc": "The maximum number of non-zeros specified for :math:`A` is smaller than the number of non-zeros in the current :math:`A`.", "value": "1252", "msg": "Too small maximum number of non-zeros for %{arg0} A is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INV_APTRE", "name": "err_inv_aptre", "brief": "aptre[j] is strictly smaller than aptrb[j] for some j.", "desc": "``aptre[j]`` is strictly smaller than ``aptrb[j]`` for some ``j``.", "value": "1253", "msg": "aptre is strictly smaller than aptrb at position %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MUL_A_ELEMENT", "name": "err_mul_a_element", "brief": "An element in A is defined multiple times.", "desc": "An element in :math:`A` is defined multiple times.", "value": "1254", "msg": "Multiple elements in row %{arg0} of A at column %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_BK", "name": "err_inv_bk", "brief": "Invalid bound key.", "value": "1255", "msg": "%{arg0} is an invalid bound key.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_BKC", "name": "err_inv_bkc", "brief": "Invalid bound key is specified for a constraint.", "value": "1256", "msg": "An invalid bound key for a constraint value of %{arg0} in argument '%{arg1}' has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INV_BKX", "name": "err_inv_bkx", "brief": "An invalid bound key is specified for a variable.", "value": "1257", "msg": "An invalid bound key for variable of value of %{arg0} in argument '%{arg1}' has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_INV_VAR_TYPE", "name": "err_inv_var_type", "brief": "An invalid variable type is specified for a variable.", "value": "1258", "msg": "An invalid type %{arg0} is specified for variable '%{arg1}' (%{arg2}) in argument '%{arg3}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "ERR_SOLVER_PROBTYPE", "name": "err_solver_probtype", "brief": "Problem type does not match the chosen optimizer.", "value": "1259", "msg": "Problem type does not match the chosen optimizer.", "args": {}}, {"caml-name": "ERR_OBJECTIVE_RANGE", "name": "err_objective_range", "brief": "Empty objective range.", "value": "1260", "msg": "Empty objective range.", "args": {}}, {"caml-name": "ERR_INV_RESCODE", "name": "err_inv_rescode", "brief": "Invalid response code.", "value": "1261", "msg": "%{arg0} is an invalid response code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_IINF", "name": "err_inv_iinf", "brief": "Invalid integer information item.", "value": "1262", "msg": "%{arg0} is an invalid integer information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_LIINF", "name": "err_inv_liinf", "brief": "Invalid long integer information item.", "value": "1263", "msg": "%{arg0} is an invalid long integer information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_DINF", "name": "err_inv_dinf", "brief": "Invalid double information item.", "value": "1264", "msg": "%{arg0} is an invalid double information item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_BASIS", "name": "err_basis", "brief": "Invalid basis is specified.", "desc": "An invalid basis is specified. Either\ntoo many or too few basis variables are specified.", "value": "1266", "msg": "%{arg0} number of basis variables are specified. %{arg1} are expected.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_SKC", "name": "err_inv_skc", "brief": "Invalid value in skc encountered.", "desc": "Invalid value in ``skc``.", "value": "1267", "msg": "Invalid value at skc[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SKX", "name": "err_inv_skx", "brief": "Invalid value in skx encountered.", "desc": "Invalid value in ``skx``.", "value": "1268", "msg": "Invalid value at skx[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SKN", "name": "err_inv_skn", "brief": "Invalid value in skn encountered.", "desc": "Invalid value in ``skn``.", "value": "1274", "msg": "Invalid value at skn[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_SK_STR", "name": "err_inv_sk_str", "brief": "Invalid status key string encountered.", "value": "1269", "msg": "'%{arg0}' is an invalid status key string.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INV_SK", "name": "err_inv_sk", "brief": "Invalid status key code encountered.", "desc": "Invalid status key code.", "value": "1270", "msg": "'%{arg0}' is an invalid status key code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_CONE_TYPE_STR", "name": "err_inv_cone_type_str", "brief": "Invalid cone type string encountered.", "value": "1271", "msg": "'%{arg0}' is an invalid cone type string.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INV_CONE_TYPE", "name": "err_inv_cone_type", "brief": "Invalid cone type code encountered.", "desc": "Invalid cone type code is encountered.", "value": "1272", "msg": "'%{arg0}' is an invalid cone type code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_SURPLUS", "name": "err_invalid_surplus", "brief": "Invalid surplus.", "value": "1275", "msg": "Invalid surplus.", "args": {}}, {"caml-name": "ERR_INV_NAME_ITEM", "name": "err_inv_name_item", "brief": "An invalid name item code is used.", "value": "1280", "msg": "'%{arg0}' is an invalid name item code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_PRO_ITEM", "name": "err_pro_item", "brief": "An invalid problem item is used.", "desc": "An invalid problem is used.", "value": "1281", "msg": "'%{arg0}' is an invalid problem item.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_FORMAT_TYPE", "name": "err_invalid_format_type", "brief": "Invalid format type.", "value": "1283", "msg": "%{arg0} is an invalid format type.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_FIRSTI", "name": "err_firsti", "brief": "Invalid firsti.", "desc": "Invalid ``firsti``.", "value": "1285", "msg": "'%{arg0}' is an invalid value for firsti.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_LASTI", "name": "err_lasti", "brief": "Invalid lasti.", "desc": "Invalid ``lasti``.", "value": "1286", "msg": "'%{arg0}' is an invalid value for lasti.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_FIRSTJ", "name": "err_firstj", "brief": "Invalid firstj.", "desc": "Invalid ``firstj``.", "value": "1287", "msg": "'%{arg0}' is an invalid value for firstj.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LASTJ", "name": "err_lastj", "brief": "Invalid lastj.", "desc": "Invalid ``lastj``.", "value": "1288", "msg": "'%{arg0}' is an invalid value for lastj.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MAX_LEN_IS_TOO_SMALL", "name": "err_max_len_is_too_small", "brief": "A maximum length that is too small has been specified.", "value": "1289", "msg": "%{arg0} specified by '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_NONLINEAR_EQUALITY", "name": "err_nonlinear_equality", "brief": "The model contains a nonlinear equality.", "desc": "The model contains a nonlinear equality which defines a nonconvex set.", "value": "1290", "msg": "Nonconvex model detected. Constraint '%{arg0}'(%{arg1}) is a nonlinear equality.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NONCONVEX", "name": "err_nonconvex", "brief": "The optimization problem is nonconvex.", "value": "1291", "msg": "The optimization problem is nonconvex.", "args": {}}, {"caml-name": "ERR_NONLINEAR_RANGED", "name": "err_nonlinear_ranged", "brief": "The problem contains a nonlinear constraint with inite lower and upper bound.", "desc": "Nonlinear constraints with finite lower and upper bound always define a nonconvex feasible set.", "value": "1292", "msg": "Constraint '%{arg0}(%{arg1})' is nonlinear and ranged constraint i.e. it has finite lower and upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_CON_Q_NOT_PSD", "name": "err_con_q_not_psd", "brief": "The quadratic constraint matrix is not PSD.", "desc": "The quadratic constraint matrix is not positive semidefinite as expected for a constraint with finite upper bound. This results in a nonconvex problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1293", "msg": "Constraint '%{arg0}'(%{arg1}) is not convex. Q should be positive semidefinite in a constraint with finite upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_CON_Q_NOT_NSD", "name": "err_con_q_not_nsd", "brief": "The quadratic constraint matrix is not NSD.", "desc": "The quadratic constraint matrix is not negative semidefinite as expected for a constraint with finite lower bound. This results in a nonconvex problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1294", "msg": "The constraint '%{arg0}'(%{arg1}) is not convex. Q should be negative semidefinite for a constraint with finite lower bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_OBJ_Q_NOT_PSD", "name": "err_obj_q_not_psd", "brief": "The quadratic coefficient matrix in the objective is not PSD.", "desc": "The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.  The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1295", "msg": "The quadratic coefficient matrix in the objective is not positive semidefinite as expected for a minimization problem.", "args": {}}, {"caml-name": "ERR_OBJ_Q_NOT_NSD", "name": "err_obj_q_not_nsd", "brief": "The quadratic coefficient matrix in the objective is not NSD.", "desc": "The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem. The parameter :msk:dparam:`check_convexity_rel_tol` can be used to relax the convexity check.", "value": "1296", "msg": "The quadratic coefficient matrix in the objective is not negative semidefinite as expected for a maximization problem.", "args": {}}, {"caml-name": "ERR_ARGUMENT_PERM_ARRAY", "name": "err_argument_perm_array", "brief": "An invalid permutation array is specified.", "value": "1299", "msg": "An invalid permutation array named '%{arg0}' is supplied. Position %{arg1} has the invalid value %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_CONE_INDEX", "name": "err_cone_index", "brief": "An index of a non-existing cone has been specified.", "value": "1300", "msg": "No cone has index '%{arg0}'.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_SIZE", "name": "err_cone_size", "brief": "A cone with incorrect number of members is specified.", "value": "1301", "msg": "Wrong number of variables in the cone. %{arg0} %{arg1} members are required for cones of type %{arg2}.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_CONE_OVERLAP", "name": "err_cone_overlap", "brief": "One or more of variables in the cone to be added is already member of another cone.", "desc": "One or more of the variables in the cone to be added is already member of another cone. Now assume the variable is :math:`x_j` then add a new variable say\n:math:`x_k` and the constraint\n\n.. math::\n   x_j = x_k\n\nand then let :math:`x_k` be member of the cone to be appended.", "value": "1302", "msg": "Variable '%{arg0}' (%{arg1}) is a member of cone '%{arg2}' (%{arg3}) and cone '%{arg4}' (%{arg5}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []], "arg4": ["arg4", "s", []], "arg5": ["arg5", "i", []]}}, {"caml-name": "ERR_CONE_REP_VAR", "name": "err_cone_rep_var", "brief": "A variable is included multiple times in the cone.", "value": "1303", "msg": "Variable '%{arg0}' (%{arg1}) are included multiple times in a cone.).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_MAXNUMCONE", "name": "err_maxnumcone", "brief": "The value specified for maxnumcone is too small.", "desc": "The value specified for ``maxnumcone`` is too small.", "value": "1304", "msg": "The value %{arg0} specified for maxnumcone is too small.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_TYPE", "name": "err_cone_type", "brief": "Invalid cone type specified.", "value": "1305", "msg": "%{arg0} is an invalid cone type specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_TYPE_STR", "name": "err_cone_type_str", "brief": "Invalid cone type specified.", "value": "1306", "msg": "%{arg0} is an invalid cone type specified.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CONE_OVERLAP_APPEND", "name": "err_cone_overlap_append", "brief": "The cone to be appended has one variable which is already member of another cone.", "value": "1307", "msg": "Variable '%{arg0}' (%{arg1}) is a member of cone '%{arg2}' (%{arg3}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_REMOVE_CONE_VARIABLE", "name": "err_remove_cone_variable", "brief": "A variable cannot be removed because it will make a cone invalid.", "value": "1310", "msg": "If variable %{arg0} ('%{arg1}') is removed, then cone %{arg2} ('%{arg3}') will be invalid.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []]}}, {"caml-name": "ERR_APPENDING_TOO_BIG_CONE", "name": "err_appending_too_big_cone", "brief": "Trying to append a too big cone.", "value": "1311", "msg": "Tyring to append a too big cone.", "args": {}}, {"caml-name": "ERR_CONE_PARAMETER", "name": "err_cone_parameter", "brief": "An invalid cone parameter.", "value": "1320", "msg": "An invalid cone parameter value of %{arg0} is specified.", "args": {"arg0": ["arg0", "e", []]}}, {"caml-name": "ERR_SOL_FILE_INVALID_NUMBER", "name": "err_sol_file_invalid_number", "brief": "An invalid number is specified in a solution file.", "value": "1350", "msg": "The invalid number '%{arg0}' is specified in a solution file.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_HUGE_C", "name": "err_huge_c", "brief": "A huge value in absolute size is specified for an objective coefficient.", "desc": "A huge value in absolute size is specified for one :math:`c_j`.", "value": "1375", "msg": "A large value of %{arg0} has been specified in cx for variable '%{arg1}' (%{arg2}).", "args": {"arg0": ["arg0", "e", ["j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_HUGE_AIJ", "name": "err_huge_aij", "brief": "A numerically huge value is specified for an element in A.", "desc": "A numerically huge value is specified for an :math:`a_{i,j}` element in :math:`A`.  The parameter  :msk:dparam:`data_tol_aij_huge` controls when an :math:`a_{i,j}` is considered huge.", "value": "1380", "msg": "The A matrix contains a huge value of %{arg0} in constraint '%{arg1}' (%{arg2}) at variable '%{arg3}' (%{arg4}).", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "ERR_DUPLICATE_AIJ", "name": "err_duplicate_aij", "brief": "An element in the A matrix is specified twice.", "value": "1385", "msg": "The A matrix element at constraint '%{arg1}' (%{arg2}), variable '%{arg3}' (%{arg4}) is specfied twice.", "args": {"arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []], "arg3": ["arg3", "s", []], "arg4": ["arg4", "i", []]}}, {"caml-name": "ERR_LOWER_BOUND_IS_A_NAN", "name": "err_lower_bound_is_a_nan", "brief": "The lower bound specified is not a number (nan).", "value": "1390", "msg": "The lower bound specified is not a number (nan).", "args": {}}, {"caml-name": "ERR_UPPER_BOUND_IS_A_NAN", "name": "err_upper_bound_is_a_nan", "brief": "The upper bound specified is not a number (nan).", "value": "1391", "msg": "The upper bound specified is not a number (nan).", "args": {}}, {"caml-name": "ERR_INFINITE_BOUND", "name": "err_infinite_bound", "brief": "A numerically huge bound value is specified.", "value": "1400", "msg": "A numerically huge bound value is specified.", "args": {}}, {"caml-name": "ERR_INV_QOBJ_SUBI", "name": "err_inv_qobj_subi", "brief": "Invalid value %d at qosubi.", "desc": "Invalid value in ``qosubi``.", "value": "1401", "msg": "Invalid value %{arg0} at qosubi[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QOBJ_SUBJ", "name": "err_inv_qobj_subj", "brief": "Invalid value in qosubj.", "desc": "Invalid value in ``qosubj``.", "value": "1402", "msg": "Invalid value %{arg0} at qosubj[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QOBJ_VAL", "name": "err_inv_qobj_val", "brief": "Invalid value in qoval.", "desc": "Invalid value in ``qoval``.", "value": "1403", "msg": "Invalid value %{arg0} at qoval[%{arg1}].", "args": {"arg0": ["arg0", "e", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBK", "name": "err_inv_qcon_subk", "brief": "Invalid value in qcsubk.", "desc": "Invalid value in ``qcsubk``.", "value": "1404", "msg": "Invalid value %{arg0} at qcsubk[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBI", "name": "err_inv_qcon_subi", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1405", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_SUBJ", "name": "err_inv_qcon_subj", "brief": "Invalid value in qcsubj.", "desc": "Invalid value in ``qcsubj``.", "value": "1406", "msg": "Invalid value %{arg0} at qcsubj[%{arg1}].", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INV_QCON_VAL", "name": "err_inv_qcon_val", "brief": "Invalid value in qcval.", "desc": "Invalid value in ``qcval``.", "value": "1407", "msg": "Invalid value (inf or nan) in constraint %{arg0}, quadratic element (%{arg1},%{arg2}).", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QCON_SUBI_TOO_SMALL", "name": "err_qcon_subi_too_small", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1408", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}]. It should be >= %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QCON_SUBI_TOO_LARGE", "name": "err_qcon_subi_too_large", "brief": "Invalid value in qcsubi.", "desc": "Invalid value in ``qcsubi``.", "value": "1409", "msg": "Invalid value %{arg0} at qcsubi[%{arg1}]. It should be < %{arg2}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_QOBJ_UPPER_TRIANGLE", "name": "err_qobj_upper_triangle", "brief": "An element in the upper triangle of the quadratic term in the objective is specified.", "desc": "An element in the upper triangle of :math:`Q^o` is specified. Only elements in the lower triangle should be specified.", "value": "1415", "msg": "Only elements in the lower triangle of the quadratic term in the objective should be specified. The element q[%{arg0},%{arg1}] is in the upper triangle.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_QCON_UPPER_TRIANGLE", "name": "err_qcon_upper_triangle", "brief": "An element in the upper triangle of the quadratic term in a constraint.", "desc": "An element in the upper triangle of a :math:`Q^k` is specified. Only elements in the lower triangle should be specified.", "value": "1417", "msg": "Only elements in the lower triangle of the quadratic terms should be specified. The element q[%{arg0},%{arg1}] is in the upper triangle of %{arg2}th constraint is specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_FIXED_BOUND_VALUES", "name": "err_fixed_bound_values", "brief": "A fixed constraint/variable has been specified using the bound keys but the numerical bounds are different.", "desc": "A fixed constraint/variable has been specified using the bound keys but the numerical value of the lower and upper\nbound is different.", "value": "1420", "msg": "For a fixed constraint/variable the specified lower bound %{arg0} and upper bound %{arg1} are different.", "args": {"arg0": ["arg0", "e", ["w=24", "j=r", "p=16"]], "arg1": ["arg1", "e", ["w=24", "j=r", "p=16"]]}}, {"caml-name": "ERR_TOO_SMALL_A_TRUNCATION_VALUE", "name": "err_too_small_a_truncation_value", "brief": "A too small value for the A trucation value is specified.", "value": "1421", "msg": "A truncation value of %{arg0} is too small. It greater or equal to %{arg1}.", "args": {"arg0": ["arg0", "e", []], "arg1": ["arg1", "e", []]}}, {"caml-name": "ERR_INVALID_OBJECTIVE_SENSE", "name": "err_invalid_objective_sense", "brief": "An invalid objective sense is specified.", "value": "1445", "msg": "%{arg0} is an invalid objective sense code.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_UNDEFINED_OBJECTIVE_SENSE", "name": "err_undefined_objective_sense", "brief": "The objective sense has not been specified before the optimization.", "value": "1446", "msg": "The objective sense has not been specified before the optimization.", "args": {}}, {"caml-name": "ERR_Y_IS_UNDEFINED", "name": "err_y_is_undefined", "brief": "The solution item y is undefined.", "desc": "The solution item :math:`y` is undefined.", "value": "1449", "msg": "The solution term y is undefined.", "args": {}}, {"caml-name": "ERR_NAN_IN_DOUBLE_DATA", "name": "err_nan_in_double_data", "brief": "An invalid floating value was used in some double data.", "desc": "An invalid floating point value was used in some double data.", "value": "1450", "msg": "The parameter '%{arg0}' contained an invalid floating value.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INF_IN_DOUBLE_DATA", "name": "err_inf_in_double_data", "brief": "An infinite floating value was used in some double data.", "desc": "An infinite floating point value was used in some double data.", "value": "1451", "msg": "The parameter '%{arg0}' contained an infinite floating value.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_NAN_IN_BLC", "name": "err_nan_in_blc", "brief": "blc contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`l^c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1461", "msg": "The bound vector blc contains an invalid value for constraint '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BUC", "name": "err_nan_in_buc", "brief": "buc contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`u^c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1462", "msg": "The bound vector buc contains an invalid value for constraint '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_CFIX", "name": "err_invalid_cfix", "brief": "An invalid fixed term in the objective is speficied.", "value": "1469", "msg": "An invalid fixed term in the objective is speficied.", "args": {}}, {"caml-name": "ERR_NAN_IN_C", "name": "err_nan_in_c", "brief": "c contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`c` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1470", "msg": "The objective vector c contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BLX", "name": "err_nan_in_blx", "brief": "blx contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`l^x` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1471", "msg": "The bound vector blx contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_NAN_IN_BUX", "name": "err_nan_in_bux", "brief": "bux contains an invalid floating point value, i.e. a NaN.", "desc": ":math:`u^x` contains an invalid floating point value, i.e. a ``NaN``.", "value": "1472", "msg": "The bound vector bux contains an invalid value for variable '%{arg0}' (%{arg1}).", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_AIJ", "name": "err_invalid_aij", "brief": "a[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`a_{i,j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1473", "msg": "The value of the A matrix element in constraint '%{arg0}' (%{arg1}) for variable '%{arg2}' (%{arg3}) is invalid.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []], "arg3": ["arg3", "i", []]}}, {"caml-name": "ERR_INVALID_CJ", "name": "err_invalid_cj", "brief": "c[j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`c_{j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1474", "msg": "The value of the c elementforvariablet '%{arg0}' (%{arg1}) is invalid.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID", "name": "err_sym_mat_invalid", "brief": "A symmetric matrix contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": "A symmetric matrix contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "1480", "msg": "Position [%{arg0},'%{arg1}'] is an invalid floating point value.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_HUGE", "name": "err_sym_mat_huge", "brief": "A numerically huge value is specified for an element in E.", "desc": "A symmetric matrix contains a huge value in absolute size. The parameter  :msk:dparam:`data_sym_mat_tol_huge` controls when an :math:`e_{i,j}` is considered huge.", "value": "1482", "msg": "Position [%{arg1},%{arg2}] = %{arg0} is huge in absolute size.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_INV_PROBLEM", "name": "err_inv_problem", "brief": "Invalid problem type.", "desc": "Invalid problem type. Probably a nonconvex problem has been specified.", "value": "1500", "msg": "Invalid problem type.", "args": {}}, {"caml-name": "ERR_MIXED_CONIC_AND_NL", "name": "err_mixed_conic_and_nl", "brief": "The problem contains both conic and nonlinear constraints.", "desc": "The problem contains nonlinear terms conic constraints. The requested operation cannot be applied to this type of problem.", "value": "1501", "msg": "The problem contains both conic and nonlinear constraints.", "args": {}}, {"caml-name": "ERR_GLOBAL_INV_CONIC_PROBLEM", "name": "err_global_inv_conic_problem", "brief": "The global optimizer can only be applied to problems without semidefinite variables.", "value": "1503", "msg": "The global optimizer can only be applied to problems without semidefinite variables. This usually means the user tried to solve a mixed-integer semidefinite problem.", "args": {}}, {"caml-name": "ERR_INV_OPTIMIZER", "name": "err_inv_optimizer", "brief": "An invalid optimizer has been chosen for the problem.", "value": "1550", "msg": "An invalid optimizer (index=%{arg0}) has been chosen for the problem.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_MIO_NO_OPTIMIZER", "name": "err_mio_no_optimizer", "brief": "No optimizer is available for the current class of integer optimization problems.", "value": "1551", "msg": "No integer optimizer is available for the optimization problem.", "args": {}}, {"caml-name": "ERR_NO_OPTIMIZER_VAR_TYPE", "name": "err_no_optimizer_var_type", "brief": "No optimizer is available for this class of optimization problems.", "value": "1552", "msg": "No optimizer is available for optimization problems containing variables of type '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_FINAL_SOLUTION", "name": "err_final_solution", "brief": "An error occurred during the solution finalization.", "value": "1560", "msg": "An error occurred during the solution finalization.", "args": {}}, {"caml-name": "ERR_FIRST", "name": "err_first", "brief": "Invalid first.", "desc": "Invalid ``first``.", "value": "1570", "msg": "Invalid index first. A given index as out of expected range, first was %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_LAST", "name": "err_last", "brief": "Invalid last.", "desc": "Invalid index ``last``. A given index was out of expected range.", "value": "1571", "msg": "Invalid index last. A given index was out of expected range, last was %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SLICE_SIZE", "name": "err_slice_size", "brief": "Invalid slice size specified.", "value": "1572", "msg": "The value %{arg0} of is an invalid slice size.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_NEGATIVE_SURPLUS", "name": "err_negative_surplus", "brief": "Negative surplus.", "value": "1573", "msg": "Negative surplus.", "args": {}}, {"caml-name": "ERR_NEGATIVE_APPEND", "name": "err_negative_append", "brief": "Cannot append a negative number.", "value": "1578", "msg": "Cannot append %{arg0} of %{arg1}. The number must be nonnegative.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_POSTSOLVE", "name": "err_postsolve", "brief": "An error occurred during the postsolve.", "desc": "An error occurred during the postsolve. Please contact |mosek| support.", "value": "1580", "msg": "An error occurred during the postsolve.", "args": {}}, {"caml-name": "ERR_OVERFLOW", "name": "err_overflow", "brief": "A computation produced an overflow.", "desc": "A computation produced an overflow i.e. a very large number.", "value": "1590", "msg": "A computation produced an overflow.", "args": {}}, {"caml-name": "ERR_NO_BASIS_SOL", "name": "err_no_basis_sol", "brief": "No basic solution is defined.", "value": "1600", "msg": "No basic solution is defined.", "args": {}}, {"caml-name": "ERR_BASIS_FACTOR", "name": "err_basis_factor", "brief": "The factorization of the basis is invalid.", "value": "1610", "msg": "The factorization of the basis is invalid.", "args": {}}, {"caml-name": "ERR_BASIS_SINGULAR", "name": "err_basis_singular", "brief": "The basis is singular.", "desc": "The basis is singular and hence cannot be factored.", "value": "1615", "msg": "The basis is singular.", "args": {}}, {"caml-name": "ERR_FACTOR", "name": "err_factor", "brief": "An error occurred while factorizing a matrix.", "value": "1650", "msg": "An error occurred while factorizing a matrix.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_CANNOT_RELAX", "name": "err_feasrepair_cannot_relax", "brief": "An optimization problem cannot be relaxed.", "value": "1700", "msg": "An optimization problem cannot be relaxed.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_SOLVING_RELAXED", "name": "err_feasrepair_solving_relaxed", "brief": "The relaxed problem could not be solved to optimality.", "desc": "The relaxed problem could not be solved to optimality. Please consult the log file for further details.", "value": "1701", "msg": "The relaxed problem could not be solved to optimality.", "args": {}}, {"caml-name": "ERR_FEASREPAIR_INCONSISTENT_BOUND", "name": "err_feasrepair_inconsistent_bound", "brief": "The upper bound is less than the lower bound for a variable or a constraint.", "desc": "The upper bound is less than the lower bound for a variable or a constraint.\nPlease correct this before running the feasibility repair.", "value": "1702", "msg": "The %{arg0} '%{arg1}' with index '%{arg2}' has lower bound larger than upper bound.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_REPAIR_INVALID_PROBLEM", "name": "err_repair_invalid_problem", "brief": "The feasibility repair does not support the specified problem type.", "value": "1710", "msg": "The feasibility repair does not support to the specified problem type.", "args": {}}, {"caml-name": "ERR_REPAIR_OPTIMIZATION_FAILED", "name": "err_repair_optimization_failed", "brief": "Computation the optimal relaxation failed.", "desc": "Computation the optimal relaxation failed. The cause may have been numerical problems.", "value": "1711", "msg": "Computation the optimal relaxation failed.", "args": {}}, {"caml-name": "ERR_NAME_MAX_LEN", "name": "err_name_max_len", "brief": "A name is longer than the buffer that is supposed to hold it.", "value": "1750", "msg": "A name('%{arg0}') of length %{arg1} is longer than the buffer of length %{arg2} that is supposed to hold it.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_NAME_IS_NULL", "name": "err_name_is_null", "brief": "The name buffer is a null pointer.", "desc": "The name buffer is a |null| pointer.", "value": "1760", "msg": "The name buffer is a null pointer.", "args": {}}, {"caml-name": "ERR_INVALID_COMPRESSION", "name": "err_invalid_compression", "brief": "Invalid compression type.", "value": "1800", "msg": "%{arg0} is an invalid compression type.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INVALID_IOMODE", "name": "err_invalid_iomode", "brief": "Invalid io mode.", "value": "1801", "msg": "%{arg0} is an io mode.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_PRIMAL_INFEAS_CER", "name": "err_no_primal_infeas_cer", "brief": "A certificate of primal infeasibility is not available.", "value": "2000", "msg": "A certificate of primal infeasibility is not available.", "args": {}}, {"caml-name": "ERR_NO_DUAL_INFEAS_CER", "name": "err_no_dual_infeas_cer", "brief": "A certificate of dual infeasibility is not available.", "desc": "A certificate of infeasibility is not available.", "value": "2001", "msg": "A certificate of dual infeasibility is not available.", "args": {}}, {"caml-name": "ERR_NO_SOLUTION_IN_CALLBACK", "name": "err_no_solution_in_callback", "brief": "The required solution is not available.", "value": "2500", "msg": "The required solution is not available.", "args": {}}, {"caml-name": "ERR_INV_MARKI", "name": "err_inv_marki", "brief": "Invalid value in marki.", "value": "2501", "msg": "Invalid value in marki[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_MARKJ", "name": "err_inv_markj", "brief": "Invalid value in markj.", "value": "2502", "msg": "Invalid value in markj[%{arg0}].", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_INV_NUMI", "name": "err_inv_numi", "brief": "Invalid numi.", "value": "2503", "msg": "Invalid numi.", "args": {}}, {"caml-name": "ERR_INV_NUMJ", "name": "err_inv_numj", "brief": "Invalid numj.", "value": "2504", "msg": "Invalid numj.", "args": {}}, {"caml-name": "ERR_TASK_INCOMPATIBLE", "name": "err_task_incompatible", "brief": "The Task file is incompatible with this platform.", "desc": "The Task file is incompatible with this platform. This results from reading a file on a 32 bit platform generated on a 64 bit platform.", "value": "2560", "msg": "The Task file is incompatible with this platform.", "args": {}}, {"caml-name": "ERR_TASK_INVALID", "name": "err_task_invalid", "brief": "The Task file is invalid.", "value": "2561", "msg": "The Task file is invalid.", "args": {}}, {"caml-name": "ERR_TASK_WRITE", "name": "err_task_write", "brief": "Failed to write the task file.", "value": "2562", "msg": "Failed to write the task file.", "args": {}}, {"caml-name": "ERR_LU_MAX_NUM_TRIES", "name": "err_lu_max_num_tries", "brief": "Could not compute the LU factors of the matrix within the maximum number of allowed tries.", "value": "2800", "msg": "Could not compute the LU factors of the matrix within the maximum number of allowed tries.", "args": {}}, {"caml-name": "ERR_INVALID_UTF8", "name": "err_invalid_utf8", "brief": "An invalid UTF8 string is encountered.", "value": "2900", "msg": "An invalid UTF8 string is encountered.", "args": {}}, {"caml-name": "ERR_INVALID_WCHAR", "name": "err_invalid_wchar", "brief": "An invalid wchar string is encountered.", "desc": "An invalid ``wchar`` string is encountered.", "value": "2901", "msg": "An invalid wchar string is encountered.", "args": {}}, {"caml-name": "ERR_NO_DUAL_FOR_ITG_SOL", "name": "err_no_dual_for_itg_sol", "brief": "No dual information is available for the integer solution.", "value": "2950", "msg": "No dual information is available for the integer solution.", "args": {}}, {"caml-name": "ERR_NO_SNX_FOR_BAS_SOL", "name": "err_no_snx_for_bas_sol", "brief": "snx is not available for the basis solution.", "desc": ":math:`s_n^x` is not available for the basis solution.", "value": "2953", "msg": "snx is not available the basis solution.", "args": {}}, {"caml-name": "ERR_INTERNAL", "name": "err_internal", "brief": "An internal error occurred.", "desc": "An internal error occurred. Please report this problem.", "value": "3000", "msg": "An internal error occurred '%{arg0}'.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_API_ARRAY_TOO_SMALL", "name": "err_api_array_too_small", "brief": "An input array was too short.", "value": "3001", "msg": "The input array '%{arg0}' is too short in call to '%{arg1}'.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_API_CB_CONNECT", "name": "err_api_cb_connect", "brief": "Failed to connect a callback object.", "value": "3002", "msg": "Failed to connect a callback object.", "args": {}}, {"caml-name": "ERR_API_FATAL_ERROR", "name": "err_api_fatal_error", "brief": "An internal error occurred in the API. Please report this problem.", "value": "3005", "msg": "An internal error occurred in the %{arg0} API: %{arg1}", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_API_INTERNAL", "name": "err_api_internal", "brief": "An internal fatal error occurred in an interface function.", "value": "3999", "msg": "An internal fatal error occurred in an interface function", "args": {}}, {"caml-name": "ERR_SEN_FORMAT", "name": "err_sen_format", "brief": "Syntax error in sensitivity analysis file.", "value": "3050", "msg": "Syntax error in sensitivity analysis file at line number: %{arg0}. %{arg1}", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_SEN_UNDEF_NAME", "name": "err_sen_undef_name", "brief": "An undefined name was encountered in the sensitivity analysis file.", "value": "3051", "msg": "Name '%{arg0}' on line %{arg1} not defined.", "args": {"arg0": ["arg0", "s", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_INDEX_RANGE", "name": "err_sen_index_range", "brief": "Index out of range in the sensitivity analysis file.", "value": "3052", "msg": "Index '%{arg0}' out of range at line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_BOUND_INVALID_UP", "name": "err_sen_bound_invalid_up", "brief": "Analysis of upper bound requested for an index, where no upper bound exists.", "value": "3053", "msg": "No upper bound for index '%{arg0}' given in line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_BOUND_INVALID_LO", "name": "err_sen_bound_invalid_lo", "brief": "Analysis of lower bound requested for an index, where no lower bound exists.", "value": "3054", "msg": "No lower bound for index '%{arg0}' given in line %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SEN_INDEX_INVALID", "name": "err_sen_index_invalid", "brief": "Invalid range given in the sensitivity file.", "value": "3055", "msg": "The index range %{arg0}-%{arg1} in line %{arg2} is invalid.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SEN_INVALID_REGEXP", "name": "err_sen_invalid_regexp", "brief": "Syntax error in regexp or regexp longer than 1024.", "value": "3056", "msg": "Syntax error in regexp on line %{arg0}: %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_SEN_SOLUTION_STATUS", "name": "err_sen_solution_status", "brief": "No optimal solution found to the original problem given for sensitivity analysis.", "value": "3057", "msg": "No optimal solution found to the original problem given for sensitivity analysis. Solution status = %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SEN_NUMERICAL", "name": "err_sen_numerical", "brief": "Numerical difficulties encountered performing the sensitivity analysis.", "value": "3058", "msg": "Numerical difficulties encountered performing the sensitivity analysis.", "args": {}}, {"caml-name": "ERR_SEN_UNHANDLED_PROBLEM_TYPE", "name": "err_sen_unhandled_problem_type", "brief": "Sensitivity analysis cannot be performed for the specified problem.", "desc": "Sensitivity analysis cannot be performed for the specified problem. Sensitivity analysis is only possible for linear problems.", "value": "3080", "msg": "Sensitivity analysis cannot be performed for the specified problem.", "args": {}}, {"caml-name": "ERR_UNB_STEP_SIZE", "name": "err_unb_step_size", "brief": "A step-size in an optimizer was unexpectedly unbounded.", "desc": "A step size in an optimizer was unexpectedly unbounded. For instance, if the step-size becomes unbounded in phase 1 of the simplex algorithm then an error occurs. Normally this will happen only if the problem is badly formulated. Please contact |mosek| support if this error occurs.", "value": "3100", "msg": "A step-size in an optimizer was unexpectedly unbounded.", "args": {}}, {"caml-name": "ERR_IDENTICAL_TASKS", "name": "err_identical_tasks", "brief": "Some tasks related to this function call were identical. Unique tasks were expected.", "value": "3101", "msg": "Some tasks related to this function call were identical. Unique tasks were expected.", "args": {}}, {"caml-name": "ERR_AD_INVALID_CODELIST", "name": "err_ad_invalid_codelist", "brief": "The code list data was invalid.", "value": "3102", "msg": "Invalid code list data.", "args": {}}, {"caml-name": "ERR_INTERNAL_TEST_FAILED", "name": "err_internal_test_failed", "brief": "An internal unit test function failed.", "value": "3500", "msg": "Internal unit test function failed.", "args": {}}, {"caml-name": "ERR_XML_INVALID_PROBLEM_TYPE", "name": "err_xml_invalid_problem_type", "brief": "The problem type is not supported by the XML format.", "value": "3600", "msg": "The problem type %{arg0} is not supported by the XML format.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_INVALID_AMPL_STUB", "name": "err_invalid_ampl_stub", "brief": "Invalid AMPL stub.", "value": "3700", "msg": "Invalid AMPL stub.", "args": {}}, {"caml-name": "ERR_INT64_TO_INT32_CAST", "name": "err_int64_to_int32_cast", "brief": "A 64 bit integer could not be cast to a 32 bit integer.", "value": "3800", "msg": "A 64 bit integer could not be cast to a 32 bit integer.", "args": {}}, {"caml-name": "ERR_SIZE_LICENSE_NUMCORES", "name": "err_size_license_numcores", "brief": "The computer contains more cpu cores than the license allows for.", "value": "3900", "msg": "The number of cpu cores detected is '%{arg0}', the license allows for only '%{arg1}' cpu cores for feature '%{arg2}'.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "s", []]}}, {"caml-name": "ERR_INFEAS_UNDEFINED", "name": "err_infeas_undefined", "brief": "The requested value is not defined for this solution type.", "value": "3910", "msg": "The requested value '%{arg0}' is not defined for this solution type.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_NO_BARX_FOR_SOLUTION", "name": "err_no_barx_for_solution", "brief": "There is no barx available for the solution specified.", "desc": "There is no :math:`\\barX` available for the solution specified. In particular note there are no :math:`\\barX` defined for the basic and integer solutions.", "value": "3915", "msg": "There is no barx available for the solution type %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_BARS_FOR_SOLUTION", "name": "err_no_bars_for_solution", "brief": "There is no bars available for the solution specified.", "desc": "There is no :math:`\\bar{s}` available for the solution specified. In particular note there are no :math:`\\bar{s}` defined for the basic and integer solutions.", "value": "3916", "msg": "There is no bars available for the solution type %{arg0}.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_BAR_VAR_DIM", "name": "err_bar_var_dim", "brief": "The dimension of a symmetric matrix variable has to be greater than 0.", "value": "3920", "msg": "The dimension %{arg0} for a symmetric matrix variable is invalid.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_ROW_INDEX", "name": "err_sym_mat_invalid_row_index", "brief": "A row index specified for sparse symmetric matrix is invalid.", "value": "3940", "msg": "The row index %{arg0} specified for sparse symmetric is invalid. The valid range is [%{arg1},%{arg2}[.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_COL_INDEX", "name": "err_sym_mat_invalid_col_index", "brief": "A column index specified for sparse symmetric matrix is invalid.", "value": "3941", "msg": "The column index %{arg0} specified for sparse symmetric matrix is invalid. The valid range is [%{arg1},%{arg2}[.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_SYM_MAT_NOT_LOWER_TRINGULAR", "name": "err_sym_mat_not_lower_tringular", "brief": "Only the lower triangular part of sparse symmetric matrix should be specified.", "value": "3942", "msg": "An element in the upper triangular part at row %{arg0} in column %{arg1} has been specified.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_INVALID_VALUE", "name": "err_sym_mat_invalid_value", "brief": "The numerical value specified in a sparse symmetric matrix is not a floating point value.", "value": "3943", "msg": "The value specified in row %{arg0} at column %{arg1} is not a valid floaing value.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_SYM_MAT_DUPLICATE", "name": "err_sym_mat_duplicate", "brief": "A value in a symmetric matric as been specified more than once.", "value": "3944", "msg": "The value (%{arg0},%{arg1}) in a sparse symmetric has been specified twice at position %{arg2} and position %{arg3}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []], "arg2": ["arg2", "l", []], "arg3": ["arg3", "l", []]}}, {"caml-name": "ERR_INVALID_SYM_MAT_DIM", "name": "err_invalid_sym_mat_dim", "brief": "A sparse symmetric matrix of invalid dimension is specified.", "value": "3950", "msg": "Expected a symmetric matrix of dimension %{arg0} but the specified dimension is %{arg1}.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT", "name": "err_invalid_file_format_for_sym_mat", "brief": "The file format does not support a problem with symmetric matrix variables.", "value": "4000", "msg": "The specified file format does not support a problem with symmetric matrix variables.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_CFIX", "name": "err_invalid_file_format_for_cfix", "brief": "The file format does not support a problem with nonzero fixed term in c.", "value": "4001", "msg": "The specified file format does not support a problem with  nonzero fixed term in c.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS", "name": "err_invalid_file_format_for_ranged_constraints", "brief": "The file format does not support a problem with ranged constraints.", "value": "4002", "msg": "The specified file format does not support a problem with ranged constraints.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS", "name": "err_invalid_file_format_for_free_constraints", "brief": "The file format does not support a problem with free constraints.", "value": "4003", "msg": "The specified file format does not support a problem with free constraints.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_CONES", "name": "err_invalid_file_format_for_cones", "brief": "The file format does not support a problem with the simple cones (deprecated).", "value": "4005", "msg": "The specified file format does not support a problem with the simple cones (deprecated).", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_QUADRATIC_TERMS", "name": "err_invalid_file_format_for_quadratic_terms", "brief": "The file format does not support a problem with quadratic terms.", "value": "4006", "msg": "The specified file format does not support a problem with quadratic terms (QO, QCQO).", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR", "name": "err_invalid_file_format_for_nonlinear", "brief": "The file format does not support a problem with nonlinear terms.", "value": "4010", "msg": "The specified file format does not support a problem with nonlinear terms.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_DISJUNCTIVE_CONSTRAINTS", "name": "err_invalid_file_format_for_disjunctive_constraints", "brief": "The file format does not support a problem with disjunctive constraints.", "value": "4011", "msg": "The file format does not support a problem with disjunctive constraints. Use the PTF format instead.", "args": {}}, {"caml-name": "ERR_INVALID_FILE_FORMAT_FOR_AFFINE_CONIC_CONSTRAINTS", "name": "err_invalid_file_format_for_affine_conic_constraints", "brief": "The file format does not support a problem with affine conic constraints.", "value": "4012", "msg": "The file format does not support a problem with affine conic constraints. Use the PTF format instead.", "args": {}}, {"caml-name": "ERR_DUPLICATE_CONSTRAINT_NAMES", "name": "err_duplicate_constraint_names", "brief": "Two constraint names are identical.", "value": "4500", "msg": "Constraint number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_VARIABLE_NAMES", "name": "err_duplicate_variable_names", "brief": "Two variable names are identical.", "value": "4501", "msg": "Variable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_BARVARIABLE_NAMES", "name": "err_duplicate_barvariable_names", "brief": "Two barvariable names are identical.", "value": "4502", "msg": "Barvariable number %i and %j is given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_CONE_NAMES", "name": "err_duplicate_cone_names", "brief": "Two cone names are identical.", "value": "4503", "msg": "Cones number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_DOMAIN_NAMES", "name": "err_duplicate_domain_names", "brief": "Two domain names are identical.", "value": "4504", "msg": "Domains number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_DUPLICATE_DJC_NAMES", "name": "err_duplicate_djc_names", "brief": "Two disjunctive constraint names are identical.", "value": "4505", "msg": "Disjunctive constraints number %i and %j are given the same name '%name'.", "args": {"i": ["i", "l", []], "j": ["j", "l", []], "name": ["name", "s", []]}}, {"caml-name": "ERR_NON_UNIQUE_ARRAY", "name": "err_non_unique_array", "brief": "An array does not contain unique elements.", "value": "5000", "msg": "Array '%{arg0}' is not unique.", "args": {"arg0": ["arg0", "s", []]}}, {"caml-name": "ERR_ARGUMENT_IS_TOO_SMALL", "name": "err_argument_is_too_small", "brief": "The value of a function argument is too small.", "value": "5004", "msg": "The value %{arg0} of argument '%{arg1}' is too small.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_ARGUMENT_IS_TOO_LARGE", "name": "err_argument_is_too_large", "brief": "The value of a function argument is too large.", "value": "5005", "msg": "The value %{arg0} of argument '%{arg1}' is too large.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []]}}, {"caml-name": "ERR_MIO_INTERNAL", "name": "err_mio_internal", "brief": "A fatal error occurred in the mixed integer optimizer.  Please contact MOSEK support.", "desc": "A fatal error occurred in the mixed integer optimizer. Please contact |mosek| support.", "value": "5010", "msg": "A fatal error occurred in the mixed integer optimizer. Please contact MOSEK support.", "args": {}}, {"caml-name": "ERR_INVALID_PROBLEM_TYPE", "name": "err_invalid_problem_type", "brief": "An invalid problem type.", "value": "6000", "msg": "An invalid problem type.", "args": {}}, {"caml-name": "ERR_UNHANDLED_SOLUTION_STATUS", "name": "err_unhandled_solution_status", "brief": "Unhandled solution status.", "value": "6010", "msg": "%{arg0} is handled solution status.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_UPPER_TRIANGLE", "name": "err_upper_triangle", "brief": "An element in the upper triangle of a lower triangular matrix is specified.", "value": "6020", "msg": "Only elements in the lower triangle should be specified however an element in position (%arg0,%arg1) is specfied.", "args": {"arg0": ["arg0", "i", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_LAU_SINGULAR_MATRIX", "name": "err_lau_singular_matrix", "brief": "A matrix is singular.", "value": "7000", "msg": "A matrix is singular.", "args": {}}, {"caml-name": "ERR_LAU_NOT_POSITIVE_DEFINITE", "name": "err_lau_not_positive_definite", "brief": "A matrix is not positive definite.", "value": "7001", "msg": "A matrix is singular.", "args": {}}, {"caml-name": "ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX", "name": "err_lau_invalid_lower_triangular_matrix", "brief": "An invalid lower triangular matrix.", "value": "7002", "msg": "An invalid lower triangular matrix.", "args": {}}, {"caml-name": "ERR_LAU_UNKNOWN", "name": "err_lau_unknown", "brief": "An unknown error.", "value": "7005", "msg": "An unknown error.", "args": {}}, {"caml-name": "ERR_LAU_ARG_M", "name": "err_lau_arg_m", "brief": "Invalid argument m.", "value": "7010", "msg": "Invalid argument m.", "args": {}}, {"caml-name": "ERR_LAU_ARG_N", "name": "err_lau_arg_n", "brief": "Invalid argument n.", "value": "7011", "msg": "Invalid argument n.", "args": {}}, {"caml-name": "ERR_LAU_ARG_K", "name": "err_lau_arg_k", "brief": "Invalid argument k.", "value": "7012", "msg": "Invalid argument k.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANSA", "name": "err_lau_arg_transa", "brief": "Invalid argument transa.", "value": "7015", "msg": "Invalid argument transa.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANSB", "name": "err_lau_arg_transb", "brief": "Invalid argument transb.", "value": "7016", "msg": "Invalid argument transb.", "args": {}}, {"caml-name": "ERR_LAU_ARG_UPLO", "name": "err_lau_arg_uplo", "brief": "Invalid argument uplo.", "value": "7017", "msg": "Invalid argument uplo.", "args": {}}, {"caml-name": "ERR_LAU_ARG_TRANS", "name": "err_lau_arg_trans", "brief": "Invalid argument trans.", "value": "7018", "msg": "Invalid argument trans.", "args": {}}, {"caml-name": "ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX", "name": "err_lau_invalid_sparse_symmetric_matrix", "brief": "An invalid sparse symmetric matrix is specfified.", "desc": "An invalid sparse symmetric matrix is specfified. Note only the lower triangular part with no duplicates is specifed.", "value": "7019", "msg": "An invalid sparse symmetric matrix is specfified.", "args": {}}, {"caml-name": "ERR_CBF_PARSE", "name": "err_cbf_parse", "brief": "An error occurred while parsing an CBF file.", "value": "7100", "msg": "(line=%{arg0}) Parse error.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_OBJ_SENSE", "name": "err_cbf_obj_sense", "brief": "An invalid objective sense is specified.", "value": "7101", "msg": "(line=%{arg0}) An invalid objective sense is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_NO_VARIABLES", "name": "err_cbf_no_variables", "brief": "An invalid objective sense is specified.", "desc": "No variables are specified.", "value": "7102", "msg": "(line=%{arg0}) An invalid objective sense is specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_CONSTRAINTS", "name": "err_cbf_too_many_constraints", "brief": "Too many constraints specified.", "value": "7103", "msg": "(line=%{arg0}) Too many constraints specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_VARIABLES", "name": "err_cbf_too_many_variables", "brief": "Too many variables specified.", "value": "7104", "msg": "(line=%{arg0}) Too many variables specified.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_NO_VERSION_SPECIFIED", "name": "err_cbf_no_version_specified", "brief": "No version specified.", "value": "7105", "msg": "No version specified.", "args": {}}, {"caml-name": "ERR_CBF_SYNTAX", "name": "err_cbf_syntax", "brief": "Invalid syntax.", "value": "7106", "msg": "(line=%{arg0}) Invalid syntax.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_OBJ", "name": "err_cbf_duplicate_obj", "brief": "Duplicate OBJ keyword.", "value": "7107", "msg": "(line=%{arg0}) Duplicate OBJ keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_CON", "name": "err_cbf_duplicate_con", "brief": "Duplicate CON keyword.", "value": "7108", "msg": "(line=%{arg0}) Duplicate CON keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_VAR", "name": "err_cbf_duplicate_var", "brief": "Duplicate VAR keyword.", "value": "7110", "msg": "(line=%{arg0}) Duplicate VAR keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_INT", "name": "err_cbf_duplicate_int", "brief": "Duplicate INT keyword.", "value": "7111", "msg": "(line=%{arg0}) Duplicate INT keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_VAR_TYPE", "name": "err_cbf_invalid_var_type", "brief": "Invalid variable type.", "value": "7112", "msg": "(line=%{arg0}) Invalid variable type.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_CON_TYPE", "name": "err_cbf_invalid_con_type", "brief": "Invalid constraint type.", "value": "7113", "msg": "(line=%{arg0}) Invalid constraint type.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_DOMAIN_DIMENSION", "name": "err_cbf_invalid_domain_dimension", "brief": "Invalid domain dimension.", "value": "7114", "msg": "(line=%{arg0}) Invalid domain dimension.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_OBJACOORD", "name": "err_cbf_duplicate_objacoord", "brief": "Duplicate index in OBJCOORD.", "value": "7115", "msg": "Index %{arg0} is duplicate in OBJACORD.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_BCOORD", "name": "err_cbf_duplicate_bcoord", "brief": "Duplicate index in BCOORD.", "value": "7116", "msg": "Index %{arg0} is duplicate in BCOORD.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_ACOORD", "name": "err_cbf_duplicate_acoord", "brief": "Duplicate index in ACOORD.", "value": "7117", "msg": "The element in row %{i} and column %{j} is duplicate in ACOORD.", "args": {"i": ["i", "i", []], "j": ["j", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_VARIABLES", "name": "err_cbf_too_few_variables", "brief": "Too few variables defined.", "value": "7118", "msg": "Expected %{expected} but got only %{got} variables.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_CONSTRAINTS", "name": "err_cbf_too_few_constraints", "brief": "Too few constraints defined.", "value": "7119", "msg": "Expected %{expected} but got only %{got} constraints.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_INTS", "name": "err_cbf_too_few_ints", "brief": "Too ints specified.", "desc": "Too few ints are specified.", "value": "7120", "msg": "Expected %{expected} ints but got %{got}.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_TOO_MANY_INTS", "name": "err_cbf_too_many_ints", "brief": "Too ints specified.", "desc": "Too many ints are specified.", "value": "7121", "msg": "Expected %{expected} ints but got %{got}.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_INT_INDEX", "name": "err_cbf_invalid_int_index", "brief": "Invalid INT index.", "value": "7122", "msg": "(line=%{lineno}) %{index} is an invalid int index.", "args": {"lineno": ["lineno", "l", []], "index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNSUPPORTED", "name": "err_cbf_unsupported", "brief": "Unsupported feature is present.", "value": "7123", "msg": "(line=%{lineno}) An unsupported feature is present.", "args": {"lineno": ["lineno", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_PSDVAR", "name": "err_cbf_duplicate_psdvar", "brief": "Duplicate PSDVAR keyword.", "value": "7124", "msg": "(line=%{arg0}) Duplicate PSDVAR keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDVAR_DIMENSION", "name": "err_cbf_invalid_psdvar_dimension", "brief": "Invalid PSDVAR dimension.", "value": "7125", "msg": "(line=%{arg0}) %{arg1} is an invalid dimension for a PSDVAR variable.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_CBF_TOO_FEW_PSDVAR", "name": "err_cbf_too_few_psdvar", "brief": "Too few variables defined.", "value": "7126", "msg": "Expected %{expected} but got only %{got} PSD variables.", "args": {"expected": ["expected", "i", []], "got": ["got", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_EXP_DIMENSION", "name": "err_cbf_invalid_exp_dimension", "brief": "Invalid dimension of a exponential cone.", "value": "7127", "msg": "Invalid dimension of a exponential cone.", "args": {}}, {"caml-name": "ERR_CBF_DUPLICATE_POW_CONES", "name": "err_cbf_duplicate_pow_cones", "brief": "Multiple POWCONES specified.", "value": "7130", "msg": "Multiple POWCONES specified.", "args": {}}, {"caml-name": "ERR_CBF_DUPLICATE_POW_STAR_CONES", "name": "err_cbf_duplicate_pow_star_cones", "brief": "Multiple POW*CONES specified.", "value": "7131", "msg": "Multiple POW*CONES specified.", "args": {}}, {"caml-name": "ERR_CBF_INVALID_POWER", "name": "err_cbf_invalid_power", "brief": "Invalid power specified.", "value": "7132", "msg": "%{alpha} is an invalid power.", "args": {"alpha": ["alpha", "e", []]}}, {"caml-name": "ERR_CBF_POWER_CONE_IS_TOO_LONG", "name": "err_cbf_power_cone_is_too_long", "brief": "Power cone is too long.", "value": "7133", "msg": "Power cone is too long.", "args": {}}, {"caml-name": "ERR_CBF_INVALID_POWER_CONE_INDEX", "name": "err_cbf_invalid_power_cone_index", "brief": "Invalid power cone index.", "value": "7134", "msg": "%{index} is an invald power cone index.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_POWER_STAR_CONE_INDEX", "name": "err_cbf_invalid_power_star_cone_index", "brief": "Invalid power star cone index.", "value": "7135", "msg": "%{index} is an invald power star cone index.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNHANDLED_POWER_CONE_TYPE", "name": "err_cbf_unhandled_power_cone_type", "brief": "An unhandled power cone type.", "value": "7136", "msg": "POWCONES #%{index} is an unhandled power cone type.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE", "name": "err_cbf_unhandled_power_star_cone_type", "brief": "An unhandled power star cone type.", "value": "7137", "msg": "POW*CONES #%{index} is an unhandled power star cone type.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_POWER_CONE_MISMATCH", "name": "err_cbf_power_cone_mismatch", "brief": "The power cone does not match with it definition.", "value": "7138", "msg": "The power cone does not match POWCONES #%{index}.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_POWER_STAR_CONE_MISMATCH", "name": "err_cbf_power_star_cone_mismatch", "brief": "The power star cone does not match with it definition.", "value": "7139", "msg": "The power star cone does not match POW*CONES #%{index}.", "args": {"index": ["index", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_NUMBER_OF_CONES", "name": "err_cbf_invalid_number_of_cones", "brief": "Invalid number of cones.", "value": "7140", "msg": "%{number} is an invalid number of cones.", "args": {"number": ["number", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_DIMENSION_OF_CONES", "name": "err_cbf_invalid_dimension_of_cones", "brief": "Invalid number of cones.", "value": "7141", "msg": "%{number} is an invalid number of cones.", "args": {"number": ["number", "i", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_OBJACOORD", "name": "err_cbf_invalid_num_objacoord", "brief": "Invalid number of OBJACOORD.", "value": "7150", "msg": "(line=%{arg0}) Invalid number of OBJACOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_OBJFCOORD", "name": "err_cbf_invalid_num_objfcoord", "brief": "Invalid number of OBJFCOORD.", "value": "7151", "msg": "(line=%{arg0}) Invalid number of OBJFCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_ACOORD", "name": "err_cbf_invalid_num_acoord", "brief": "Invalid number of ACOORD.", "value": "7152", "msg": "(line=%{arg0}) Invalid number of ACOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_BCOORD", "name": "err_cbf_invalid_num_bcoord", "brief": "Invalid number of BCOORD.", "value": "7153", "msg": "(line=%{arg0}) Invalid number of BCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_FCOORD", "name": "err_cbf_invalid_num_fcoord", "brief": "Invalid number of FCOORD.", "value": "7155", "msg": "(line=%{arg0}) Invalid number of FCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_HCOORD", "name": "err_cbf_invalid_num_hcoord", "brief": "Invalid number of HCOORD.", "value": "7156", "msg": "(line=%{arg0}) Invalid number of HCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_DCOORD", "name": "err_cbf_invalid_num_dcoord", "brief": "Invalid number of DCOORD.", "value": "7157", "msg": "(line=%{arg0}) Invalid number of DCOORD.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_EXPECTED_A_KEYWORD", "name": "err_cbf_expected_a_keyword", "brief": "Expected a key word.", "value": "7158", "msg": "(line=%{arg0}) Expected a keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_NUM_PSDCON", "name": "err_cbf_invalid_num_psdcon", "brief": "Invalid number of PSDCON.", "value": "7200", "msg": "(line=%{arg0}) Invalid number of PSDCON.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_DUPLICATE_PSDCON", "name": "err_cbf_duplicate_psdcon", "brief": "Duplicate CON keyword.", "value": "7201", "msg": "(line=%{arg0}) Duplicate PSDCON keyword.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_DIMENSION_OF_PSDCON", "name": "err_cbf_invalid_dimension_of_psdcon", "brief": "Invalid PSDCON dimension.", "value": "7202", "msg": "(line=%{arg0}) Invalid PSDCON dimmension.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_INDEX", "name": "err_cbf_invalid_psdcon_index", "brief": "Invalid PSDCON index.", "value": "7203", "msg": "Invalid PSDCON of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_VARIABLE_INDEX", "name": "err_cbf_invalid_psdcon_variable_index", "brief": "Invalid PSDCON index.", "value": "7204", "msg": "Invalid PSDCON variable index of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_INVALID_PSDCON_BLOCK_INDEX", "name": "err_cbf_invalid_psdcon_block_index", "brief": "Invalid PSDCON index.", "value": "7205", "msg": "Invalid PSDCON block index of %{arg2} at coordinate %{arg1}.", "args": {"arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_CBF_UNSUPPORTED_CHANGE", "name": "err_cbf_unsupported_change", "brief": "The CHANGE section is not supported.", "value": "7210", "msg": "The CHANGE section is not supported.", "args": {}}, {"caml-name": "ERR_MIO_INVALID_ROOT_OPTIMIZER", "name": "err_mio_invalid_root_optimizer", "brief": "An invalid root optimizer was selected for the problem type.", "value": "7700", "msg": "An invalid root optimizer was selected for the problem type.", "args": {}}, {"caml-name": "ERR_MIO_INVALID_NODE_OPTIMIZER", "name": "err_mio_invalid_node_optimizer", "brief": "An invalid node optimizer was selected for the problem type.", "value": "7701", "msg": "An invalid node optimizer was selected for the problem type.", "args": {}}, {"caml-name": "ERR_MPS_WRITE_CPLEX_INVALID_CONE_TYPE", "name": "err_mps_write_cplex_invalid_cone_type", "brief": "An invalid cone type occurs when writing a CPLEX formatted MPS file.", "value": "7750", "msg": "An invalid cone type ('%{arg0}') occurs when writing a CPLEX formatted MPS file.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_TOCONIC_CONSTR_Q_NOT_PSD", "name": "err_toconic_constr_q_not_psd", "brief": "The matrix defining the quadratric part of constraint is not positive semidefinite.", "value": "7800", "msg": "(constraint=%{constrno}) : The matrix defining the quadratric part of constraint is not positive semidefinite.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTRAINT_FX", "name": "err_toconic_constraint_fx", "brief": "The quadratic constraint is an equality, thus not convex.", "value": "7801", "msg": "(constraint=%{constrno}) : The quadratic constraint is an equality, thus not convex.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTRAINT_RA", "name": "err_toconic_constraint_ra", "brief": "The quadratic constraint has finite lower and upper bound, and therefore it is not convex.", "value": "7802", "msg": "(constraint=%{constrno}) : The quadratic constraint has finite lower and upper bound, and therefore it is not convex.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_CONSTR_NOT_CONIC", "name": "err_toconic_constr_not_conic", "brief": "The constraint is not conic representable.", "value": "7803", "msg": "(constraint=%{constrno}) : The constraint is not conic representable.", "args": {"constrno": ["constrno", "l", []]}}, {"caml-name": "ERR_TOCONIC_OBJECTIVE_NOT_PSD", "name": "err_toconic_objective_not_psd", "brief": "The matrix defining the quadratric part of the objective function is not positive semidefinite.", "value": "7804", "msg": "The objective function can not not be converted in conic form.", "args": {}}, {"caml-name": "ERR_SERVER_CONNECT", "name": "err_server_connect", "brief": "Failed to connect to remote solver server.", "desc": "Failed to connect to remote solver server. The server\nstring or the port string were invalid, or the server\ndid not accept connection.", "value": "8000", "msg": "Failed to connect to remote solver server (%{server}:%{port}).", "args": {"server": ["server", "s", []], "port": ["port", "s", []]}}, {"caml-name": "ERR_SERVER_PROTOCOL", "name": "err_server_protocol", "brief": "Unexpected message or data from solver server.", "value": "8001", "msg": "Unexpected message or data from solver server.", "args": {}}, {"caml-name": "ERR_SERVER_STATUS", "name": "err_server_status", "brief": "Server returned non-ok status code", "desc": "Server returned non-ok HTTP status code", "value": "8002", "msg": "Server returned status: %{status} %{reason}.", "args": {"status": ["status", "i", []], "reason": ["reason", "s", []]}}, {"caml-name": "ERR_SERVER_TOKEN", "name": "err_server_token", "brief": "Invalid job ID", "desc": "The job ID specified is incorrect or invalid", "value": "8003", "msg": "Invalid job ID %{token}.", "args": {"token": ["token", "s", []]}}, {"caml-name": "ERR_SERVER_ADDRESS", "name": "err_server_address", "brief": "Invalid address", "desc": "Invalid address string", "value": "8004", "msg": "Invalid address string '%{addr}'", "args": {"addr": ["addr", "s", []]}}, {"caml-name": "ERR_SERVER_CERTIFICATE", "name": "err_server_certificate", "brief": "Invalid TLS certificate format or path", "value": "8005", "msg": "Invalid TLS certificate format or path.", "args": {}}, {"caml-name": "ERR_SERVER_TLS_CLIENT", "name": "err_server_tls_client", "brief": "Failed to create TLS client", "desc": "Failed to create TLS cleint", "value": "8006", "msg": "Failed to create TLS client", "args": {}}, {"caml-name": "ERR_SERVER_ACCESS_TOKEN", "name": "err_server_access_token", "brief": "Invalid access token", "value": "8007", "msg": "Invalid access token", "args": {}}, {"caml-name": "ERR_SERVER_PROBLEM_SIZE", "name": "err_server_problem_size", "brief": "The problem is too large.", "desc": "The size of the problem exceeds the dimensions permitted by the instance of the |optserver| where it was run.", "value": "8008", "msg": "The problem is too large", "args": {}}, {"caml-name": "ERR_DUPLICATE_INDEX_IN_A_SPARSE_MATRIX", "name": "err_duplicate_index_in_a_sparse_matrix", "brief": "An element in a sparse matrix is specified twice.", "value": "20050", "msg": "The the element in row '%{arg1}'and column '%{arg2}' is specfied twice.", "args": {"arg1": ["arg1", "i", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_DUPLICATE_INDEX_IN_AFEIDX_LIST", "name": "err_duplicate_index_in_afeidx_list", "brief": "An index is specified twice in an affine expression list.", "value": "20060", "msg": "the index  '%{arg1}' is specified twice in an affine expression list.", "args": {"arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_DUPLICATE_FIJ", "name": "err_duplicate_fij", "brief": "An element in the F matrix is specified twice.", "value": "20100", "msg": "The F matrix element at at row %{arg0} and column %{arg1} is specified twice.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_INVALID_FIJ", "name": "err_invalid_fij", "brief": "f[i,j] contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`f_{i,j}` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20101", "msg": "The value of the f[%{arg0},%{arg1}] is invalid.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "i", []]}}, {"caml-name": "ERR_HUGE_FIJ", "name": "err_huge_fij", "brief": "A numerically huge value is specified for an element in F.", "desc": "A numerically huge value is specified for an :math:`f_{i,j}` element in :math:`F`.  The parameter  :msk:dparam:`data_tol_aij_huge` controls when an :math:`f_{i,j}` is considered huge.", "value": "20102", "msg": "The F matrix contains a huge value of %{arg0} in row %{arg1} and column %{arg2}.", "args": {"arg0": ["arg0", "e", ["w=8", "j=r", "p=1"]], "arg1": ["arg1", "l", []], "arg2": ["arg2", "i", []]}}, {"caml-name": "ERR_INVALID_G", "name": "err_invalid_g", "brief": "g contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`g` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20103", "msg": "The value of g in position %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_INVALID_B", "name": "err_invalid_b", "brief": "b contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": ":math:`b` contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20150", "msg": "The value of b in position %{arg0} is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_INVALID_INDEX", "name": "err_domain_invalid_index", "brief": "A domain index is invalid.", "value": "20400", "msg": "The domain index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_DOMAIN_DIMENSION", "name": "err_domain_dimension", "brief": "A domain dimension is invalid.", "value": "20401", "msg": "The dimension %{arg0} is invalid for this domain. It should be %{arg1} %{arg2}.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "s", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_DOMAIN_DIMENSION_PSD", "name": "err_domain_dimension_psd", "brief": "A PSD domain dimension is invalid.", "value": "20402", "msg": "The dimension %{arg0} is invalid for a positive semi-definite cone domain.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_NOT_POWER_DOMAIN", "name": "err_not_power_domain", "brief": "The function is only applicable to primal and dual power cone domains.", "value": "20403", "msg": "The domain %{arg0} is not a power cone domain.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_INVALID_ALPHA", "name": "err_domain_power_invalid_alpha", "brief": "Alpha contains an invalid floating point value, i.e. a NaN or an infinite value.", "desc": "Alpha contains an invalid floating point value, i.e. a ``NaN`` or an infinite value.", "value": "20404", "msg": "The value of alpha[%{arg0}] is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_NEGATIVE_ALPHA", "name": "err_domain_power_negative_alpha", "brief": "Alpha contains a negative value or zero.", "value": "20405", "msg": "The value of alpha[%{arg0}] not strictly positive.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DOMAIN_POWER_NLEFT", "name": "err_domain_power_nleft", "brief": "The value of nleft is too small or too large.", "desc": "The value of :math:`n_\\mathrm{left}` is not in :math:`[1, n-1]` where :math:`n` is the dimension.", "value": "20406", "msg": "The left dimension '%{arg0}' is invalid. It should belong to the range [1,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_AFE_INVALID_INDEX", "name": "err_afe_invalid_index", "brief": "An affine expression index is invalid.", "value": "20500", "msg": "The affine expression index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_ACC_INVALID_INDEX", "name": "err_acc_invalid_index", "brief": "A affine conic constraint index is invalid.", "value": "20600", "msg": "The affine conic constraint index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_ACC_INVALID_ENTRY_INDEX", "name": "err_acc_invalid_entry_index", "brief": "The index of an element in an affine conic constraint is invalid.", "value": "20601", "msg": "The element index '%{arg0}' is invalid for constraint '%{arg1}'. It should belong to the range [0,%{arg2}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []], "arg2": ["arg2", "l", []]}}, {"caml-name": "ERR_ACC_AFE_DOMAIN_MISMATCH", "name": "err_acc_afe_domain_mismatch", "brief": "There is a mismatch between between the number of affine expressions and total dimension of the domain(s).", "value": "20602", "msg": "The number affine expressions is %{numafe} and the total dimension of the domain(s) is %{n} which is mismatch.", "args": {"numafe": ["numafe", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_INVALID_INDEX", "name": "err_djc_invalid_index", "brief": "A disjunctive constraint index is invalid.", "value": "20700", "msg": "The disjunctive constraint index '%{arg0}' is invalid. It should belong to the range [0,%{arg1}[.", "args": {"arg0": ["arg0", "l", []], "arg1": ["arg1", "l", []]}}, {"caml-name": "ERR_DJC_UNSUPPORTED_DOMAIN_TYPE", "name": "err_djc_unsupported_domain_type", "brief": "An unsupported domain type has been used in a disjunctive constraint.", "value": "20701", "msg": "Domain type '%{arg0}' is unsupported in a disjunctive constraint.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DJC_AFE_DOMAIN_MISMATCH", "name": "err_djc_afe_domain_mismatch", "brief": "There is a mismatch between the number of affine expressions and total dimension of the domain(s).", "value": "20702", "msg": "The number affine expressions is %{numafe} and the total dimension of the domain(s) is %{n} which is mismatch.", "args": {"numafe": ["numafe", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_INVALID_TERM_SIZE", "name": "err_djc_invalid_term_size", "brief": "A termize is invalid.", "value": "20703", "msg": "The term size '%{arg0}' is invalid.", "args": {"arg0": ["arg0", "l", []]}}, {"caml-name": "ERR_DJC_DOMAIN_TERMSIZE_MISMATCH", "name": "err_djc_domain_termsize_mismatch", "brief": "There is a mismatch between the number of domains and the term sizes.", "value": "20704", "msg": "The number of domains is %{numdom} and the total term size is %{n} which is mismatch.", "args": {"numdom": ["numdom", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_DJC_TOTAL_NUM_TERMS_MISMATCH", "name": "err_djc_total_num_terms_mismatch", "brief": "There total number of terms in all domains does not match.", "value": "20705", "msg": "The number of terms is %{numterm} and the sum per domain gives %{n} which is mismatch.", "args": {"numterm": ["numterm", "l", []], "n": ["n", "l", []]}}, {"caml-name": "ERR_UNDEF_SOLUTION", "name": "err_undef_solution", "brief": "The required solution is not defined.", "desc": "|mosek| has the following solution types:\n\n* an interior-point solution,\n* a basic solution,\n* and an integer solution.\n\nEach optimizer may set one or more of these solutions; e.g by default a successful optimization with the interior-point optimizer defines the interior-point solution and, for linear problems, also the basic  solution. This error occurs when asking for a solution  or for information about a solution that is not defined.", "value": "22000", "msg": "The solution with code %{arg0} is not defined.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "ERR_NO_DOTY", "name": "err_no_doty", "brief": "No doty is available.", "desc": "No doty is available", "value": "22010", "msg": "A doty is not available for the solution with code %{arg0} is not defined.", "args": {"arg0": ["arg0", "i", []]}}, {"caml-name": "TRM_MAX_ITERATIONS", "name": "trm_max_iterations", "brief": "The optimizer terminated at the maximum number of iterations.", "value": "100000", "msg": "Maximum number of iterations is exceeded.", "args": {}}, {"caml-name": "TRM_MAX_TIME", "name": "trm_max_time", "brief": "The optimizer terminated at the maximum amount of time.", "value": "100001", "msg": "Maximum amount of time exceeded.", "args": {}}, {"caml-name": "TRM_OBJECTIVE_RANGE", "name": "trm_objective_range", "brief": "The optimizer terminated with an objective value outside the objective range.", "value": "100002", "msg": "The optimal solution has an objective value outside the objective range.", "args": {}}, {"caml-name": "TRM_MIO_NUM_RELAXS", "name": "trm_mio_num_relaxs", "brief": "The mixed-integer optimizer terminated as the maximum number of relaxations was reached.", "value": "100008", "msg": "The mixed-integer optimizer terminated as the maximum number of relaxations was reached.", "args": {}}, {"caml-name": "TRM_MIO_NUM_BRANCHES", "name": "trm_mio_num_branches", "brief": "The mixed-integer optimizer terminated as the maximum number of branches was reached.", "value": "100009", "msg": "The mixed-integer optimizer terminated as the maximum number of branches was reached.", "args": {}}, {"caml-name": "TRM_NUM_MAX_NUM_INT_SOLUTIONS", "name": "trm_num_max_num_int_solutions", "brief": "The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.", "value": "100015", "msg": "The mixed-integer optimizer terminated as the maximum number of feasible solutions was reached.", "args": {}}, {"caml-name": "TRM_STALL", "name": "trm_stall", "brief": "The optimizer is terminated due to slow progress.", "desc": "The optimizer is terminated due to slow progress.\n\nStalling means that numerical problems prevent the optimizer from\nmaking reasonable progress and that it makes no sense to continue.\nIn many cases this happens if the problem is badly scaled or\notherwise ill-conditioned. There is no guarantee that the\nsolution will be feasible or optimal. However, often\nstalling happens near the optimum, and the returned solution may\nbe of good quality. Therefore, it is recommended to check the\nstatus of the solution. If the solution status is optimal the solution is\nmost likely good enough for most practical purposes.\n\nPlease note that if a linear optimization problem is solved using\nthe interior-point optimizer with basis identification turned on,\nthe returned basic solution likely to have high accuracy, even though\nthe optimizer stalled.\n\nSome common causes of stalling are a) badly scaled models, b)\nnear feasible or near infeasible problems.", "value": "100006", "msg": "The optimizer is terminated due to slow progress.", "args": {}}, {"caml-name": "TRM_USER_CALLBACK", "name": "trm_user_callback", "brief": "The user-defined progress callback function terminated the optimization.", "desc": "The optimizer terminated due to the return of\nthe user-defined callback function.", "value": "100007", "msg": "The user-defined progress callback function terminated the optimization.", "args": {}}, {"caml-name": "TRM_MAX_NUM_SETBACKS", "name": "trm_max_num_setbacks", "brief": "The optimizer terminated as the maximum number of set-backs was reached.", "desc": "The optimizer terminated as the maximum number of set-backs was reached.\nThis indicates serious numerical problems and a possibly badly formulated problem.", "value": "100020", "msg": "The optimizer terminated as the maximum number of set-backs was reached.", "args": {}}, {"caml-name": "TRM_NUMERICAL_PROBLEM", "name": "trm_numerical_problem", "brief": "The optimizer terminated due to a numerical problem.", "desc": "The optimizer terminated due to numerical problems.", "value": "100025", "msg": "The optimizer terminated due to a numerical problem.", "args": {}}, {"caml-name": "TRM_LOST_RACE", "name": "trm_lost_race", "brief": "Lost a race.", "value": "100027", "msg": "Lost a race.", "args": {}}, {"caml-name": "TRM_INTERNAL", "name": "trm_internal", "brief": "The optimizer terminated due to some internal reason.", "desc": "The optimizer terminated due to some internal reason. Please contact |mosek| support.", "value": "100030", "msg": "The optimizer terminated due to some internal reason.", "args": {}}, {"caml-name": "TRM_INTERNAL_STOP", "name": "trm_internal_stop", "brief": "The optimizer terminated for internal reasons.", "desc": "The optimizer terminated for internal reasons. Please contact |mosek| support.", "value": "100031", "msg": "The optimizer terminated for internal reasons.", "args": {}}]}}}}, "mosek-version": [10, 1, 10], "jsonais-version": [1, 0, 0]}