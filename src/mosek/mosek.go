package mosek

// #include <stdlib.h>
// #include <mosek.h>
// #cgo LDFLAGS: -lmosek64
// 
// extern void streamfunc_log(void *, char *);
// extern void streamfunc_wrn(void *, char *);
// extern void streamfunc_msg(void *, char *);
// extern void streamfunc_err(void *, char *);
// extern int callbackfunc(void *, void *, int, double *, int *, long long *);
import "C"

import "unsafe"

type Env struct {
        cptr unsafe.Pointer
}

type Task struct {
        cptr unsafe.Pointer
	streamfunc      [4]func(string)
	callbackfunc    func(int32)int
	infcallbackfunc func(int32,[]float64,[]int32,[]int64)int
}

func (t * Task) ptr() C.MSKtask_t { return C.MSKtask_t(t.cptr) }
func (e * Env)  ptr() C.MSKenv_t  { return C.MSKenv_t(e.cptr) }

//export streamfunc_log
func streamfunc_log(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_LOG] != nil { task.streamfunc[STREAM_LOG](C.GoString(msg)) }
}

//export streamfunc_msg
func streamfunc_msg(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_MSG] != nil { task.streamfunc[STREAM_MSG](C.GoString(msg)) }
}

//export streamfunc_wrn
func streamfunc_wrn(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_WRN] != nil { task.streamfunc[STREAM_WRN](C.GoString(msg)) }
}

//export streamfunc_err
func streamfunc_err(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_ERR] != nil { task.streamfunc[STREAM_ERR](C.GoString(msg)) }
}

//export callbackfunc
func callbackfunc(
	nativetask unsafe.Pointer, 
	handle  unsafe.Pointer, 
	code    C.int, 
	dinf  * C.MSKrealt, 
	iinf  * C.MSKint32t, 
	liinf * C.MSKint64t) (C.int) {
	
	task := (*Task)(handle)

	var r int = 0

	if task.infcallbackfunc != nil {
		_dinf  := (*[int(DINF_END)]float64)(unsafe.Pointer(dinf))[0:DINF_END]
		_iinf  := (*[int(IINF_END)]int32)  (unsafe.Pointer(iinf))[0:IINF_END]
		_liinf := (*[int(LIINF_END)]int64) (unsafe.Pointer(liinf))[0:LIINF_END]

		r = task.infcallbackfunc(int32(code),_dinf,_iinf,_liinf)
	} else if task.callbackfunc != nil {
		r = task.callbackfunc(int32(code))
	}
	return C.int(r)
}


func MakeEnv() (env Env, res int32) {
        var envptr C.MSKenv_t
        res = int32(C.MSK_makeenv(&envptr,nil))
        if res == 0 {
                env.cptr = unsafe.Pointer(envptr)
        }        
        return
}

func (env *Env) MakeTask() (task Task, res int32) {
        var taskptr C.MSKtask_t
        res = int32(C.MSK_maketask(env.ptr(), 0,0, &taskptr))
        if res != 0 { return }
	task.cptr            = unsafe.Pointer(taskptr)        
	task.streamfunc[0]   = nil
	task.streamfunc[1]   = nil
	task.streamfunc[2]   = nil
	task.streamfunc[3]   = nil
	task.callbackfunc    = nil
	task.infcallbackfunc = nil
	
        return
}

func (e *Env) DeleteEnv() {
        envptr := e.ptr()
        C.MSK_deleteenv(&envptr)
        e.cptr = nil
}

func (t *Task) DeleteTask() {
        taskptr := t.ptr()
        C.MSK_deletetask(&taskptr)
        t.cptr = nil
}

func (t *Task) PutStreamFunc(whichstream int32, fun func(string)) {
	t.streamfunc[whichstream] = fun

	if fun == nil {
		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream), 
			nil, 
			nil)
	} else {
		var strmfun (*[0]byte)
		switch whichstream {
		case STREAM_MSG: strmfun = (*[0]byte)(C.streamfunc_msg) 
		case STREAM_LOG: strmfun = (*[0]byte)(C.streamfunc_log) 
		case STREAM_ERR: strmfun = (*[0]byte)(C.streamfunc_err) 
		case STREAM_WRN: strmfun = (*[0]byte)(C.streamfunc_wrn) 
		}
		
		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream), 
			C.MSKuserhandle_t(unsafe.Pointer(t)),
			strmfun) // ?!?
	}
}

func (t *Task) PutCallbackFunc(fun func(int32) int) {
	t.callbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}
func (t *Task) PutInfoCallbackFunc(fun func(int32) int) {
	t.callbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func minint(a []int) (r int) {
        if len(a) == 0 { panic("Minimum of empty array") }
        r = a[0]
        for i := 1; i < len(a); i++ {
                if a[i] < r { r = a[i] }
        }
        return        
}

const ( // enum solveform
    SOLVE_DUAL int32 = 2
    SOLVE_FREE int32 = 0
    SOLVE_PRIMAL int32 = 1
    SOLVE_BEGIN int32 = 0
    SOLVE_END   int32 = 3
)
const ( // enum problemitem
    PI_CON int32 = 1
    PI_CONE int32 = 2
    PI_VAR int32 = 0
    PI_BEGIN int32 = 0
    PI_END   int32 = 3
)
const ( // enum accmode
    ACC_CON int32 = 1
    ACC_VAR int32 = 0
    ACC_BEGIN int32 = 0
    ACC_END   int32 = 2
)
const ( // enum sensitivitytype
    SENSITIVITY_TYPE_BASIS int32 = 0
    SENSITIVITY_TYPE_OPTIMAL_PARTITION int32 = 1
    SENSITIVITY_TYPE_BEGIN int32 = 0
    SENSITIVITY_TYPE_END   int32 = 2
)
const ( // enum uplo
    UPLO_LO int32 = 0
    UPLO_UP int32 = 1
    UPLO_BEGIN int32 = 0
    UPLO_END   int32 = 2
)
const ( // enum intpnthotstart
    INTPNT_HOTSTART_DUAL int32 = 2
    INTPNT_HOTSTART_NONE int32 = 0
    INTPNT_HOTSTART_PRIMAL int32 = 1
    INTPNT_HOTSTART_PRIMAL_DUAL int32 = 3
    INTPNT_HOTSTART_BEGIN int32 = 0
    INTPNT_HOTSTART_END   int32 = 4
)
const ( // enum sparam
    SPAR_BAS_SOL_FILE_NAME int32 = 0
    SPAR_DATA_FILE_NAME int32 = 1
    SPAR_DEBUG_FILE_NAME int32 = 2
    SPAR_INT_SOL_FILE_NAME int32 = 3
    SPAR_ITR_SOL_FILE_NAME int32 = 4
    SPAR_MIO_DEBUG_STRING int32 = 5
    SPAR_PARAM_COMMENT_SIGN int32 = 6
    SPAR_PARAM_READ_FILE_NAME int32 = 7
    SPAR_PARAM_WRITE_FILE_NAME int32 = 8
    SPAR_READ_MPS_BOU_NAME int32 = 9
    SPAR_READ_MPS_OBJ_NAME int32 = 10
    SPAR_READ_MPS_RAN_NAME int32 = 11
    SPAR_READ_MPS_RHS_NAME int32 = 12
    SPAR_SENSITIVITY_FILE_NAME int32 = 13
    SPAR_SENSITIVITY_RES_FILE_NAME int32 = 14
    SPAR_SOL_FILTER_XC_LOW int32 = 15
    SPAR_SOL_FILTER_XC_UPR int32 = 16
    SPAR_SOL_FILTER_XX_LOW int32 = 17
    SPAR_SOL_FILTER_XX_UPR int32 = 18
    SPAR_STAT_FILE_NAME int32 = 19
    SPAR_STAT_KEY int32 = 20
    SPAR_STAT_NAME int32 = 21
    SPAR_WRITE_LP_GEN_VAR_NAME int32 = 22
    SPAR_BEGIN int32 = 0
    SPAR_END   int32 = 23
)
const ( // enum iparam
    IPAR_ANA_SOL_BASIS int32 = 0
    IPAR_ANA_SOL_PRINT_VIOLATED int32 = 1
    IPAR_AUTO_SORT_A_BEFORE_OPT int32 = 2
    IPAR_AUTO_UPDATE_SOL_INFO int32 = 3
    IPAR_BASIS_SOLVE_USE_PLUS_ONE int32 = 4
    IPAR_BI_CLEAN_OPTIMIZER int32 = 5
    IPAR_BI_IGNORE_MAX_ITER int32 = 6
    IPAR_BI_IGNORE_NUM_ERROR int32 = 7
    IPAR_BI_MAX_ITERATIONS int32 = 8
    IPAR_CACHE_LICENSE int32 = 9
    IPAR_CHECK_CONVEXITY int32 = 10
    IPAR_COMPRESS_STATFILE int32 = 11
    IPAR_CONCURRENT_NUM_OPTIMIZERS int32 = 12
    IPAR_CONCURRENT_PRIORITY_DUAL_SIMPLEX int32 = 13
    IPAR_CONCURRENT_PRIORITY_FREE_SIMPLEX int32 = 14
    IPAR_CONCURRENT_PRIORITY_INTPNT int32 = 15
    IPAR_CONCURRENT_PRIORITY_PRIMAL_SIMPLEX int32 = 16
    IPAR_FEASREPAIR_OPTIMIZE int32 = 17
    IPAR_INFEAS_GENERIC_NAMES int32 = 18
    IPAR_INFEAS_PREFER_PRIMAL int32 = 19
    IPAR_INFEAS_REPORT_AUTO int32 = 20
    IPAR_INFEAS_REPORT_LEVEL int32 = 21
    IPAR_INTPNT_BASIS int32 = 22
    IPAR_INTPNT_DIFF_STEP int32 = 23
    IPAR_INTPNT_FACTOR_DEBUG_LVL int32 = 24
    IPAR_INTPNT_FACTOR_METHOD int32 = 25
    IPAR_INTPNT_HOTSTART int32 = 26
    IPAR_INTPNT_MAX_ITERATIONS int32 = 27
    IPAR_INTPNT_MAX_NUM_COR int32 = 28
    IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS int32 = 29
    IPAR_INTPNT_OFF_COL_TRH int32 = 30
    IPAR_INTPNT_ORDER_METHOD int32 = 31
    IPAR_INTPNT_REGULARIZATION_USE int32 = 32
    IPAR_INTPNT_SCALING int32 = 33
    IPAR_INTPNT_SOLVE_FORM int32 = 34
    IPAR_INTPNT_STARTING_POINT int32 = 35
    IPAR_LIC_TRH_EXPIRY_WRN int32 = 36
    IPAR_LICENSE_DEBUG int32 = 37
    IPAR_LICENSE_PAUSE_TIME int32 = 38
    IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS int32 = 39
    IPAR_LICENSE_WAIT int32 = 40
    IPAR_LOG int32 = 41
    IPAR_LOG_ANA_PRO int32 = 42
    IPAR_LOG_BI int32 = 43
    IPAR_LOG_BI_FREQ int32 = 44
    IPAR_LOG_CHECK_CONVEXITY int32 = 45
    IPAR_LOG_CONCURRENT int32 = 46
    IPAR_LOG_CUT_SECOND_OPT int32 = 47
    IPAR_LOG_EXPAND int32 = 48
    IPAR_LOG_FACTOR int32 = 49
    IPAR_LOG_FEAS_REPAIR int32 = 50
    IPAR_LOG_FILE int32 = 51
    IPAR_LOG_HEAD int32 = 52
    IPAR_LOG_INFEAS_ANA int32 = 53
    IPAR_LOG_INTPNT int32 = 54
    IPAR_LOG_MIO int32 = 55
    IPAR_LOG_MIO_FREQ int32 = 56
    IPAR_LOG_OPTIMIZER int32 = 57
    IPAR_LOG_ORDER int32 = 58
    IPAR_LOG_PRESOLVE int32 = 59
    IPAR_LOG_RESPONSE int32 = 60
    IPAR_LOG_SENSITIVITY int32 = 61
    IPAR_LOG_SENSITIVITY_OPT int32 = 62
    IPAR_LOG_SIM int32 = 63
    IPAR_LOG_SIM_FREQ int32 = 64
    IPAR_LOG_SIM_MINOR int32 = 65
    IPAR_LOG_SIM_NETWORK_FREQ int32 = 66
    IPAR_LOG_STORAGE int32 = 67
    IPAR_MAX_NUM_WARNINGS int32 = 68
    IPAR_MIO_BRANCH_DIR int32 = 69
    IPAR_MIO_BRANCH_PRIORITIES_USE int32 = 70
    IPAR_MIO_CONSTRUCT_SOL int32 = 71
    IPAR_MIO_CUT_CG int32 = 72
    IPAR_MIO_CUT_CMIR int32 = 73
    IPAR_MIO_CUT_LEVEL_ROOT int32 = 74
    IPAR_MIO_CUT_LEVEL_TREE int32 = 75
    IPAR_MIO_FEASPUMP_LEVEL int32 = 76
    IPAR_MIO_HEURISTIC_LEVEL int32 = 77
    IPAR_MIO_HOTSTART int32 = 78
    IPAR_MIO_KEEP_BASIS int32 = 79
    IPAR_MIO_LOCAL_BRANCH_NUMBER int32 = 80
    IPAR_MIO_MAX_NUM_BRANCHES int32 = 81
    IPAR_MIO_MAX_NUM_RELAXS int32 = 82
    IPAR_MIO_MAX_NUM_SOLUTIONS int32 = 83
    IPAR_MIO_MODE int32 = 84
    IPAR_MIO_MT_USER_CB int32 = 85
    IPAR_MIO_NODE_OPTIMIZER int32 = 86
    IPAR_MIO_NODE_SELECTION int32 = 87
    IPAR_MIO_OPTIMIZER_MODE int32 = 88
    IPAR_MIO_PRESOLVE_AGGREGATE int32 = 89
    IPAR_MIO_PRESOLVE_USE int32 = 90
    IPAR_MIO_PROBING_LEVEL int32 = 91
    IPAR_MIO_RINS_MAX_NODES int32 = 92
    IPAR_MIO_ROOT_OPTIMIZER int32 = 93
    IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL int32 = 94
    IPAR_MIO_STRONG_BRANCH int32 = 95
    IPAR_MT_SPINCOUNT int32 = 96
    IPAR_NUM_THREADS int32 = 97
    IPAR_OPF_MAX_TERMS_PER_LINE int32 = 98
    IPAR_OPF_WRITE_HEADER int32 = 99
    IPAR_OPF_WRITE_HINTS int32 = 100
    IPAR_OPF_WRITE_PARAMETERS int32 = 101
    IPAR_OPF_WRITE_PROBLEM int32 = 102
    IPAR_OPF_WRITE_SOL_BAS int32 = 103
    IPAR_OPF_WRITE_SOL_ITG int32 = 104
    IPAR_OPF_WRITE_SOL_ITR int32 = 105
    IPAR_OPF_WRITE_SOLUTIONS int32 = 106
    IPAR_OPTIMIZER int32 = 107
    IPAR_PARAM_READ_CASE_NAME int32 = 108
    IPAR_PARAM_READ_IGN_ERROR int32 = 109
    IPAR_PRESOLVE_ELIMINATOR_MAX_FILL int32 = 110
    IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES int32 = 111
    IPAR_PRESOLVE_LEVEL int32 = 112
    IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH int32 = 113
    IPAR_PRESOLVE_LINDEP_REL_WORK_TRH int32 = 114
    IPAR_PRESOLVE_LINDEP_USE int32 = 115
    IPAR_PRESOLVE_MAX_NUM_REDUCTIONS int32 = 116
    IPAR_PRESOLVE_USE int32 = 117
    IPAR_PRIMAL_REPAIR_OPTIMIZER int32 = 118
    IPAR_QO_SEPARABLE_REFORMULATION int32 = 119
    IPAR_READ_DATA_COMPRESSED int32 = 120
    IPAR_READ_DATA_FORMAT int32 = 121
    IPAR_READ_DEBUG int32 = 122
    IPAR_READ_KEEP_FREE_CON int32 = 123
    IPAR_READ_LP_DROP_NEW_VARS_IN_BOU int32 = 124
    IPAR_READ_LP_QUOTED_NAMES int32 = 125
    IPAR_READ_MPS_FORMAT int32 = 126
    IPAR_READ_MPS_KEEP_INT int32 = 127
    IPAR_READ_MPS_RELAX int32 = 128
    IPAR_READ_MPS_WIDTH int32 = 129
    IPAR_READ_TASK_IGNORE_PARAM int32 = 130
    IPAR_SENSITIVITY_ALL int32 = 131
    IPAR_SENSITIVITY_OPTIMIZER int32 = 132
    IPAR_SENSITIVITY_TYPE int32 = 133
    IPAR_SIM_BASIS_FACTOR_USE int32 = 134
    IPAR_SIM_DEGEN int32 = 135
    IPAR_SIM_DUAL_CRASH int32 = 136
    IPAR_SIM_DUAL_PHASEONE_METHOD int32 = 137
    IPAR_SIM_DUAL_RESTRICT_SELECTION int32 = 138
    IPAR_SIM_DUAL_SELECTION int32 = 139
    IPAR_SIM_EXPLOIT_DUPVEC int32 = 140
    IPAR_SIM_HOTSTART int32 = 141
    IPAR_SIM_HOTSTART_LU int32 = 142
    IPAR_SIM_INTEGER int32 = 143
    IPAR_SIM_MAX_ITERATIONS int32 = 144
    IPAR_SIM_MAX_NUM_SETBACKS int32 = 145
    IPAR_SIM_NON_SINGULAR int32 = 146
    IPAR_SIM_PRIMAL_CRASH int32 = 147
    IPAR_SIM_PRIMAL_PHASEONE_METHOD int32 = 148
    IPAR_SIM_PRIMAL_RESTRICT_SELECTION int32 = 149
    IPAR_SIM_PRIMAL_SELECTION int32 = 150
    IPAR_SIM_REFACTOR_FREQ int32 = 151
    IPAR_SIM_REFORMULATION int32 = 152
    IPAR_SIM_SAVE_LU int32 = 153
    IPAR_SIM_SCALING int32 = 154
    IPAR_SIM_SCALING_METHOD int32 = 155
    IPAR_SIM_SOLVE_FORM int32 = 156
    IPAR_SIM_STABILITY_PRIORITY int32 = 157
    IPAR_SIM_SWITCH_OPTIMIZER int32 = 158
    IPAR_SOL_FILTER_KEEP_BASIC int32 = 159
    IPAR_SOL_FILTER_KEEP_RANGED int32 = 160
    IPAR_SOL_READ_NAME_WIDTH int32 = 161
    IPAR_SOL_READ_WIDTH int32 = 162
    IPAR_SOLUTION_CALLBACK int32 = 163
    IPAR_TIMING_LEVEL int32 = 164
    IPAR_WARNING_LEVEL int32 = 165
    IPAR_WRITE_BAS_CONSTRAINTS int32 = 166
    IPAR_WRITE_BAS_HEAD int32 = 167
    IPAR_WRITE_BAS_VARIABLES int32 = 168
    IPAR_WRITE_DATA_COMPRESSED int32 = 169
    IPAR_WRITE_DATA_FORMAT int32 = 170
    IPAR_WRITE_DATA_PARAM int32 = 171
    IPAR_WRITE_FREE_CON int32 = 172
    IPAR_WRITE_GENERIC_NAMES int32 = 173
    IPAR_WRITE_GENERIC_NAMES_IO int32 = 174
    IPAR_WRITE_IGNORE_INCOMPATIBLE_CONIC_ITEMS int32 = 175
    IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS int32 = 176
    IPAR_WRITE_IGNORE_INCOMPATIBLE_NL_ITEMS int32 = 177
    IPAR_WRITE_IGNORE_INCOMPATIBLE_PSD_ITEMS int32 = 178
    IPAR_WRITE_INT_CONSTRAINTS int32 = 179
    IPAR_WRITE_INT_HEAD int32 = 180
    IPAR_WRITE_INT_VARIABLES int32 = 181
    IPAR_WRITE_LP_LINE_WIDTH int32 = 182
    IPAR_WRITE_LP_QUOTED_NAMES int32 = 183
    IPAR_WRITE_LP_STRICT_FORMAT int32 = 184
    IPAR_WRITE_LP_TERMS_PER_LINE int32 = 185
    IPAR_WRITE_MPS_FORMAT int32 = 186
    IPAR_WRITE_MPS_INT int32 = 187
    IPAR_WRITE_PRECISION int32 = 188
    IPAR_WRITE_SOL_BARVARIABLES int32 = 189
    IPAR_WRITE_SOL_CONSTRAINTS int32 = 190
    IPAR_WRITE_SOL_HEAD int32 = 191
    IPAR_WRITE_SOL_IGNORE_INVALID_NAMES int32 = 192
    IPAR_WRITE_SOL_VARIABLES int32 = 193
    IPAR_WRITE_TASK_INC_SOL int32 = 194
    IPAR_WRITE_XML_MODE int32 = 195
    IPAR_BEGIN int32 = 0
    IPAR_END   int32 = 196
)
const ( // enum solsta
    SOL_STA_DUAL_FEAS int32 = 3
    SOL_STA_DUAL_INFEAS_CER int32 = 6
    SOL_STA_INTEGER_OPTIMAL int32 = 14
    SOL_STA_NEAR_DUAL_FEAS int32 = 10
    SOL_STA_NEAR_DUAL_INFEAS_CER int32 = 13
    SOL_STA_NEAR_INTEGER_OPTIMAL int32 = 15
    SOL_STA_NEAR_OPTIMAL int32 = 8
    SOL_STA_NEAR_PRIM_AND_DUAL_FEAS int32 = 11
    SOL_STA_NEAR_PRIM_FEAS int32 = 9
    SOL_STA_NEAR_PRIM_INFEAS_CER int32 = 12
    SOL_STA_OPTIMAL int32 = 1
    SOL_STA_PRIM_AND_DUAL_FEAS int32 = 4
    SOL_STA_PRIM_FEAS int32 = 2
    SOL_STA_PRIM_INFEAS_CER int32 = 5
    SOL_STA_UNKNOWN int32 = 0
    SOL_STA_BEGIN int32 = 0
    SOL_STA_END   int32 = 16
)
const ( // enum objsense
    OBJECTIVE_SENSE_MAXIMIZE int32 = 1
    OBJECTIVE_SENSE_MINIMIZE int32 = 0
    OBJECTIVE_SENSE_BEGIN int32 = 0
    OBJECTIVE_SENSE_END   int32 = 2
)
const ( // enum solitem
    SOL_ITEM_SLC int32 = 3
    SOL_ITEM_SLX int32 = 5
    SOL_ITEM_SNX int32 = 7
    SOL_ITEM_SUC int32 = 4
    SOL_ITEM_SUX int32 = 6
    SOL_ITEM_XC int32 = 0
    SOL_ITEM_XX int32 = 1
    SOL_ITEM_Y int32 = 2
    SOL_ITEM_BEGIN int32 = 0
    SOL_ITEM_END   int32 = 8
)
const ( // enum boundkey
    BK_FR int32 = 3
    BK_FX int32 = 2
    BK_LO int32 = 0
    BK_RA int32 = 4
    BK_UP int32 = 1
    BK_BEGIN int32 = 0
    BK_END   int32 = 5
)
const ( // enum basindtype
    BI_ALWAYS int32 = 1
    BI_IF_FEASIBLE int32 = 3
    BI_NEVER int32 = 0
    BI_NO_ERROR int32 = 2
    BI_RESERVERED int32 = 4
    BI_BEGIN int32 = 0
    BI_END   int32 = 5
)
const ( // enum branchdir
    BRANCH_DIR_DOWN int32 = 2
    BRANCH_DIR_FAR int32 = 4
    BRANCH_DIR_FREE int32 = 0
    BRANCH_DIR_GUIDED int32 = 6
    BRANCH_DIR_INTERVAL_SIZE int32 = 8
    BRANCH_DIR_NEAR int32 = 3
    BRANCH_DIR_PSEUDOCOST int32 = 7
    BRANCH_DIR_ROOT_LP int32 = 5
    BRANCH_DIR_UP int32 = 1
    BRANCH_DIR_BEGIN int32 = 0
    BRANCH_DIR_END   int32 = 9
)
const ( // enum liinfitem
    LIINF_BI_CLEAN_DUAL_DEG_ITER int32 = 0
    LIINF_BI_CLEAN_DUAL_ITER int32 = 1
    LIINF_BI_CLEAN_PRIMAL_DEG_ITER int32 = 2
    LIINF_BI_CLEAN_PRIMAL_DUAL_DEG_ITER int32 = 3
    LIINF_BI_CLEAN_PRIMAL_DUAL_ITER int32 = 4
    LIINF_BI_CLEAN_PRIMAL_DUAL_SUB_ITER int32 = 5
    LIINF_BI_CLEAN_PRIMAL_ITER int32 = 6
    LIINF_BI_DUAL_ITER int32 = 7
    LIINF_BI_PRIMAL_ITER int32 = 8
    LIINF_INTPNT_FACTOR_NUM_NZ int32 = 9
    LIINF_MIO_INTPNT_ITER int32 = 10
    LIINF_MIO_PRESOLVED_ANZ int32 = 11
    LIINF_MIO_SIMPLEX_ITER int32 = 12
    LIINF_RD_NUMANZ int32 = 13
    LIINF_RD_NUMQNZ int32 = 14
    LIINF_BEGIN int32 = 0
    LIINF_END   int32 = 15
)
const ( // enum streamtype
    STREAM_ERR int32 = 2
    STREAM_LOG int32 = 0
    STREAM_MSG int32 = 1
    STREAM_WRN int32 = 3
    STREAM_BEGIN int32 = 0
    STREAM_END   int32 = 4
)
const ( // enum simhotstart
    SIM_HOTSTART_FREE int32 = 1
    SIM_HOTSTART_NONE int32 = 0
    SIM_HOTSTART_STATUS_KEYS int32 = 2
    SIM_HOTSTART_BEGIN int32 = 0
    SIM_HOTSTART_END   int32 = 3
)
const ( // enum callbackcode
    CALLBACK_BEGIN_BI int32 = 0
    CALLBACK_BEGIN_CONCURRENT int32 = 1
    CALLBACK_BEGIN_CONIC int32 = 2
    CALLBACK_BEGIN_DUAL_BI int32 = 3
    CALLBACK_BEGIN_DUAL_SENSITIVITY int32 = 4
    CALLBACK_BEGIN_DUAL_SETUP_BI int32 = 5
    CALLBACK_BEGIN_DUAL_SIMPLEX int32 = 6
    CALLBACK_BEGIN_DUAL_SIMPLEX_BI int32 = 7
    CALLBACK_BEGIN_FULL_CONVEXITY_CHECK int32 = 8
    CALLBACK_BEGIN_INFEAS_ANA int32 = 9
    CALLBACK_BEGIN_INTPNT int32 = 10
    CALLBACK_BEGIN_LICENSE_WAIT int32 = 11
    CALLBACK_BEGIN_MIO int32 = 12
    CALLBACK_BEGIN_NETWORK_DUAL_SIMPLEX int32 = 13
    CALLBACK_BEGIN_NETWORK_PRIMAL_SIMPLEX int32 = 14
    CALLBACK_BEGIN_NETWORK_SIMPLEX int32 = 15
    CALLBACK_BEGIN_OPTIMIZER int32 = 16
    CALLBACK_BEGIN_PRESOLVE int32 = 17
    CALLBACK_BEGIN_PRIMAL_BI int32 = 18
    CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX int32 = 19
    CALLBACK_BEGIN_PRIMAL_DUAL_SIMPLEX_BI int32 = 20
    CALLBACK_BEGIN_PRIMAL_REPAIR int32 = 21
    CALLBACK_BEGIN_PRIMAL_SENSITIVITY int32 = 22
    CALLBACK_BEGIN_PRIMAL_SETUP_BI int32 = 23
    CALLBACK_BEGIN_PRIMAL_SIMPLEX int32 = 24
    CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI int32 = 25
    CALLBACK_BEGIN_QCQO_REFORMULATE int32 = 26
    CALLBACK_BEGIN_READ int32 = 27
    CALLBACK_BEGIN_ROOT_CUTGEN int32 = 28
    CALLBACK_BEGIN_SIMPLEX int32 = 29
    CALLBACK_BEGIN_SIMPLEX_BI int32 = 30
    CALLBACK_BEGIN_SIMPLEX_NETWORK_DETECT int32 = 31
    CALLBACK_BEGIN_WRITE int32 = 32
    CALLBACK_CONIC int32 = 33
    CALLBACK_DUAL_SIMPLEX int32 = 34
    CALLBACK_END_BI int32 = 35
    CALLBACK_END_CONCURRENT int32 = 36
    CALLBACK_END_CONIC int32 = 37
    CALLBACK_END_DUAL_BI int32 = 38
    CALLBACK_END_DUAL_SENSITIVITY int32 = 39
    CALLBACK_END_DUAL_SETUP_BI int32 = 40
    CALLBACK_END_DUAL_SIMPLEX int32 = 41
    CALLBACK_END_DUAL_SIMPLEX_BI int32 = 42
    CALLBACK_END_FULL_CONVEXITY_CHECK int32 = 43
    CALLBACK_END_INFEAS_ANA int32 = 44
    CALLBACK_END_INTPNT int32 = 45
    CALLBACK_END_LICENSE_WAIT int32 = 46
    CALLBACK_END_MIO int32 = 47
    CALLBACK_END_NETWORK_DUAL_SIMPLEX int32 = 48
    CALLBACK_END_NETWORK_PRIMAL_SIMPLEX int32 = 49
    CALLBACK_END_NETWORK_SIMPLEX int32 = 50
    CALLBACK_END_OPTIMIZER int32 = 51
    CALLBACK_END_PRESOLVE int32 = 52
    CALLBACK_END_PRIMAL_BI int32 = 53
    CALLBACK_END_PRIMAL_DUAL_SIMPLEX int32 = 54
    CALLBACK_END_PRIMAL_DUAL_SIMPLEX_BI int32 = 55
    CALLBACK_END_PRIMAL_REPAIR int32 = 56
    CALLBACK_END_PRIMAL_SENSITIVITY int32 = 57
    CALLBACK_END_PRIMAL_SETUP_BI int32 = 58
    CALLBACK_END_PRIMAL_SIMPLEX int32 = 59
    CALLBACK_END_PRIMAL_SIMPLEX_BI int32 = 60
    CALLBACK_END_QCQO_REFORMULATE int32 = 61
    CALLBACK_END_READ int32 = 62
    CALLBACK_END_ROOT_CUTGEN int32 = 63
    CALLBACK_END_SIMPLEX int32 = 64
    CALLBACK_END_SIMPLEX_BI int32 = 65
    CALLBACK_END_SIMPLEX_NETWORK_DETECT int32 = 66
    CALLBACK_END_WRITE int32 = 67
    CALLBACK_IM_BI int32 = 68
    CALLBACK_IM_CONIC int32 = 69
    CALLBACK_IM_DUAL_BI int32 = 70
    CALLBACK_IM_DUAL_SENSIVITY int32 = 71
    CALLBACK_IM_DUAL_SIMPLEX int32 = 72
    CALLBACK_IM_FULL_CONVEXITY_CHECK int32 = 73
    CALLBACK_IM_INTPNT int32 = 74
    CALLBACK_IM_LICENSE_WAIT int32 = 75
    CALLBACK_IM_LU int32 = 76
    CALLBACK_IM_MIO int32 = 77
    CALLBACK_IM_MIO_DUAL_SIMPLEX int32 = 78
    CALLBACK_IM_MIO_INTPNT int32 = 79
    CALLBACK_IM_MIO_PRIMAL_SIMPLEX int32 = 80
    CALLBACK_IM_NETWORK_DUAL_SIMPLEX int32 = 81
    CALLBACK_IM_NETWORK_PRIMAL_SIMPLEX int32 = 82
    CALLBACK_IM_ORDER int32 = 83
    CALLBACK_IM_PRESOLVE int32 = 84
    CALLBACK_IM_PRIMAL_BI int32 = 85
    CALLBACK_IM_PRIMAL_DUAL_SIMPLEX int32 = 86
    CALLBACK_IM_PRIMAL_SENSIVITY int32 = 87
    CALLBACK_IM_PRIMAL_SIMPLEX int32 = 88
    CALLBACK_IM_QO_REFORMULATE int32 = 89
    CALLBACK_IM_READ int32 = 90
    CALLBACK_IM_ROOT_CUTGEN int32 = 91
    CALLBACK_IM_SIMPLEX int32 = 92
    CALLBACK_IM_SIMPLEX_BI int32 = 93
    CALLBACK_INTPNT int32 = 94
    CALLBACK_NEW_INT_MIO int32 = 95
    CALLBACK_PRIMAL_SIMPLEX int32 = 96
    CALLBACK_READ_OPF int32 = 97
    CALLBACK_READ_OPF_SECTION int32 = 98
    CALLBACK_UPDATE_DUAL_BI int32 = 99
    CALLBACK_UPDATE_DUAL_SIMPLEX int32 = 100
    CALLBACK_UPDATE_DUAL_SIMPLEX_BI int32 = 101
    CALLBACK_UPDATE_NETWORK_DUAL_SIMPLEX int32 = 102
    CALLBACK_UPDATE_NETWORK_PRIMAL_SIMPLEX int32 = 103
    CALLBACK_UPDATE_PRESOLVE int32 = 104
    CALLBACK_UPDATE_PRIMAL_BI int32 = 105
    CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX int32 = 106
    CALLBACK_UPDATE_PRIMAL_DUAL_SIMPLEX_BI int32 = 107
    CALLBACK_UPDATE_PRIMAL_SIMPLEX int32 = 108
    CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI int32 = 109
    CALLBACK_WRITE_OPF int32 = 110
    CALLBACK_BEGIN int32 = 0
    CALLBACK_END   int32 = 111
)
const ( // enum symmattype
    SYMMAT_TYPE_SPARSE int32 = 0
    SYMMAT_TYPE_BEGIN int32 = 0
    SYMMAT_TYPE_END   int32 = 1
)
const ( // enum feature
    FEATURE_PTOM int32 = 2
    FEATURE_PTON int32 = 1
    FEATURE_PTOX int32 = 3
    FEATURE_PTS int32 = 0
    FEATURE_BEGIN int32 = 0
    FEATURE_END   int32 = 4
)
const ( // enum mark
    MARK_LO int32 = 0
    MARK_UP int32 = 1
    MARK_BEGIN int32 = 0
    MARK_END   int32 = 2
)
const ( // enum conetype
    CT_QUAD int32 = 0
    CT_RQUAD int32 = 1
    CT_BEGIN int32 = 0
    CT_END   int32 = 2
)
const ( // enum feasrepairtype
    FEASREPAIR_OPTIMIZE_COMBINED int32 = 2
    FEASREPAIR_OPTIMIZE_NONE int32 = 0
    FEASREPAIR_OPTIMIZE_PENALTY int32 = 1
    FEASREPAIR_BEGIN int32 = 0
    FEASREPAIR_END   int32 = 3
)
const ( // enum iomode
    IOMODE_READ int32 = 0
    IOMODE_READWRITE int32 = 2
    IOMODE_WRITE int32 = 1
    IOMODE_BEGIN int32 = 0
    IOMODE_END   int32 = 3
)
const ( // enum simseltype
    SIM_SELECTION_ASE int32 = 2
    SIM_SELECTION_DEVEX int32 = 3
    SIM_SELECTION_FREE int32 = 0
    SIM_SELECTION_FULL int32 = 1
    SIM_SELECTION_PARTIAL int32 = 5
    SIM_SELECTION_SE int32 = 4
    SIM_SELECTION_BEGIN int32 = 0
    SIM_SELECTION_END   int32 = 6
)
const ( // enum msgkey
    MSG_MPS_SELECTED int32 = 1100
    MSG_READING_FILE int32 = 1000
    MSG_WRITING_FILE int32 = 1001
)
const ( // enum miomode
    MIO_MODE_IGNORED int32 = 0
    MIO_MODE_SATISFIED int32 = 1
    MIO_MODE_BEGIN int32 = 0
    MIO_MODE_END   int32 = 2
)
const ( // enum dinfitem
    DINF_BI_CLEAN_DUAL_TIME int32 = 0
    DINF_BI_CLEAN_PRIMAL_DUAL_TIME int32 = 1
    DINF_BI_CLEAN_PRIMAL_TIME int32 = 2
    DINF_BI_CLEAN_TIME int32 = 3
    DINF_BI_DUAL_TIME int32 = 4
    DINF_BI_PRIMAL_TIME int32 = 5
    DINF_BI_TIME int32 = 6
    DINF_CONCURRENT_TIME int32 = 7
    DINF_INTPNT_DUAL_FEAS int32 = 8
    DINF_INTPNT_DUAL_OBJ int32 = 9
    DINF_INTPNT_FACTOR_NUM_FLOPS int32 = 10
    DINF_INTPNT_OPT_STATUS int32 = 11
    DINF_INTPNT_ORDER_TIME int32 = 12
    DINF_INTPNT_PRIMAL_FEAS int32 = 13
    DINF_INTPNT_PRIMAL_OBJ int32 = 14
    DINF_INTPNT_TIME int32 = 15
    DINF_MIO_CG_SEPERATION_TIME int32 = 16
    DINF_MIO_CMIR_SEPERATION_TIME int32 = 17
    DINF_MIO_CONSTRUCT_SOLUTION_OBJ int32 = 18
    DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE int32 = 19
    DINF_MIO_HEURISTIC_TIME int32 = 20
    DINF_MIO_OBJ_ABS_GAP int32 = 21
    DINF_MIO_OBJ_BOUND int32 = 22
    DINF_MIO_OBJ_INT int32 = 23
    DINF_MIO_OBJ_REL_GAP int32 = 24
    DINF_MIO_OPTIMIZER_TIME int32 = 25
    DINF_MIO_PROBING_TIME int32 = 26
    DINF_MIO_ROOT_CUTGEN_TIME int32 = 27
    DINF_MIO_ROOT_OPTIMIZER_TIME int32 = 28
    DINF_MIO_ROOT_PRESOLVE_TIME int32 = 29
    DINF_MIO_TIME int32 = 30
    DINF_MIO_USER_OBJ_CUT int32 = 31
    DINF_OPTIMIZER_TIME int32 = 32
    DINF_PRESOLVE_ELI_TIME int32 = 33
    DINF_PRESOLVE_LINDEP_TIME int32 = 34
    DINF_PRESOLVE_TIME int32 = 35
    DINF_PRIMAL_REPAIR_PENALTY_OBJ int32 = 36
    DINF_QCQO_REFORMULATE_MAX_PERTURBATION int32 = 37
    DINF_QCQO_REFORMULATE_TIME int32 = 38
    DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING int32 = 39
    DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING int32 = 40
    DINF_RD_TIME int32 = 41
    DINF_SIM_DUAL_TIME int32 = 42
    DINF_SIM_FEAS int32 = 43
    DINF_SIM_NETWORK_DUAL_TIME int32 = 44
    DINF_SIM_NETWORK_PRIMAL_TIME int32 = 45
    DINF_SIM_NETWORK_TIME int32 = 46
    DINF_SIM_OBJ int32 = 47
    DINF_SIM_PRIMAL_DUAL_TIME int32 = 48
    DINF_SIM_PRIMAL_TIME int32 = 49
    DINF_SIM_TIME int32 = 50
    DINF_SOL_BAS_DUAL_OBJ int32 = 51
    DINF_SOL_BAS_DVIOLCON int32 = 52
    DINF_SOL_BAS_DVIOLVAR int32 = 53
    DINF_SOL_BAS_PRIMAL_OBJ int32 = 54
    DINF_SOL_BAS_PVIOLCON int32 = 55
    DINF_SOL_BAS_PVIOLVAR int32 = 56
    DINF_SOL_ITG_PRIMAL_OBJ int32 = 57
    DINF_SOL_ITG_PVIOLBARVAR int32 = 58
    DINF_SOL_ITG_PVIOLCON int32 = 59
    DINF_SOL_ITG_PVIOLCONES int32 = 60
    DINF_SOL_ITG_PVIOLITG int32 = 61
    DINF_SOL_ITG_PVIOLVAR int32 = 62
    DINF_SOL_ITR_DUAL_OBJ int32 = 63
    DINF_SOL_ITR_DVIOLBARVAR int32 = 64
    DINF_SOL_ITR_DVIOLCON int32 = 65
    DINF_SOL_ITR_DVIOLCONES int32 = 66
    DINF_SOL_ITR_DVIOLVAR int32 = 67
    DINF_SOL_ITR_PRIMAL_OBJ int32 = 68
    DINF_SOL_ITR_PVIOLBARVAR int32 = 69
    DINF_SOL_ITR_PVIOLCON int32 = 70
    DINF_SOL_ITR_PVIOLCONES int32 = 71
    DINF_SOL_ITR_PVIOLVAR int32 = 72
    DINF_BEGIN int32 = 0
    DINF_END   int32 = 73
)
const ( // enum parametertype
    PAR_DOU_TYPE int32 = 1
    PAR_INT_TYPE int32 = 2
    PAR_INVALID_TYPE int32 = 0
    PAR_STR_TYPE int32 = 3
    PAR_BEGIN int32 = 0
    PAR_END   int32 = 4
)
const ( // enum rescodetype
    RESPONSE_ERR int32 = 3
    RESPONSE_OK int32 = 0
    RESPONSE_TRM int32 = 2
    RESPONSE_UNK int32 = 4
    RESPONSE_WRN int32 = 1
    RESPONSE_BEGIN int32 = 0
    RESPONSE_END   int32 = 5
)
const ( // enum prosta
    PRO_STA_DUAL_FEAS int32 = 3
    PRO_STA_DUAL_INFEAS int32 = 5
    PRO_STA_ILL_POSED int32 = 7
    PRO_STA_NEAR_DUAL_FEAS int32 = 10
    PRO_STA_NEAR_PRIM_AND_DUAL_FEAS int32 = 8
    PRO_STA_NEAR_PRIM_FEAS int32 = 9
    PRO_STA_PRIM_AND_DUAL_FEAS int32 = 1
    PRO_STA_PRIM_AND_DUAL_INFEAS int32 = 6
    PRO_STA_PRIM_FEAS int32 = 2
    PRO_STA_PRIM_INFEAS int32 = 4
    PRO_STA_PRIM_INFEAS_OR_UNBOUNDED int32 = 11
    PRO_STA_UNKNOWN int32 = 0
    PRO_STA_BEGIN int32 = 0
    PRO_STA_END   int32 = 12
)
const ( // enum scalingtype
    SCALING_AGGRESSIVE int32 = 3
    SCALING_FREE int32 = 0
    SCALING_MODERATE int32 = 2
    SCALING_NONE int32 = 1
    SCALING_BEGIN int32 = 0
    SCALING_END   int32 = 4
)
const ( // enum rescode
    RES_ERR_AD_INVALID_CODELIST int32 = 3102
    RES_ERR_AD_INVALID_OPERAND int32 = 3104
    RES_ERR_AD_INVALID_OPERATOR int32 = 3103
    RES_ERR_AD_MISSING_OPERAND int32 = 3105
    RES_ERR_AD_MISSING_RETURN int32 = 3106
    RES_ERR_API_ARRAY_TOO_SMALL int32 = 3001
    RES_ERR_API_CB_CONNECT int32 = 3002
    RES_ERR_API_FATAL_ERROR int32 = 3005
    RES_ERR_API_INTERNAL int32 = 3999
    RES_ERR_ARG_IS_TOO_LARGE int32 = 1227
    RES_ERR_ARG_IS_TOO_SMALL int32 = 1226
    RES_ERR_ARGUMENT_DIMENSION int32 = 1201
    RES_ERR_ARGUMENT_IS_TOO_LARGE int32 = 5005
    RES_ERR_ARGUMENT_LENNEQ int32 = 1197
    RES_ERR_ARGUMENT_PERM_ARRAY int32 = 1299
    RES_ERR_ARGUMENT_TYPE int32 = 1198
    RES_ERR_BAR_VAR_DIM int32 = 3920
    RES_ERR_BASIS int32 = 1266
    RES_ERR_BASIS_FACTOR int32 = 1610
    RES_ERR_BASIS_SINGULAR int32 = 1615
    RES_ERR_BLANK_NAME int32 = 1070
    RES_ERR_CANNOT_CLONE_NL int32 = 2505
    RES_ERR_CANNOT_HANDLE_NL int32 = 2506
    RES_ERR_CBF_DUPLICATE_ACOORD int32 = 7116
    RES_ERR_CBF_DUPLICATE_BCOORD int32 = 7115
    RES_ERR_CBF_DUPLICATE_CON int32 = 7108
    RES_ERR_CBF_DUPLICATE_INT int32 = 7110
    RES_ERR_CBF_DUPLICATE_OBJ int32 = 7107
    RES_ERR_CBF_DUPLICATE_OBJACOORD int32 = 7114
    RES_ERR_CBF_DUPLICATE_VAR int32 = 7109
    RES_ERR_CBF_INVALID_CON_TYPE int32 = 7112
    RES_ERR_CBF_INVALID_DOMAIN_DIMENSION int32 = 7113
    RES_ERR_CBF_INVALID_INT_INDEX int32 = 7121
    RES_ERR_CBF_INVALID_VAR_TYPE int32 = 7111
    RES_ERR_CBF_NO_VARIABLES int32 = 7102
    RES_ERR_CBF_NO_VERSION_SPECIFIED int32 = 7105
    RES_ERR_CBF_OBJ_SENSE int32 = 7101
    RES_ERR_CBF_PARSE int32 = 7100
    RES_ERR_CBF_SYNTAX int32 = 7106
    RES_ERR_CBF_TOO_FEW_CONSTRAINTS int32 = 7118
    RES_ERR_CBF_TOO_FEW_INTS int32 = 7119
    RES_ERR_CBF_TOO_FEW_VARIABLES int32 = 7117
    RES_ERR_CBF_TOO_MANY_CONSTRAINTS int32 = 7103
    RES_ERR_CBF_TOO_MANY_INTS int32 = 7120
    RES_ERR_CBF_TOO_MANY_VARIABLES int32 = 7104
    RES_ERR_CBF_UNSUPPORTED int32 = 7122
    RES_ERR_CON_Q_NOT_NSD int32 = 1294
    RES_ERR_CON_Q_NOT_PSD int32 = 1293
    RES_ERR_CONCURRENT_OPTIMIZER int32 = 3059
    RES_ERR_CONE_INDEX int32 = 1300
    RES_ERR_CONE_OVERLAP int32 = 1302
    RES_ERR_CONE_OVERLAP_APPEND int32 = 1307
    RES_ERR_CONE_REP_VAR int32 = 1303
    RES_ERR_CONE_SIZE int32 = 1301
    RES_ERR_CONE_TYPE int32 = 1305
    RES_ERR_CONE_TYPE_STR int32 = 1306
    RES_ERR_DATA_FILE_EXT int32 = 1055
    RES_ERR_DUP_NAME int32 = 1071
    RES_ERR_DUPLICATE_AIJ int32 = 1385
    RES_ERR_DUPLICATE_BARVARIABLE_NAMES int32 = 4502
    RES_ERR_DUPLICATE_CONE_NAMES int32 = 4503
    RES_ERR_DUPLICATE_CONSTRAINT_NAMES int32 = 4500
    RES_ERR_DUPLICATE_VARIABLE_NAMES int32 = 4501
    RES_ERR_END_OF_FILE int32 = 1059
    RES_ERR_FACTOR int32 = 1650
    RES_ERR_FEASREPAIR_CANNOT_RELAX int32 = 1700
    RES_ERR_FEASREPAIR_INCONSISTENT_BOUND int32 = 1702
    RES_ERR_FEASREPAIR_SOLVING_RELAXED int32 = 1701
    RES_ERR_FILE_LICENSE int32 = 1007
    RES_ERR_FILE_OPEN int32 = 1052
    RES_ERR_FILE_READ int32 = 1053
    RES_ERR_FILE_WRITE int32 = 1054
    RES_ERR_FIRST int32 = 1261
    RES_ERR_FIRSTI int32 = 1285
    RES_ERR_FIRSTJ int32 = 1287
    RES_ERR_FIXED_BOUND_VALUES int32 = 1425
    RES_ERR_FLEXLM int32 = 1014
    RES_ERR_GLOBAL_INV_CONIC_PROBLEM int32 = 1503
    RES_ERR_HUGE_AIJ int32 = 1380
    RES_ERR_HUGE_C int32 = 1375
    RES_ERR_IDENTICAL_TASKS int32 = 3101
    RES_ERR_IN_ARGUMENT int32 = 1200
    RES_ERR_INDEX int32 = 1235
    RES_ERR_INDEX_ARR_IS_TOO_LARGE int32 = 1222
    RES_ERR_INDEX_ARR_IS_TOO_SMALL int32 = 1221
    RES_ERR_INDEX_IS_TOO_LARGE int32 = 1204
    RES_ERR_INDEX_IS_TOO_SMALL int32 = 1203
    RES_ERR_INF_DOU_INDEX int32 = 1219
    RES_ERR_INF_DOU_NAME int32 = 1230
    RES_ERR_INF_INT_INDEX int32 = 1220
    RES_ERR_INF_INT_NAME int32 = 1231
    RES_ERR_INF_LINT_INDEX int32 = 1225
    RES_ERR_INF_LINT_NAME int32 = 1234
    RES_ERR_INF_TYPE int32 = 1232
    RES_ERR_INFEAS_UNDEFINED int32 = 3910
    RES_ERR_INFINITE_BOUND int32 = 1400
    RES_ERR_INT64_TO_INT32_CAST int32 = 3800
    RES_ERR_INTERNAL int32 = 3000
    RES_ERR_INTERNAL_TEST_FAILED int32 = 3500
    RES_ERR_INV_APTRE int32 = 1253
    RES_ERR_INV_BK int32 = 1255
    RES_ERR_INV_BKC int32 = 1256
    RES_ERR_INV_BKX int32 = 1257
    RES_ERR_INV_CONE_TYPE int32 = 1272
    RES_ERR_INV_CONE_TYPE_STR int32 = 1271
    RES_ERR_INV_MARKI int32 = 2501
    RES_ERR_INV_MARKJ int32 = 2502
    RES_ERR_INV_NAME_ITEM int32 = 1280
    RES_ERR_INV_NUMI int32 = 2503
    RES_ERR_INV_NUMJ int32 = 2504
    RES_ERR_INV_OPTIMIZER int32 = 1550
    RES_ERR_INV_PROBLEM int32 = 1500
    RES_ERR_INV_QCON_SUBI int32 = 1405
    RES_ERR_INV_QCON_SUBJ int32 = 1406
    RES_ERR_INV_QCON_SUBK int32 = 1404
    RES_ERR_INV_QCON_VAL int32 = 1407
    RES_ERR_INV_QOBJ_SUBI int32 = 1401
    RES_ERR_INV_QOBJ_SUBJ int32 = 1402
    RES_ERR_INV_QOBJ_VAL int32 = 1403
    RES_ERR_INV_SK int32 = 1270
    RES_ERR_INV_SK_STR int32 = 1269
    RES_ERR_INV_SKC int32 = 1267
    RES_ERR_INV_SKN int32 = 1274
    RES_ERR_INV_SKX int32 = 1268
    RES_ERR_INV_VAR_TYPE int32 = 1258
    RES_ERR_INVALID_ACCMODE int32 = 2520
    RES_ERR_INVALID_AIJ int32 = 1473
    RES_ERR_INVALID_AMPL_STUB int32 = 3700
    RES_ERR_INVALID_BARVAR_NAME int32 = 1079
    RES_ERR_INVALID_BRANCH_DIRECTION int32 = 3200
    RES_ERR_INVALID_BRANCH_PRIORITY int32 = 3201
    RES_ERR_INVALID_COMPRESSION int32 = 1800
    RES_ERR_INVALID_CON_NAME int32 = 1076
    RES_ERR_INVALID_CONE_NAME int32 = 1078
    RES_ERR_INVALID_FILE_FORMAT_FOR_CONES int32 = 4005
    RES_ERR_INVALID_FILE_FORMAT_FOR_GENERAL_NL int32 = 4010
    RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT int32 = 4000
    RES_ERR_INVALID_FILE_NAME int32 = 1056
    RES_ERR_INVALID_FORMAT_TYPE int32 = 1283
    RES_ERR_INVALID_IDX int32 = 1246
    RES_ERR_INVALID_IOMODE int32 = 1801
    RES_ERR_INVALID_MAX_NUM int32 = 1247
    RES_ERR_INVALID_NAME_IN_SOL_FILE int32 = 1170
    RES_ERR_INVALID_NETWORK_PROBLEM int32 = 1504
    RES_ERR_INVALID_OBJ_NAME int32 = 1075
    RES_ERR_INVALID_OBJECTIVE_SENSE int32 = 1445
    RES_ERR_INVALID_PROBLEM_TYPE int32 = 6000
    RES_ERR_INVALID_SOL_FILE_NAME int32 = 1057
    RES_ERR_INVALID_STREAM int32 = 1062
    RES_ERR_INVALID_SURPLUS int32 = 1275
    RES_ERR_INVALID_SYM_MAT_DIM int32 = 3950
    RES_ERR_INVALID_TASK int32 = 1064
    RES_ERR_INVALID_UTF8 int32 = 2900
    RES_ERR_INVALID_VAR_NAME int32 = 1077
    RES_ERR_INVALID_WCHAR int32 = 2901
    RES_ERR_INVALID_WHICHSOL int32 = 1228
    RES_ERR_LAST int32 = 1262
    RES_ERR_LASTI int32 = 1286
    RES_ERR_LASTJ int32 = 1288
    RES_ERR_LAU_ARG_K int32 = 7004
    RES_ERR_LAU_ARG_M int32 = 7002
    RES_ERR_LAU_ARG_N int32 = 7003
    RES_ERR_LAU_ARG_TRANS int32 = 7008
    RES_ERR_LAU_ARG_TRANSA int32 = 7005
    RES_ERR_LAU_ARG_TRANSB int32 = 7006
    RES_ERR_LAU_ARG_UPLO int32 = 7007
    RES_ERR_LAU_SINGULAR_MATRIX int32 = 7000
    RES_ERR_LAU_UNKNOWN int32 = 7001
    RES_ERR_LICENSE int32 = 1000
    RES_ERR_LICENSE_CANNOT_ALLOCATE int32 = 1020
    RES_ERR_LICENSE_CANNOT_CONNECT int32 = 1021
    RES_ERR_LICENSE_EXPIRED int32 = 1001
    RES_ERR_LICENSE_FEATURE int32 = 1018
    RES_ERR_LICENSE_INVALID_HOSTID int32 = 1025
    RES_ERR_LICENSE_MAX int32 = 1016
    RES_ERR_LICENSE_MOSEKLM_DAEMON int32 = 1017
    RES_ERR_LICENSE_NO_SERVER_LINE int32 = 1028
    RES_ERR_LICENSE_NO_SERVER_SUPPORT int32 = 1027
    RES_ERR_LICENSE_SERVER int32 = 1015
    RES_ERR_LICENSE_SERVER_VERSION int32 = 1026
    RES_ERR_LICENSE_VERSION int32 = 1002
    RES_ERR_LINK_FILE_DLL int32 = 1040
    RES_ERR_LIVING_TASKS int32 = 1066
    RES_ERR_LOWER_BOUND_IS_A_NAN int32 = 1390
    RES_ERR_LP_DUP_SLACK_NAME int32 = 1152
    RES_ERR_LP_EMPTY int32 = 1151
    RES_ERR_LP_FILE_FORMAT int32 = 1157
    RES_ERR_LP_FORMAT int32 = 1160
    RES_ERR_LP_FREE_CONSTRAINT int32 = 1155
    RES_ERR_LP_INCOMPATIBLE int32 = 1150
    RES_ERR_LP_INVALID_CON_NAME int32 = 1171
    RES_ERR_LP_INVALID_VAR_NAME int32 = 1154
    RES_ERR_LP_WRITE_CONIC_PROBLEM int32 = 1163
    RES_ERR_LP_WRITE_GECO_PROBLEM int32 = 1164
    RES_ERR_LU_MAX_NUM_TRIES int32 = 2800
    RES_ERR_MAX_LEN_IS_TOO_SMALL int32 = 1289
    RES_ERR_MAXNUMBARVAR int32 = 1242
    RES_ERR_MAXNUMCON int32 = 1240
    RES_ERR_MAXNUMCONE int32 = 1304
    RES_ERR_MAXNUMQNZ int32 = 1243
    RES_ERR_MAXNUMVAR int32 = 1241
    RES_ERR_MIO_INTERNAL int32 = 5010
    RES_ERR_MIO_INVALID_NODE_OPTIMIZER int32 = 7131
    RES_ERR_MIO_INVALID_ROOT_OPTIMIZER int32 = 7130
    RES_ERR_MIO_NO_OPTIMIZER int32 = 1551
    RES_ERR_MIO_NOT_LOADED int32 = 1553
    RES_ERR_MISSING_LICENSE_FILE int32 = 1008
    RES_ERR_MIXED_CONIC_AND_NL int32 = 1501
    RES_ERR_MPS_CONE_OVERLAP int32 = 1118
    RES_ERR_MPS_CONE_REPEAT int32 = 1119
    RES_ERR_MPS_CONE_TYPE int32 = 1117
    RES_ERR_MPS_DUPLICATE_Q_ELEMENT int32 = 1121
    RES_ERR_MPS_FILE int32 = 1100
    RES_ERR_MPS_INV_BOUND_KEY int32 = 1108
    RES_ERR_MPS_INV_CON_KEY int32 = 1107
    RES_ERR_MPS_INV_FIELD int32 = 1101
    RES_ERR_MPS_INV_MARKER int32 = 1102
    RES_ERR_MPS_INV_SEC_NAME int32 = 1109
    RES_ERR_MPS_INV_SEC_ORDER int32 = 1115
    RES_ERR_MPS_INVALID_OBJ_NAME int32 = 1128
    RES_ERR_MPS_INVALID_OBJSENSE int32 = 1122
    RES_ERR_MPS_MUL_CON_NAME int32 = 1112
    RES_ERR_MPS_MUL_CSEC int32 = 1116
    RES_ERR_MPS_MUL_QOBJ int32 = 1114
    RES_ERR_MPS_MUL_QSEC int32 = 1113
    RES_ERR_MPS_NO_OBJECTIVE int32 = 1110
    RES_ERR_MPS_NON_SYMMETRIC_Q int32 = 1120
    RES_ERR_MPS_NULL_CON_NAME int32 = 1103
    RES_ERR_MPS_NULL_VAR_NAME int32 = 1104
    RES_ERR_MPS_SPLITTED_VAR int32 = 1111
    RES_ERR_MPS_TAB_IN_FIELD2 int32 = 1125
    RES_ERR_MPS_TAB_IN_FIELD3 int32 = 1126
    RES_ERR_MPS_TAB_IN_FIELD5 int32 = 1127
    RES_ERR_MPS_UNDEF_CON_NAME int32 = 1105
    RES_ERR_MPS_UNDEF_VAR_NAME int32 = 1106
    RES_ERR_MUL_A_ELEMENT int32 = 1254
    RES_ERR_NAME_IS_NULL int32 = 1760
    RES_ERR_NAME_MAX_LEN int32 = 1750
    RES_ERR_NAN_IN_BLC int32 = 1461
    RES_ERR_NAN_IN_BLX int32 = 1471
    RES_ERR_NAN_IN_BUC int32 = 1462
    RES_ERR_NAN_IN_BUX int32 = 1472
    RES_ERR_NAN_IN_C int32 = 1470
    RES_ERR_NAN_IN_DOUBLE_DATA int32 = 1450
    RES_ERR_NEGATIVE_APPEND int32 = 1264
    RES_ERR_NEGATIVE_SURPLUS int32 = 1263
    RES_ERR_NEWER_DLL int32 = 1036
    RES_ERR_NO_BARS_FOR_SOLUTION int32 = 3916
    RES_ERR_NO_BARX_FOR_SOLUTION int32 = 3915
    RES_ERR_NO_BASIS_SOL int32 = 1600
    RES_ERR_NO_DUAL_FOR_ITG_SOL int32 = 2950
    RES_ERR_NO_DUAL_INFEAS_CER int32 = 2001
    RES_ERR_NO_INIT_ENV int32 = 1063
    RES_ERR_NO_OPTIMIZER_VAR_TYPE int32 = 1552
    RES_ERR_NO_PRIMAL_INFEAS_CER int32 = 2000
    RES_ERR_NO_SNX_FOR_BAS_SOL int32 = 2953
    RES_ERR_NO_SOLUTION_IN_CALLBACK int32 = 2500
    RES_ERR_NON_UNIQUE_ARRAY int32 = 5000
    RES_ERR_NONCONVEX int32 = 1291
    RES_ERR_NONLINEAR_EQUALITY int32 = 1290
    RES_ERR_NONLINEAR_FUNCTIONS_NOT_ALLOWED int32 = 1428
    RES_ERR_NONLINEAR_RANGED int32 = 1292
    RES_ERR_NR_ARGUMENTS int32 = 1199
    RES_ERR_NULL_ENV int32 = 1060
    RES_ERR_NULL_POINTER int32 = 1065
    RES_ERR_NULL_TASK int32 = 1061
    RES_ERR_NUMCONLIM int32 = 1250
    RES_ERR_NUMVARLIM int32 = 1251
    RES_ERR_OBJ_Q_NOT_NSD int32 = 1296
    RES_ERR_OBJ_Q_NOT_PSD int32 = 1295
    RES_ERR_OBJECTIVE_RANGE int32 = 1260
    RES_ERR_OLDER_DLL int32 = 1035
    RES_ERR_OPEN_DL int32 = 1030
    RES_ERR_OPF_FORMAT int32 = 1168
    RES_ERR_OPF_NEW_VARIABLE int32 = 1169
    RES_ERR_OPF_PREMATURE_EOF int32 = 1172
    RES_ERR_OPTIMIZER_LICENSE int32 = 1013
    RES_ERR_ORD_INVALID int32 = 1131
    RES_ERR_ORD_INVALID_BRANCH_DIR int32 = 1130
    RES_ERR_OVERFLOW int32 = 1590
    RES_ERR_PARAM_INDEX int32 = 1210
    RES_ERR_PARAM_IS_TOO_LARGE int32 = 1215
    RES_ERR_PARAM_IS_TOO_SMALL int32 = 1216
    RES_ERR_PARAM_NAME int32 = 1205
    RES_ERR_PARAM_NAME_DOU int32 = 1206
    RES_ERR_PARAM_NAME_INT int32 = 1207
    RES_ERR_PARAM_NAME_STR int32 = 1208
    RES_ERR_PARAM_TYPE int32 = 1218
    RES_ERR_PARAM_VALUE_STR int32 = 1217
    RES_ERR_PLATFORM_NOT_LICENSED int32 = 1019
    RES_ERR_POSTSOLVE int32 = 1580
    RES_ERR_PRO_ITEM int32 = 1281
    RES_ERR_PROB_LICENSE int32 = 1006
    RES_ERR_QCON_SUBI_TOO_LARGE int32 = 1409
    RES_ERR_QCON_SUBI_TOO_SMALL int32 = 1408
    RES_ERR_QCON_UPPER_TRIANGLE int32 = 1417
    RES_ERR_QOBJ_UPPER_TRIANGLE int32 = 1415
    RES_ERR_READ_FORMAT int32 = 1090
    RES_ERR_READ_LP_MISSING_END_TAG int32 = 1159
    RES_ERR_READ_LP_NONEXISTING_NAME int32 = 1162
    RES_ERR_REMOVE_CONE_VARIABLE int32 = 1310
    RES_ERR_REPAIR_INVALID_PROBLEM int32 = 1710
    RES_ERR_REPAIR_OPTIMIZATION_FAILED int32 = 1711
    RES_ERR_SEN_BOUND_INVALID_LO int32 = 3054
    RES_ERR_SEN_BOUND_INVALID_UP int32 = 3053
    RES_ERR_SEN_FORMAT int32 = 3050
    RES_ERR_SEN_INDEX_INVALID int32 = 3055
    RES_ERR_SEN_INDEX_RANGE int32 = 3052
    RES_ERR_SEN_INVALID_REGEXP int32 = 3056
    RES_ERR_SEN_NUMERICAL int32 = 3058
    RES_ERR_SEN_SOLUTION_STATUS int32 = 3057
    RES_ERR_SEN_UNDEF_NAME int32 = 3051
    RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE int32 = 3080
    RES_ERR_SIZE_LICENSE int32 = 1005
    RES_ERR_SIZE_LICENSE_CON int32 = 1010
    RES_ERR_SIZE_LICENSE_INTVAR int32 = 1012
    RES_ERR_SIZE_LICENSE_NUMCORES int32 = 3900
    RES_ERR_SIZE_LICENSE_VAR int32 = 1011
    RES_ERR_SOL_FILE_INVALID_NUMBER int32 = 1350
    RES_ERR_SOLITEM int32 = 1237
    RES_ERR_SOLVER_PROBTYPE int32 = 1259
    RES_ERR_SPACE int32 = 1051
    RES_ERR_SPACE_LEAKING int32 = 1080
    RES_ERR_SPACE_NO_INFO int32 = 1081
    RES_ERR_SYM_MAT_DUPLICATE int32 = 3944
    RES_ERR_SYM_MAT_INVALID_COL_INDEX int32 = 3941
    RES_ERR_SYM_MAT_INVALID_ROW_INDEX int32 = 3940
    RES_ERR_SYM_MAT_INVALID_VALUE int32 = 3943
    RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR int32 = 3942
    RES_ERR_TASK_INCOMPATIBLE int32 = 2560
    RES_ERR_TASK_INVALID int32 = 2561
    RES_ERR_THREAD_COND_INIT int32 = 1049
    RES_ERR_THREAD_CREATE int32 = 1048
    RES_ERR_THREAD_MUTEX_INIT int32 = 1045
    RES_ERR_THREAD_MUTEX_LOCK int32 = 1046
    RES_ERR_THREAD_MUTEX_UNLOCK int32 = 1047
    RES_ERR_TOCONIC_CONVERSION_FAIL int32 = 7200
    RES_ERR_TOO_MANY_CONCURRENT_TASKS int32 = 3090
    RES_ERR_TOO_SMALL_MAX_NUM_NZ int32 = 1245
    RES_ERR_TOO_SMALL_MAXNUMANZ int32 = 1252
    RES_ERR_UNB_STEP_SIZE int32 = 3100
    RES_ERR_UNDEF_SOLUTION int32 = 1265
    RES_ERR_UNDEFINED_OBJECTIVE_SENSE int32 = 1446
    RES_ERR_UNHANDLED_SOLUTION_STATUS int32 = 6010
    RES_ERR_UNKNOWN int32 = 1050
    RES_ERR_UPPER_BOUND_IS_A_NAN int32 = 1391
    RES_ERR_UPPER_TRIANGLE int32 = 6020
    RES_ERR_USER_FUNC_RET int32 = 1430
    RES_ERR_USER_FUNC_RET_DATA int32 = 1431
    RES_ERR_USER_NLO_EVAL int32 = 1433
    RES_ERR_USER_NLO_EVAL_HESSUBI int32 = 1440
    RES_ERR_USER_NLO_EVAL_HESSUBJ int32 = 1441
    RES_ERR_USER_NLO_FUNC int32 = 1432
    RES_ERR_WHICHITEM_NOT_ALLOWED int32 = 1238
    RES_ERR_WHICHSOL int32 = 1236
    RES_ERR_WRITE_LP_FORMAT int32 = 1158
    RES_ERR_WRITE_LP_NON_UNIQUE_NAME int32 = 1161
    RES_ERR_WRITE_MPS_INVALID_NAME int32 = 1153
    RES_ERR_WRITE_OPF_INVALID_VAR_NAME int32 = 1156
    RES_ERR_WRITING_FILE int32 = 1166
    RES_ERR_XML_INVALID_PROBLEM_TYPE int32 = 3600
    RES_ERR_Y_IS_UNDEFINED int32 = 1449
    RES_OK int32 = 0
    RES_TRM_INTERNAL int32 = 10030
    RES_TRM_INTERNAL_STOP int32 = 10031
    RES_TRM_MAX_ITERATIONS int32 = 10000
    RES_TRM_MAX_NUM_SETBACKS int32 = 10020
    RES_TRM_MAX_TIME int32 = 10001
    RES_TRM_MIO_NEAR_ABS_GAP int32 = 10004
    RES_TRM_MIO_NEAR_REL_GAP int32 = 10003
    RES_TRM_MIO_NUM_BRANCHES int32 = 10009
    RES_TRM_MIO_NUM_RELAXS int32 = 10008
    RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS int32 = 10015
    RES_TRM_NUMERICAL_PROBLEM int32 = 10025
    RES_TRM_OBJECTIVE_RANGE int32 = 10002
    RES_TRM_STALL int32 = 10006
    RES_TRM_USER_CALLBACK int32 = 10007
    RES_WRN_ANA_ALMOST_INT_BOUNDS int32 = 904
    RES_WRN_ANA_C_ZERO int32 = 901
    RES_WRN_ANA_CLOSE_BOUNDS int32 = 903
    RES_WRN_ANA_EMPTY_COLS int32 = 902
    RES_WRN_ANA_LARGE_BOUNDS int32 = 900
    RES_WRN_CONSTRUCT_INVALID_SOL_ITG int32 = 807
    RES_WRN_CONSTRUCT_NO_SOL_ITG int32 = 810
    RES_WRN_CONSTRUCT_SOLUTION_INFEAS int32 = 805
    RES_WRN_DROPPED_NZ_QOBJ int32 = 201
    RES_WRN_DUPLICATE_BARVARIABLE_NAMES int32 = 852
    RES_WRN_DUPLICATE_CONE_NAMES int32 = 853
    RES_WRN_DUPLICATE_CONSTRAINT_NAMES int32 = 850
    RES_WRN_DUPLICATE_VARIABLE_NAMES int32 = 851
    RES_WRN_ELIMINATOR_SPACE int32 = 801
    RES_WRN_EMPTY_NAME int32 = 502
    RES_WRN_IGNORE_INTEGER int32 = 250
    RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK int32 = 800
    RES_WRN_LARGE_AIJ int32 = 62
    RES_WRN_LARGE_BOUND int32 = 51
    RES_WRN_LARGE_CJ int32 = 57
    RES_WRN_LARGE_CON_FX int32 = 54
    RES_WRN_LARGE_LO_BOUND int32 = 52
    RES_WRN_LARGE_UP_BOUND int32 = 53
    RES_WRN_LICENSE_EXPIRE int32 = 500
    RES_WRN_LICENSE_FEATURE_EXPIRE int32 = 505
    RES_WRN_LICENSE_SERVER int32 = 501
    RES_WRN_LP_DROP_VARIABLE int32 = 85
    RES_WRN_LP_OLD_QUAD_FORMAT int32 = 80
    RES_WRN_MIO_INFEASIBLE_FINAL int32 = 270
    RES_WRN_MPS_SPLIT_BOU_VECTOR int32 = 72
    RES_WRN_MPS_SPLIT_RAN_VECTOR int32 = 71
    RES_WRN_MPS_SPLIT_RHS_VECTOR int32 = 70
    RES_WRN_NAME_MAX_LEN int32 = 65
    RES_WRN_NO_DUALIZER int32 = 950
    RES_WRN_NO_GLOBAL_OPTIMIZER int32 = 251
    RES_WRN_NO_NONLINEAR_FUNCTION_WRITE int32 = 450
    RES_WRN_NZ_IN_UPR_TRI int32 = 200
    RES_WRN_OPEN_PARAM_FILE int32 = 50
    RES_WRN_PARAM_IGNORED_CMIO int32 = 516
    RES_WRN_PARAM_NAME_DOU int32 = 510
    RES_WRN_PARAM_NAME_INT int32 = 511
    RES_WRN_PARAM_NAME_STR int32 = 512
    RES_WRN_PARAM_STR_VALUE int32 = 515
    RES_WRN_PRESOLVE_OUTOFSPACE int32 = 802
    RES_WRN_QUAD_CONES_WITH_ROOT_FIXED_AT_ZERO int32 = 930
    RES_WRN_RQUAD_CONES_WITH_ROOT_FIXED_AT_ZERO int32 = 931
    RES_WRN_SOL_FILE_IGNORED_CON int32 = 351
    RES_WRN_SOL_FILE_IGNORED_VAR int32 = 352
    RES_WRN_SOL_FILTER int32 = 300
    RES_WRN_SPAR_MAX_LEN int32 = 66
    RES_WRN_TOO_FEW_BASIS_VARS int32 = 400
    RES_WRN_TOO_MANY_BASIS_VARS int32 = 405
    RES_WRN_TOO_MANY_THREADS_CONCURRENT int32 = 750
    RES_WRN_UNDEF_SOL_FILE_NAME int32 = 350
    RES_WRN_USING_GENERIC_NAMES int32 = 503
    RES_WRN_WRITE_CHANGED_NAMES int32 = 803
    RES_WRN_WRITE_DISCARDED_CFIX int32 = 804
    RES_WRN_ZERO_AIJ int32 = 63
    RES_WRN_ZEROS_IN_SPARSE_COL int32 = 710
    RES_WRN_ZEROS_IN_SPARSE_ROW int32 = 705
)
const ( // enum mionodeseltype
    MIO_NODE_SELECTION_BEST int32 = 2
    MIO_NODE_SELECTION_FIRST int32 = 1
    MIO_NODE_SELECTION_FREE int32 = 0
    MIO_NODE_SELECTION_HYBRID int32 = 4
    MIO_NODE_SELECTION_PSEUDO int32 = 5
    MIO_NODE_SELECTION_WORST int32 = 3
    MIO_NODE_SELECTION_BEGIN int32 = 0
    MIO_NODE_SELECTION_END   int32 = 6
)
const ( // enum transpose
    TRANSPOSE_NO int32 = 0
    TRANSPOSE_YES int32 = 1
    TRANSPOSE_BEGIN int32 = 0
    TRANSPOSE_END   int32 = 2
)
const ( // enum onoffkey
    OFF int32 = 0
    ON int32 = 1
)
const ( // enum simdegen
    SIM_DEGEN_AGGRESSIVE int32 = 2
    SIM_DEGEN_FREE int32 = 1
    SIM_DEGEN_MINIMUM int32 = 4
    SIM_DEGEN_MODERATE int32 = 3
    SIM_DEGEN_NONE int32 = 0
    SIM_DEGEN_BEGIN int32 = 0
    SIM_DEGEN_END   int32 = 5
)
const ( // enum dataformat
    DATA_FORMAT_CB int32 = 7
    DATA_FORMAT_EXTENSION int32 = 0
    DATA_FORMAT_FREE_MPS int32 = 5
    DATA_FORMAT_LP int32 = 2
    DATA_FORMAT_MPS int32 = 1
    DATA_FORMAT_OP int32 = 3
    DATA_FORMAT_TASK int32 = 6
    DATA_FORMAT_XML int32 = 4
    DATA_FORMAT_BEGIN int32 = 0
    DATA_FORMAT_END   int32 = 8
)
const ( // enum orderingtype
    ORDER_METHOD_APPMINLOC int32 = 1
    ORDER_METHOD_EXPERIMENTAL int32 = 2
    ORDER_METHOD_FORCE_GRAPHPAR int32 = 4
    ORDER_METHOD_FREE int32 = 0
    ORDER_METHOD_NONE int32 = 5
    ORDER_METHOD_TRY_GRAPHPAR int32 = 3
    ORDER_METHOD_BEGIN int32 = 0
    ORDER_METHOD_END   int32 = 6
)
const ( // enum problemtype
    PROBTYPE_CONIC int32 = 4
    PROBTYPE_GECO int32 = 3
    PROBTYPE_LO int32 = 0
    PROBTYPE_MIXED int32 = 5
    PROBTYPE_QCQO int32 = 2
    PROBTYPE_QO int32 = 1
    PROBTYPE_BEGIN int32 = 0
    PROBTYPE_END   int32 = 6
)
const ( // enum inftype
    INF_DOU_TYPE int32 = 0
    INF_INT_TYPE int32 = 1
    INF_LINT_TYPE int32 = 2
    INF_BEGIN int32 = 0
    INF_END   int32 = 3
)
const ( // enum dparam
    DPAR_ANA_SOL_INFEAS_TOL int32 = 0
    DPAR_BASIS_REL_TOL_S int32 = 1
    DPAR_BASIS_TOL_S int32 = 2
    DPAR_BASIS_TOL_X int32 = 3
    DPAR_CHECK_CONVEXITY_REL_TOL int32 = 4
    DPAR_DATA_TOL_AIJ int32 = 5
    DPAR_DATA_TOL_AIJ_HUGE int32 = 6
    DPAR_DATA_TOL_AIJ_LARGE int32 = 7
    DPAR_DATA_TOL_BOUND_INF int32 = 8
    DPAR_DATA_TOL_BOUND_WRN int32 = 9
    DPAR_DATA_TOL_C_HUGE int32 = 10
    DPAR_DATA_TOL_CJ_LARGE int32 = 11
    DPAR_DATA_TOL_QIJ int32 = 12
    DPAR_DATA_TOL_X int32 = 13
    DPAR_FEASREPAIR_TOL int32 = 14
    DPAR_INTPNT_CO_TOL_DFEAS int32 = 15
    DPAR_INTPNT_CO_TOL_INFEAS int32 = 16
    DPAR_INTPNT_CO_TOL_MU_RED int32 = 17
    DPAR_INTPNT_CO_TOL_NEAR_REL int32 = 18
    DPAR_INTPNT_CO_TOL_PFEAS int32 = 19
    DPAR_INTPNT_CO_TOL_REL_GAP int32 = 20
    DPAR_INTPNT_NL_MERIT_BAL int32 = 21
    DPAR_INTPNT_NL_TOL_DFEAS int32 = 22
    DPAR_INTPNT_NL_TOL_MU_RED int32 = 23
    DPAR_INTPNT_NL_TOL_NEAR_REL int32 = 24
    DPAR_INTPNT_NL_TOL_PFEAS int32 = 25
    DPAR_INTPNT_NL_TOL_REL_GAP int32 = 26
    DPAR_INTPNT_NL_TOL_REL_STEP int32 = 27
    DPAR_INTPNT_QO_TOL_DFEAS int32 = 28
    DPAR_INTPNT_QO_TOL_INFEAS int32 = 29
    DPAR_INTPNT_QO_TOL_MU_RED int32 = 30
    DPAR_INTPNT_QO_TOL_NEAR_REL int32 = 31
    DPAR_INTPNT_QO_TOL_PFEAS int32 = 32
    DPAR_INTPNT_QO_TOL_REL_GAP int32 = 33
    DPAR_INTPNT_TOL_DFEAS int32 = 34
    DPAR_INTPNT_TOL_DSAFE int32 = 35
    DPAR_INTPNT_TOL_INFEAS int32 = 36
    DPAR_INTPNT_TOL_MU_RED int32 = 37
    DPAR_INTPNT_TOL_PATH int32 = 38
    DPAR_INTPNT_TOL_PFEAS int32 = 39
    DPAR_INTPNT_TOL_PSAFE int32 = 40
    DPAR_INTPNT_TOL_REL_GAP int32 = 41
    DPAR_INTPNT_TOL_REL_STEP int32 = 42
    DPAR_INTPNT_TOL_STEP_SIZE int32 = 43
    DPAR_LOWER_OBJ_CUT int32 = 44
    DPAR_LOWER_OBJ_CUT_FINITE_TRH int32 = 45
    DPAR_MIO_DISABLE_TERM_TIME int32 = 46
    DPAR_MIO_HEURISTIC_TIME int32 = 47
    DPAR_MIO_MAX_TIME int32 = 48
    DPAR_MIO_MAX_TIME_APRX_OPT int32 = 49
    DPAR_MIO_NEAR_TOL_ABS_GAP int32 = 50
    DPAR_MIO_NEAR_TOL_REL_GAP int32 = 51
    DPAR_MIO_REL_ADD_CUT_LIMITED int32 = 52
    DPAR_MIO_REL_GAP_CONST int32 = 53
    DPAR_MIO_TOL_ABS_GAP int32 = 54
    DPAR_MIO_TOL_ABS_RELAX_INT int32 = 55
    DPAR_MIO_TOL_FEAS int32 = 56
    DPAR_MIO_TOL_MAX_CUT_FRAC_RHS int32 = 57
    DPAR_MIO_TOL_MIN_CUT_FRAC_RHS int32 = 58
    DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT int32 = 59
    DPAR_MIO_TOL_REL_GAP int32 = 60
    DPAR_MIO_TOL_REL_RELAX_INT int32 = 61
    DPAR_MIO_TOL_X int32 = 62
    DPAR_OPTIMIZER_MAX_TIME int32 = 63
    DPAR_PRESOLVE_TOL_ABS_LINDEP int32 = 64
    DPAR_PRESOLVE_TOL_AIJ int32 = 65
    DPAR_PRESOLVE_TOL_REL_LINDEP int32 = 66
    DPAR_PRESOLVE_TOL_S int32 = 67
    DPAR_PRESOLVE_TOL_X int32 = 68
    DPAR_QCQO_REFORMULATE_REL_DROP_TOL int32 = 69
    DPAR_SEMIDEFINITE_TOL_APPROX int32 = 70
    DPAR_SIM_LU_TOL_REL_PIV int32 = 71
    DPAR_SIMPLEX_ABS_TOL_PIV int32 = 72
    DPAR_UPPER_OBJ_CUT int32 = 73
    DPAR_UPPER_OBJ_CUT_FINITE_TRH int32 = 74
    DPAR_BEGIN int32 = 0
    DPAR_END   int32 = 75
)
const ( // enum simdupvec
    SIM_EXPLOIT_DUPVEC_FREE int32 = 2
    SIM_EXPLOIT_DUPVEC_OFF int32 = 0
    SIM_EXPLOIT_DUPVEC_ON int32 = 1
    SIM_EXPLOIT_DUPVEC_BEGIN int32 = 0
    SIM_EXPLOIT_DUPVEC_END   int32 = 3
)
const ( // enum compresstype
    COMPRESS_FREE int32 = 1
    COMPRESS_GZIP int32 = 2
    COMPRESS_NONE int32 = 0
    COMPRESS_BEGIN int32 = 0
    COMPRESS_END   int32 = 3
)
const ( // enum nametype
    NAME_TYPE_GEN int32 = 0
    NAME_TYPE_LP int32 = 2
    NAME_TYPE_MPS int32 = 1
    NAME_TYPE_BEGIN int32 = 0
    NAME_TYPE_END   int32 = 3
)
const ( // enum mpsformat
    MPS_FORMAT_CPLEX int32 = 3
    MPS_FORMAT_FREE int32 = 2
    MPS_FORMAT_RELAXED int32 = 1
    MPS_FORMAT_STRICT int32 = 0
    MPS_FORMAT_BEGIN int32 = 0
    MPS_FORMAT_END   int32 = 4
)
const ( // enum variabletype
    VAR_TYPE_CONT int32 = 0
    VAR_TYPE_INT int32 = 1
    VAR_BEGIN int32 = 0
    VAR_END   int32 = 2
)
const ( // enum checkconvexitytype
    CHECK_CONVEXITY_FULL int32 = 2
    CHECK_CONVEXITY_NONE int32 = 0
    CHECK_CONVEXITY_SIMPLE int32 = 1
    CHECK_CONVEXITY_BEGIN int32 = 0
    CHECK_CONVEXITY_END   int32 = 3
)
const ( // enum language
    LANG_DAN int32 = 1
    LANG_ENG int32 = 0
    LANG_BEGIN int32 = 0
    LANG_END   int32 = 2
)
const ( // enum startpointtype
    STARTING_POINT_CONSTANT int32 = 2
    STARTING_POINT_FREE int32 = 0
    STARTING_POINT_GUESS int32 = 1
    STARTING_POINT_SATISFY_BOUNDS int32 = 3
    STARTING_POINT_BEGIN int32 = 0
    STARTING_POINT_END   int32 = 4
)
const ( // enum soltype
    SOL_BAS int32 = 1
    SOL_ITG int32 = 2
    SOL_ITR int32 = 0
    SOL_BEGIN int32 = 0
    SOL_END   int32 = 3
)
const ( // enum scalingmethod
    SCALING_METHOD_FREE int32 = 1
    SCALING_METHOD_POW2 int32 = 0
    SCALING_METHOD_BEGIN int32 = 0
    SCALING_METHOD_END   int32 = 2
)
const ( // enum value
    LICENSE_BUFFER_LENGTH int32 = 20
    MAX_STR_LEN int32 = 1024
)
const ( // enum stakey
    SK_BAS int32 = 1
    SK_FIX int32 = 5
    SK_INF int32 = 6
    SK_LOW int32 = 3
    SK_SUPBAS int32 = 2
    SK_UNK int32 = 0
    SK_UPR int32 = 4
    SK_BEGIN int32 = 0
    SK_END   int32 = 7
)
const ( // enum simreform
    SIM_REFORMULATION_AGGRESSIVE int32 = 3
    SIM_REFORMULATION_FREE int32 = 2
    SIM_REFORMULATION_OFF int32 = 0
    SIM_REFORMULATION_ON int32 = 1
    SIM_REFORMULATION_BEGIN int32 = 0
    SIM_REFORMULATION_END   int32 = 4
)
const ( // enum iinfitem
    IINF_ANA_PRO_NUM_CON int32 = 0
    IINF_ANA_PRO_NUM_CON_EQ int32 = 1
    IINF_ANA_PRO_NUM_CON_FR int32 = 2
    IINF_ANA_PRO_NUM_CON_LO int32 = 3
    IINF_ANA_PRO_NUM_CON_RA int32 = 4
    IINF_ANA_PRO_NUM_CON_UP int32 = 5
    IINF_ANA_PRO_NUM_VAR int32 = 6
    IINF_ANA_PRO_NUM_VAR_BIN int32 = 7
    IINF_ANA_PRO_NUM_VAR_CONT int32 = 8
    IINF_ANA_PRO_NUM_VAR_EQ int32 = 9
    IINF_ANA_PRO_NUM_VAR_FR int32 = 10
    IINF_ANA_PRO_NUM_VAR_INT int32 = 11
    IINF_ANA_PRO_NUM_VAR_LO int32 = 12
    IINF_ANA_PRO_NUM_VAR_RA int32 = 13
    IINF_ANA_PRO_NUM_VAR_UP int32 = 14
    IINF_CONCURRENT_FASTEST_OPTIMIZER int32 = 15
    IINF_INTPNT_FACTOR_DIM_DENSE int32 = 16
    IINF_INTPNT_ITER int32 = 17
    IINF_INTPNT_NUM_THREADS int32 = 18
    IINF_INTPNT_SOLVE_DUAL int32 = 19
    IINF_MIO_ABSGAP_SATISFIED int32 = 20
    IINF_MIO_CONSTRUCT_NUM_ROUNDINGS int32 = 21
    IINF_MIO_CONSTRUCT_SOLUTION int32 = 22
    IINF_MIO_INITIAL_SOLUTION int32 = 23
    IINF_MIO_NEAR_ABSGAP_SATISFIED int32 = 24
    IINF_MIO_NEAR_RELGAP_SATISFIED int32 = 25
    IINF_MIO_NODE_DEPTH int32 = 26
    IINF_MIO_NUM_ACTIVE_NODES int32 = 27
    IINF_MIO_NUM_BRANCH int32 = 28
    IINF_MIO_NUM_CMIR_CUTS int32 = 29
    IINF_MIO_NUM_GOMORY_CUTS int32 = 30
    IINF_MIO_NUM_INT_SOLUTIONS int32 = 31
    IINF_MIO_NUM_RELAX int32 = 32
    IINF_MIO_NUM_REPEATED_PRESOLVE int32 = 33
    IINF_MIO_NUMCON int32 = 34
    IINF_MIO_NUMINT int32 = 35
    IINF_MIO_NUMVAR int32 = 36
    IINF_MIO_OBJ_BOUND_DEFINED int32 = 37
    IINF_MIO_PRESOLVED_NUMBIN int32 = 38
    IINF_MIO_PRESOLVED_NUMCON int32 = 39
    IINF_MIO_PRESOLVED_NUMCONT int32 = 40
    IINF_MIO_PRESOLVED_NUMINT int32 = 41
    IINF_MIO_PRESOLVED_NUMVAR int32 = 42
    IINF_MIO_RELGAP_SATISFIED int32 = 43
    IINF_MIO_TOTAL_NUM_CUTS int32 = 44
    IINF_MIO_USER_OBJ_CUT int32 = 45
    IINF_OPT_NUMCON int32 = 46
    IINF_OPT_NUMVAR int32 = 47
    IINF_OPTIMIZE_RESPONSE int32 = 48
    IINF_RD_NUMBARVAR int32 = 49
    IINF_RD_NUMCON int32 = 50
    IINF_RD_NUMCONE int32 = 51
    IINF_RD_NUMINTVAR int32 = 52
    IINF_RD_NUMQ int32 = 53
    IINF_RD_NUMVAR int32 = 54
    IINF_RD_PROTYPE int32 = 55
    IINF_SIM_DUAL_DEG_ITER int32 = 56
    IINF_SIM_DUAL_HOTSTART int32 = 57
    IINF_SIM_DUAL_HOTSTART_LU int32 = 58
    IINF_SIM_DUAL_INF_ITER int32 = 59
    IINF_SIM_DUAL_ITER int32 = 60
    IINF_SIM_NETWORK_DUAL_DEG_ITER int32 = 61
    IINF_SIM_NETWORK_DUAL_HOTSTART int32 = 62
    IINF_SIM_NETWORK_DUAL_HOTSTART_LU int32 = 63
    IINF_SIM_NETWORK_DUAL_INF_ITER int32 = 64
    IINF_SIM_NETWORK_DUAL_ITER int32 = 65
    IINF_SIM_NETWORK_PRIMAL_DEG_ITER int32 = 66
    IINF_SIM_NETWORK_PRIMAL_HOTSTART int32 = 67
    IINF_SIM_NETWORK_PRIMAL_HOTSTART_LU int32 = 68
    IINF_SIM_NETWORK_PRIMAL_INF_ITER int32 = 69
    IINF_SIM_NETWORK_PRIMAL_ITER int32 = 70
    IINF_SIM_NUMCON int32 = 71
    IINF_SIM_NUMVAR int32 = 72
    IINF_SIM_PRIMAL_DEG_ITER int32 = 73
    IINF_SIM_PRIMAL_DUAL_DEG_ITER int32 = 74
    IINF_SIM_PRIMAL_DUAL_HOTSTART int32 = 75
    IINF_SIM_PRIMAL_DUAL_HOTSTART_LU int32 = 76
    IINF_SIM_PRIMAL_DUAL_INF_ITER int32 = 77
    IINF_SIM_PRIMAL_DUAL_ITER int32 = 78
    IINF_SIM_PRIMAL_HOTSTART int32 = 79
    IINF_SIM_PRIMAL_HOTSTART_LU int32 = 80
    IINF_SIM_PRIMAL_INF_ITER int32 = 81
    IINF_SIM_PRIMAL_ITER int32 = 82
    IINF_SIM_SOLVE_DUAL int32 = 83
    IINF_SOL_BAS_PROSTA int32 = 84
    IINF_SOL_BAS_SOLSTA int32 = 85
    IINF_SOL_ITG_PROSTA int32 = 86
    IINF_SOL_ITG_SOLSTA int32 = 87
    IINF_SOL_ITR_PROSTA int32 = 88
    IINF_SOL_ITR_SOLSTA int32 = 89
    IINF_STO_NUM_A_CACHE_FLUSHES int32 = 90
    IINF_STO_NUM_A_REALLOC int32 = 91
    IINF_STO_NUM_A_TRANSPOSES int32 = 92
    IINF_BEGIN int32 = 0
    IINF_END   int32 = 93
)
const ( // enum xmlwriteroutputtype
    WRITE_XML_MODE_COL int32 = 1
    WRITE_XML_MODE_ROW int32 = 0
    WRITE_XML_MODE_BEGIN int32 = 0
    WRITE_XML_MODE_END   int32 = 2
)
const ( // enum optimizertype
    OPTIMIZER_CONCURRENT int32 = 10
    OPTIMIZER_CONIC int32 = 2
    OPTIMIZER_DUAL_SIMPLEX int32 = 4
    OPTIMIZER_FREE int32 = 0
    OPTIMIZER_FREE_SIMPLEX int32 = 6
    OPTIMIZER_INTPNT int32 = 1
    OPTIMIZER_MIXED_INT int32 = 9
    OPTIMIZER_MIXED_INT_CONIC int32 = 8
    OPTIMIZER_NETWORK_PRIMAL_SIMPLEX int32 = 7
    OPTIMIZER_PRIMAL_DUAL_SIMPLEX int32 = 5
    OPTIMIZER_PRIMAL_SIMPLEX int32 = 3
    OPTIMIZER_BEGIN int32 = 0
    OPTIMIZER_END   int32 = 11
)
const ( // enum presolvemode
    PRESOLVE_MODE_FREE int32 = 2
    PRESOLVE_MODE_OFF int32 = 0
    PRESOLVE_MODE_ON int32 = 1
    PRESOLVE_MODE_BEGIN int32 = 0
    PRESOLVE_MODE_END   int32 = 3
)
const ( // enum miocontsoltype
    MIO_CONT_SOL_ITG int32 = 2
    MIO_CONT_SOL_ITG_REL int32 = 3
    MIO_CONT_SOL_NONE int32 = 0
    MIO_CONT_SOL_ROOT int32 = 1
    MIO_CONT_SOL_BEGIN int32 = 0
    MIO_CONT_SOL_END   int32 = 4
)
func (task *Task) AnalyzeNames(whichstream_ int32,nametype_ int32) (_res int32) {
  _res = int32(C.MSK_analyzenames(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKnametypee(nametype_)))
  if _res != 0 { return }
  return
}
func (task *Task) AnalyzeProblem(whichstream_ int32) (_res int32) {
  _res = int32(C.MSK_analyzeproblem(task.ptr(),C.MSKstreamtypee(whichstream_)))
  if _res != 0 { return }
  return
}
func (task *Task) AnalyzeSolution(whichstream_ int32,whichsol_ int32) (_res int32) {
  _res = int32(C.MSK_analyzesolution(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKsoltypee(whichsol_)))
  if _res != 0 { return }
  return
}
func (task *Task) AppendBarvars(dim_ []int32) (_res int32) {
  num_ := minint([]int{ len(dim_) })
  _c_num_ := C.MSKint32t(num_)
  if dim_ == nil { panic("Argument 'dim_' is nil in call to 'AppendBarvars'") }
  var _c_dim_ *C.MSKint32t = nil
  if len(dim_) > 0 { _c_dim_ = (*C.MSKint32t)(&dim_[0]) }
  _res = int32(C.MSK_appendbarvars(task.ptr(),_c_num_,_c_dim_))
  if _res != 0 { return }
  return
}
func (task *Task) AppendCone(conetype_ int32,conepar_ float64,submem_ []int32) (_res int32) {
  _c_conepar_ := C.MSKrealt(conepar_)
  nummem_ := minint([]int{ len(submem_) })
  _c_nummem_ := C.MSKint32t(nummem_)
  if submem_ == nil { panic("Argument 'submem_' is nil in call to 'AppendCone'") }
  var _c_submem_ *C.MSKint32t = nil
  if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
  _res = int32(C.MSK_appendcone(task.ptr(),C.MSKconetypee(conetype_),_c_conepar_,_c_nummem_,_c_submem_))
  if _res != 0 { return }
  return
}
func (task *Task) AppendConeSeq(conetype_ int32,conepar_ float64,nummem_ int32,j_ int32) (_res int32) {
  _c_conepar_ := C.MSKrealt(conepar_)
  _c_nummem_ := C.MSKint32t(nummem_)
  _c_j_ := C.MSKint32t(j_)
  _res = int32(C.MSK_appendconeseq(task.ptr(),C.MSKconetypee(conetype_),_c_conepar_,_c_nummem_,_c_j_))
  if _res != 0 { return }
  return
}
func (task *Task) AppendConesSeq(conetype_ []int32,conepar_ []float64,nummem_ []int32,j_ int32) (_res int32) {
  num_ := minint([]int{ len(conetype_),len(conepar_),len(nummem_) })
  _c_num_ := C.MSKint32t(num_)
  if conetype_ == nil { panic("Argument 'conetype_' is nil in call to 'AppendConesSeq'") }
  var _c_conetype_ *C.MSKconetypee = nil
  if len(conetype_) > 0 { _c_conetype_ = (*C.MSKconetypee)(unsafe.Pointer(&conetype_[0])) }
  if conepar_ == nil { panic("Argument 'conepar_' is nil in call to 'AppendConesSeq'") }
  var _c_conepar_ *C.MSKrealt = nil
  if len(conepar_) > 0 { _c_conepar_ = (*C.MSKrealt)(&conepar_[0]) }
  if nummem_ == nil { panic("Argument 'nummem_' is nil in call to 'AppendConesSeq'") }
  var _c_nummem_ *C.MSKint32t = nil
  if len(nummem_) > 0 { _c_nummem_ = (*C.MSKint32t)(&nummem_[0]) }
  _c_j_ := C.MSKint32t(j_)
  _res = int32(C.MSK_appendconesseq(task.ptr(),_c_num_,_c_conetype_,_c_conepar_,_c_nummem_,_c_j_))
  if _res != 0 { return }
  return
}
func (task *Task) AppendCons(num_ int32) (_res int32) {
  _c_num_ := C.MSKint32t(num_)
  _res = int32(C.MSK_appendcons(task.ptr(),_c_num_))
  if _res != 0 { return }
  return
}
func (task *Task) AppendSparseSymMat(dim_ int32,subi_ []int32,subj_ []int32,valij_ []float64) (_r_idx_ int64,_res int32) {
  _c_dim_ := C.MSKint32t(dim_)
  nz_ := minint([]int{ len(subi_),len(subj_),len(valij_) })
  _c_nz_ := C.MSKint64t(nz_)
  if subi_ == nil { panic("Argument 'subi_' is nil in call to 'AppendSparseSymMat'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'AppendSparseSymMat'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if valij_ == nil { panic("Argument 'valij_' is nil in call to 'AppendSparseSymMat'") }
  var _c_valij_ *C.MSKrealt = nil
  if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
  var _c_idx_ C.MSKint64t
  _res = int32(C.MSK_appendsparsesymmat(task.ptr(),_c_dim_,_c_nz_,_c_subi_,_c_subj_,_c_valij_,&_c_idx_))
  if _res != 0 { return }
  _r_idx_ = int64(_c_idx_)
  return
}
func (task *Task) AppendStat() (_res int32) {
  _res = int32(C.MSK_appendstat(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) AppendVars(num_ int32) (_res int32) {
  _c_num_ := C.MSKint32t(num_)
  _res = int32(C.MSK_appendvars(task.ptr(),_c_num_))
  if _res != 0 { return }
  return
}
func (task *Task) BasisCond() (_r_nrmbasis_ float64,_r_nrminvbasis_ float64,_res int32) {
  var _c_nrmbasis_ C.MSKrealt
  var _c_nrminvbasis_ C.MSKrealt
  _res = int32(C.MSK_basiscond(task.ptr(),&_c_nrmbasis_,&_c_nrminvbasis_))
  if _res != 0 { return }
  _r_nrmbasis_ = float64(_c_nrmbasis_)
  _r_nrminvbasis_ = float64(_c_nrminvbasis_)
  return
}
func (task *Task) CheckConvexity() (_res int32) {
  _res = int32(C.MSK_checkconvexity(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) CheckMem(file_ string,line_ int32) (_res int32) {
  _c_file_ := C.CString(file_)
  defer C.free(unsafe.Pointer(_c_file_))
  _c_line_ := C.MSKint32t(line_)
  _res = int32(C.MSK_checkmemtask(task.ptr(),C.MSKstring_t(_c_file_),_c_line_))
  if _res != 0 { return }
  return
}
func (task *Task) ChgBound(accmode_ int32,i_ int32,lower_ int32,finite_ int32,value_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_lower_ := C.MSKint32t(lower_)
  _c_finite_ := C.MSKint32t(finite_)
  _c_value_ := C.MSKrealt(value_)
  _res = int32(C.MSK_chgbound(task.ptr(),C.MSKaccmodee(accmode_),_c_i_,_c_lower_,_c_finite_,_c_value_))
  if _res != 0 { return }
  return
}
func (task *Task) ChgConBound(i_ int32,lower_ int32,finite_ int32,value_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_lower_ := C.MSKint32t(lower_)
  _c_finite_ := C.MSKint32t(finite_)
  _c_value_ := C.MSKrealt(value_)
  _res = int32(C.MSK_chgconbound(task.ptr(),_c_i_,_c_lower_,_c_finite_,_c_value_))
  if _res != 0 { return }
  return
}
func (task *Task) ChgVarBound(j_ int32,lower_ int32,finite_ int32,value_ float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_lower_ := C.MSKint32t(lower_)
  _c_finite_ := C.MSKint32t(finite_)
  _c_value_ := C.MSKrealt(value_)
  _res = int32(C.MSK_chgvarbound(task.ptr(),_c_j_,_c_lower_,_c_finite_,_c_value_))
  if _res != 0 { return }
  return
}
func (task *Task) CommitChanges() (_res int32) {
  _res = int32(C.MSK_commitchanges(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) DeleteSolution(whichsol_ int32) (_res int32) {
  _res = int32(C.MSK_deletesolution(task.ptr(),C.MSKsoltypee(whichsol_)))
  if _res != 0 { return }
  return
}
func (task *Task) DualSensitivity(subj_ []int32,leftpricej_ []float64,rightpricej_ []float64,leftrangej_ []float64,rightrangej_ []float64) (_r_leftpricej_ []float64,_r_rightpricej_ []float64,_r_leftrangej_ []float64,_r_rightrangej_ []float64,_res int32) {
  numj_ := minint([]int{ len(subj_) })
  _c_numj_ := C.MSKint32t(numj_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'DualSensitivity'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if leftpricej_ == nil { leftpricej_ = make([]float64,numj_,numj_)
  } else if len(leftpricej_) < int(numj_) { panic("Slice in 'leftpricej_' is too short in call to 'DualSensitivity'") }
  var _c_leftpricej_ *C.MSKrealt = nil
  if len(leftpricej_) > 0 { _c_leftpricej_ = (*C.MSKrealt)(&leftpricej_[0]) }
  if rightpricej_ == nil { rightpricej_ = make([]float64,numj_,numj_)
  } else if len(rightpricej_) < int(numj_) { panic("Slice in 'rightpricej_' is too short in call to 'DualSensitivity'") }
  var _c_rightpricej_ *C.MSKrealt = nil
  if len(rightpricej_) > 0 { _c_rightpricej_ = (*C.MSKrealt)(&rightpricej_[0]) }
  if leftrangej_ == nil { leftrangej_ = make([]float64,numj_,numj_)
  } else if len(leftrangej_) < int(numj_) { panic("Slice in 'leftrangej_' is too short in call to 'DualSensitivity'") }
  var _c_leftrangej_ *C.MSKrealt = nil
  if len(leftrangej_) > 0 { _c_leftrangej_ = (*C.MSKrealt)(&leftrangej_[0]) }
  if rightrangej_ == nil { rightrangej_ = make([]float64,numj_,numj_)
  } else if len(rightrangej_) < int(numj_) { panic("Slice in 'rightrangej_' is too short in call to 'DualSensitivity'") }
  var _c_rightrangej_ *C.MSKrealt = nil
  if len(rightrangej_) > 0 { _c_rightrangej_ = (*C.MSKrealt)(&rightrangej_[0]) }
  _res = int32(C.MSK_dualsensitivity(task.ptr(),_c_numj_,_c_subj_,_c_leftpricej_,_c_rightpricej_,_c_leftrangej_,_c_rightrangej_))
  if _res != 0 { return }
  _r_leftpricej_ = leftpricej_
  _r_rightpricej_ = rightpricej_
  _r_leftrangej_ = leftrangej_
  _r_rightrangej_ = rightrangej_
  return
}
func (task *Task) GetACol(j_ int32,subj_ []int32,valj_ []float64) (_r_nzj_ int32,_r_subj_ []int32,_r_valj_ []float64,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_nzj_ C.MSKint32t
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetAColNumNz(j_)
  if _res != 0 { return }
  if subj_ == nil { subj_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(subj_) < int(__tmp_var_1) { panic("Slice in 'subj_' is too short in call to 'GetACol'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  var __tmp_var_4 int32
  __tmp_var_4,_res = task.GetAColNumNz(j_)
  if _res != 0 { return }
  if valj_ == nil { valj_ = make([]float64,__tmp_var_4,__tmp_var_4)
  } else if len(valj_) < int(__tmp_var_4) { panic("Slice in 'valj_' is too short in call to 'GetACol'") }
  var _c_valj_ *C.MSKrealt = nil
  if len(valj_) > 0 { _c_valj_ = (*C.MSKrealt)(&valj_[0]) }
  _res = int32(C.MSK_getacol(task.ptr(),_c_j_,&_c_nzj_,_c_subj_,_c_valj_))
  if _res != 0 { return }
  _r_nzj_ = int32(_c_nzj_)
  _r_subj_ = subj_
  _r_valj_ = valj_
  return
}
func (task *Task) GetAColNumNz(i_ int32) (_r_nzj_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_nzj_ C.MSKint32t
  _res = int32(C.MSK_getacolnumnz(task.ptr(),_c_i_,&_c_nzj_))
  if _res != 0 { return }
  _r_nzj_ = int32(_c_nzj_)
  return
}
func (task *Task) GetAColSliceTrip(first_ int32,last_ int32,subi_ []int32,subj_ []int32,val_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_val_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  maxnumnz_ := minint([]int{ len(subi_),len(subj_),len(val_) })
  _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
  var _c_surp_ C.MSKint64t = C.MSKint64t(len(subi_))
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if subi_ == nil { subi_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(subi_) < int(__tmp_var_1) { panic("Slice in 'subi_' is too short in call to 'GetAColSliceTrip'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  var __tmp_var_6 int64
  __tmp_var_6,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if subj_ == nil { subj_ = make([]int32,__tmp_var_6,__tmp_var_6)
  } else if len(subj_) < int(__tmp_var_6) { panic("Slice in 'subj_' is too short in call to 'GetAColSliceTrip'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  var __tmp_var_11 int64
  __tmp_var_11,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if val_ == nil { val_ = make([]float64,__tmp_var_11,__tmp_var_11)
  } else if len(val_) < int(__tmp_var_11) { panic("Slice in 'val_' is too short in call to 'GetAColSliceTrip'") }
  var _c_val_ *C.MSKrealt = nil
  if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
  _res = int32(C.MSK_getacolslicetrip(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_subi_,_c_subj_,_c_val_))
  if _res != 0 { return }
  _r_subi_ = subi_
  _r_subj_ = subj_
  _r_val_ = val_
  return
}
func (task *Task) GetAij(i_ int32,j_ int32) (_r_aij_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_j_ := C.MSKint32t(j_)
  var _c_aij_ C.MSKrealt
  _res = int32(C.MSK_getaij(task.ptr(),_c_i_,_c_j_,&_c_aij_))
  if _res != 0 { return }
  _r_aij_ = float64(_c_aij_)
  return
}
func (task *Task) GetAPieceNumNz(firsti_ int32,lasti_ int32,firstj_ int32,lastj_ int32) (_r_numnz_ int32,_res int32) {
  _c_firsti_ := C.MSKint32t(firsti_)
  _c_lasti_ := C.MSKint32t(lasti_)
  _c_firstj_ := C.MSKint32t(firstj_)
  _c_lastj_ := C.MSKint32t(lastj_)
  var _c_numnz_ C.MSKint32t
  _res = int32(C.MSK_getapiecenumnz(task.ptr(),_c_firsti_,_c_lasti_,_c_firstj_,_c_lastj_,&_c_numnz_))
  if _res != 0 { return }
  _r_numnz_ = int32(_c_numnz_)
  return
}
func (task *Task) GetARow(i_ int32,subi_ []int32,vali_ []float64) (_r_nzi_ int32,_r_subi_ []int32,_r_vali_ []float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_nzi_ C.MSKint32t
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetARowNumNz(i_)
  if _res != 0 { return }
  if subi_ == nil { subi_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(subi_) < int(__tmp_var_1) { panic("Slice in 'subi_' is too short in call to 'GetARow'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  var __tmp_var_4 int32
  __tmp_var_4,_res = task.GetARowNumNz(i_)
  if _res != 0 { return }
  if vali_ == nil { vali_ = make([]float64,__tmp_var_4,__tmp_var_4)
  } else if len(vali_) < int(__tmp_var_4) { panic("Slice in 'vali_' is too short in call to 'GetARow'") }
  var _c_vali_ *C.MSKrealt = nil
  if len(vali_) > 0 { _c_vali_ = (*C.MSKrealt)(&vali_[0]) }
  _res = int32(C.MSK_getarow(task.ptr(),_c_i_,&_c_nzi_,_c_subi_,_c_vali_))
  if _res != 0 { return }
  _r_nzi_ = int32(_c_nzi_)
  _r_subi_ = subi_
  _r_vali_ = vali_
  return
}
func (task *Task) GetARowNumNz(i_ int32) (_r_nzi_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_nzi_ C.MSKint32t
  _res = int32(C.MSK_getarownumnz(task.ptr(),_c_i_,&_c_nzi_))
  if _res != 0 { return }
  _r_nzi_ = int32(_c_nzi_)
  return
}
func (task *Task) GetARowSliceTrip(first_ int32,last_ int32,subi_ []int32,subj_ []int32,val_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_val_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  maxnumnz_ := minint([]int{ len(subi_),len(subj_),len(val_) })
  _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
  var _c_surp_ C.MSKint64t = C.MSKint64t(len(subi_))
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if subi_ == nil { subi_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(subi_) < int(__tmp_var_1) { panic("Slice in 'subi_' is too short in call to 'GetARowSliceTrip'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  var __tmp_var_6 int64
  __tmp_var_6,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if subj_ == nil { subj_ = make([]int32,__tmp_var_6,__tmp_var_6)
  } else if len(subj_) < int(__tmp_var_6) { panic("Slice in 'subj_' is too short in call to 'GetARowSliceTrip'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  var __tmp_var_11 int64
  __tmp_var_11,_res = task.GetASliceNumNz(ACC_CON,first_,last_)
  if _res != 0 { return }
  if val_ == nil { val_ = make([]float64,__tmp_var_11,__tmp_var_11)
  } else if len(val_) < int(__tmp_var_11) { panic("Slice in 'val_' is too short in call to 'GetARowSliceTrip'") }
  var _c_val_ *C.MSKrealt = nil
  if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
  _res = int32(C.MSK_getarowslicetrip(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_subi_,_c_subj_,_c_val_))
  if _res != 0 { return }
  _r_subi_ = subi_
  _r_subj_ = subj_
  _r_val_ = val_
  return
}
func (task *Task) GetASlice(accmode_ int32,first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,sub_ []int32,val_ []float64) (_r_ptrb_ []int64,_r_ptre_ []int64,_r_sub_ []int32,_r_val_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetASliceNumNz(accmode_,first_,last_)
  if _res != 0 { return }
  maxnumnz_ := __tmp_var_1
  _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
  var _c_surp_ C.MSKint64t = C.MSKint64t(len(sub_))
  if ptrb_ == nil { ptrb_ = make([]int64,last_ - first_,last_ - first_)
  } else if len(ptrb_) < int(last_ - first_) { panic("Slice in 'ptrb_' is too short in call to 'GetASlice'") }
  var _c_ptrb_ *C.MSKint64t = nil
  if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
  if ptre_ == nil { ptre_ = make([]int64,last_ - first_,last_ - first_)
  } else if len(ptre_) < int(last_ - first_) { panic("Slice in 'ptre_' is too short in call to 'GetASlice'") }
  var _c_ptre_ *C.MSKint64t = nil
  if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
  if sub_ == nil { sub_ = make([]int32,maxnumnz_,maxnumnz_)
  } else if len(sub_) < int(maxnumnz_) { panic("Slice in 'sub_' is too short in call to 'GetASlice'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if val_ == nil { val_ = make([]float64,maxnumnz_,maxnumnz_)
  } else if len(val_) < int(maxnumnz_) { panic("Slice in 'val_' is too short in call to 'GetASlice'") }
  var _c_val_ *C.MSKrealt = nil
  if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
  _res = int32(C.MSK_getaslice64(task.ptr(),C.MSKaccmodee(accmode_),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_ptrb_,_c_ptre_,_c_sub_,_c_val_))
  if _res != 0 { return }
  _r_ptrb_ = ptrb_
  _r_ptre_ = ptre_
  _r_sub_ = sub_
  _r_val_ = val_
  return
}
func (task *Task) GetASliceNumNz(accmode_ int32,first_ int32,last_ int32) (_r_numnz_ int64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  var _c_numnz_ C.MSKint64t
  _res = int32(C.MSK_getaslicenumnz64(task.ptr(),C.MSKaccmodee(accmode_),_c_first_,_c_last_,&_c_numnz_))
  if _res != 0 { return }
  _r_numnz_ = int64(_c_numnz_)
  return
}
func (task *Task) GetBaraBlockTriplet(subi_ []int32,subj_ []int32,subk_ []int32,subl_ []int32,valijkl_ []float64) (_r_num_ int64,_r_subi_ []int32,_r_subj_ []int32,_r_subk_ []int32,_r_subl_ []int32,_r_valijkl_ []float64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumBaraBlockTriplets()
  if _res != 0 { return }
  maxnum_ := __tmp_var_1
  _c_maxnum_ := C.MSKint64t(maxnum_)
  var _c_num_ C.MSKint64t
  if subi_ == nil { subi_ = make([]int32,maxnum_,maxnum_)
  } else if len(subi_) < int(maxnum_) { panic("Slice in 'subi_' is too short in call to 'GetBaraBlockTriplet'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if subj_ == nil { subj_ = make([]int32,maxnum_,maxnum_)
  } else if len(subj_) < int(maxnum_) { panic("Slice in 'subj_' is too short in call to 'GetBaraBlockTriplet'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if subk_ == nil { subk_ = make([]int32,maxnum_,maxnum_)
  } else if len(subk_) < int(maxnum_) { panic("Slice in 'subk_' is too short in call to 'GetBaraBlockTriplet'") }
  var _c_subk_ *C.MSKint32t = nil
  if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
  if subl_ == nil { subl_ = make([]int32,maxnum_,maxnum_)
  } else if len(subl_) < int(maxnum_) { panic("Slice in 'subl_' is too short in call to 'GetBaraBlockTriplet'") }
  var _c_subl_ *C.MSKint32t = nil
  if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
  if valijkl_ == nil { valijkl_ = make([]float64,maxnum_,maxnum_)
  } else if len(valijkl_) < int(maxnum_) { panic("Slice in 'valijkl_' is too short in call to 'GetBaraBlockTriplet'") }
  var _c_valijkl_ *C.MSKrealt = nil
  if len(valijkl_) > 0 { _c_valijkl_ = (*C.MSKrealt)(&valijkl_[0]) }
  _res = int32(C.MSK_getbarablocktriplet(task.ptr(),_c_maxnum_,&_c_num_,_c_subi_,_c_subj_,_c_subk_,_c_subl_,_c_valijkl_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  _r_subi_ = subi_
  _r_subj_ = subj_
  _r_subk_ = subk_
  _r_subl_ = subl_
  _r_valijkl_ = valijkl_
  return
}
func (task *Task) GetBaraIdx(idx_ int64,sub_ []int64,weights_ []float64) (_r_i_ int32,_r_j_ int32,_r_num_ int64,_r_sub_ []int64,_r_weights_ []float64,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetBaraIdxInfo(idx_)
  if _res != 0 { return }
  maxnum_ := __tmp_var_1
  _c_maxnum_ := C.MSKint64t(maxnum_)
  var _c_i_ C.MSKint32t
  var _c_j_ C.MSKint32t
  var _c_num_ C.MSKint64t
  if sub_ == nil { sub_ = make([]int64,maxnum_,maxnum_)
  } else if len(sub_) < int(maxnum_) { panic("Slice in 'sub_' is too short in call to 'GetBaraIdx'") }
  var _c_sub_ *C.MSKint64t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
  if weights_ == nil { weights_ = make([]float64,maxnum_,maxnum_)
  } else if len(weights_) < int(maxnum_) { panic("Slice in 'weights_' is too short in call to 'GetBaraIdx'") }
  var _c_weights_ *C.MSKrealt = nil
  if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
  _res = int32(C.MSK_getbaraidx(task.ptr(),_c_idx_,_c_maxnum_,&_c_i_,&_c_j_,&_c_num_,_c_sub_,_c_weights_))
  if _res != 0 { return }
  _r_i_ = int32(_c_i_)
  _r_j_ = int32(_c_j_)
  _r_num_ = int64(_c_num_)
  _r_sub_ = sub_
  _r_weights_ = weights_
  return
}
func (task *Task) GetBaraIdxIJ(idx_ int64) (_r_i_ int32,_r_j_ int32,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var _c_i_ C.MSKint32t
  var _c_j_ C.MSKint32t
  _res = int32(C.MSK_getbaraidxij(task.ptr(),_c_idx_,&_c_i_,&_c_j_))
  if _res != 0 { return }
  _r_i_ = int32(_c_i_)
  _r_j_ = int32(_c_j_)
  return
}
func (task *Task) GetBaraIdxInfo(idx_ int64) (_r_num_ int64,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var _c_num_ C.MSKint64t
  _res = int32(C.MSK_getbaraidxinfo(task.ptr(),_c_idx_,&_c_num_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  return
}
func (task *Task) GetBaraSparsity(idxij_ []int64) (_r_numnz_ int64,_r_idxij_ []int64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumBaraNz()
  if _res != 0 { return }
  maxnumnz_ := __tmp_var_1
  _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
  var _c_numnz_ C.MSKint64t
  if idxij_ == nil { idxij_ = make([]int64,maxnumnz_,maxnumnz_)
  } else if len(idxij_) < int(maxnumnz_) { panic("Slice in 'idxij_' is too short in call to 'GetBaraSparsity'") }
  var _c_idxij_ *C.MSKint64t = nil
  if len(idxij_) > 0 { _c_idxij_ = (*C.MSKint64t)(&idxij_[0]) }
  _res = int32(C.MSK_getbarasparsity(task.ptr(),_c_maxnumnz_,&_c_numnz_,_c_idxij_))
  if _res != 0 { return }
  _r_numnz_ = int64(_c_numnz_)
  _r_idxij_ = idxij_
  return
}
func (task *Task) GetBarcBlockTriplet(subj_ []int32,subk_ []int32,subl_ []int32,valijkl_ []float64) (_r_num_ int64,_r_subj_ []int32,_r_subk_ []int32,_r_subl_ []int32,_r_valijkl_ []float64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumBarcBlockTriplets()
  if _res != 0 { return }
  maxnum_ := __tmp_var_1
  _c_maxnum_ := C.MSKint64t(maxnum_)
  var _c_num_ C.MSKint64t
  if subj_ == nil { subj_ = make([]int32,maxnum_,maxnum_)
  } else if len(subj_) < int(maxnum_) { panic("Slice in 'subj_' is too short in call to 'GetBarcBlockTriplet'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if subk_ == nil { subk_ = make([]int32,maxnum_,maxnum_)
  } else if len(subk_) < int(maxnum_) { panic("Slice in 'subk_' is too short in call to 'GetBarcBlockTriplet'") }
  var _c_subk_ *C.MSKint32t = nil
  if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
  if subl_ == nil { subl_ = make([]int32,maxnum_,maxnum_)
  } else if len(subl_) < int(maxnum_) { panic("Slice in 'subl_' is too short in call to 'GetBarcBlockTriplet'") }
  var _c_subl_ *C.MSKint32t = nil
  if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
  if valijkl_ == nil { valijkl_ = make([]float64,maxnum_,maxnum_)
  } else if len(valijkl_) < int(maxnum_) { panic("Slice in 'valijkl_' is too short in call to 'GetBarcBlockTriplet'") }
  var _c_valijkl_ *C.MSKrealt = nil
  if len(valijkl_) > 0 { _c_valijkl_ = (*C.MSKrealt)(&valijkl_[0]) }
  _res = int32(C.MSK_getbarcblocktriplet(task.ptr(),_c_maxnum_,&_c_num_,_c_subj_,_c_subk_,_c_subl_,_c_valijkl_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  _r_subj_ = subj_
  _r_subk_ = subk_
  _r_subl_ = subl_
  _r_valijkl_ = valijkl_
  return
}
func (task *Task) GetBarcIdx(idx_ int64,sub_ []int64,weights_ []float64) (_r_j_ int32,_r_num_ int64,_r_sub_ []int64,_r_weights_ []float64,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetBarcIdxInfo(idx_)
  if _res != 0 { return }
  maxnum_ := __tmp_var_1
  _c_maxnum_ := C.MSKint64t(maxnum_)
  var _c_j_ C.MSKint32t
  var _c_num_ C.MSKint64t
  if sub_ == nil { sub_ = make([]int64,maxnum_,maxnum_)
  } else if len(sub_) < int(maxnum_) { panic("Slice in 'sub_' is too short in call to 'GetBarcIdx'") }
  var _c_sub_ *C.MSKint64t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
  if weights_ == nil { weights_ = make([]float64,maxnum_,maxnum_)
  } else if len(weights_) < int(maxnum_) { panic("Slice in 'weights_' is too short in call to 'GetBarcIdx'") }
  var _c_weights_ *C.MSKrealt = nil
  if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
  _res = int32(C.MSK_getbarcidx(task.ptr(),_c_idx_,_c_maxnum_,&_c_j_,&_c_num_,_c_sub_,_c_weights_))
  if _res != 0 { return }
  _r_j_ = int32(_c_j_)
  _r_num_ = int64(_c_num_)
  _r_sub_ = sub_
  _r_weights_ = weights_
  return
}
func (task *Task) GetBarcIdxInfo(idx_ int64) (_r_num_ int64,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var _c_num_ C.MSKint64t
  _res = int32(C.MSK_getbarcidxinfo(task.ptr(),_c_idx_,&_c_num_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  return
}
func (task *Task) GetBarcIdxJ(idx_ int64) (_r_j_ int32,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var _c_j_ C.MSKint32t
  _res = int32(C.MSK_getbarcidxj(task.ptr(),_c_idx_,&_c_j_))
  if _res != 0 { return }
  _r_j_ = int32(_c_j_)
  return
}
func (task *Task) GetBarcSparsity(idxj_ []int64) (_r_numnz_ int64,_r_idxj_ []int64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumBarcNz()
  if _res != 0 { return }
  maxnumnz_ := __tmp_var_1
  _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
  var _c_numnz_ C.MSKint64t
  if idxj_ == nil { idxj_ = make([]int64,maxnumnz_,maxnumnz_)
  } else if len(idxj_) < int(maxnumnz_) { panic("Slice in 'idxj_' is too short in call to 'GetBarcSparsity'") }
  var _c_idxj_ *C.MSKint64t = nil
  if len(idxj_) > 0 { _c_idxj_ = (*C.MSKint64t)(&idxj_[0]) }
  _res = int32(C.MSK_getbarcsparsity(task.ptr(),_c_maxnumnz_,&_c_numnz_,_c_idxj_))
  if _res != 0 { return }
  _r_numnz_ = int64(_c_numnz_)
  _r_idxj_ = idxj_
  return
}
func (task *Task) GetBarsJ(whichsol_ int32,j_ int32,barsj_ []float64) (_r_barsj_ []float64,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetLenBarvarJ(j_)
  if _res != 0 { return }
  if barsj_ == nil { barsj_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(barsj_) < int(__tmp_var_1) { panic("Slice in 'barsj_' is too short in call to 'GetBarsJ'") }
  var _c_barsj_ *C.MSKrealt = nil
  if len(barsj_) > 0 { _c_barsj_ = (*C.MSKrealt)(&barsj_[0]) }
  _res = int32(C.MSK_getbarsj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barsj_))
  if _res != 0 { return }
  _r_barsj_ = barsj_
  return
}
func (task *Task) GetBarvarName(i_ int32) (_r_name_ string,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetBarvarNameLen(i_)
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_name_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_getbarvarname(task.ptr(),_c_i_,_c_maxlen_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  _r_name_ = C.GoStringN(_c_name_,C.int(maxlen_))
  return
}
func (task *Task) GetBarvarNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32,_res int32) {
  _c_somename_ := C.CString(somename_)
  defer C.free(unsafe.Pointer(_c_somename_))
  var _c_asgn_ C.MSKint32t
  var _c_index_ C.MSKint32t
  _res = int32(C.MSK_getbarvarnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
  if _res != 0 { return }
  _r_asgn_ = int32(_c_asgn_)
  _r_index_ = int32(_c_index_)
  return
}
func (task *Task) GetBarvarNameLen(i_ int32) (_r_len_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getbarvarnamelen(task.ptr(),_c_i_,&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetBarxJ(whichsol_ int32,j_ int32,barxj_ []float64) (_r_barxj_ []float64,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetLenBarvarJ(j_)
  if _res != 0 { return }
  if barxj_ == nil { barxj_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(barxj_) < int(__tmp_var_1) { panic("Slice in 'barxj_' is too short in call to 'GetBarxJ'") }
  var _c_barxj_ *C.MSKrealt = nil
  if len(barxj_) > 0 { _c_barxj_ = (*C.MSKrealt)(&barxj_[0]) }
  _res = int32(C.MSK_getbarxj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barxj_))
  if _res != 0 { return }
  _r_barxj_ = barxj_
  return
}
func (task *Task) GetBound(accmode_ int32,i_ int32) (_r_bk_ int32,_r_bl_ float64,_r_bu_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_bk_ C.MSKboundkeye
  var _c_bl_ C.MSKrealt
  var _c_bu_ C.MSKrealt
  _res = int32(C.MSK_getbound(task.ptr(),C.MSKaccmodee(accmode_),_c_i_,&_c_bk_,&_c_bl_,&_c_bu_))
  if _res != 0 { return }
  _r_bk_ = int32(_c_bk_)
  _r_bl_ = float64(_c_bl_)
  _r_bu_ = float64(_c_bu_)
  return
}
func (task *Task) GetBoundSlice(accmode_ int32,first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_r_bk_ []int32,_r_bl_ []float64,_r_bu_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { bk_ = make([]int32,last_ - first_,last_ - first_)
  } else if len(bk_) < int(last_ - first_) { panic("Slice in 'bk_' is too short in call to 'GetBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { bl_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bl_) < int(last_ - first_) { panic("Slice in 'bl_' is too short in call to 'GetBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { bu_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bu_) < int(last_ - first_) { panic("Slice in 'bu_' is too short in call to 'GetBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_getboundslice(task.ptr(),C.MSKaccmodee(accmode_),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  _r_bk_ = bk_
  _r_bl_ = bl_
  _r_bu_ = bu_
  return
}
func (task *Task) GetC(c_ []float64) (_r_c_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if c_ == nil { c_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(c_) < int(__tmp_var_1) { panic("Slice in 'c_' is too short in call to 'GetC'") }
  var _c_c_ *C.MSKrealt = nil
  if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
  _res = int32(C.MSK_getc(task.ptr(),_c_c_))
  if _res != 0 { return }
  _r_c_ = c_
  return
}
func (task *Task) GetCfix() (_r_cfix_ float64,_res int32) {
  var _c_cfix_ C.MSKrealt
  _res = int32(C.MSK_getcfix(task.ptr(),&_c_cfix_))
  if _res != 0 { return }
  _r_cfix_ = float64(_c_cfix_)
  return
}
func (task *Task) GetCJ(j_ int32) (_r_cj_ float64,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_cj_ C.MSKrealt
  _res = int32(C.MSK_getcj(task.ptr(),_c_j_,&_c_cj_))
  if _res != 0 { return }
  _r_cj_ = float64(_c_cj_)
  return
}
func (task *Task) GetConBound(i_ int32) (_r_bk_ int32,_r_bl_ float64,_r_bu_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_bk_ C.MSKboundkeye
  var _c_bl_ C.MSKrealt
  var _c_bu_ C.MSKrealt
  _res = int32(C.MSK_getconbound(task.ptr(),_c_i_,&_c_bk_,&_c_bl_,&_c_bu_))
  if _res != 0 { return }
  _r_bk_ = int32(_c_bk_)
  _r_bl_ = float64(_c_bl_)
  _r_bu_ = float64(_c_bu_)
  return
}
func (task *Task) GetConBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_r_bk_ []int32,_r_bl_ []float64,_r_bu_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { bk_ = make([]int32,last_ - first_,last_ - first_)
  } else if len(bk_) < int(last_ - first_) { panic("Slice in 'bk_' is too short in call to 'GetConBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { bl_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bl_) < int(last_ - first_) { panic("Slice in 'bl_' is too short in call to 'GetConBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { bu_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bu_) < int(last_ - first_) { panic("Slice in 'bu_' is too short in call to 'GetConBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_getconboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  _r_bk_ = bk_
  _r_bl_ = bl_
  _r_bu_ = bu_
  return
}
func (task *Task) GetCone(k_ int32,submem_ []int32) (_r_conetype_ int32,_r_conepar_ float64,_r_nummem_ int32,_r_submem_ []int32,_res int32) {
  _c_k_ := C.MSKint32t(k_)
  var _c_conetype_ C.MSKconetypee
  var _c_conepar_ C.MSKrealt
  var _c_nummem_ C.MSKint32t
  var __tmp_var_1 int32
  _,_,__tmp_var_1,_res = task.GetConeInfo(k_)
  if _res != 0 { return }
  if submem_ == nil { submem_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(submem_) < int(__tmp_var_1) { panic("Slice in 'submem_' is too short in call to 'GetCone'") }
  var _c_submem_ *C.MSKint32t = nil
  if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
  _res = int32(C.MSK_getcone(task.ptr(),_c_k_,&_c_conetype_,&_c_conepar_,&_c_nummem_,_c_submem_))
  if _res != 0 { return }
  _r_conetype_ = int32(_c_conetype_)
  _r_conepar_ = float64(_c_conepar_)
  _r_nummem_ = int32(_c_nummem_)
  _r_submem_ = submem_
  return
}
func (task *Task) GetConeInfo(k_ int32) (_r_conetype_ int32,_r_conepar_ float64,_r_nummem_ int32,_res int32) {
  _c_k_ := C.MSKint32t(k_)
  var _c_conetype_ C.MSKconetypee
  var _c_conepar_ C.MSKrealt
  var _c_nummem_ C.MSKint32t
  _res = int32(C.MSK_getconeinfo(task.ptr(),_c_k_,&_c_conetype_,&_c_conepar_,&_c_nummem_))
  if _res != 0 { return }
  _r_conetype_ = int32(_c_conetype_)
  _r_conepar_ = float64(_c_conepar_)
  _r_nummem_ = int32(_c_nummem_)
  return
}
func (task *Task) GetConeName(i_ int32) (_r_name_ string,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetConeNameLen(i_)
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_name_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_getconename(task.ptr(),_c_i_,_c_maxlen_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  _r_name_ = C.GoStringN(_c_name_,C.int(maxlen_))
  return
}
func (task *Task) GetConeNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32,_res int32) {
  _c_somename_ := C.CString(somename_)
  defer C.free(unsafe.Pointer(_c_somename_))
  var _c_asgn_ C.MSKint32t
  var _c_index_ C.MSKint32t
  _res = int32(C.MSK_getconenameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
  if _res != 0 { return }
  _r_asgn_ = int32(_c_asgn_)
  _r_index_ = int32(_c_index_)
  return
}
func (task *Task) GetConeNameLen(i_ int32) (_r_len_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getconenamelen(task.ptr(),_c_i_,&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetConName(i_ int32) (_r_name_ string,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetConNameLen(i_)
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_name_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_getconname(task.ptr(),_c_i_,_c_maxlen_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  _r_name_ = C.GoStringN(_c_name_,C.int(maxlen_))
  return
}
func (task *Task) GetConNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32,_res int32) {
  _c_somename_ := C.CString(somename_)
  defer C.free(unsafe.Pointer(_c_somename_))
  var _c_asgn_ C.MSKint32t
  var _c_index_ C.MSKint32t
  _res = int32(C.MSK_getconnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
  if _res != 0 { return }
  _r_asgn_ = int32(_c_asgn_)
  _r_index_ = int32(_c_index_)
  return
}
func (task *Task) GetConNameLen(i_ int32) (_r_len_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getconnamelen(task.ptr(),_c_i_,&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetCSlice(first_ int32,last_ int32,c_ []float64) (_r_c_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if c_ == nil { c_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(c_) < int(last_ - first_) { panic("Slice in 'c_' is too short in call to 'GetCSlice'") }
  var _c_c_ *C.MSKrealt = nil
  if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
  _res = int32(C.MSK_getcslice(task.ptr(),_c_first_,_c_last_,_c_c_))
  if _res != 0 { return }
  _r_c_ = c_
  return
}
func (task *Task) GetDimBarvarJ(j_ int32) (_r_dimbarvarj_ int32,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_dimbarvarj_ C.MSKint32t
  _res = int32(C.MSK_getdimbarvarj(task.ptr(),_c_j_,&_c_dimbarvarj_))
  if _res != 0 { return }
  _r_dimbarvarj_ = int32(_c_dimbarvarj_)
  return
}
func (task *Task) GetDouInf(whichdinf_ int32) (_r_dvalue_ float64,_res int32) {
  var _c_dvalue_ C.MSKrealt
  _res = int32(C.MSK_getdouinf(task.ptr(),C.MSKdinfiteme(whichdinf_),&_c_dvalue_))
  if _res != 0 { return }
  _r_dvalue_ = float64(_c_dvalue_)
  return
}
func (task *Task) GetDouParam(param_ int32) (_r_parvalue_ float64,_res int32) {
  var _c_parvalue_ C.MSKrealt
  _res = int32(C.MSK_getdouparam(task.ptr(),C.MSKdparame(param_),&_c_parvalue_))
  if _res != 0 { return }
  _r_parvalue_ = float64(_c_parvalue_)
  return
}
func (task *Task) GetDualObj(whichsol_ int32) (_r_dualobj_ float64,_res int32) {
  var _c_dualobj_ C.MSKrealt
  _res = int32(C.MSK_getdualobj(task.ptr(),C.MSKsoltypee(whichsol_),&_c_dualobj_))
  if _res != 0 { return }
  _r_dualobj_ = float64(_c_dualobj_)
  return
}
func (task *Task) GetDviolBarvar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolBarvar'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolBarvar'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getdviolbarvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetDviolCon(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolCon'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolCon'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getdviolcon(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetDviolCones(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolCones'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolCones'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getdviolcones(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetDviolVar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolVar'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolVar'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getdviolvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetInfeasibleSubProblem(whichsol_ int32) (_r_inftask_ Task,_res int32) {
  var _c_inftask_ C.MSKtask_t
  _res = int32(C.MSK_getinfeasiblesubproblem(task.ptr(),C.MSKsoltypee(whichsol_),&_c_inftask_))
  if _res != 0 { return }
  _r_inftask_.cptr = unsafe.Pointer(_c_inftask_)
  return
}
func (task *Task) GetInfIndex(inftype_ int32,infname_ string) (_r_infindex_ int32,_res int32) {
  _c_infname_ := C.CString(infname_)
  defer C.free(unsafe.Pointer(_c_infname_))
  var _c_infindex_ C.MSKint32t
  _res = int32(C.MSK_getinfindex(task.ptr(),C.MSKinftypee(inftype_),C.MSKstring_t(_c_infname_),&_c_infindex_))
  if _res != 0 { return }
  _r_infindex_ = int32(_c_infindex_)
  return
}
func (task *Task) GetInfMax(inftype_ int32,infmax_ []int32) (_r_infmax_ []int32,_res int32) {
  if infmax_ == nil { infmax_ = make([]int32,MAX_STR_LEN,MAX_STR_LEN)
  } else if len(infmax_) < int(MAX_STR_LEN) { panic("Slice in 'infmax_' is too short in call to 'GetInfMax'") }
  var _c_infmax_ *C.MSKint32t = nil
  if len(infmax_) > 0 { _c_infmax_ = (*C.MSKint32t)(&infmax_[0]) }
  _res = int32(C.MSK_getinfmax(task.ptr(),C.MSKinftypee(inftype_),_c_infmax_))
  if _res != 0 { return }
  _r_infmax_ = infmax_
  return
}
func (task *Task) GetInfName(inftype_ int32,whichinf_ int32) (_r_infname_ string,_res int32) {
  _c_whichinf_ := C.MSKint32t(whichinf_)
  _c_infname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_infname_))
  _res = int32(C.MSK_getinfname(task.ptr(),C.MSKinftypee(inftype_),_c_whichinf_,C.MSKstring_t(_c_infname_)))
  if _res != 0 { return }
  _r_infname_ = C.GoStringN(_c_infname_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) GetIntInf(whichiinf_ int32) (_r_ivalue_ int32,_res int32) {
  var _c_ivalue_ C.MSKint32t
  _res = int32(C.MSK_getintinf(task.ptr(),C.MSKiinfiteme(whichiinf_),&_c_ivalue_))
  if _res != 0 { return }
  _r_ivalue_ = int32(_c_ivalue_)
  return
}
func (task *Task) GetIntParam(param_ int32) (_r_parvalue_ int32,_res int32) {
  var _c_parvalue_ C.MSKint32t
  _res = int32(C.MSK_getintparam(task.ptr(),C.MSKiparame(param_),&_c_parvalue_))
  if _res != 0 { return }
  _r_parvalue_ = int32(_c_parvalue_)
  return
}
func (task *Task) GetLenBarvarJ(j_ int32) (_r_lenbarvarj_ int64,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_lenbarvarj_ C.MSKint64t
  _res = int32(C.MSK_getlenbarvarj(task.ptr(),_c_j_,&_c_lenbarvarj_))
  if _res != 0 { return }
  _r_lenbarvarj_ = int64(_c_lenbarvarj_)
  return
}
func (task *Task) GetLintInf(whichliinf_ int32) (_r_ivalue_ int64,_res int32) {
  var _c_ivalue_ C.MSKint64t
  _res = int32(C.MSK_getlintinf(task.ptr(),C.MSKliinfiteme(whichliinf_),&_c_ivalue_))
  if _res != 0 { return }
  _r_ivalue_ = int64(_c_ivalue_)
  return
}
func (task *Task) GetMaxNumANz() (_r_maxnumanz_ int64,_res int32) {
  var _c_maxnumanz_ C.MSKint64t
  _res = int32(C.MSK_getmaxnumanz64(task.ptr(),&_c_maxnumanz_))
  if _res != 0 { return }
  _r_maxnumanz_ = int64(_c_maxnumanz_)
  return
}
func (task *Task) GetMaxNumBarvar() (_r_maxnumbarvar_ int32,_res int32) {
  var _c_maxnumbarvar_ C.MSKint32t
  _res = int32(C.MSK_getmaxnumbarvar(task.ptr(),&_c_maxnumbarvar_))
  if _res != 0 { return }
  _r_maxnumbarvar_ = int32(_c_maxnumbarvar_)
  return
}
func (task *Task) GetMaxNumCon() (_r_maxnumcon_ int32,_res int32) {
  var _c_maxnumcon_ C.MSKint32t
  _res = int32(C.MSK_getmaxnumcon(task.ptr(),&_c_maxnumcon_))
  if _res != 0 { return }
  _r_maxnumcon_ = int32(_c_maxnumcon_)
  return
}
func (task *Task) GetMaxNumCone() (_r_maxnumcone_ int32,_res int32) {
  var _c_maxnumcone_ C.MSKint32t
  _res = int32(C.MSK_getmaxnumcone(task.ptr(),&_c_maxnumcone_))
  if _res != 0 { return }
  _r_maxnumcone_ = int32(_c_maxnumcone_)
  return
}
func (task *Task) GetMaxNumQNz() (_r_maxnumqnz_ int64,_res int32) {
  var _c_maxnumqnz_ C.MSKint64t
  _res = int32(C.MSK_getmaxnumqnz64(task.ptr(),&_c_maxnumqnz_))
  if _res != 0 { return }
  _r_maxnumqnz_ = int64(_c_maxnumqnz_)
  return
}
func (task *Task) GetMaxNumVar() (_r_maxnumvar_ int32,_res int32) {
  var _c_maxnumvar_ C.MSKint32t
  _res = int32(C.MSK_getmaxnumvar(task.ptr(),&_c_maxnumvar_))
  if _res != 0 { return }
  _r_maxnumvar_ = int32(_c_maxnumvar_)
  return
}
func (task *Task) GetMemUsage() (_r_meminuse_ int64,_r_maxmemuse_ int64,_res int32) {
  var _c_meminuse_ C.MSKint64t
  var _c_maxmemuse_ C.MSKint64t
  _res = int32(C.MSK_getmemusagetask(task.ptr(),&_c_meminuse_,&_c_maxmemuse_))
  if _res != 0 { return }
  _r_meminuse_ = int64(_c_meminuse_)
  _r_maxmemuse_ = int64(_c_maxmemuse_)
  return
}
func (task *Task) GetNumANz() (_r_numanz_ int32,_res int32) {
  var _c_numanz_ C.MSKint32t
  _res = int32(C.MSK_getnumanz(task.ptr(),&_c_numanz_))
  if _res != 0 { return }
  _r_numanz_ = int32(_c_numanz_)
  return
}
func (task *Task) GetNumANz64() (_r_numanz_ int64,_res int32) {
  var _c_numanz_ C.MSKint64t
  _res = int32(C.MSK_getnumanz64(task.ptr(),&_c_numanz_))
  if _res != 0 { return }
  _r_numanz_ = int64(_c_numanz_)
  return
}
func (task *Task) GetNumBaraBlockTriplets() (_r_num_ int64,_res int32) {
  var _c_num_ C.MSKint64t
  _res = int32(C.MSK_getnumbarablocktriplets(task.ptr(),&_c_num_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  return
}
func (task *Task) GetNumBaraNz() (_r_nz_ int64,_res int32) {
  var _c_nz_ C.MSKint64t
  _res = int32(C.MSK_getnumbaranz(task.ptr(),&_c_nz_))
  if _res != 0 { return }
  _r_nz_ = int64(_c_nz_)
  return
}
func (task *Task) GetNumBarcBlockTriplets() (_r_num_ int64,_res int32) {
  var _c_num_ C.MSKint64t
  _res = int32(C.MSK_getnumbarcblocktriplets(task.ptr(),&_c_num_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  return
}
func (task *Task) GetNumBarcNz() (_r_nz_ int64,_res int32) {
  var _c_nz_ C.MSKint64t
  _res = int32(C.MSK_getnumbarcnz(task.ptr(),&_c_nz_))
  if _res != 0 { return }
  _r_nz_ = int64(_c_nz_)
  return
}
func (task *Task) GetNumBarvar() (_r_numbarvar_ int32,_res int32) {
  var _c_numbarvar_ C.MSKint32t
  _res = int32(C.MSK_getnumbarvar(task.ptr(),&_c_numbarvar_))
  if _res != 0 { return }
  _r_numbarvar_ = int32(_c_numbarvar_)
  return
}
func (task *Task) GetNumCon() (_r_numcon_ int32,_res int32) {
  var _c_numcon_ C.MSKint32t
  _res = int32(C.MSK_getnumcon(task.ptr(),&_c_numcon_))
  if _res != 0 { return }
  _r_numcon_ = int32(_c_numcon_)
  return
}
func (task *Task) GetNumCone() (_r_numcone_ int32,_res int32) {
  var _c_numcone_ C.MSKint32t
  _res = int32(C.MSK_getnumcone(task.ptr(),&_c_numcone_))
  if _res != 0 { return }
  _r_numcone_ = int32(_c_numcone_)
  return
}
func (task *Task) GetNumConeMem(k_ int32) (_r_nummem_ int32,_res int32) {
  _c_k_ := C.MSKint32t(k_)
  var _c_nummem_ C.MSKint32t
  _res = int32(C.MSK_getnumconemem(task.ptr(),_c_k_,&_c_nummem_))
  if _res != 0 { return }
  _r_nummem_ = int32(_c_nummem_)
  return
}
func (task *Task) GetNumIntVar() (_r_numintvar_ int32,_res int32) {
  var _c_numintvar_ C.MSKint32t
  _res = int32(C.MSK_getnumintvar(task.ptr(),&_c_numintvar_))
  if _res != 0 { return }
  _r_numintvar_ = int32(_c_numintvar_)
  return
}
func (task *Task) GetNumParam(partype_ int32) (_r_numparam_ int32,_res int32) {
  var _c_numparam_ C.MSKint32t
  _res = int32(C.MSK_getnumparam(task.ptr(),C.MSKparametertypee(partype_),&_c_numparam_))
  if _res != 0 { return }
  _r_numparam_ = int32(_c_numparam_)
  return
}
func (task *Task) GetNumQConKNz(k_ int32) (_r_numqcnz_ int64,_res int32) {
  _c_k_ := C.MSKint32t(k_)
  var _c_numqcnz_ C.MSKint64t
  _res = int32(C.MSK_getnumqconknz64(task.ptr(),_c_k_,&_c_numqcnz_))
  if _res != 0 { return }
  _r_numqcnz_ = int64(_c_numqcnz_)
  return
}
func (task *Task) GetNumQObjNz() (_r_numqonz_ int64,_res int32) {
  var _c_numqonz_ C.MSKint64t
  _res = int32(C.MSK_getnumqobjnz64(task.ptr(),&_c_numqonz_))
  if _res != 0 { return }
  _r_numqonz_ = int64(_c_numqonz_)
  return
}
func (task *Task) GetNumSymMat() (_r_num_ int64,_res int32) {
  var _c_num_ C.MSKint64t
  _res = int32(C.MSK_getnumsymmat(task.ptr(),&_c_num_))
  if _res != 0 { return }
  _r_num_ = int64(_c_num_)
  return
}
func (task *Task) GetNumVar() (_r_numvar_ int32,_res int32) {
  var _c_numvar_ C.MSKint32t
  _res = int32(C.MSK_getnumvar(task.ptr(),&_c_numvar_))
  if _res != 0 { return }
  _r_numvar_ = int32(_c_numvar_)
  return
}
func (task *Task) GetObjName() (_r_objname_ string,_res int32) {
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetObjNameLen()
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_objname_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_objname_))
  _res = int32(C.MSK_getobjname(task.ptr(),_c_maxlen_,C.MSKstring_t(_c_objname_)))
  if _res != 0 { return }
  _r_objname_ = C.GoStringN(_c_objname_,C.int(maxlen_))
  return
}
func (task *Task) GetObjNameLen() (_r_len_ int32,_res int32) {
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getobjnamelen(task.ptr(),&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetObjSense() (_r_sense_ int32,_res int32) {
  var _c_sense_ C.MSKobjsensee
  _res = int32(C.MSK_getobjsense(task.ptr(),&_c_sense_))
  if _res != 0 { return }
  _r_sense_ = int32(_c_sense_)
  return
}
func (task *Task) GetParamMax(partype_ int32) (_r_parammax_ int32,_res int32) {
  var _c_parammax_ C.MSKint32t
  _res = int32(C.MSK_getparammax(task.ptr(),C.MSKparametertypee(partype_),&_c_parammax_))
  if _res != 0 { return }
  _r_parammax_ = int32(_c_parammax_)
  return
}
func (task *Task) GetParamName(partype_ int32,param_ int32) (_r_parname_ string,_res int32) {
  _c_param_ := C.MSKint32t(param_)
  _c_parname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_parname_))
  _res = int32(C.MSK_getparamname(task.ptr(),C.MSKparametertypee(partype_),_c_param_,C.MSKstring_t(_c_parname_)))
  if _res != 0 { return }
  _r_parname_ = C.GoStringN(_c_parname_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) GetPrimalObj(whichsol_ int32) (_r_primalobj_ float64,_res int32) {
  var _c_primalobj_ C.MSKrealt
  _res = int32(C.MSK_getprimalobj(task.ptr(),C.MSKsoltypee(whichsol_),&_c_primalobj_))
  if _res != 0 { return }
  _r_primalobj_ = float64(_c_primalobj_)
  return
}
func (task *Task) GetProbType() (_r_probtype_ int32,_res int32) {
  var _c_probtype_ C.MSKproblemtypee
  _res = int32(C.MSK_getprobtype(task.ptr(),&_c_probtype_))
  if _res != 0 { return }
  _r_probtype_ = int32(_c_probtype_)
  return
}
func (task *Task) GetProSta(whichsol_ int32) (_r_prosta_ int32,_res int32) {
  var _c_prosta_ C.MSKprostae
  _res = int32(C.MSK_getprosta(task.ptr(),C.MSKsoltypee(whichsol_),&_c_prosta_))
  if _res != 0 { return }
  _r_prosta_ = int32(_c_prosta_)
  return
}
func (task *Task) GetPviolBarvar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolBarvar'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolBarvar'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getpviolbarvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetPviolCon(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolCon'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolCon'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getpviolcon(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetPviolCones(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolCones'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolCones'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getpviolcones(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetPviolVar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64,_res int32) {
  num_ := minint([]int{ len(sub_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolVar'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if viol_ == nil { viol_ = make([]float64,num_,num_)
  } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolVar'") }
  var _c_viol_ *C.MSKrealt = nil
  if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
  _res = int32(C.MSK_getpviolvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
  if _res != 0 { return }
  _r_viol_ = viol_
  return
}
func (task *Task) GetQConK(k_ int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) (_r_numqcnz_ int64,_r_qcsubi_ []int32,_r_qcsubj_ []int32,_r_qcval_ []float64,_res int32) {
  _c_k_ := C.MSKint32t(k_)
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumQConKNz(k_)
  if _res != 0 { return }
  maxnumqcnz_ := __tmp_var_1
  _c_maxnumqcnz_ := C.MSKint64t(maxnumqcnz_)
  var _c_qcsurp_ C.MSKint64t = C.MSKint64t(len(qcsubi_))
  var _c_numqcnz_ C.MSKint64t
  var __tmp_var_4 int64
  __tmp_var_4,_res = task.GetNumQConKNz(k_)
  if _res != 0 { return }
  if qcsubi_ == nil { qcsubi_ = make([]int32,__tmp_var_4,__tmp_var_4)
  } else if len(qcsubi_) < int(__tmp_var_4) { panic("Slice in 'qcsubi_' is too short in call to 'GetQConK'") }
  var _c_qcsubi_ *C.MSKint32t = nil
  if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
  var __tmp_var_7 int64
  __tmp_var_7,_res = task.GetNumQConKNz(k_)
  if _res != 0 { return }
  if qcsubj_ == nil { qcsubj_ = make([]int32,__tmp_var_7,__tmp_var_7)
  } else if len(qcsubj_) < int(__tmp_var_7) { panic("Slice in 'qcsubj_' is too short in call to 'GetQConK'") }
  var _c_qcsubj_ *C.MSKint32t = nil
  if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
  var __tmp_var_10 int64
  __tmp_var_10,_res = task.GetNumQConKNz(k_)
  if _res != 0 { return }
  if qcval_ == nil { qcval_ = make([]float64,__tmp_var_10,__tmp_var_10)
  } else if len(qcval_) < int(__tmp_var_10) { panic("Slice in 'qcval_' is too short in call to 'GetQConK'") }
  var _c_qcval_ *C.MSKrealt = nil
  if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
  _res = int32(C.MSK_getqconk64(task.ptr(),_c_k_,_c_maxnumqcnz_,&_c_qcsurp_,&_c_numqcnz_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
  if _res != 0 { return }
  _r_numqcnz_ = int64(_c_numqcnz_)
  _r_qcsubi_ = qcsubi_
  _r_qcsubj_ = qcsubj_
  _r_qcval_ = qcval_
  return
}
func (task *Task) GetQObj(qosubi_ []int32,qosubj_ []int32,qoval_ []float64) (_r_numqonz_ int32,_r_qosubi_ []int32,_r_qosubj_ []int32,_r_qoval_ []float64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumQObjNz()
  if _res != 0 { return }
  maxnumqonz_ := __tmp_var_1
  _c_maxnumqonz_ := C.MSKint32t(maxnumqonz_)
  var _c_qosurp_ C.MSKint32t = C.MSKint32t(len(qosubi_))
  var _c_numqonz_ C.MSKint32t
  if qosubi_ == nil { qosubi_ = make([]int32,maxnumqonz_,maxnumqonz_)
  } else if len(qosubi_) < int(maxnumqonz_) { panic("Slice in 'qosubi_' is too short in call to 'GetQObj'") }
  var _c_qosubi_ *C.MSKint32t = nil
  if len(qosubi_) > 0 { _c_qosubi_ = (*C.MSKint32t)(&qosubi_[0]) }
  if qosubj_ == nil { qosubj_ = make([]int32,maxnumqonz_,maxnumqonz_)
  } else if len(qosubj_) < int(maxnumqonz_) { panic("Slice in 'qosubj_' is too short in call to 'GetQObj'") }
  var _c_qosubj_ *C.MSKint32t = nil
  if len(qosubj_) > 0 { _c_qosubj_ = (*C.MSKint32t)(&qosubj_[0]) }
  if qoval_ == nil { qoval_ = make([]float64,maxnumqonz_,maxnumqonz_)
  } else if len(qoval_) < int(maxnumqonz_) { panic("Slice in 'qoval_' is too short in call to 'GetQObj'") }
  var _c_qoval_ *C.MSKrealt = nil
  if len(qoval_) > 0 { _c_qoval_ = (*C.MSKrealt)(&qoval_[0]) }
  _res = int32(C.MSK_getqobj(task.ptr(),_c_maxnumqonz_,&_c_qosurp_,&_c_numqonz_,_c_qosubi_,_c_qosubj_,_c_qoval_))
  if _res != 0 { return }
  _r_numqonz_ = int32(_c_numqonz_)
  _r_qosubi_ = qosubi_
  _r_qosubj_ = qosubj_
  _r_qoval_ = qoval_
  return
}
func (task *Task) GetQObj64(qosubi_ []int32,qosubj_ []int32,qoval_ []float64) (_r_numqonz_ int64,_r_qosubi_ []int32,_r_qosubj_ []int32,_r_qoval_ []float64,_res int32) {
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetNumQObjNz()
  if _res != 0 { return }
  maxnumqonz_ := __tmp_var_1
  _c_maxnumqonz_ := C.MSKint64t(maxnumqonz_)
  var _c_qosurp_ C.MSKint64t = C.MSKint64t(len(qosubi_))
  var _c_numqonz_ C.MSKint64t
  if qosubi_ == nil { qosubi_ = make([]int32,maxnumqonz_,maxnumqonz_)
  } else if len(qosubi_) < int(maxnumqonz_) { panic("Slice in 'qosubi_' is too short in call to 'GetQObj64'") }
  var _c_qosubi_ *C.MSKint32t = nil
  if len(qosubi_) > 0 { _c_qosubi_ = (*C.MSKint32t)(&qosubi_[0]) }
  if qosubj_ == nil { qosubj_ = make([]int32,maxnumqonz_,maxnumqonz_)
  } else if len(qosubj_) < int(maxnumqonz_) { panic("Slice in 'qosubj_' is too short in call to 'GetQObj64'") }
  var _c_qosubj_ *C.MSKint32t = nil
  if len(qosubj_) > 0 { _c_qosubj_ = (*C.MSKint32t)(&qosubj_[0]) }
  if qoval_ == nil { qoval_ = make([]float64,maxnumqonz_,maxnumqonz_)
  } else if len(qoval_) < int(maxnumqonz_) { panic("Slice in 'qoval_' is too short in call to 'GetQObj64'") }
  var _c_qoval_ *C.MSKrealt = nil
  if len(qoval_) > 0 { _c_qoval_ = (*C.MSKrealt)(&qoval_[0]) }
  _res = int32(C.MSK_getqobj64(task.ptr(),_c_maxnumqonz_,&_c_qosurp_,&_c_numqonz_,_c_qosubi_,_c_qosubj_,_c_qoval_))
  if _res != 0 { return }
  _r_numqonz_ = int64(_c_numqonz_)
  _r_qosubi_ = qosubi_
  _r_qosubj_ = qosubj_
  _r_qoval_ = qoval_
  return
}
func (task *Task) GetQObjIJ(i_ int32,j_ int32) (_r_qoij_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_j_ := C.MSKint32t(j_)
  var _c_qoij_ C.MSKrealt
  _res = int32(C.MSK_getqobjij(task.ptr(),_c_i_,_c_j_,&_c_qoij_))
  if _res != 0 { return }
  _r_qoij_ = float64(_c_qoij_)
  return
}
func (task *Task) GetReducedCosts(whichsol_ int32,first_ int32,last_ int32,redcosts_ []float64) (_r_redcosts_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if redcosts_ == nil { redcosts_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(redcosts_) < int(last_ - first_) { panic("Slice in 'redcosts_' is too short in call to 'GetReducedCosts'") }
  var _c_redcosts_ *C.MSKrealt = nil
  if len(redcosts_) > 0 { _c_redcosts_ = (*C.MSKrealt)(&redcosts_[0]) }
  _res = int32(C.MSK_getreducedcosts(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_redcosts_))
  if _res != 0 { return }
  _r_redcosts_ = redcosts_
  return
}
func (task *Task) GetSkc(whichsol_ int32,skc_ []int32) (_r_skc_ []int32,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if skc_ == nil { skc_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(skc_) < int(__tmp_var_1) { panic("Slice in 'skc_' is too short in call to 'GetSkc'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  _res = int32(C.MSK_getskc(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_))
  if _res != 0 { return }
  _r_skc_ = skc_
  return
}
func (task *Task) GetSkcSlice(whichsol_ int32,first_ int32,last_ int32,skc_ []int32) (_r_skc_ []int32,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if skc_ == nil { skc_ = make([]int32,last_ - first_,last_ - first_)
  } else if len(skc_) < int(last_ - first_) { panic("Slice in 'skc_' is too short in call to 'GetSkcSlice'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  _res = int32(C.MSK_getskcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skc_))
  if _res != 0 { return }
  _r_skc_ = skc_
  return
}
func (task *Task) GetSkx(whichsol_ int32,skx_ []int32) (_r_skx_ []int32,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if skx_ == nil { skx_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(skx_) < int(__tmp_var_1) { panic("Slice in 'skx_' is too short in call to 'GetSkx'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  _res = int32(C.MSK_getskx(task.ptr(),C.MSKsoltypee(whichsol_),_c_skx_))
  if _res != 0 { return }
  _r_skx_ = skx_
  return
}
func (task *Task) GetSkxSlice(whichsol_ int32,first_ int32,last_ int32,skx_ []int32) (_r_skx_ []int32,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if skx_ == nil { skx_ = make([]int32,last_ - first_,last_ - first_)
  } else if len(skx_) < int(last_ - first_) { panic("Slice in 'skx_' is too short in call to 'GetSkxSlice'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  _res = int32(C.MSK_getskxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skx_))
  if _res != 0 { return }
  _r_skx_ = skx_
  return
}
func (task *Task) GetSlc(whichsol_ int32,slc_ []float64) (_r_slc_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if slc_ == nil { slc_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(slc_) < int(__tmp_var_1) { panic("Slice in 'slc_' is too short in call to 'GetSlc'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  _res = int32(C.MSK_getslc(task.ptr(),C.MSKsoltypee(whichsol_),_c_slc_))
  if _res != 0 { return }
  _r_slc_ = slc_
  return
}
func (task *Task) GetSlcSlice(whichsol_ int32,first_ int32,last_ int32,slc_ []float64) (_r_slc_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if slc_ == nil { slc_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(slc_) < int(last_ - first_) { panic("Slice in 'slc_' is too short in call to 'GetSlcSlice'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  _res = int32(C.MSK_getslcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slc_))
  if _res != 0 { return }
  _r_slc_ = slc_
  return
}
func (task *Task) GetSlx(whichsol_ int32,slx_ []float64) (_r_slx_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if slx_ == nil { slx_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(slx_) < int(__tmp_var_1) { panic("Slice in 'slx_' is too short in call to 'GetSlx'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  _res = int32(C.MSK_getslx(task.ptr(),C.MSKsoltypee(whichsol_),_c_slx_))
  if _res != 0 { return }
  _r_slx_ = slx_
  return
}
func (task *Task) GetSlxSlice(whichsol_ int32,first_ int32,last_ int32,slx_ []float64) (_r_slx_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if slx_ == nil { slx_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(slx_) < int(last_ - first_) { panic("Slice in 'slx_' is too short in call to 'GetSlxSlice'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  _res = int32(C.MSK_getslxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slx_))
  if _res != 0 { return }
  _r_slx_ = slx_
  return
}
func (task *Task) GetSnx(whichsol_ int32,snx_ []float64) (_r_snx_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if snx_ == nil { snx_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(snx_) < int(__tmp_var_1) { panic("Slice in 'snx_' is too short in call to 'GetSnx'") }
  var _c_snx_ *C.MSKrealt = nil
  if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
  _res = int32(C.MSK_getsnx(task.ptr(),C.MSKsoltypee(whichsol_),_c_snx_))
  if _res != 0 { return }
  _r_snx_ = snx_
  return
}
func (task *Task) GetSnxSlice(whichsol_ int32,first_ int32,last_ int32,snx_ []float64) (_r_snx_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if snx_ == nil { snx_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(snx_) < int(last_ - first_) { panic("Slice in 'snx_' is too short in call to 'GetSnxSlice'") }
  var _c_snx_ *C.MSKrealt = nil
  if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
  _res = int32(C.MSK_getsnxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_snx_))
  if _res != 0 { return }
  _r_snx_ = snx_
  return
}
func (task *Task) GetSolSta(whichsol_ int32) (_r_solsta_ int32,_res int32) {
  var _c_solsta_ C.MSKsolstae
  _res = int32(C.MSK_getsolsta(task.ptr(),C.MSKsoltypee(whichsol_),&_c_solsta_))
  if _res != 0 { return }
  _r_solsta_ = int32(_c_solsta_)
  return
}
func (task *Task) GetSolution(whichsol_ int32,skc_ []int32,skx_ []int32,skn_ []int32,xc_ []float64,xx_ []float64,y_ []float64,slc_ []float64,suc_ []float64,slx_ []float64,sux_ []float64,snx_ []float64) (_r_prosta_ int32,_r_solsta_ int32,_r_skc_ []int32,_r_skx_ []int32,_r_skn_ []int32,_r_xc_ []float64,_r_xx_ []float64,_r_y_ []float64,_r_slc_ []float64,_r_suc_ []float64,_r_slx_ []float64,_r_sux_ []float64,_r_snx_ []float64,_res int32) {
  var _c_prosta_ C.MSKprostae
  var _c_solsta_ C.MSKsolstae
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if skc_ == nil { skc_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(skc_) < int(__tmp_var_1) { panic("Slice in 'skc_' is too short in call to 'GetSolution'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetNumVar()
  if _res != 0 { return }
  if skx_ == nil { skx_ = make([]int32,__tmp_var_3,__tmp_var_3)
  } else if len(skx_) < int(__tmp_var_3) { panic("Slice in 'skx_' is too short in call to 'GetSolution'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  var __tmp_var_5 int32
  __tmp_var_5,_res = task.GetNumCone()
  if _res != 0 { return }
  if skn_ == nil { skn_ = make([]int32,__tmp_var_5,__tmp_var_5)
  } else if len(skn_) < int(__tmp_var_5) { panic("Slice in 'skn_' is too short in call to 'GetSolution'") }
  var _c_skn_ *C.MSKstakeye = nil
  if len(skn_) > 0 { _c_skn_ = (*C.MSKstakeye)(unsafe.Pointer(&skn_[0])) }
  var __tmp_var_7 int32
  __tmp_var_7,_res = task.GetNumCon()
  if _res != 0 { return }
  if xc_ == nil { xc_ = make([]float64,__tmp_var_7,__tmp_var_7)
  } else if len(xc_) < int(__tmp_var_7) { panic("Slice in 'xc_' is too short in call to 'GetSolution'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  var __tmp_var_9 int32
  __tmp_var_9,_res = task.GetNumVar()
  if _res != 0 { return }
  if xx_ == nil { xx_ = make([]float64,__tmp_var_9,__tmp_var_9)
  } else if len(xx_) < int(__tmp_var_9) { panic("Slice in 'xx_' is too short in call to 'GetSolution'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  var __tmp_var_11 int32
  __tmp_var_11,_res = task.GetNumCon()
  if _res != 0 { return }
  if y_ == nil { y_ = make([]float64,__tmp_var_11,__tmp_var_11)
  } else if len(y_) < int(__tmp_var_11) { panic("Slice in 'y_' is too short in call to 'GetSolution'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  var __tmp_var_13 int32
  __tmp_var_13,_res = task.GetNumCon()
  if _res != 0 { return }
  if slc_ == nil { slc_ = make([]float64,__tmp_var_13,__tmp_var_13)
  } else if len(slc_) < int(__tmp_var_13) { panic("Slice in 'slc_' is too short in call to 'GetSolution'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  var __tmp_var_15 int32
  __tmp_var_15,_res = task.GetNumCon()
  if _res != 0 { return }
  if suc_ == nil { suc_ = make([]float64,__tmp_var_15,__tmp_var_15)
  } else if len(suc_) < int(__tmp_var_15) { panic("Slice in 'suc_' is too short in call to 'GetSolution'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  var __tmp_var_17 int32
  __tmp_var_17,_res = task.GetNumVar()
  if _res != 0 { return }
  if slx_ == nil { slx_ = make([]float64,__tmp_var_17,__tmp_var_17)
  } else if len(slx_) < int(__tmp_var_17) { panic("Slice in 'slx_' is too short in call to 'GetSolution'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  var __tmp_var_19 int32
  __tmp_var_19,_res = task.GetNumVar()
  if _res != 0 { return }
  if sux_ == nil { sux_ = make([]float64,__tmp_var_19,__tmp_var_19)
  } else if len(sux_) < int(__tmp_var_19) { panic("Slice in 'sux_' is too short in call to 'GetSolution'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  var __tmp_var_21 int32
  __tmp_var_21,_res = task.GetNumCone()
  if _res != 0 { return }
  if snx_ == nil { snx_ = make([]float64,__tmp_var_21,__tmp_var_21)
  } else if len(snx_) < int(__tmp_var_21) { panic("Slice in 'snx_' is too short in call to 'GetSolution'") }
  var _c_snx_ *C.MSKrealt = nil
  if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
  _res = int32(C.MSK_getsolution(task.ptr(),C.MSKsoltypee(whichsol_),&_c_prosta_,&_c_solsta_,_c_skc_,_c_skx_,_c_skn_,_c_xc_,_c_xx_,_c_y_,_c_slc_,_c_suc_,_c_slx_,_c_sux_,_c_snx_))
  if _res != 0 { return }
  _r_prosta_ = int32(_c_prosta_)
  _r_solsta_ = int32(_c_solsta_)
  _r_skc_ = skc_
  _r_skx_ = skx_
  _r_skn_ = skn_
  _r_xc_ = xc_
  _r_xx_ = xx_
  _r_y_ = y_
  _r_slc_ = slc_
  _r_suc_ = suc_
  _r_slx_ = slx_
  _r_sux_ = sux_
  _r_snx_ = snx_
  return
}
func (task *Task) GetSolutionI(accmode_ int32,i_ int32,whichsol_ int32) (_r_sk_ int32,_r_x_ float64,_r_sl_ float64,_r_su_ float64,_r_sn_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_sk_ C.MSKstakeye
  var _c_x_ C.MSKrealt
  var _c_sl_ C.MSKrealt
  var _c_su_ C.MSKrealt
  var _c_sn_ C.MSKrealt
  _res = int32(C.MSK_getsolutioni(task.ptr(),C.MSKaccmodee(accmode_),_c_i_,C.MSKsoltypee(whichsol_),&_c_sk_,&_c_x_,&_c_sl_,&_c_su_,&_c_sn_))
  if _res != 0 { return }
  _r_sk_ = int32(_c_sk_)
  _r_x_ = float64(_c_x_)
  _r_sl_ = float64(_c_sl_)
  _r_su_ = float64(_c_su_)
  _r_sn_ = float64(_c_sn_)
  return
}
func (task *Task) GetSolutionInfo(whichsol_ int32) (_r_pobj_ float64,_r_pviolcon_ float64,_r_pviolvar_ float64,_r_pviolbarvar_ float64,_r_pviolcone_ float64,_r_pviolitg_ float64,_r_dobj_ float64,_r_dviolcon_ float64,_r_dviolvar_ float64,_r_dviolbarvar_ float64,_r_dviolcone_ float64,_res int32) {
  var _c_pobj_ C.MSKrealt
  var _c_pviolcon_ C.MSKrealt
  var _c_pviolvar_ C.MSKrealt
  var _c_pviolbarvar_ C.MSKrealt
  var _c_pviolcone_ C.MSKrealt
  var _c_pviolitg_ C.MSKrealt
  var _c_dobj_ C.MSKrealt
  var _c_dviolcon_ C.MSKrealt
  var _c_dviolvar_ C.MSKrealt
  var _c_dviolbarvar_ C.MSKrealt
  var _c_dviolcone_ C.MSKrealt
  _res = int32(C.MSK_getsolutioninfo(task.ptr(),C.MSKsoltypee(whichsol_),&_c_pobj_,&_c_pviolcon_,&_c_pviolvar_,&_c_pviolbarvar_,&_c_pviolcone_,&_c_pviolitg_,&_c_dobj_,&_c_dviolcon_,&_c_dviolvar_,&_c_dviolbarvar_,&_c_dviolcone_))
  if _res != 0 { return }
  _r_pobj_ = float64(_c_pobj_)
  _r_pviolcon_ = float64(_c_pviolcon_)
  _r_pviolvar_ = float64(_c_pviolvar_)
  _r_pviolbarvar_ = float64(_c_pviolbarvar_)
  _r_pviolcone_ = float64(_c_pviolcone_)
  _r_pviolitg_ = float64(_c_pviolitg_)
  _r_dobj_ = float64(_c_dobj_)
  _r_dviolcon_ = float64(_c_dviolcon_)
  _r_dviolvar_ = float64(_c_dviolvar_)
  _r_dviolbarvar_ = float64(_c_dviolbarvar_)
  _r_dviolcone_ = float64(_c_dviolcone_)
  return
}
func (task *Task) GetSolutionSlice(whichsol_ int32,solitem_ int32,first_ int32,last_ int32,values_ []float64) (_r_values_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if values_ == nil { values_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(values_) < int(last_ - first_) { panic("Slice in 'values_' is too short in call to 'GetSolutionSlice'") }
  var _c_values_ *C.MSKrealt = nil
  if len(values_) > 0 { _c_values_ = (*C.MSKrealt)(&values_[0]) }
  _res = int32(C.MSK_getsolutionslice(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKsoliteme(solitem_),_c_first_,_c_last_,_c_values_))
  if _res != 0 { return }
  _r_values_ = values_
  return
}
func (task *Task) GetSparseSymMat(idx_ int64,subi_ []int32,subj_ []int32,valij_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_valij_ []float64,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var __tmp_var_1 int64
  _,__tmp_var_1,_,_res = task.GetSymMatInfo(idx_)
  if _res != 0 { return }
  maxlen_ := __tmp_var_1
  _c_maxlen_ := C.MSKint64t(maxlen_)
  if subi_ == nil { subi_ = make([]int32,maxlen_,maxlen_)
  } else if len(subi_) < int(maxlen_) { panic("Slice in 'subi_' is too short in call to 'GetSparseSymMat'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if subj_ == nil { subj_ = make([]int32,maxlen_,maxlen_)
  } else if len(subj_) < int(maxlen_) { panic("Slice in 'subj_' is too short in call to 'GetSparseSymMat'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if valij_ == nil { valij_ = make([]float64,maxlen_,maxlen_)
  } else if len(valij_) < int(maxlen_) { panic("Slice in 'valij_' is too short in call to 'GetSparseSymMat'") }
  var _c_valij_ *C.MSKrealt = nil
  if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
  _res = int32(C.MSK_getsparsesymmat(task.ptr(),_c_idx_,_c_maxlen_,_c_subi_,_c_subj_,_c_valij_))
  if _res != 0 { return }
  _r_subi_ = subi_
  _r_subj_ = subj_
  _r_valij_ = valij_
  return
}
func (task *Task) GetStrParam(param_ int32) (_r_len_ int32,_r_parvalue_ string,_res int32) {
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetStrParamLen(param_)
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  var _c_len_ C.MSKint32t
  _c_parvalue_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_parvalue_))
  _res = int32(C.MSK_getstrparam(task.ptr(),C.MSKsparame(param_),_c_maxlen_,&_c_len_,C.MSKstring_t(_c_parvalue_)))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  _r_parvalue_ = C.GoStringN(_c_parvalue_,C.int(maxlen_))
  return
}
func (task *Task) GetStrParamLen(param_ int32) (_r_len_ int32,_res int32) {
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getstrparamlen(task.ptr(),C.MSKsparame(param_),&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetSuc(whichsol_ int32,suc_ []float64) (_r_suc_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if suc_ == nil { suc_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(suc_) < int(__tmp_var_1) { panic("Slice in 'suc_' is too short in call to 'GetSuc'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  _res = int32(C.MSK_getsuc(task.ptr(),C.MSKsoltypee(whichsol_),_c_suc_))
  if _res != 0 { return }
  _r_suc_ = suc_
  return
}
func (task *Task) GetSucSlice(whichsol_ int32,first_ int32,last_ int32,suc_ []float64) (_r_suc_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if suc_ == nil { suc_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(suc_) < int(last_ - first_) { panic("Slice in 'suc_' is too short in call to 'GetSucSlice'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  _res = int32(C.MSK_getsucslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_suc_))
  if _res != 0 { return }
  _r_suc_ = suc_
  return
}
func (task *Task) GetSux(whichsol_ int32,sux_ []float64) (_r_sux_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if sux_ == nil { sux_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(sux_) < int(__tmp_var_1) { panic("Slice in 'sux_' is too short in call to 'GetSux'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  _res = int32(C.MSK_getsux(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
  if _res != 0 { return }
  _r_sux_ = sux_
  return
}
func (task *Task) GetSuxSlice(whichsol_ int32,first_ int32,last_ int32,sux_ []float64) (_r_sux_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if sux_ == nil { sux_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(sux_) < int(last_ - first_) { panic("Slice in 'sux_' is too short in call to 'GetSuxSlice'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  _res = int32(C.MSK_getsuxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_sux_))
  if _res != 0 { return }
  _r_sux_ = sux_
  return
}
func (task *Task) GetSymMatInfo(idx_ int64) (_r_dim_ int32,_r_nz_ int64,_r_type_ int32,_res int32) {
  _c_idx_ := C.MSKint64t(idx_)
  var _c_dim_ C.MSKint32t
  var _c_nz_ C.MSKint64t
  var _c_type_ C.MSKsymmattypee
  _res = int32(C.MSK_getsymmatinfo(task.ptr(),_c_idx_,&_c_dim_,&_c_nz_,&_c_type_))
  if _res != 0 { return }
  _r_dim_ = int32(_c_dim_)
  _r_nz_ = int64(_c_nz_)
  _r_type_ = int32(_c_type_)
  return
}
func (task *Task) GetTaskName() (_r_taskname_ string,_res int32) {
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetTaskNameLen()
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_taskname_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_taskname_))
  _res = int32(C.MSK_gettaskname(task.ptr(),_c_maxlen_,C.MSKstring_t(_c_taskname_)))
  if _res != 0 { return }
  _r_taskname_ = C.GoStringN(_c_taskname_,C.int(maxlen_))
  return
}
func (task *Task) GetTaskNameLen() (_r_len_ int32,_res int32) {
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_gettasknamelen(task.ptr(),&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetVarBound(i_ int32) (_r_bk_ int32,_r_bl_ float64,_r_bu_ float64,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_bk_ C.MSKboundkeye
  var _c_bl_ C.MSKrealt
  var _c_bu_ C.MSKrealt
  _res = int32(C.MSK_getvarbound(task.ptr(),_c_i_,&_c_bk_,&_c_bl_,&_c_bu_))
  if _res != 0 { return }
  _r_bk_ = int32(_c_bk_)
  _r_bl_ = float64(_c_bl_)
  _r_bu_ = float64(_c_bu_)
  return
}
func (task *Task) GetVarBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_r_bk_ []int32,_r_bl_ []float64,_r_bu_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { bk_ = make([]int32,last_ - first_,last_ - first_)
  } else if len(bk_) < int(last_ - first_) { panic("Slice in 'bk_' is too short in call to 'GetVarBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { bl_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bl_) < int(last_ - first_) { panic("Slice in 'bl_' is too short in call to 'GetVarBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { bu_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(bu_) < int(last_ - first_) { panic("Slice in 'bu_' is too short in call to 'GetVarBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_getvarboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  _r_bk_ = bk_
  _r_bl_ = bl_
  _r_bu_ = bu_
  return
}
func (task *Task) GetVarBranchDir(j_ int32) (_r_direction_ int32,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_direction_ C.MSKbranchdire
  _res = int32(C.MSK_getvarbranchdir(task.ptr(),_c_j_,&_c_direction_))
  if _res != 0 { return }
  _r_direction_ = int32(_c_direction_)
  return
}
func (task *Task) GetVarBranchOrder(j_ int32) (_r_priority_ int32,_r_direction_ int32,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_priority_ C.MSKint32t
  var _c_direction_ C.MSKbranchdire
  _res = int32(C.MSK_getvarbranchorder(task.ptr(),_c_j_,&_c_priority_,&_c_direction_))
  if _res != 0 { return }
  _r_priority_ = int32(_c_priority_)
  _r_direction_ = int32(_c_direction_)
  return
}
func (task *Task) GetVarBranchPri(j_ int32) (_r_priority_ int32,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_priority_ C.MSKint32t
  _res = int32(C.MSK_getvarbranchpri(task.ptr(),_c_j_,&_c_priority_))
  if _res != 0 { return }
  _r_priority_ = int32(_c_priority_)
  return
}
func (task *Task) GetVarName(j_ int32) (_r_name_ string,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetVarNameLen(j_)
  if _res != 0 { return }
  maxlen_ := 1 + __tmp_var_3
  _c_maxlen_ := C.MSKint32t(maxlen_)
  _c_name_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_getvarname(task.ptr(),_c_j_,_c_maxlen_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  _r_name_ = C.GoStringN(_c_name_,C.int(maxlen_))
  return
}
func (task *Task) GetVarNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32,_res int32) {
  _c_somename_ := C.CString(somename_)
  defer C.free(unsafe.Pointer(_c_somename_))
  var _c_asgn_ C.MSKint32t
  var _c_index_ C.MSKint32t
  _res = int32(C.MSK_getvarnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
  if _res != 0 { return }
  _r_asgn_ = int32(_c_asgn_)
  _r_index_ = int32(_c_index_)
  return
}
func (task *Task) GetVarNameLen(i_ int32) (_r_len_ int32,_res int32) {
  _c_i_ := C.MSKint32t(i_)
  var _c_len_ C.MSKint32t
  _res = int32(C.MSK_getvarnamelen(task.ptr(),_c_i_,&_c_len_))
  if _res != 0 { return }
  _r_len_ = int32(_c_len_)
  return
}
func (task *Task) GetVarType(j_ int32) (_r_vartype_ int32,_res int32) {
  _c_j_ := C.MSKint32t(j_)
  var _c_vartype_ C.MSKvariabletypee
  _res = int32(C.MSK_getvartype(task.ptr(),_c_j_,&_c_vartype_))
  if _res != 0 { return }
  _r_vartype_ = int32(_c_vartype_)
  return
}
func (task *Task) GetVarTypeList(subj_ []int32,vartype_ []int32) (_r_vartype_ []int32,_res int32) {
  num_ := minint([]int{ len(subj_) })
  _c_num_ := C.MSKint32t(num_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'GetVarTypeList'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if vartype_ == nil { vartype_ = make([]int32,num_,num_)
  } else if len(vartype_) < int(num_) { panic("Slice in 'vartype_' is too short in call to 'GetVarTypeList'") }
  var _c_vartype_ *C.MSKvariabletypee = nil
  if len(vartype_) > 0 { _c_vartype_ = (*C.MSKvariabletypee)(unsafe.Pointer(&vartype_[0])) }
  _res = int32(C.MSK_getvartypelist(task.ptr(),_c_num_,_c_subj_,_c_vartype_))
  if _res != 0 { return }
  _r_vartype_ = vartype_
  return
}
func (task *Task) GetXc(whichsol_ int32,xc_ []float64) (_r_xc_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if xc_ == nil { xc_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(xc_) < int(__tmp_var_1) { panic("Slice in 'xc_' is too short in call to 'GetXc'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  _res = int32(C.MSK_getxc(task.ptr(),C.MSKsoltypee(whichsol_),_c_xc_))
  if _res != 0 { return }
  _r_xc_ = xc_
  return
}
func (task *Task) GetXcSlice(whichsol_ int32,first_ int32,last_ int32,xc_ []float64) (_r_xc_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if xc_ == nil { xc_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(xc_) < int(last_ - first_) { panic("Slice in 'xc_' is too short in call to 'GetXcSlice'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  _res = int32(C.MSK_getxcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xc_))
  if _res != 0 { return }
  _r_xc_ = xc_
  return
}
func (task *Task) GetXx(whichsol_ int32,xx_ []float64) (_r_xx_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if xx_ == nil { xx_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(xx_) < int(__tmp_var_1) { panic("Slice in 'xx_' is too short in call to 'GetXx'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  _res = int32(C.MSK_getxx(task.ptr(),C.MSKsoltypee(whichsol_),_c_xx_))
  if _res != 0 { return }
  _r_xx_ = xx_
  return
}
func (task *Task) GetXxSlice(whichsol_ int32,first_ int32,last_ int32,xx_ []float64) (_r_xx_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if xx_ == nil { xx_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(xx_) < int(last_ - first_) { panic("Slice in 'xx_' is too short in call to 'GetXxSlice'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  _res = int32(C.MSK_getxxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xx_))
  if _res != 0 { return }
  _r_xx_ = xx_
  return
}
func (task *Task) GetY(whichsol_ int32,y_ []float64) (_r_y_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if y_ == nil { y_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(y_) < int(__tmp_var_1) { panic("Slice in 'y_' is too short in call to 'GetY'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_gety(task.ptr(),C.MSKsoltypee(whichsol_),_c_y_))
  if _res != 0 { return }
  _r_y_ = y_
  return
}
func (task *Task) GetYSlice(whichsol_ int32,first_ int32,last_ int32,y_ []float64) (_r_y_ []float64,_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if y_ == nil { y_ = make([]float64,last_ - first_,last_ - first_)
  } else if len(y_) < int(last_ - first_) { panic("Slice in 'y_' is too short in call to 'GetYSlice'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_getyslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_y_))
  if _res != 0 { return }
  _r_y_ = y_
  return
}
func (task *Task) InitBasisSolve(basis_ []int32) (_r_basis_ []int32,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if basis_ == nil { basis_ = make([]int32,__tmp_var_1,__tmp_var_1)
  } else if len(basis_) < int(__tmp_var_1) { panic("Slice in 'basis_' is too short in call to 'InitBasisSolve'") }
  var _c_basis_ *C.MSKint32t = nil
  if len(basis_) > 0 { _c_basis_ = (*C.MSKint32t)(&basis_[0]) }
  _res = int32(C.MSK_initbasissolve(task.ptr(),_c_basis_))
  if _res != 0 { return }
  _r_basis_ = basis_
  return
}
func (task *Task) InputData(maxnumcon_ int32,maxnumvar_ int32,c_ []float64,cfix_ float64,aptrb_ []int64,aptre_ []int64,asub_ []int32,aval_ []float64,bkc_ []int32,blc_ []float64,buc_ []float64,bkx_ []int32,blx_ []float64,bux_ []float64) (_res int32) {
  _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
  _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
  numcon_ := minint([]int{ len(buc_),len(blc_),len(bkc_) })
  _c_numcon_ := C.MSKint32t(numcon_)
  numvar_ := minint([]int{ len(c_),len(bux_),len(blx_),len(bkx_),len(aptrb_),len(aptre_) })
  _c_numvar_ := C.MSKint32t(numvar_)
  if c_ == nil { panic("Argument 'c_' is nil in call to 'InputData'") }
  var _c_c_ *C.MSKrealt = nil
  if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
  _c_cfix_ := C.MSKrealt(cfix_)
  if aptrb_ == nil { panic("Argument 'aptrb_' is nil in call to 'InputData'") }
  var _c_aptrb_ *C.MSKint64t = nil
  if len(aptrb_) > 0 { _c_aptrb_ = (*C.MSKint64t)(&aptrb_[0]) }
  if aptre_ == nil { panic("Argument 'aptre_' is nil in call to 'InputData'") }
  var _c_aptre_ *C.MSKint64t = nil
  if len(aptre_) > 0 { _c_aptre_ = (*C.MSKint64t)(&aptre_[0]) }
  if asub_ == nil { panic("Argument 'asub_' is nil in call to 'InputData'") }
  var _c_asub_ *C.MSKint32t = nil
  if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
  if aval_ == nil { panic("Argument 'aval_' is nil in call to 'InputData'") }
  var _c_aval_ *C.MSKrealt = nil
  if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
  if bkc_ == nil { panic("Argument 'bkc_' is nil in call to 'InputData'") }
  var _c_bkc_ *C.MSKboundkeye = nil
  if len(bkc_) > 0 { _c_bkc_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkc_[0])) }
  if blc_ == nil { panic("Argument 'blc_' is nil in call to 'InputData'") }
  var _c_blc_ *C.MSKrealt = nil
  if len(blc_) > 0 { _c_blc_ = (*C.MSKrealt)(&blc_[0]) }
  if buc_ == nil { panic("Argument 'buc_' is nil in call to 'InputData'") }
  var _c_buc_ *C.MSKrealt = nil
  if len(buc_) > 0 { _c_buc_ = (*C.MSKrealt)(&buc_[0]) }
  if bkx_ == nil { panic("Argument 'bkx_' is nil in call to 'InputData'") }
  var _c_bkx_ *C.MSKboundkeye = nil
  if len(bkx_) > 0 { _c_bkx_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkx_[0])) }
  if blx_ == nil { panic("Argument 'blx_' is nil in call to 'InputData'") }
  var _c_blx_ *C.MSKrealt = nil
  if len(blx_) > 0 { _c_blx_ = (*C.MSKrealt)(&blx_[0]) }
  if bux_ == nil { panic("Argument 'bux_' is nil in call to 'InputData'") }
  var _c_bux_ *C.MSKrealt = nil
  if len(bux_) > 0 { _c_bux_ = (*C.MSKrealt)(&bux_[0]) }
  _res = int32(C.MSK_inputdata64(task.ptr(),_c_maxnumcon_,_c_maxnumvar_,_c_numcon_,_c_numvar_,_c_c_,_c_cfix_,_c_aptrb_,_c_aptre_,_c_asub_,_c_aval_,_c_bkc_,_c_blc_,_c_buc_,_c_bkx_,_c_blx_,_c_bux_))
  if _res != 0 { return }
  return
}
func (task *Task) IsDouParName(parname_ string) (_r_param_ int32,_res int32) {
  _c_parname_ := C.CString(parname_)
  defer C.free(unsafe.Pointer(_c_parname_))
  var _c_param_ C.MSKdparame
  _res = int32(C.MSK_isdouparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
  if _res != 0 { return }
  _r_param_ = int32(_c_param_)
  return
}
func (task *Task) IsIntParName(parname_ string) (_r_param_ int32,_res int32) {
  _c_parname_ := C.CString(parname_)
  defer C.free(unsafe.Pointer(_c_parname_))
  var _c_param_ C.MSKiparame
  _res = int32(C.MSK_isintparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
  if _res != 0 { return }
  _r_param_ = int32(_c_param_)
  return
}
func (task *Task) IsStrParName(parname_ string) (_r_param_ int32,_res int32) {
  _c_parname_ := C.CString(parname_)
  defer C.free(unsafe.Pointer(_c_parname_))
  var _c_param_ C.MSKsparame
  _res = int32(C.MSK_isstrparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
  if _res != 0 { return }
  _r_param_ = int32(_c_param_)
  return
}
func (task *Task) LinkFileToStream(whichstream_ int32,filename_ string,append_ int32) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _c_append_ := C.MSKint32t(append_)
  _res = int32(C.MSK_linkfiletotaskstream(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKstring_t(_c_filename_),_c_append_))
  if _res != 0 { return }
  return
}
func (task *Task) OneSolutionSummary(whichstream_ int32,whichsol_ int32) (_res int32) {
  _res = int32(C.MSK_onesolutionsummary(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKsoltypee(whichsol_)))
  if _res != 0 { return }
  return
}
func (task *Task) OptimizerSummary(whichstream_ int32) (_res int32) {
  _res = int32(C.MSK_optimizersummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
  if _res != 0 { return }
  return
}
func (task *Task) Optimize() (_r_trmcode_ int32,_res int32) {
  var _c_trmcode_ C.MSKrescodee
  _res = int32(C.MSK_optimizetrm(task.ptr(),&_c_trmcode_))
  if _res != 0 { return }
  _r_trmcode_ = int32(_c_trmcode_)
  return
}
func (task *Task) PrimalRepair(wlc_ []float64,wuc_ []float64,wlx_ []float64,wux_ []float64) (_res int32) {
  if wlc_ == nil { panic("Argument 'wlc_' is nil in call to 'PrimalRepair'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(wlc_) < int(__tmp_var_1) { panic("Slice argument 'wlc_' is too short in call to 'PrimalRepair'") }
  var _c_wlc_ *C.MSKrealt = nil
  if len(wlc_) > 0 { _c_wlc_ = (*C.MSKrealt)(&wlc_[0]) }
  if wuc_ == nil { panic("Argument 'wuc_' is nil in call to 'PrimalRepair'") }
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(wuc_) < int(__tmp_var_3) { panic("Slice argument 'wuc_' is too short in call to 'PrimalRepair'") }
  var _c_wuc_ *C.MSKrealt = nil
  if len(wuc_) > 0 { _c_wuc_ = (*C.MSKrealt)(&wuc_[0]) }
  if wlx_ == nil { panic("Argument 'wlx_' is nil in call to 'PrimalRepair'") }
  var __tmp_var_5 int32
  __tmp_var_5,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(wlx_) < int(__tmp_var_5) { panic("Slice argument 'wlx_' is too short in call to 'PrimalRepair'") }
  var _c_wlx_ *C.MSKrealt = nil
  if len(wlx_) > 0 { _c_wlx_ = (*C.MSKrealt)(&wlx_[0]) }
  if wux_ == nil { panic("Argument 'wux_' is nil in call to 'PrimalRepair'") }
  var __tmp_var_7 int32
  __tmp_var_7,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(wux_) < int(__tmp_var_7) { panic("Slice argument 'wux_' is too short in call to 'PrimalRepair'") }
  var _c_wux_ *C.MSKrealt = nil
  if len(wux_) > 0 { _c_wux_ = (*C.MSKrealt)(&wux_[0]) }
  _res = int32(C.MSK_primalrepair(task.ptr(),_c_wlc_,_c_wuc_,_c_wlx_,_c_wux_))
  if _res != 0 { return }
  return
}
func (task *Task) PrimalSensitivity(subi_ []int32,marki_ []int32,subj_ []int32,markj_ []int32,leftpricei_ []float64,rightpricei_ []float64,leftrangei_ []float64,rightrangei_ []float64,leftpricej_ []float64,rightpricej_ []float64,leftrangej_ []float64,rightrangej_ []float64) (_r_leftpricei_ []float64,_r_rightpricei_ []float64,_r_leftrangei_ []float64,_r_rightrangei_ []float64,_r_leftpricej_ []float64,_r_rightpricej_ []float64,_r_leftrangej_ []float64,_r_rightrangej_ []float64,_res int32) {
  numi_ := minint([]int{ len(subi_),len(marki_) })
  _c_numi_ := C.MSKint32t(numi_)
  if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PrimalSensitivity'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if marki_ == nil { panic("Argument 'marki_' is nil in call to 'PrimalSensitivity'") }
  var _c_marki_ *C.MSKmarke = nil
  if len(marki_) > 0 { _c_marki_ = (*C.MSKmarke)(unsafe.Pointer(&marki_[0])) }
  numj_ := minint([]int{ len(subj_),len(markj_) })
  _c_numj_ := C.MSKint32t(numj_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PrimalSensitivity'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if markj_ == nil { panic("Argument 'markj_' is nil in call to 'PrimalSensitivity'") }
  var _c_markj_ *C.MSKmarke = nil
  if len(markj_) > 0 { _c_markj_ = (*C.MSKmarke)(unsafe.Pointer(&markj_[0])) }
  if leftpricei_ == nil { leftpricei_ = make([]float64,numi_,numi_)
  } else if len(leftpricei_) < int(numi_) { panic("Slice in 'leftpricei_' is too short in call to 'PrimalSensitivity'") }
  var _c_leftpricei_ *C.MSKrealt = nil
  if len(leftpricei_) > 0 { _c_leftpricei_ = (*C.MSKrealt)(&leftpricei_[0]) }
  if rightpricei_ == nil { rightpricei_ = make([]float64,numi_,numi_)
  } else if len(rightpricei_) < int(numi_) { panic("Slice in 'rightpricei_' is too short in call to 'PrimalSensitivity'") }
  var _c_rightpricei_ *C.MSKrealt = nil
  if len(rightpricei_) > 0 { _c_rightpricei_ = (*C.MSKrealt)(&rightpricei_[0]) }
  if leftrangei_ == nil { leftrangei_ = make([]float64,numi_,numi_)
  } else if len(leftrangei_) < int(numi_) { panic("Slice in 'leftrangei_' is too short in call to 'PrimalSensitivity'") }
  var _c_leftrangei_ *C.MSKrealt = nil
  if len(leftrangei_) > 0 { _c_leftrangei_ = (*C.MSKrealt)(&leftrangei_[0]) }
  if rightrangei_ == nil { rightrangei_ = make([]float64,numi_,numi_)
  } else if len(rightrangei_) < int(numi_) { panic("Slice in 'rightrangei_' is too short in call to 'PrimalSensitivity'") }
  var _c_rightrangei_ *C.MSKrealt = nil
  if len(rightrangei_) > 0 { _c_rightrangei_ = (*C.MSKrealt)(&rightrangei_[0]) }
  if leftpricej_ == nil { leftpricej_ = make([]float64,numj_,numj_)
  } else if len(leftpricej_) < int(numj_) { panic("Slice in 'leftpricej_' is too short in call to 'PrimalSensitivity'") }
  var _c_leftpricej_ *C.MSKrealt = nil
  if len(leftpricej_) > 0 { _c_leftpricej_ = (*C.MSKrealt)(&leftpricej_[0]) }
  if rightpricej_ == nil { rightpricej_ = make([]float64,numj_,numj_)
  } else if len(rightpricej_) < int(numj_) { panic("Slice in 'rightpricej_' is too short in call to 'PrimalSensitivity'") }
  var _c_rightpricej_ *C.MSKrealt = nil
  if len(rightpricej_) > 0 { _c_rightpricej_ = (*C.MSKrealt)(&rightpricej_[0]) }
  if leftrangej_ == nil { leftrangej_ = make([]float64,numj_,numj_)
  } else if len(leftrangej_) < int(numj_) { panic("Slice in 'leftrangej_' is too short in call to 'PrimalSensitivity'") }
  var _c_leftrangej_ *C.MSKrealt = nil
  if len(leftrangej_) > 0 { _c_leftrangej_ = (*C.MSKrealt)(&leftrangej_[0]) }
  if rightrangej_ == nil { rightrangej_ = make([]float64,numj_,numj_)
  } else if len(rightrangej_) < int(numj_) { panic("Slice in 'rightrangej_' is too short in call to 'PrimalSensitivity'") }
  var _c_rightrangej_ *C.MSKrealt = nil
  if len(rightrangej_) > 0 { _c_rightrangej_ = (*C.MSKrealt)(&rightrangej_[0]) }
  _res = int32(C.MSK_primalsensitivity(task.ptr(),_c_numi_,_c_subi_,_c_marki_,_c_numj_,_c_subj_,_c_markj_,_c_leftpricei_,_c_rightpricei_,_c_leftrangei_,_c_rightrangei_,_c_leftpricej_,_c_rightpricej_,_c_leftrangej_,_c_rightrangej_))
  if _res != 0 { return }
  _r_leftpricei_ = leftpricei_
  _r_rightpricei_ = rightpricei_
  _r_leftrangei_ = leftrangei_
  _r_rightrangei_ = rightrangei_
  _r_leftpricej_ = leftpricej_
  _r_rightpricej_ = rightpricej_
  _r_leftrangej_ = leftrangej_
  _r_rightrangej_ = rightrangej_
  return
}
func (task *Task) ProbTypeToStr(probtype_ int32) (_r_str_ string,_res int32) {
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_probtypetostr(task.ptr(),C.MSKproblemtypee(probtype_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) ProStaToStr(prosta_ int32) (_r_str_ string,_res int32) {
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_prostatostr(task.ptr(),C.MSKprostae(prosta_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) PutACol(j_ int32,subj_ []int32,valj_ []float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  nzj_ := minint([]int{ len(subj_),len(valj_) })
  _c_nzj_ := C.MSKint32t(nzj_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutACol'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if valj_ == nil { panic("Argument 'valj_' is nil in call to 'PutACol'") }
  var _c_valj_ *C.MSKrealt = nil
  if len(valj_) > 0 { _c_valj_ = (*C.MSKrealt)(&valj_[0]) }
  _res = int32(C.MSK_putacol(task.ptr(),_c_j_,_c_nzj_,_c_subj_,_c_valj_))
  if _res != 0 { return }
  return
}
func (task *Task) PutAColList(sub_ []int32,ptrb_ []int32,ptre_ []int32,asub_ []int32,aval_ []float64) (_res int32) {
  num_ := minint([]int{ len(sub_),len(ptrb_),len(ptre_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutAColList'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutAColList'") }
  var _c_ptrb_ *C.MSKint32t = nil
  if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint32t)(&ptrb_[0]) }
  if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutAColList'") }
  var _c_ptre_ *C.MSKint32t = nil
  if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint32t)(&ptre_[0]) }
  if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutAColList'") }
  var _c_asub_ *C.MSKint32t = nil
  if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
  if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutAColList'") }
  var _c_aval_ *C.MSKrealt = nil
  if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
  _res = int32(C.MSK_putacollist(task.ptr(),_c_num_,_c_sub_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutAColSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,asub_ []int32,aval_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutAColSlice'") }
  if len(ptrb_) < int(last_ - first_) { panic("Slice argument 'ptrb_' is too short in call to 'PutAColSlice'") }
  var _c_ptrb_ *C.MSKint64t = nil
  if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
  if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutAColSlice'") }
  if len(ptre_) < int(last_ - first_) { panic("Slice argument 'ptre_' is too short in call to 'PutAColSlice'") }
  var _c_ptre_ *C.MSKint64t = nil
  if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
  if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutAColSlice'") }
  var _c_asub_ *C.MSKint32t = nil
  if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
  if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutAColSlice'") }
  var _c_aval_ *C.MSKrealt = nil
  if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
  _res = int32(C.MSK_putacolslice64(task.ptr(),_c_first_,_c_last_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutAij(i_ int32,j_ int32,aij_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_j_ := C.MSKint32t(j_)
  _c_aij_ := C.MSKrealt(aij_)
  _res = int32(C.MSK_putaij(task.ptr(),_c_i_,_c_j_,_c_aij_))
  if _res != 0 { return }
  return
}
func (task *Task) PutAijList(subi_ []int32,subj_ []int32,valij_ []float64) (_res int32) {
  num_ := minint([]int{ len(subi_),len(subj_),len(valij_) })
  _c_num_ := C.MSKint64t(num_)
  if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutAijList'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutAijList'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if valij_ == nil { panic("Argument 'valij_' is nil in call to 'PutAijList'") }
  var _c_valij_ *C.MSKrealt = nil
  if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
  _res = int32(C.MSK_putaijlist64(task.ptr(),_c_num_,_c_subi_,_c_subj_,_c_valij_))
  if _res != 0 { return }
  return
}
func (task *Task) PutARow(i_ int32,subi_ []int32,vali_ []float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  nzi_ := minint([]int{ len(subi_),len(vali_) })
  _c_nzi_ := C.MSKint32t(nzi_)
  if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutARow'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if vali_ == nil { panic("Argument 'vali_' is nil in call to 'PutARow'") }
  var _c_vali_ *C.MSKrealt = nil
  if len(vali_) > 0 { _c_vali_ = (*C.MSKrealt)(&vali_[0]) }
  _res = int32(C.MSK_putarow(task.ptr(),_c_i_,_c_nzi_,_c_subi_,_c_vali_))
  if _res != 0 { return }
  return
}
func (task *Task) PutARowList(sub_ []int32,aptrb_ []int32,aptre_ []int32,asub_ []int32,aval_ []float64) (_res int32) {
  num_ := minint([]int{ len(sub_),len(aptrb_),len(aptre_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutARowList'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if aptrb_ == nil { panic("Argument 'aptrb_' is nil in call to 'PutARowList'") }
  var _c_aptrb_ *C.MSKint32t = nil
  if len(aptrb_) > 0 { _c_aptrb_ = (*C.MSKint32t)(&aptrb_[0]) }
  if aptre_ == nil { panic("Argument 'aptre_' is nil in call to 'PutARowList'") }
  var _c_aptre_ *C.MSKint32t = nil
  if len(aptre_) > 0 { _c_aptre_ = (*C.MSKint32t)(&aptre_[0]) }
  if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutARowList'") }
  var _c_asub_ *C.MSKint32t = nil
  if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
  if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutARowList'") }
  var _c_aval_ *C.MSKrealt = nil
  if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
  _res = int32(C.MSK_putarowlist(task.ptr(),_c_num_,_c_sub_,_c_aptrb_,_c_aptre_,_c_asub_,_c_aval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutARowSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,asub_ []int32,aval_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutARowSlice'") }
  if len(ptrb_) < int(last_ - first_) { panic("Slice argument 'ptrb_' is too short in call to 'PutARowSlice'") }
  var _c_ptrb_ *C.MSKint64t = nil
  if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
  if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutARowSlice'") }
  if len(ptre_) < int(last_ - first_) { panic("Slice argument 'ptre_' is too short in call to 'PutARowSlice'") }
  var _c_ptre_ *C.MSKint64t = nil
  if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
  if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutARowSlice'") }
  var _c_asub_ *C.MSKint32t = nil
  if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
  if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutARowSlice'") }
  var _c_aval_ *C.MSKrealt = nil
  if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
  _res = int32(C.MSK_putarowslice64(task.ptr(),_c_first_,_c_last_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBaraBlockTriplet(num_ int64,subi_ []int32,subj_ []int32,subk_ []int32,subl_ []int32,valijkl_ []float64) (_res int32) {
  _c_num_ := C.MSKint64t(num_)
  if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutBaraBlockTriplet'") }
  if len(subi_) < int(num_) { panic("Slice argument 'subi_' is too short in call to 'PutBaraBlockTriplet'") }
  var _c_subi_ *C.MSKint32t = nil
  if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBaraBlockTriplet'") }
  if len(subj_) < int(num_) { panic("Slice argument 'subj_' is too short in call to 'PutBaraBlockTriplet'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if subk_ == nil { panic("Argument 'subk_' is nil in call to 'PutBaraBlockTriplet'") }
  if len(subk_) < int(num_) { panic("Slice argument 'subk_' is too short in call to 'PutBaraBlockTriplet'") }
  var _c_subk_ *C.MSKint32t = nil
  if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
  if subl_ == nil { panic("Argument 'subl_' is nil in call to 'PutBaraBlockTriplet'") }
  if len(subl_) < int(num_) { panic("Slice argument 'subl_' is too short in call to 'PutBaraBlockTriplet'") }
  var _c_subl_ *C.MSKint32t = nil
  if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
  if valijkl_ == nil { panic("Argument 'valijkl_' is nil in call to 'PutBaraBlockTriplet'") }
  if len(valijkl_) < int(num_) { panic("Slice argument 'valijkl_' is too short in call to 'PutBaraBlockTriplet'") }
  var _c_valijkl_ *C.MSKrealt = nil
  if len(valijkl_) > 0 { _c_valijkl_ = (*C.MSKrealt)(&valijkl_[0]) }
  _res = int32(C.MSK_putbarablocktriplet(task.ptr(),_c_num_,_c_subi_,_c_subj_,_c_subk_,_c_subl_,_c_valijkl_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarAij(i_ int32,j_ int32,sub_ []int64,weights_ []float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_j_ := C.MSKint32t(j_)
  num_ := minint([]int{ len(sub_),len(weights_) })
  _c_num_ := C.MSKint64t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutBarAij'") }
  var _c_sub_ *C.MSKint64t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
  if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBarAij'") }
  var _c_weights_ *C.MSKrealt = nil
  if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
  _res = int32(C.MSK_putbaraij(task.ptr(),_c_i_,_c_j_,_c_num_,_c_sub_,_c_weights_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarcBlockTriplet(num_ int64,subj_ []int32,subk_ []int32,subl_ []int32,valjkl_ []float64) (_res int32) {
  _c_num_ := C.MSKint64t(num_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBarcBlockTriplet'") }
  if len(subj_) < int(num_) { panic("Slice argument 'subj_' is too short in call to 'PutBarcBlockTriplet'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if subk_ == nil { panic("Argument 'subk_' is nil in call to 'PutBarcBlockTriplet'") }
  if len(subk_) < int(num_) { panic("Slice argument 'subk_' is too short in call to 'PutBarcBlockTriplet'") }
  var _c_subk_ *C.MSKint32t = nil
  if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
  if subl_ == nil { panic("Argument 'subl_' is nil in call to 'PutBarcBlockTriplet'") }
  if len(subl_) < int(num_) { panic("Slice argument 'subl_' is too short in call to 'PutBarcBlockTriplet'") }
  var _c_subl_ *C.MSKint32t = nil
  if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
  if valjkl_ == nil { panic("Argument 'valjkl_' is nil in call to 'PutBarcBlockTriplet'") }
  if len(valjkl_) < int(num_) { panic("Slice argument 'valjkl_' is too short in call to 'PutBarcBlockTriplet'") }
  var _c_valjkl_ *C.MSKrealt = nil
  if len(valjkl_) > 0 { _c_valjkl_ = (*C.MSKrealt)(&valjkl_[0]) }
  _res = int32(C.MSK_putbarcblocktriplet(task.ptr(),_c_num_,_c_subj_,_c_subk_,_c_subl_,_c_valjkl_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarcJ(j_ int32,sub_ []int64,weights_ []float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  num_ := minint([]int{ len(sub_),len(weights_) })
  _c_num_ := C.MSKint64t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutBarcJ'") }
  var _c_sub_ *C.MSKint64t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
  if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBarcJ'") }
  var _c_weights_ *C.MSKrealt = nil
  if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
  _res = int32(C.MSK_putbarcj(task.ptr(),_c_j_,_c_num_,_c_sub_,_c_weights_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarsJ(whichsol_ int32,j_ int32,barsj_ []float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  if barsj_ == nil { panic("Argument 'barsj_' is nil in call to 'PutBarsJ'") }
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetLenBarvarJ(j_)
  if _res != 0 { return }
  if len(barsj_) < int(__tmp_var_1) { panic("Slice argument 'barsj_' is too short in call to 'PutBarsJ'") }
  var _c_barsj_ *C.MSKrealt = nil
  if len(barsj_) > 0 { _c_barsj_ = (*C.MSKrealt)(&barsj_[0]) }
  _res = int32(C.MSK_putbarsj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barsj_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarvarName(j_ int32,name_ string) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_name_ := C.CString(name_)
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_putbarvarname(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutBarxJ(whichsol_ int32,j_ int32,barxj_ []float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  if barxj_ == nil { panic("Argument 'barxj_' is nil in call to 'PutBarxJ'") }
  var __tmp_var_1 int64
  __tmp_var_1,_res = task.GetLenBarvarJ(j_)
  if _res != 0 { return }
  if len(barxj_) < int(__tmp_var_1) { panic("Slice argument 'barxj_' is too short in call to 'PutBarxJ'") }
  var _c_barxj_ *C.MSKrealt = nil
  if len(barxj_) > 0 { _c_barxj_ = (*C.MSKrealt)(&barxj_[0]) }
  _res = int32(C.MSK_putbarxj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barxj_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBound(accmode_ int32,i_ int32,bk_ int32,bl_ float64,bu_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_bl_ := C.MSKrealt(bl_)
  _c_bu_ := C.MSKrealt(bu_)
  _res = int32(C.MSK_putbound(task.ptr(),C.MSKaccmodee(accmode_),_c_i_,C.MSKboundkeye(bk_),_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBoundList(accmode_ int32,sub_ []int32,bk_ []int32,bl_ []float64,bu_ []float64) (_res int32) {
  num_ := minint([]int{ len(sub_),len(bk_),len(bl_),len(bu_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutBoundList'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if bk_ == nil { panic("Argument 'bk_' is nil in call to 'PutBoundList'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { panic("Argument 'bl_' is nil in call to 'PutBoundList'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { panic("Argument 'bu_' is nil in call to 'PutBoundList'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_putboundlist(task.ptr(),C.MSKaccmodee(accmode_),_c_num_,_c_sub_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutBoundSlice(con_ int32,first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { panic("Argument 'bk_' is nil in call to 'PutBoundSlice'") }
  if len(bk_) < int(last_ - first_) { panic("Slice argument 'bk_' is too short in call to 'PutBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { panic("Argument 'bl_' is nil in call to 'PutBoundSlice'") }
  if len(bl_) < int(last_ - first_) { panic("Slice argument 'bl_' is too short in call to 'PutBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { panic("Argument 'bu_' is nil in call to 'PutBoundSlice'") }
  if len(bu_) < int(last_ - first_) { panic("Slice argument 'bu_' is too short in call to 'PutBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_putboundslice(task.ptr(),C.MSKaccmodee(con_),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutCfix(cfix_ float64) (_res int32) {
  _c_cfix_ := C.MSKrealt(cfix_)
  _res = int32(C.MSK_putcfix(task.ptr(),_c_cfix_))
  if _res != 0 { return }
  return
}
func (task *Task) PutCJ(j_ int32,cj_ float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_cj_ := C.MSKrealt(cj_)
  _res = int32(C.MSK_putcj(task.ptr(),_c_j_,_c_cj_))
  if _res != 0 { return }
  return
}
func (task *Task) PutCList(subj_ []int32,val_ []float64) (_res int32) {
  num_ := minint([]int{ len(subj_),len(val_) })
  _c_num_ := C.MSKint32t(num_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutCList'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if val_ == nil { panic("Argument 'val_' is nil in call to 'PutCList'") }
  var _c_val_ *C.MSKrealt = nil
  if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
  _res = int32(C.MSK_putclist(task.ptr(),_c_num_,_c_subj_,_c_val_))
  if _res != 0 { return }
  return
}
func (task *Task) PutConBound(i_ int32,bk_ int32,bl_ float64,bu_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_bl_ := C.MSKrealt(bl_)
  _c_bu_ := C.MSKrealt(bu_)
  _res = int32(C.MSK_putconbound(task.ptr(),_c_i_,C.MSKboundkeye(bk_),_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutConBoundList(sub_ []int32,bkc_ []int32,blc_ []float64,buc_ []float64) (_res int32) {
  num_ := minint([]int{ len(sub_),len(bkc_),len(blc_),len(buc_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutConBoundList'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if bkc_ == nil { panic("Argument 'bkc_' is nil in call to 'PutConBoundList'") }
  var _c_bkc_ *C.MSKboundkeye = nil
  if len(bkc_) > 0 { _c_bkc_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkc_[0])) }
  if blc_ == nil { panic("Argument 'blc_' is nil in call to 'PutConBoundList'") }
  var _c_blc_ *C.MSKrealt = nil
  if len(blc_) > 0 { _c_blc_ = (*C.MSKrealt)(&blc_[0]) }
  if buc_ == nil { panic("Argument 'buc_' is nil in call to 'PutConBoundList'") }
  var _c_buc_ *C.MSKrealt = nil
  if len(buc_) > 0 { _c_buc_ = (*C.MSKrealt)(&buc_[0]) }
  _res = int32(C.MSK_putconboundlist(task.ptr(),_c_num_,_c_sub_,_c_bkc_,_c_blc_,_c_buc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutConBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { panic("Argument 'bk_' is nil in call to 'PutConBoundSlice'") }
  if len(bk_) < int(last_ - first_) { panic("Slice argument 'bk_' is too short in call to 'PutConBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { panic("Argument 'bl_' is nil in call to 'PutConBoundSlice'") }
  if len(bl_) < int(last_ - first_) { panic("Slice argument 'bl_' is too short in call to 'PutConBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { panic("Argument 'bu_' is nil in call to 'PutConBoundSlice'") }
  if len(bu_) < int(last_ - first_) { panic("Slice argument 'bu_' is too short in call to 'PutConBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_putconboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutCone(k_ int32,conetype_ int32,conepar_ float64,submem_ []int32) (_res int32) {
  _c_k_ := C.MSKint32t(k_)
  _c_conepar_ := C.MSKrealt(conepar_)
  nummem_ := minint([]int{ len(submem_) })
  _c_nummem_ := C.MSKint32t(nummem_)
  if submem_ == nil { panic("Argument 'submem_' is nil in call to 'PutCone'") }
  var _c_submem_ *C.MSKint32t = nil
  if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
  _res = int32(C.MSK_putcone(task.ptr(),_c_k_,C.MSKconetypee(conetype_),_c_conepar_,_c_nummem_,_c_submem_))
  if _res != 0 { return }
  return
}
func (task *Task) PutConeName(j_ int32,name_ string) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_name_ := C.CString(name_)
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_putconename(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutConName(i_ int32,name_ string) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_name_ := C.CString(name_)
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_putconname(task.ptr(),_c_i_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutCSlice(first_ int32,last_ int32,slice_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if slice_ == nil { panic("Argument 'slice_' is nil in call to 'PutCSlice'") }
  if len(slice_) < int(last_ - first_) { panic("Slice argument 'slice_' is too short in call to 'PutCSlice'") }
  var _c_slice_ *C.MSKrealt = nil
  if len(slice_) > 0 { _c_slice_ = (*C.MSKrealt)(&slice_[0]) }
  _res = int32(C.MSK_putcslice(task.ptr(),_c_first_,_c_last_,_c_slice_))
  if _res != 0 { return }
  return
}
func (task *Task) PutDouParam(param_ int32,parvalue_ float64) (_res int32) {
  _c_parvalue_ := C.MSKrealt(parvalue_)
  _res = int32(C.MSK_putdouparam(task.ptr(),C.MSKdparame(param_),_c_parvalue_))
  if _res != 0 { return }
  return
}
func (task *Task) PutIntParam(param_ int32,parvalue_ int32) (_res int32) {
  _c_parvalue_ := C.MSKint32t(parvalue_)
  _res = int32(C.MSK_putintparam(task.ptr(),C.MSKiparame(param_),_c_parvalue_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumANz(maxnumanz_ int64) (_res int32) {
  _c_maxnumanz_ := C.MSKint64t(maxnumanz_)
  _res = int32(C.MSK_putmaxnumanz(task.ptr(),_c_maxnumanz_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumBarvar(maxnumbarvar_ int32) (_res int32) {
  _c_maxnumbarvar_ := C.MSKint32t(maxnumbarvar_)
  _res = int32(C.MSK_putmaxnumbarvar(task.ptr(),_c_maxnumbarvar_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumCon(maxnumcon_ int32) (_res int32) {
  _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
  _res = int32(C.MSK_putmaxnumcon(task.ptr(),_c_maxnumcon_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumCone(maxnumcone_ int32) (_res int32) {
  _c_maxnumcone_ := C.MSKint32t(maxnumcone_)
  _res = int32(C.MSK_putmaxnumcone(task.ptr(),_c_maxnumcone_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumQNz(maxnumqnz_ int64) (_res int32) {
  _c_maxnumqnz_ := C.MSKint64t(maxnumqnz_)
  _res = int32(C.MSK_putmaxnumqnz(task.ptr(),_c_maxnumqnz_))
  if _res != 0 { return }
  return
}
func (task *Task) PutMaxNumVar(maxnumvar_ int32) (_res int32) {
  _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
  _res = int32(C.MSK_putmaxnumvar(task.ptr(),_c_maxnumvar_))
  if _res != 0 { return }
  return
}
func (task *Task) PutNaDouParam(paramname_ string,parvalue_ float64) (_res int32) {
  _c_paramname_ := C.CString(paramname_)
  defer C.free(unsafe.Pointer(_c_paramname_))
  _c_parvalue_ := C.MSKrealt(parvalue_)
  _res = int32(C.MSK_putnadouparam(task.ptr(),C.MSKstring_t(_c_paramname_),_c_parvalue_))
  if _res != 0 { return }
  return
}
func (task *Task) PutNaIntParam(paramname_ string,parvalue_ int32) (_res int32) {
  _c_paramname_ := C.CString(paramname_)
  defer C.free(unsafe.Pointer(_c_paramname_))
  _c_parvalue_ := C.MSKint32t(parvalue_)
  _res = int32(C.MSK_putnaintparam(task.ptr(),C.MSKstring_t(_c_paramname_),_c_parvalue_))
  if _res != 0 { return }
  return
}
func (task *Task) PutNaStrParam(paramname_ string,parvalue_ string) (_res int32) {
  _c_paramname_ := C.CString(paramname_)
  defer C.free(unsafe.Pointer(_c_paramname_))
  _c_parvalue_ := C.CString(parvalue_)
  defer C.free(unsafe.Pointer(_c_parvalue_))
  _res = int32(C.MSK_putnastrparam(task.ptr(),C.MSKstring_t(_c_paramname_),C.MSKstring_t(_c_parvalue_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutObjName(objname_ string) (_res int32) {
  _c_objname_ := C.CString(objname_)
  defer C.free(unsafe.Pointer(_c_objname_))
  _res = int32(C.MSK_putobjname(task.ptr(),C.MSKstring_t(_c_objname_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutObjSense(sense_ int32) (_res int32) {
  _res = int32(C.MSK_putobjsense(task.ptr(),C.MSKobjsensee(sense_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutParam(parname_ string,parvalue_ string) (_res int32) {
  _c_parname_ := C.CString(parname_)
  defer C.free(unsafe.Pointer(_c_parname_))
  _c_parvalue_ := C.CString(parvalue_)
  defer C.free(unsafe.Pointer(_c_parvalue_))
  _res = int32(C.MSK_putparam(task.ptr(),C.MSKstring_t(_c_parname_),C.MSKstring_t(_c_parvalue_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutQCon(qcsubk_ []int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) (_res int32) {
  numqcnz_ := minint([]int{ len(qcsubi_),len(qcsubj_),len(qcval_) })
  _c_numqcnz_ := C.MSKint32t(numqcnz_)
  if qcsubk_ == nil { panic("Argument 'qcsubk_' is nil in call to 'PutQCon'") }
  var _c_qcsubk_ *C.MSKint32t = nil
  if len(qcsubk_) > 0 { _c_qcsubk_ = (*C.MSKint32t)(&qcsubk_[0]) }
  if qcsubi_ == nil { panic("Argument 'qcsubi_' is nil in call to 'PutQCon'") }
  var _c_qcsubi_ *C.MSKint32t = nil
  if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
  if qcsubj_ == nil { panic("Argument 'qcsubj_' is nil in call to 'PutQCon'") }
  var _c_qcsubj_ *C.MSKint32t = nil
  if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
  if qcval_ == nil { panic("Argument 'qcval_' is nil in call to 'PutQCon'") }
  var _c_qcval_ *C.MSKrealt = nil
  if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
  _res = int32(C.MSK_putqcon(task.ptr(),_c_numqcnz_,_c_qcsubk_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutQConK(k_ int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) (_res int32) {
  _c_k_ := C.MSKint32t(k_)
  numqcnz_ := minint([]int{ len(qcsubi_),len(qcsubj_),len(qcval_) })
  _c_numqcnz_ := C.MSKint32t(numqcnz_)
  if qcsubi_ == nil { panic("Argument 'qcsubi_' is nil in call to 'PutQConK'") }
  var _c_qcsubi_ *C.MSKint32t = nil
  if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
  if qcsubj_ == nil { panic("Argument 'qcsubj_' is nil in call to 'PutQConK'") }
  var _c_qcsubj_ *C.MSKint32t = nil
  if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
  if qcval_ == nil { panic("Argument 'qcval_' is nil in call to 'PutQConK'") }
  var _c_qcval_ *C.MSKrealt = nil
  if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
  _res = int32(C.MSK_putqconk(task.ptr(),_c_k_,_c_numqcnz_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutQObj(qosubi_ []int32,qosubj_ []int32,qoval_ []float64) (_res int32) {
  numqonz_ := minint([]int{ len(qosubi_),len(qosubj_),len(qoval_) })
  _c_numqonz_ := C.MSKint32t(numqonz_)
  if qosubi_ == nil { panic("Argument 'qosubi_' is nil in call to 'PutQObj'") }
  var _c_qosubi_ *C.MSKint32t = nil
  if len(qosubi_) > 0 { _c_qosubi_ = (*C.MSKint32t)(&qosubi_[0]) }
  if qosubj_ == nil { panic("Argument 'qosubj_' is nil in call to 'PutQObj'") }
  var _c_qosubj_ *C.MSKint32t = nil
  if len(qosubj_) > 0 { _c_qosubj_ = (*C.MSKint32t)(&qosubj_[0]) }
  if qoval_ == nil { panic("Argument 'qoval_' is nil in call to 'PutQObj'") }
  var _c_qoval_ *C.MSKrealt = nil
  if len(qoval_) > 0 { _c_qoval_ = (*C.MSKrealt)(&qoval_[0]) }
  _res = int32(C.MSK_putqobj(task.ptr(),_c_numqonz_,_c_qosubi_,_c_qosubj_,_c_qoval_))
  if _res != 0 { return }
  return
}
func (task *Task) PutQObjIJ(i_ int32,j_ int32,qoij_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_j_ := C.MSKint32t(j_)
  _c_qoij_ := C.MSKrealt(qoij_)
  _res = int32(C.MSK_putqobjij(task.ptr(),_c_i_,_c_j_,_c_qoij_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSkc(whichsol_ int32,skc_ []int32) (_res int32) {
  if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSkc'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(skc_) < int(__tmp_var_1) { panic("Slice argument 'skc_' is too short in call to 'PutSkc'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  _res = int32(C.MSK_putskc(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSkcSlice(whichsol_ int32,first_ int32,last_ int32,skc_ []int32) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSkcSlice'") }
  if len(skc_) < int(last_ - first_) { panic("Slice argument 'skc_' is too short in call to 'PutSkcSlice'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  _res = int32(C.MSK_putskcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSkx(whichsol_ int32,skx_ []int32) (_res int32) {
  if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSkx'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(skx_) < int(__tmp_var_1) { panic("Slice argument 'skx_' is too short in call to 'PutSkx'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  _res = int32(C.MSK_putskx(task.ptr(),C.MSKsoltypee(whichsol_),_c_skx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSkxSlice(whichsol_ int32,first_ int32,last_ int32,skx_ []int32) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSkxSlice'") }
  if len(skx_) < int(last_ - first_) { panic("Slice argument 'skx_' is too short in call to 'PutSkxSlice'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  _res = int32(C.MSK_putskxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSlc(whichsol_ int32,slc_ []float64) (_res int32) {
  if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSlc'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(slc_) < int(__tmp_var_1) { panic("Slice argument 'slc_' is too short in call to 'PutSlc'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  _res = int32(C.MSK_putslc(task.ptr(),C.MSKsoltypee(whichsol_),_c_slc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSlcSlice(whichsol_ int32,first_ int32,last_ int32,slc_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSlcSlice'") }
  if len(slc_) < int(last_ - first_) { panic("Slice argument 'slc_' is too short in call to 'PutSlcSlice'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  _res = int32(C.MSK_putslcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSlx(whichsol_ int32,slx_ []float64) (_res int32) {
  if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSlx'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(slx_) < int(__tmp_var_1) { panic("Slice argument 'slx_' is too short in call to 'PutSlx'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  _res = int32(C.MSK_putslx(task.ptr(),C.MSKsoltypee(whichsol_),_c_slx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSlxSlice(whichsol_ int32,first_ int32,last_ int32,slx_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSlxSlice'") }
  if len(slx_) < int(last_ - first_) { panic("Slice argument 'slx_' is too short in call to 'PutSlxSlice'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  _res = int32(C.MSK_putslxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSnx(whichsol_ int32,sux_ []float64) (_res int32) {
  if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSnx'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(sux_) < int(__tmp_var_1) { panic("Slice argument 'sux_' is too short in call to 'PutSnx'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  _res = int32(C.MSK_putsnx(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSnxSlice(whichsol_ int32,first_ int32,last_ int32,snx_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if snx_ == nil { panic("Argument 'snx_' is nil in call to 'PutSnxSlice'") }
  if len(snx_) < int(last_ - first_) { panic("Slice argument 'snx_' is too short in call to 'PutSnxSlice'") }
  var _c_snx_ *C.MSKrealt = nil
  if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
  _res = int32(C.MSK_putsnxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_snx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSolution(whichsol_ int32,skc_ []int32,skx_ []int32,skn_ []int32,xc_ []float64,xx_ []float64,y_ []float64,slc_ []float64,suc_ []float64,slx_ []float64,sux_ []float64,snx_ []float64) (_res int32) {
  if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSolution'") }
  var _c_skc_ *C.MSKstakeye = nil
  if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
  if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSolution'") }
  var _c_skx_ *C.MSKstakeye = nil
  if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
  if skn_ == nil { panic("Argument 'skn_' is nil in call to 'PutSolution'") }
  var _c_skn_ *C.MSKstakeye = nil
  if len(skn_) > 0 { _c_skn_ = (*C.MSKstakeye)(unsafe.Pointer(&skn_[0])) }
  if xc_ == nil { panic("Argument 'xc_' is nil in call to 'PutSolution'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutSolution'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  if y_ == nil { panic("Argument 'y_' is nil in call to 'PutSolution'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSolution'") }
  var _c_slc_ *C.MSKrealt = nil
  if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
  if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSolution'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSolution'") }
  var _c_slx_ *C.MSKrealt = nil
  if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
  if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSolution'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  if snx_ == nil { panic("Argument 'snx_' is nil in call to 'PutSolution'") }
  var _c_snx_ *C.MSKrealt = nil
  if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
  _res = int32(C.MSK_putsolution(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_,_c_skx_,_c_skn_,_c_xc_,_c_xx_,_c_y_,_c_slc_,_c_suc_,_c_slx_,_c_sux_,_c_snx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSolutionI(accmode_ int32,i_ int32,whichsol_ int32,sk_ int32,x_ float64,sl_ float64,su_ float64,sn_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_x_ := C.MSKrealt(x_)
  _c_sl_ := C.MSKrealt(sl_)
  _c_su_ := C.MSKrealt(su_)
  _c_sn_ := C.MSKrealt(sn_)
  _res = int32(C.MSK_putsolutioni(task.ptr(),C.MSKaccmodee(accmode_),_c_i_,C.MSKsoltypee(whichsol_),C.MSKstakeye(sk_),_c_x_,_c_sl_,_c_su_,_c_sn_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSolutionYI(i_ int32,whichsol_ int32,y_ float64) (_res int32) {
  _c_i_ := C.MSKint32t(i_)
  _c_y_ := C.MSKrealt(y_)
  _res = int32(C.MSK_putsolutionyi(task.ptr(),_c_i_,C.MSKsoltypee(whichsol_),_c_y_))
  if _res != 0 { return }
  return
}
func (task *Task) PutStrParam(param_ int32,parvalue_ string) (_res int32) {
  _c_parvalue_ := C.CString(parvalue_)
  defer C.free(unsafe.Pointer(_c_parvalue_))
  _res = int32(C.MSK_putstrparam(task.ptr(),C.MSKsparame(param_),C.MSKstring_t(_c_parvalue_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutSuc(whichsol_ int32,suc_ []float64) (_res int32) {
  if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSuc'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(suc_) < int(__tmp_var_1) { panic("Slice argument 'suc_' is too short in call to 'PutSuc'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  _res = int32(C.MSK_putsuc(task.ptr(),C.MSKsoltypee(whichsol_),_c_suc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSucSlice(whichsol_ int32,first_ int32,last_ int32,suc_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSucSlice'") }
  if len(suc_) < int(last_ - first_) { panic("Slice argument 'suc_' is too short in call to 'PutSucSlice'") }
  var _c_suc_ *C.MSKrealt = nil
  if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
  _res = int32(C.MSK_putsucslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_suc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSux(whichsol_ int32,sux_ []float64) (_res int32) {
  if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSux'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(sux_) < int(__tmp_var_1) { panic("Slice argument 'sux_' is too short in call to 'PutSux'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  _res = int32(C.MSK_putsux(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
  if _res != 0 { return }
  return
}
func (task *Task) PutSuxSlice(whichsol_ int32,first_ int32,last_ int32,sux_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSuxSlice'") }
  if len(sux_) < int(last_ - first_) { panic("Slice argument 'sux_' is too short in call to 'PutSuxSlice'") }
  var _c_sux_ *C.MSKrealt = nil
  if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
  _res = int32(C.MSK_putsuxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_sux_))
  if _res != 0 { return }
  return
}
func (task *Task) PutTaskName(taskname_ string) (_res int32) {
  _c_taskname_ := C.CString(taskname_)
  defer C.free(unsafe.Pointer(_c_taskname_))
  _res = int32(C.MSK_puttaskname(task.ptr(),C.MSKstring_t(_c_taskname_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarBound(j_ int32,bk_ int32,bl_ float64,bu_ float64) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_bl_ := C.MSKrealt(bl_)
  _c_bu_ := C.MSKrealt(bu_)
  _res = int32(C.MSK_putvarbound(task.ptr(),_c_j_,C.MSKboundkeye(bk_),_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarBoundList(sub_ []int32,bkx_ []int32,blx_ []float64,bux_ []float64) (_res int32) {
  num_ := minint([]int{ len(sub_),len(bkx_),len(blx_),len(bux_) })
  _c_num_ := C.MSKint32t(num_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutVarBoundList'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if bkx_ == nil { panic("Argument 'bkx_' is nil in call to 'PutVarBoundList'") }
  var _c_bkx_ *C.MSKboundkeye = nil
  if len(bkx_) > 0 { _c_bkx_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkx_[0])) }
  if blx_ == nil { panic("Argument 'blx_' is nil in call to 'PutVarBoundList'") }
  var _c_blx_ *C.MSKrealt = nil
  if len(blx_) > 0 { _c_blx_ = (*C.MSKrealt)(&blx_[0]) }
  if bux_ == nil { panic("Argument 'bux_' is nil in call to 'PutVarBoundList'") }
  var _c_bux_ *C.MSKrealt = nil
  if len(bux_) > 0 { _c_bux_ = (*C.MSKrealt)(&bux_[0]) }
  _res = int32(C.MSK_putvarboundlist(task.ptr(),_c_num_,_c_sub_,_c_bkx_,_c_blx_,_c_bux_))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if bk_ == nil { panic("Argument 'bk_' is nil in call to 'PutVarBoundSlice'") }
  if len(bk_) < int(last_ - first_) { panic("Slice argument 'bk_' is too short in call to 'PutVarBoundSlice'") }
  var _c_bk_ *C.MSKboundkeye = nil
  if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
  if bl_ == nil { panic("Argument 'bl_' is nil in call to 'PutVarBoundSlice'") }
  if len(bl_) < int(last_ - first_) { panic("Slice argument 'bl_' is too short in call to 'PutVarBoundSlice'") }
  var _c_bl_ *C.MSKrealt = nil
  if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
  if bu_ == nil { panic("Argument 'bu_' is nil in call to 'PutVarBoundSlice'") }
  if len(bu_) < int(last_ - first_) { panic("Slice argument 'bu_' is too short in call to 'PutVarBoundSlice'") }
  var _c_bu_ *C.MSKrealt = nil
  if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
  _res = int32(C.MSK_putvarboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarBranchOrder(j_ int32,priority_ int32,direction_ int32) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_priority_ := C.MSKint32t(priority_)
  _res = int32(C.MSK_putvarbranchorder(task.ptr(),_c_j_,_c_priority_,C.int(direction_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarName(j_ int32,name_ string) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _c_name_ := C.CString(name_)
  defer C.free(unsafe.Pointer(_c_name_))
  _res = int32(C.MSK_putvarname(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarType(j_ int32,vartype_ int32) (_res int32) {
  _c_j_ := C.MSKint32t(j_)
  _res = int32(C.MSK_putvartype(task.ptr(),_c_j_,C.MSKvariabletypee(vartype_)))
  if _res != 0 { return }
  return
}
func (task *Task) PutVarTypeList(subj_ []int32,vartype_ []int32) (_res int32) {
  num_ := minint([]int{ len(subj_),len(vartype_) })
  _c_num_ := C.MSKint32t(num_)
  if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutVarTypeList'") }
  var _c_subj_ *C.MSKint32t = nil
  if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
  if vartype_ == nil { panic("Argument 'vartype_' is nil in call to 'PutVarTypeList'") }
  var _c_vartype_ *C.MSKvariabletypee = nil
  if len(vartype_) > 0 { _c_vartype_ = (*C.MSKvariabletypee)(unsafe.Pointer(&vartype_[0])) }
  _res = int32(C.MSK_putvartypelist(task.ptr(),_c_num_,_c_subj_,_c_vartype_))
  if _res != 0 { return }
  return
}
func (task *Task) PutXc(whichsol_ int32,xc_ []float64) (_r_xc_ []float64,_res int32) {
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if xc_ == nil { xc_ = make([]float64,__tmp_var_1,__tmp_var_1)
  } else if len(xc_) < int(__tmp_var_1) { panic("Slice in 'xc_' is too short in call to 'PutXc'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  _res = int32(C.MSK_putxc(task.ptr(),C.MSKsoltypee(whichsol_),_c_xc_))
  if _res != 0 { return }
  _r_xc_ = xc_
  return
}
func (task *Task) PutXcSlice(whichsol_ int32,first_ int32,last_ int32,xc_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if xc_ == nil { panic("Argument 'xc_' is nil in call to 'PutXcSlice'") }
  if len(xc_) < int(last_ - first_) { panic("Slice argument 'xc_' is too short in call to 'PutXcSlice'") }
  var _c_xc_ *C.MSKrealt = nil
  if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
  _res = int32(C.MSK_putxcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xc_))
  if _res != 0 { return }
  return
}
func (task *Task) PutXx(whichsol_ int32,xx_ []float64) (_res int32) {
  if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutXx'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumVar()
  if _res != 0 { return }
  if len(xx_) < int(__tmp_var_1) { panic("Slice argument 'xx_' is too short in call to 'PutXx'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  _res = int32(C.MSK_putxx(task.ptr(),C.MSKsoltypee(whichsol_),_c_xx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutXxSlice(whichsol_ int32,first_ int32,last_ int32,xx_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutXxSlice'") }
  if len(xx_) < int(last_ - first_) { panic("Slice argument 'xx_' is too short in call to 'PutXxSlice'") }
  var _c_xx_ *C.MSKrealt = nil
  if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
  _res = int32(C.MSK_putxxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xx_))
  if _res != 0 { return }
  return
}
func (task *Task) PutY(whichsol_ int32,y_ []float64) (_res int32) {
  if y_ == nil { panic("Argument 'y_' is nil in call to 'PutY'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(y_) < int(__tmp_var_1) { panic("Slice argument 'y_' is too short in call to 'PutY'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_puty(task.ptr(),C.MSKsoltypee(whichsol_),_c_y_))
  if _res != 0 { return }
  return
}
func (task *Task) PutYSlice(whichsol_ int32,first_ int32,last_ int32,y_ []float64) (_res int32) {
  _c_first_ := C.MSKint32t(first_)
  _c_last_ := C.MSKint32t(last_)
  if y_ == nil { panic("Argument 'y_' is nil in call to 'PutYSlice'") }
  if len(y_) < int(last_ - first_) { panic("Slice argument 'y_' is too short in call to 'PutYSlice'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_putyslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_y_))
  if _res != 0 { return }
  return
}
func (task *Task) ReadBranchPriorities(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readbranchpriorities(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadData(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readdataautoformat(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadDataFormat(filename_ string,format_ int32,compress_ int32) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readdataformat(task.ptr(),C.MSKstring_t(_c_filename_),C.int(format_),C.int(compress_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadParamFile(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readparamfile(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadSolution(whichsol_ int32,filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readsolution(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadSummary(whichstream_ int32) (_res int32) {
  _res = int32(C.MSK_readsummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
  if _res != 0 { return }
  return
}
func (task *Task) ReadTask(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_readtask(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) RemoveBarvars(subset_ []int32) (_res int32) {
  num_ := minint([]int{ len(subset_) })
  _c_num_ := C.MSKint32t(num_)
  if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveBarvars'") }
  var _c_subset_ *C.MSKint32t = nil
  if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
  _res = int32(C.MSK_removebarvars(task.ptr(),_c_num_,_c_subset_))
  if _res != 0 { return }
  return
}
func (task *Task) RemoveCones(subset_ []int32) (_res int32) {
  num_ := minint([]int{ len(subset_) })
  _c_num_ := C.MSKint32t(num_)
  if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveCones'") }
  var _c_subset_ *C.MSKint32t = nil
  if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
  _res = int32(C.MSK_removecones(task.ptr(),_c_num_,_c_subset_))
  if _res != 0 { return }
  return
}
func (task *Task) RemoveCons(subset_ []int32) (_res int32) {
  num_ := minint([]int{ len(subset_) })
  _c_num_ := C.MSKint32t(num_)
  if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveCons'") }
  var _c_subset_ *C.MSKint32t = nil
  if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
  _res = int32(C.MSK_removecons(task.ptr(),_c_num_,_c_subset_))
  if _res != 0 { return }
  return
}
func (task *Task) RemoveVars(subset_ []int32) (_res int32) {
  num_ := minint([]int{ len(subset_) })
  _c_num_ := C.MSKint32t(num_)
  if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveVars'") }
  var _c_subset_ *C.MSKint32t = nil
  if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
  _res = int32(C.MSK_removevars(task.ptr(),_c_num_,_c_subset_))
  if _res != 0 { return }
  return
}
func (task *Task) ResizeTask(maxnumcon_ int32,maxnumvar_ int32,maxnumcone_ int32,maxnumanz_ int64,maxnumqnz_ int64) (_res int32) {
  _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
  _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
  _c_maxnumcone_ := C.MSKint32t(maxnumcone_)
  _c_maxnumanz_ := C.MSKint64t(maxnumanz_)
  _c_maxnumqnz_ := C.MSKint64t(maxnumqnz_)
  _res = int32(C.MSK_resizetask(task.ptr(),_c_maxnumcon_,_c_maxnumvar_,_c_maxnumcone_,_c_maxnumanz_,_c_maxnumqnz_))
  if _res != 0 { return }
  return
}
func (task *Task) SensitivityReport(whichstream_ int32) (_res int32) {
  _res = int32(C.MSK_sensitivityreport(task.ptr(),C.MSKstreamtypee(whichstream_)))
  if _res != 0 { return }
  return
}
func (task *Task) SetDefaults() (_res int32) {
  _res = int32(C.MSK_setdefaults(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) SkToStr(sk_ int32) (_r_str_ string,_res int32) {
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_sktostr(task.ptr(),C.MSKstakeye(sk_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) SolStaToStr(solsta_ int32) (_r_str_ string,_res int32) {
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_solstatostr(task.ptr(),C.MSKsolstae(solsta_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func (task *Task) SolutionDef(whichsol_ int32) (_r_isdef_ bool,_res int32) {
  var _c_isdef_ C.MSKbooleant
  _res = int32(C.MSK_solutiondef(task.ptr(),C.MSKsoltypee(whichsol_),&_c_isdef_))
  if _res != 0 { return }
  _r_isdef_ = int(_c_isdef_)!=0
  return
}
func (task *Task) SolutionSummary(whichstream_ int32) (_res int32) {
  _res = int32(C.MSK_solutionsummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
  if _res != 0 { return }
  return
}
func (task *Task) SolveWithBasis(transp_ int32,numnz_ int32,sub_ []int32,val_ []float64) (_r_numnz_ int32,_r_sub_ []int32,_r_val_ []float64,_res int32) {
  _c_transp_ := C.MSKint32t(transp_)
  var _c_numnz_ C.MSKint32t = C.MSKint32t(numnz_)
  if sub_ == nil { panic("Argument 'sub_' is nil in call to 'SolveWithBasis'") }
  var __tmp_var_1 int32
  __tmp_var_1,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(sub_) < int(__tmp_var_1) { panic("Slice argument 'sub_' is too short in call to 'SolveWithBasis'") }
  var _c_sub_ *C.MSKint32t = nil
  if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
  if val_ == nil { panic("Argument 'val_' is nil in call to 'SolveWithBasis'") }
  var __tmp_var_3 int32
  __tmp_var_3,_res = task.GetNumCon()
  if _res != 0 { return }
  if len(val_) < int(__tmp_var_3) { panic("Slice argument 'val_' is too short in call to 'SolveWithBasis'") }
  var _c_val_ *C.MSKrealt = nil
  if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
  _res = int32(C.MSK_solvewithbasis(task.ptr(),_c_transp_,& _c_numnz_,_c_sub_,_c_val_))
  if _res != 0 { return }
  _r_numnz_ = int32(_c_numnz_)
  _r_sub_ = sub_
  _r_val_ = val_
  return
}
func (task *Task) StartStat() (_res int32) {
  _res = int32(C.MSK_startstat(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) StopStat() (_res int32) {
  _res = int32(C.MSK_stopstat(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) StrToConeType(str_ string) (_r_conetype_ int32,_res int32) {
  _c_str_ := C.CString(str_)
  defer C.free(unsafe.Pointer(_c_str_))
  var _c_conetype_ C.MSKconetypee
  _res = int32(C.MSK_strtoconetype(task.ptr(),C.MSKstring_t(_c_str_),&_c_conetype_))
  if _res != 0 { return }
  _r_conetype_ = int32(_c_conetype_)
  return
}
func (task *Task) StrToSk(str_ string) (_r_sk_ int32,_res int32) {
  _c_str_ := C.CString(str_)
  defer C.free(unsafe.Pointer(_c_str_))
  var _c_sk_ C.MSKint32t
  _res = int32(C.MSK_strtosk(task.ptr(),C.MSKstring_t(_c_str_),&_c_sk_))
  if _res != 0 { return }
  _r_sk_ = int32(_c_sk_)
  return
}
func (task *Task) Toconic() (_res int32) {
  _res = int32(C.MSK_toconic(task.ptr()))
  if _res != 0 { return }
  return
}
func (task *Task) UpdateSolutionInfo(whichsol_ int32) (_res int32) {
  _res = int32(C.MSK_updatesolutioninfo(task.ptr(),C.MSKsoltypee(whichsol_)))
  if _res != 0 { return }
  return
}
func (task *Task) WriteBranchPriorities(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_writebranchpriorities(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) WriteData(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_writedata(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) WriteParamFile(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_writeparamfile(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) WriteSolution(whichsol_ int32,filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_writesolution(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (task *Task) WriteTask(filename_ string) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _res = int32(C.MSK_writetask(task.ptr(),C.MSKstring_t(_c_filename_)))
  if _res != 0 { return }
  return
}
func (env *Env) Axpy(n_ int32,alpha_ float64,x_ []float64,y_ []float64) (_r_y_ []float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  _c_alpha_ := C.MSKrealt(alpha_)
  if x_ == nil { panic("Argument 'x_' is nil in call to 'Axpy'") }
  if len(x_) < int(n_) { panic("Slice argument 'x_' is too short in call to 'Axpy'") }
  var _c_x_ *C.MSKrealt = nil
  if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
  if y_ == nil { panic("Argument 'y_' is nil in call to 'Axpy'") }
  if len(y_) < int(n_) { panic("Slice argument 'y_' is too short in call to 'Axpy'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_axpy(env.ptr(),_c_n_,_c_alpha_,_c_x_,_c_y_))
  if _res != 0 { return }
  _r_y_ = y_
  return
}
func (env *Env) CheckInLicense(feature_ int32) (_res int32) {
  _res = int32(C.MSK_checkinlicense(env.ptr(),C.MSKfeaturee(feature_)))
  if _res != 0 { return }
  return
}
func (env *Env) CheckoutLicense(feature_ int32) (_res int32) {
  _res = int32(C.MSK_checkoutlicense(env.ptr(),C.MSKfeaturee(feature_)))
  if _res != 0 { return }
  return
}
func (env *Env) Dot(n_ int32,x_ []float64,y_ []float64) (_r_xty_ float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  if x_ == nil { panic("Argument 'x_' is nil in call to 'Dot'") }
  if len(x_) < int(n_) { panic("Slice argument 'x_' is too short in call to 'Dot'") }
  var _c_x_ *C.MSKrealt = nil
  if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
  if y_ == nil { panic("Argument 'y_' is nil in call to 'Dot'") }
  if len(y_) < int(n_) { panic("Slice argument 'y_' is too short in call to 'Dot'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  var _c_xty_ C.MSKrealt
  _res = int32(C.MSK_dot(env.ptr(),_c_n_,_c_x_,_c_y_,&_c_xty_))
  if _res != 0 { return }
  _r_xty_ = float64(_c_xty_)
  return
}
func (env *Env) EchoIntro(longver_ int32) (_res int32) {
  _c_longver_ := C.MSKint32t(longver_)
  _res = int32(C.MSK_echointro(env.ptr(),_c_longver_))
  if _res != 0 { return }
  return
}
func (env *Env) Gemm(transa_ int32,transb_ int32,m_ int32,n_ int32,k_ int32,alpha_ float64,a_ []float64,b_ []float64,beta_ float64,c_ []float64) (_r_c_ []float64,_res int32) {
  _c_m_ := C.MSKint32t(m_)
  _c_n_ := C.MSKint32t(n_)
  _c_k_ := C.MSKint32t(k_)
  _c_alpha_ := C.MSKrealt(alpha_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Gemm'") }
  if len(a_) < int(m_ * k_) { panic("Slice argument 'a_' is too short in call to 'Gemm'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  if b_ == nil { panic("Argument 'b_' is nil in call to 'Gemm'") }
  if len(b_) < int(k_ * n_) { panic("Slice argument 'b_' is too short in call to 'Gemm'") }
  var _c_b_ *C.MSKrealt = nil
  if len(b_) > 0 { _c_b_ = (*C.MSKrealt)(&b_[0]) }
  _c_beta_ := C.MSKrealt(beta_)
  if c_ == nil { panic("Argument 'c_' is nil in call to 'Gemm'") }
  if len(c_) < int(m_ * n_) { panic("Slice argument 'c_' is too short in call to 'Gemm'") }
  var _c_c_ *C.MSKrealt = nil
  if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
  _res = int32(C.MSK_gemm(env.ptr(),C.MSKtransposee(transa_),C.MSKtransposee(transb_),_c_m_,_c_n_,_c_k_,_c_alpha_,_c_a_,_c_b_,_c_beta_,_c_c_))
  if _res != 0 { return }
  _r_c_ = c_
  return
}
func (env *Env) Gemv(transa_ int32,m_ int32,n_ int32,alpha_ float64,a_ []float64,x_ []float64,beta_ float64,y_ []float64) (_r_y_ []float64,_res int32) {
  _c_m_ := C.MSKint32t(m_)
  _c_n_ := C.MSKint32t(n_)
  _c_alpha_ := C.MSKrealt(alpha_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Gemv'") }
  if len(a_) < int(n_ * m_) { panic("Slice argument 'a_' is too short in call to 'Gemv'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  if x_ == nil { panic("Argument 'x_' is nil in call to 'Gemv'") }
  var __tmp_var_3 int32
  if (transa_ == TRANSPOSE_NO) {
    __tmp_var_3 = n_
  }else {
    __tmp_var_3 = m_
  }
  if len(x_) < int(__tmp_var_3) { panic("Slice argument 'x_' is too short in call to 'Gemv'") }
  var _c_x_ *C.MSKrealt = nil
  if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
  _c_beta_ := C.MSKrealt(beta_)
  if y_ == nil { panic("Argument 'y_' is nil in call to 'Gemv'") }
  var __tmp_var_9 int32
  if (transa_ == TRANSPOSE_NO) {
    __tmp_var_9 = m_
  }else {
    __tmp_var_9 = n_
  }
  if len(y_) < int(__tmp_var_9) { panic("Slice argument 'y_' is too short in call to 'Gemv'") }
  var _c_y_ *C.MSKrealt = nil
  if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
  _res = int32(C.MSK_gemv(env.ptr(),C.MSKtransposee(transa_),_c_m_,_c_n_,_c_alpha_,_c_a_,_c_x_,_c_beta_,_c_y_))
  if _res != 0 { return }
  _r_y_ = y_
  return
}
func GetCodeDesc(code_ int32) (_r_symname_ string,_r_str_ string,_res int32) {
  _c_symname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_symname_))
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_getcodedesc(C.MSKrescodee(code_),C.MSKstring_t(_c_symname_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_symname_ = C.GoStringN(_c_symname_,C.int(MAX_STR_LEN))
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func GetVersion() (_r_major_ int32,_r_minor_ int32,_r_build_ int32,_r_revision_ int32,_res int32) {
  var _c_major_ C.MSKint32t
  var _c_minor_ C.MSKint32t
  var _c_build_ C.MSKint32t
  var _c_revision_ C.MSKint32t
  _res = int32(C.MSK_getversion(&_c_major_,&_c_minor_,&_c_build_,&_c_revision_))
  if _res != 0 { return }
  _r_major_ = int32(_c_major_)
  _r_minor_ = int32(_c_minor_)
  _r_build_ = int32(_c_build_)
  _r_revision_ = int32(_c_revision_)
  return
}
func Licensecleanup() (_res int32) {
  _res = int32(C.MSK_licensecleanup())
  if _res != 0 { return }
  return
}
func (env *Env) Linkfiletostream(whichstream_ int32,filename_ string,append_ int32) (_res int32) {
  _c_filename_ := C.CString(filename_)
  defer C.free(unsafe.Pointer(_c_filename_))
  _c_append_ := C.MSKint32t(append_)
  _res = int32(C.MSK_linkfiletoenvstream(env.ptr(),C.MSKstreamtypee(whichstream_),C.MSKstring_t(_c_filename_),_c_append_))
  if _res != 0 { return }
  return
}
func (env *Env) Potrf(uplo_ int32,n_ int32,a_ []float64) (_r_a_ []float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Potrf'") }
  if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Potrf'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  _res = int32(C.MSK_potrf(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_))
  if _res != 0 { return }
  _r_a_ = a_
  return
}
func (env *Env) PutKeepDlls(keepdlls_ int32) (_res int32) {
  _c_keepdlls_ := C.MSKint32t(keepdlls_)
  _res = int32(C.MSK_putkeepdlls(env.ptr(),_c_keepdlls_))
  if _res != 0 { return }
  return
}
func (env *Env) PutLicenseCode(code_ []int32) (_res int32) {
  if code_ == nil { panic("Argument 'code_' is nil in call to 'PutLicenseCode'") }
  if len(code_) < int(LICENSE_BUFFER_LENGTH) { panic("Slice argument 'code_' is too short in call to 'PutLicenseCode'") }
  var _c_code_ *C.MSKint32t = nil
  if len(code_) > 0 { _c_code_ = (*C.MSKint32t)(&code_[0]) }
  _res = int32(C.MSK_putlicensecode(env.ptr(),_c_code_))
  if _res != 0 { return }
  return
}
func (env *Env) PutLicenseDebug(licdebug_ int32) (_res int32) {
  _c_licdebug_ := C.MSKint32t(licdebug_)
  _res = int32(C.MSK_putlicensedebug(env.ptr(),_c_licdebug_))
  if _res != 0 { return }
  return
}
func (env *Env) PutLicensePath(licensepath_ string) (_res int32) {
  _c_licensepath_ := C.CString(licensepath_)
  defer C.free(unsafe.Pointer(_c_licensepath_))
  _res = int32(C.MSK_putlicensepath(env.ptr(),C.MSKstring_t(_c_licensepath_)))
  if _res != 0 { return }
  return
}
func (env *Env) PutLicenseWait(licwait_ int32) (_res int32) {
  _c_licwait_ := C.MSKint32t(licwait_)
  _res = int32(C.MSK_putlicensewait(env.ptr(),_c_licwait_))
  if _res != 0 { return }
  return
}
func (env *Env) Syeig(uplo_ int32,n_ int32,a_ []float64,w_ []float64) (_r_w_ []float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Syeig'") }
  if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Syeig'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  if w_ == nil { w_ = make([]float64,n_,n_)
  } else if len(w_) < int(n_) { panic("Slice in 'w_' is too short in call to 'Syeig'") }
  var _c_w_ *C.MSKrealt = nil
  if len(w_) > 0 { _c_w_ = (*C.MSKrealt)(&w_[0]) }
  _res = int32(C.MSK_syeig(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_,_c_w_))
  if _res != 0 { return }
  _r_w_ = w_
  return
}
func (env *Env) Syevd(uplo_ int32,n_ int32,a_ []float64,w_ []float64) (_r_a_ []float64,_r_w_ []float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Syevd'") }
  if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Syevd'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  if w_ == nil { w_ = make([]float64,n_,n_)
  } else if len(w_) < int(n_) { panic("Slice in 'w_' is too short in call to 'Syevd'") }
  var _c_w_ *C.MSKrealt = nil
  if len(w_) > 0 { _c_w_ = (*C.MSKrealt)(&w_[0]) }
  _res = int32(C.MSK_syevd(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_,_c_w_))
  if _res != 0 { return }
  _r_a_ = a_
  _r_w_ = w_
  return
}
func (env *Env) Syrk(uplo_ int32,trans_ int32,n_ int32,k_ int32,alpha_ float64,a_ []float64,beta_ float64,c_ []float64) (_r_c_ []float64,_res int32) {
  _c_n_ := C.MSKint32t(n_)
  _c_k_ := C.MSKint32t(k_)
  _c_alpha_ := C.MSKrealt(alpha_)
  if a_ == nil { panic("Argument 'a_' is nil in call to 'Syrk'") }
  if len(a_) < int(n_ * k_) { panic("Slice argument 'a_' is too short in call to 'Syrk'") }
  var _c_a_ *C.MSKrealt = nil
  if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
  _c_beta_ := C.MSKrealt(beta_)
  if c_ == nil { panic("Argument 'c_' is nil in call to 'Syrk'") }
  if len(c_) < int(n_ * n_) { panic("Slice argument 'c_' is too short in call to 'Syrk'") }
  var _c_c_ *C.MSKrealt = nil
  if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
  _res = int32(C.MSK_syrk(env.ptr(),C.MSKuploe(uplo_),C.MSKtransposee(trans_),_c_n_,_c_k_,_c_alpha_,_c_a_,_c_beta_,_c_c_))
  if _res != 0 { return }
  _r_c_ = c_
  return
}
