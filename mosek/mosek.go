package mosek // import "mosek.com/mosek"

// #include <stdlib.h>
// #include <mosek.h>
// #cgo LDFLAGS: -lmosek64
//
// extern void streamfunc_log(void *, char *);
// extern void streamfunc_wrn(void *, char *);
// extern void streamfunc_msg(void *, char *);
// extern void streamfunc_err(void *, char *);
// extern int callbackfunc(void *, void *, int, double *, int *, long long *);
import "C"

import "unsafe"

type Env struct {
        r    int32
        cptr unsafe.Pointer
}

type Task struct {
        r               int32
        cptr            unsafe.Pointer
	streamfunc      [4]func(string)
	callbackfunc    func(int32)int
	infcallbackfunc func(int32,[]float64,[]int32,[]int64)int
}

func (t * Task) ptr() C.MSKtask_t { return C.MSKtask_t(t.cptr) }
func (e * Env)  ptr() C.MSKenv_t  { return C.MSKenv_t(e.cptr) }

//export streamfunc_log
func streamfunc_log(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_LOG] != nil { task.streamfunc[STREAM_LOG](C.GoString(msg)) }
}

//export streamfunc_msg
func streamfunc_msg(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_MSG] != nil { task.streamfunc[STREAM_MSG](C.GoString(msg)) }
}

//export streamfunc_wrn
func streamfunc_wrn(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_WRN] != nil { task.streamfunc[STREAM_WRN](C.GoString(msg)) }
}

//export streamfunc_err
func streamfunc_err(handle unsafe.Pointer, msg * C.char) {
	task := (*Task)(handle)
	if task.streamfunc[STREAM_ERR] != nil { task.streamfunc[STREAM_ERR](C.GoString(msg)) }
}

//export callbackfunc
func callbackfunc(
	nativetask unsafe.Pointer,
	handle  unsafe.Pointer,
	code    C.int,
	dinf  * C.MSKrealt,
	iinf  * C.MSKint32t,
	liinf * C.MSKint64t) (C.int) {

	task := (*Task)(handle)

	var r int = 0

	if task.infcallbackfunc != nil {
		_dinf  := (*[int(DINF_END)]float64)(unsafe.Pointer(dinf))[0:DINF_END]
		_iinf  := (*[int(IINF_END)]int32)  (unsafe.Pointer(iinf))[0:IINF_END]
		_liinf := (*[int(LIINF_END)]int64) (unsafe.Pointer(liinf))[0:LIINF_END]

		r = task.infcallbackfunc(int32(code),_dinf,_iinf,_liinf)
	} else if task.callbackfunc != nil {
		r = task.callbackfunc(int32(code))
	}
	return C.int(r)
}


func MakeEnv() (env Env, res int32) {
        var envptr C.MSKenv_t
        res = int32(C.MSK_makeenv(&envptr,nil))
        if res == 0 {
                env.cptr = unsafe.Pointer(envptr)
        }
        return
}

func (env *Env) MakeTask() (task Task, res int32) {
        var taskptr C.MSKtask_t
        res = int32(C.MSK_maketask(env.ptr(), 0,0, &taskptr))
        if res != 0 { return }
	task.cptr            = unsafe.Pointer(taskptr)
	task.streamfunc[0]   = nil
	task.streamfunc[1]   = nil
	task.streamfunc[2]   = nil
	task.streamfunc[3]   = nil
	task.callbackfunc    = nil
	task.infcallbackfunc = nil

        return
}

func (e *Env) DeleteEnv() {
        envptr := e.ptr()
        C.MSK_deleteenv(&envptr)
        e.cptr = nil
}

func (t *Task) DeleteTask() {
        taskptr := t.ptr()
        C.MSK_deletetask(&taskptr)
        t.cptr = nil
}

func (t *Task) PutStreamFunc(whichstream int32, fun func(string)) {
	t.streamfunc[whichstream] = fun

	if fun == nil {
		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			nil,
			nil)
	} else {
		var strmfun (*[0]byte)
		switch whichstream {
		case STREAM_MSG: strmfun = (*[0]byte)(C.streamfunc_msg)
		case STREAM_LOG: strmfun = (*[0]byte)(C.streamfunc_log)
		case STREAM_ERR: strmfun = (*[0]byte)(C.streamfunc_err)
		case STREAM_WRN: strmfun = (*[0]byte)(C.streamfunc_wrn)
		}

		C.MSK_linkfunctotaskstream(
			t.ptr(),
			C.MSKstreamtypee(whichstream),
			C.MSKuserhandle_t(unsafe.Pointer(t)),
			strmfun) // ?!?
	}
}

func (t *Task) PutCallbackFunc(fun func(int32) int) {
	t.callbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (t *Task) PutInfoCallbackFunc(fun func(int32,[]float64,[]int32,[]int64) int) {
	t.infcallbackfunc = fun
	if fun == nil {
		C.MSK_putcallbackfunc(t.ptr(), nil, nil)
	} else {
		C.MSK_putcallbackfunc(t.ptr(), (*[0]byte)(C.callbackfunc), C.MSKuserhandle_t(unsafe.Pointer(t)))
	}
}

func (e * Env)  ClearError() { e.r = RES_OK }
func (t * Task) ClearError() { t.r = RES_OK }

func (e * Env)  GetRes() int32 { return e.r }
func (t * Task) GetRes() int32 { return t.r }

func minint(a []int) (r int) {
        if len(a) == 0 { panic("Minimum of empty array") }
        r = a[0]
        for i := 1; i < len(a); i++ {
                if a[i] < r { r = a[i] }
        }
        return
}

const ( // enum iinfitem
    IINF_ANA_PRO_NUM_CON int32 = 0
    IINF_ANA_PRO_NUM_CON_EQ int32 = 1
    IINF_ANA_PRO_NUM_CON_FR int32 = 2
    IINF_ANA_PRO_NUM_CON_LO int32 = 3
    IINF_ANA_PRO_NUM_CON_RA int32 = 4
    IINF_ANA_PRO_NUM_CON_UP int32 = 5
    IINF_ANA_PRO_NUM_VAR int32 = 6
    IINF_ANA_PRO_NUM_VAR_BIN int32 = 7
    IINF_ANA_PRO_NUM_VAR_CONT int32 = 8
    IINF_ANA_PRO_NUM_VAR_EQ int32 = 9
    IINF_ANA_PRO_NUM_VAR_FR int32 = 10
    IINF_ANA_PRO_NUM_VAR_INT int32 = 11
    IINF_ANA_PRO_NUM_VAR_LO int32 = 12
    IINF_ANA_PRO_NUM_VAR_RA int32 = 13
    IINF_ANA_PRO_NUM_VAR_UP int32 = 14
    IINF_INTPNT_FACTOR_DIM_DENSE int32 = 15
    IINF_INTPNT_ITER int32 = 16
    IINF_INTPNT_NUM_THREADS int32 = 17
    IINF_INTPNT_SOLVE_DUAL int32 = 18
    IINF_MIO_ABSGAP_SATISFIED int32 = 19
    IINF_MIO_CLIQUE_TABLE_SIZE int32 = 20
    IINF_MIO_CONSTRUCT_SOLUTION int32 = 21
    IINF_MIO_NODE_DEPTH int32 = 22
    IINF_MIO_NUM_ACTIVE_NODES int32 = 23
    IINF_MIO_NUM_BRANCH int32 = 24
    IINF_MIO_NUM_CLIQUE_CUTS int32 = 25
    IINF_MIO_NUM_CMIR_CUTS int32 = 26
    IINF_MIO_NUM_GOMORY_CUTS int32 = 27
    IINF_MIO_NUM_IMPLIED_BOUND_CUTS int32 = 28
    IINF_MIO_NUM_INT_SOLUTIONS int32 = 29
    IINF_MIO_NUM_KNAPSACK_COVER_CUTS int32 = 30
    IINF_MIO_NUM_RELAX int32 = 31
    IINF_MIO_NUM_REPEATED_PRESOLVE int32 = 32
    IINF_MIO_NUMBIN int32 = 33
    IINF_MIO_NUMBINCONEVAR int32 = 34
    IINF_MIO_NUMCON int32 = 35
    IINF_MIO_NUMCONE int32 = 36
    IINF_MIO_NUMCONEVAR int32 = 37
    IINF_MIO_NUMCONT int32 = 38
    IINF_MIO_NUMCONTCONEVAR int32 = 39
    IINF_MIO_NUMDEXPCONES int32 = 40
    IINF_MIO_NUMDPOWCONES int32 = 41
    IINF_MIO_NUMINT int32 = 42
    IINF_MIO_NUMINTCONEVAR int32 = 43
    IINF_MIO_NUMPEXPCONES int32 = 44
    IINF_MIO_NUMPPOWCONES int32 = 45
    IINF_MIO_NUMQCONES int32 = 46
    IINF_MIO_NUMRQCONES int32 = 47
    IINF_MIO_NUMVAR int32 = 48
    IINF_MIO_OBJ_BOUND_DEFINED int32 = 49
    IINF_MIO_PRESOLVED_NUMBIN int32 = 50
    IINF_MIO_PRESOLVED_NUMBINCONEVAR int32 = 51
    IINF_MIO_PRESOLVED_NUMCON int32 = 52
    IINF_MIO_PRESOLVED_NUMCONE int32 = 53
    IINF_MIO_PRESOLVED_NUMCONEVAR int32 = 54
    IINF_MIO_PRESOLVED_NUMCONT int32 = 55
    IINF_MIO_PRESOLVED_NUMCONTCONEVAR int32 = 56
    IINF_MIO_PRESOLVED_NUMDEXPCONES int32 = 57
    IINF_MIO_PRESOLVED_NUMDPOWCONES int32 = 58
    IINF_MIO_PRESOLVED_NUMINT int32 = 59
    IINF_MIO_PRESOLVED_NUMINTCONEVAR int32 = 60
    IINF_MIO_PRESOLVED_NUMPEXPCONES int32 = 61
    IINF_MIO_PRESOLVED_NUMPPOWCONES int32 = 62
    IINF_MIO_PRESOLVED_NUMQCONES int32 = 63
    IINF_MIO_PRESOLVED_NUMRQCONES int32 = 64
    IINF_MIO_PRESOLVED_NUMVAR int32 = 65
    IINF_MIO_RELGAP_SATISFIED int32 = 66
    IINF_MIO_TOTAL_NUM_CUTS int32 = 67
    IINF_MIO_USER_OBJ_CUT int32 = 68
    IINF_OPT_NUMCON int32 = 69
    IINF_OPT_NUMVAR int32 = 70
    IINF_OPTIMIZE_RESPONSE int32 = 71
    IINF_PURIFY_DUAL_SUCCESS int32 = 72
    IINF_PURIFY_PRIMAL_SUCCESS int32 = 73
    IINF_RD_NUMBARVAR int32 = 74
    IINF_RD_NUMCON int32 = 75
    IINF_RD_NUMCONE int32 = 76
    IINF_RD_NUMINTVAR int32 = 77
    IINF_RD_NUMQ int32 = 78
    IINF_RD_NUMVAR int32 = 79
    IINF_RD_PROTYPE int32 = 80
    IINF_SIM_DUAL_DEG_ITER int32 = 81
    IINF_SIM_DUAL_HOTSTART int32 = 82
    IINF_SIM_DUAL_HOTSTART_LU int32 = 83
    IINF_SIM_DUAL_INF_ITER int32 = 84
    IINF_SIM_DUAL_ITER int32 = 85
    IINF_SIM_NUMCON int32 = 86
    IINF_SIM_NUMVAR int32 = 87
    IINF_SIM_PRIMAL_DEG_ITER int32 = 88
    IINF_SIM_PRIMAL_HOTSTART int32 = 89
    IINF_SIM_PRIMAL_HOTSTART_LU int32 = 90
    IINF_SIM_PRIMAL_INF_ITER int32 = 91
    IINF_SIM_PRIMAL_ITER int32 = 92
    IINF_SIM_SOLVE_DUAL int32 = 93
    IINF_SOL_BAS_PROSTA int32 = 94
    IINF_SOL_BAS_SOLSTA int32 = 95
    IINF_SOL_ITG_PROSTA int32 = 96
    IINF_SOL_ITG_SOLSTA int32 = 97
    IINF_SOL_ITR_PROSTA int32 = 98
    IINF_SOL_ITR_SOLSTA int32 = 99
    IINF_STO_NUM_A_REALLOC int32 = 100
    IINF_BEGIN int32 = 0
    IINF_END   int32 = 101
)
const ( // enum iomode
    IOMODE_READ int32 = 0
    IOMODE_READWRITE int32 = 2
    IOMODE_WRITE int32 = 1
    IOMODE_BEGIN int32 = 0
    IOMODE_END   int32 = 3
)
const ( // enum miocontsoltype
    MIO_CONT_SOL_ITG int32 = 2
    MIO_CONT_SOL_ITG_REL int32 = 3
    MIO_CONT_SOL_NONE int32 = 0
    MIO_CONT_SOL_ROOT int32 = 1
    MIO_CONT_SOL_BEGIN int32 = 0
    MIO_CONT_SOL_END   int32 = 4
)
const ( // enum callbackcode
    CALLBACK_BEGIN_BI int32 = 0
    CALLBACK_BEGIN_CONIC int32 = 1
    CALLBACK_BEGIN_DUAL_BI int32 = 2
    CALLBACK_BEGIN_DUAL_SENSITIVITY int32 = 3
    CALLBACK_BEGIN_DUAL_SETUP_BI int32 = 4
    CALLBACK_BEGIN_DUAL_SIMPLEX int32 = 5
    CALLBACK_BEGIN_DUAL_SIMPLEX_BI int32 = 6
    CALLBACK_BEGIN_FULL_CONVEXITY_CHECK int32 = 7
    CALLBACK_BEGIN_INFEAS_ANA int32 = 8
    CALLBACK_BEGIN_INTPNT int32 = 9
    CALLBACK_BEGIN_LICENSE_WAIT int32 = 10
    CALLBACK_BEGIN_MIO int32 = 11
    CALLBACK_BEGIN_OPTIMIZER int32 = 12
    CALLBACK_BEGIN_PRESOLVE int32 = 13
    CALLBACK_BEGIN_PRIMAL_BI int32 = 14
    CALLBACK_BEGIN_PRIMAL_REPAIR int32 = 15
    CALLBACK_BEGIN_PRIMAL_SENSITIVITY int32 = 16
    CALLBACK_BEGIN_PRIMAL_SETUP_BI int32 = 17
    CALLBACK_BEGIN_PRIMAL_SIMPLEX int32 = 18
    CALLBACK_BEGIN_PRIMAL_SIMPLEX_BI int32 = 19
    CALLBACK_BEGIN_QCQO_REFORMULATE int32 = 20
    CALLBACK_BEGIN_READ int32 = 21
    CALLBACK_BEGIN_ROOT_CUTGEN int32 = 22
    CALLBACK_BEGIN_SIMPLEX int32 = 23
    CALLBACK_BEGIN_SIMPLEX_BI int32 = 24
    CALLBACK_BEGIN_TO_CONIC int32 = 25
    CALLBACK_BEGIN_WRITE int32 = 26
    CALLBACK_CONIC int32 = 27
    CALLBACK_DUAL_SIMPLEX int32 = 28
    CALLBACK_END_BI int32 = 29
    CALLBACK_END_CONIC int32 = 30
    CALLBACK_END_DUAL_BI int32 = 31
    CALLBACK_END_DUAL_SENSITIVITY int32 = 32
    CALLBACK_END_DUAL_SETUP_BI int32 = 33
    CALLBACK_END_DUAL_SIMPLEX int32 = 34
    CALLBACK_END_DUAL_SIMPLEX_BI int32 = 35
    CALLBACK_END_FULL_CONVEXITY_CHECK int32 = 36
    CALLBACK_END_INFEAS_ANA int32 = 37
    CALLBACK_END_INTPNT int32 = 38
    CALLBACK_END_LICENSE_WAIT int32 = 39
    CALLBACK_END_MIO int32 = 40
    CALLBACK_END_OPTIMIZER int32 = 41
    CALLBACK_END_PRESOLVE int32 = 42
    CALLBACK_END_PRIMAL_BI int32 = 43
    CALLBACK_END_PRIMAL_REPAIR int32 = 44
    CALLBACK_END_PRIMAL_SENSITIVITY int32 = 45
    CALLBACK_END_PRIMAL_SETUP_BI int32 = 46
    CALLBACK_END_PRIMAL_SIMPLEX int32 = 47
    CALLBACK_END_PRIMAL_SIMPLEX_BI int32 = 48
    CALLBACK_END_QCQO_REFORMULATE int32 = 49
    CALLBACK_END_READ int32 = 50
    CALLBACK_END_ROOT_CUTGEN int32 = 51
    CALLBACK_END_SIMPLEX int32 = 52
    CALLBACK_END_SIMPLEX_BI int32 = 53
    CALLBACK_END_TO_CONIC int32 = 54
    CALLBACK_END_WRITE int32 = 55
    CALLBACK_IM_BI int32 = 56
    CALLBACK_IM_CONIC int32 = 57
    CALLBACK_IM_DUAL_BI int32 = 58
    CALLBACK_IM_DUAL_SENSIVITY int32 = 59
    CALLBACK_IM_DUAL_SIMPLEX int32 = 60
    CALLBACK_IM_FULL_CONVEXITY_CHECK int32 = 61
    CALLBACK_IM_INTPNT int32 = 62
    CALLBACK_IM_LICENSE_WAIT int32 = 63
    CALLBACK_IM_LU int32 = 64
    CALLBACK_IM_MIO int32 = 65
    CALLBACK_IM_MIO_DUAL_SIMPLEX int32 = 66
    CALLBACK_IM_MIO_INTPNT int32 = 67
    CALLBACK_IM_MIO_PRIMAL_SIMPLEX int32 = 68
    CALLBACK_IM_ORDER int32 = 69
    CALLBACK_IM_PRESOLVE int32 = 70
    CALLBACK_IM_PRIMAL_BI int32 = 71
    CALLBACK_IM_PRIMAL_SENSIVITY int32 = 72
    CALLBACK_IM_PRIMAL_SIMPLEX int32 = 73
    CALLBACK_IM_QO_REFORMULATE int32 = 74
    CALLBACK_IM_READ int32 = 75
    CALLBACK_IM_ROOT_CUTGEN int32 = 76
    CALLBACK_IM_SIMPLEX int32 = 77
    CALLBACK_IM_SIMPLEX_BI int32 = 78
    CALLBACK_INTPNT int32 = 79
    CALLBACK_NEW_INT_MIO int32 = 80
    CALLBACK_PRIMAL_SIMPLEX int32 = 81
    CALLBACK_READ_OPF int32 = 82
    CALLBACK_READ_OPF_SECTION int32 = 83
    CALLBACK_SOLVING_REMOTE int32 = 84
    CALLBACK_UPDATE_DUAL_BI int32 = 85
    CALLBACK_UPDATE_DUAL_SIMPLEX int32 = 86
    CALLBACK_UPDATE_DUAL_SIMPLEX_BI int32 = 87
    CALLBACK_UPDATE_PRESOLVE int32 = 88
    CALLBACK_UPDATE_PRIMAL_BI int32 = 89
    CALLBACK_UPDATE_PRIMAL_SIMPLEX int32 = 90
    CALLBACK_UPDATE_PRIMAL_SIMPLEX_BI int32 = 91
    CALLBACK_WRITE_OPF int32 = 92
    CALLBACK_BEGIN int32 = 0
    CALLBACK_END   int32 = 93
)
const ( // enum variabletype
    VAR_TYPE_CONT int32 = 0
    VAR_TYPE_INT int32 = 1
    VAR_BEGIN int32 = 0
    VAR_END   int32 = 2
)
const ( // enum sensitivitytype
    SENSITIVITY_TYPE_BASIS int32 = 0
    SENSITIVITY_TYPE_BEGIN int32 = 0
    SENSITIVITY_TYPE_END   int32 = 1
)
const ( // enum feature
    FEATURE_PTON int32 = 1
    FEATURE_PTS int32 = 0
    FEATURE_BEGIN int32 = 0
    FEATURE_END   int32 = 2
)
const ( // enum dinfitem
    DINF_BI_CLEAN_DUAL_TIME int32 = 0
    DINF_BI_CLEAN_PRIMAL_TIME int32 = 1
    DINF_BI_CLEAN_TIME int32 = 2
    DINF_BI_DUAL_TIME int32 = 3
    DINF_BI_PRIMAL_TIME int32 = 4
    DINF_BI_TIME int32 = 5
    DINF_INTPNT_DUAL_FEAS int32 = 6
    DINF_INTPNT_DUAL_OBJ int32 = 7
    DINF_INTPNT_FACTOR_NUM_FLOPS int32 = 8
    DINF_INTPNT_OPT_STATUS int32 = 9
    DINF_INTPNT_ORDER_TIME int32 = 10
    DINF_INTPNT_PRIMAL_FEAS int32 = 11
    DINF_INTPNT_PRIMAL_OBJ int32 = 12
    DINF_INTPNT_TIME int32 = 13
    DINF_MIO_CLIQUE_SEPARATION_TIME int32 = 14
    DINF_MIO_CMIR_SEPARATION_TIME int32 = 15
    DINF_MIO_CONSTRUCT_SOLUTION_OBJ int32 = 16
    DINF_MIO_DUAL_BOUND_AFTER_PRESOLVE int32 = 17
    DINF_MIO_GMI_SEPARATION_TIME int32 = 18
    DINF_MIO_IMPLIED_BOUND_TIME int32 = 19
    DINF_MIO_KNAPSACK_COVER_SEPARATION_TIME int32 = 20
    DINF_MIO_OBJ_ABS_GAP int32 = 21
    DINF_MIO_OBJ_BOUND int32 = 22
    DINF_MIO_OBJ_INT int32 = 23
    DINF_MIO_OBJ_REL_GAP int32 = 24
    DINF_MIO_PROBING_TIME int32 = 25
    DINF_MIO_ROOT_CUTGEN_TIME int32 = 26
    DINF_MIO_ROOT_OPTIMIZER_TIME int32 = 27
    DINF_MIO_ROOT_PRESOLVE_TIME int32 = 28
    DINF_MIO_TIME int32 = 29
    DINF_MIO_USER_OBJ_CUT int32 = 30
    DINF_OPTIMIZER_TIME int32 = 31
    DINF_PRESOLVE_ELI_TIME int32 = 32
    DINF_PRESOLVE_LINDEP_TIME int32 = 33
    DINF_PRESOLVE_TIME int32 = 34
    DINF_PRIMAL_REPAIR_PENALTY_OBJ int32 = 35
    DINF_QCQO_REFORMULATE_MAX_PERTURBATION int32 = 36
    DINF_QCQO_REFORMULATE_TIME int32 = 37
    DINF_QCQO_REFORMULATE_WORST_CHOLESKY_COLUMN_SCALING int32 = 38
    DINF_QCQO_REFORMULATE_WORST_CHOLESKY_DIAG_SCALING int32 = 39
    DINF_RD_TIME int32 = 40
    DINF_SIM_DUAL_TIME int32 = 41
    DINF_SIM_FEAS int32 = 42
    DINF_SIM_OBJ int32 = 43
    DINF_SIM_PRIMAL_TIME int32 = 44
    DINF_SIM_TIME int32 = 45
    DINF_SOL_BAS_DUAL_OBJ int32 = 46
    DINF_SOL_BAS_DVIOLCON int32 = 47
    DINF_SOL_BAS_DVIOLVAR int32 = 48
    DINF_SOL_BAS_NRM_BARX int32 = 49
    DINF_SOL_BAS_NRM_SLC int32 = 50
    DINF_SOL_BAS_NRM_SLX int32 = 51
    DINF_SOL_BAS_NRM_SUC int32 = 52
    DINF_SOL_BAS_NRM_SUX int32 = 53
    DINF_SOL_BAS_NRM_XC int32 = 54
    DINF_SOL_BAS_NRM_XX int32 = 55
    DINF_SOL_BAS_NRM_Y int32 = 56
    DINF_SOL_BAS_PRIMAL_OBJ int32 = 57
    DINF_SOL_BAS_PVIOLCON int32 = 58
    DINF_SOL_BAS_PVIOLVAR int32 = 59
    DINF_SOL_ITG_NRM_BARX int32 = 60
    DINF_SOL_ITG_NRM_XC int32 = 61
    DINF_SOL_ITG_NRM_XX int32 = 62
    DINF_SOL_ITG_PRIMAL_OBJ int32 = 63
    DINF_SOL_ITG_PVIOLBARVAR int32 = 64
    DINF_SOL_ITG_PVIOLCON int32 = 65
    DINF_SOL_ITG_PVIOLCONES int32 = 66
    DINF_SOL_ITG_PVIOLITG int32 = 67
    DINF_SOL_ITG_PVIOLVAR int32 = 68
    DINF_SOL_ITR_DUAL_OBJ int32 = 69
    DINF_SOL_ITR_DVIOLBARVAR int32 = 70
    DINF_SOL_ITR_DVIOLCON int32 = 71
    DINF_SOL_ITR_DVIOLCONES int32 = 72
    DINF_SOL_ITR_DVIOLVAR int32 = 73
    DINF_SOL_ITR_NRM_BARS int32 = 74
    DINF_SOL_ITR_NRM_BARX int32 = 75
    DINF_SOL_ITR_NRM_SLC int32 = 76
    DINF_SOL_ITR_NRM_SLX int32 = 77
    DINF_SOL_ITR_NRM_SNX int32 = 78
    DINF_SOL_ITR_NRM_SUC int32 = 79
    DINF_SOL_ITR_NRM_SUX int32 = 80
    DINF_SOL_ITR_NRM_XC int32 = 81
    DINF_SOL_ITR_NRM_XX int32 = 82
    DINF_SOL_ITR_NRM_Y int32 = 83
    DINF_SOL_ITR_PRIMAL_OBJ int32 = 84
    DINF_SOL_ITR_PVIOLBARVAR int32 = 85
    DINF_SOL_ITR_PVIOLCON int32 = 86
    DINF_SOL_ITR_PVIOLCONES int32 = 87
    DINF_SOL_ITR_PVIOLVAR int32 = 88
    DINF_TO_CONIC_TIME int32 = 89
    DINF_BEGIN int32 = 0
    DINF_END   int32 = 90
)
const ( // enum startpointtype
    STARTING_POINT_CONSTANT int32 = 2
    STARTING_POINT_FREE int32 = 0
    STARTING_POINT_GUESS int32 = 1
    STARTING_POINT_SATISFY_BOUNDS int32 = 3
    STARTING_POINT_BEGIN int32 = 0
    STARTING_POINT_END   int32 = 4
)
const ( // enum onoffkey
    OFF int32 = 0
    ON int32 = 1
)
const ( // enum scalingtype
    SCALING_AGGRESSIVE int32 = 3
    SCALING_FREE int32 = 0
    SCALING_MODERATE int32 = 2
    SCALING_NONE int32 = 1
    SCALING_BEGIN int32 = 0
    SCALING_END   int32 = 4
)
const ( // enum basindtype
    BI_ALWAYS int32 = 1
    BI_IF_FEASIBLE int32 = 3
    BI_NEVER int32 = 0
    BI_NO_ERROR int32 = 2
    BI_RESERVERED int32 = 4
    BI_BEGIN int32 = 0
    BI_END   int32 = 5
)
const ( // enum problemtype
    PROBTYPE_CONIC int32 = 3
    PROBTYPE_LO int32 = 0
    PROBTYPE_MIXED int32 = 4
    PROBTYPE_QCQO int32 = 2
    PROBTYPE_QO int32 = 1
    PROBTYPE_BEGIN int32 = 0
    PROBTYPE_END   int32 = 5
)
const ( // enum simhotstart
    SIM_HOTSTART_FREE int32 = 1
    SIM_HOTSTART_NONE int32 = 0
    SIM_HOTSTART_STATUS_KEYS int32 = 2
    SIM_HOTSTART_BEGIN int32 = 0
    SIM_HOTSTART_END   int32 = 3
)
const ( // enum miomode
    MIO_MODE_IGNORED int32 = 0
    MIO_MODE_SATISFIED int32 = 1
    MIO_MODE_BEGIN int32 = 0
    MIO_MODE_END   int32 = 2
)
const ( // enum stakey
    SK_BAS int32 = 1
    SK_FIX int32 = 5
    SK_INF int32 = 6
    SK_LOW int32 = 3
    SK_SUPBAS int32 = 2
    SK_UNK int32 = 0
    SK_UPR int32 = 4
    SK_BEGIN int32 = 0
    SK_END   int32 = 7
)
const ( // enum branchdir
    BRANCH_DIR_DOWN int32 = 2
    BRANCH_DIR_FAR int32 = 4
    BRANCH_DIR_FREE int32 = 0
    BRANCH_DIR_GUIDED int32 = 6
    BRANCH_DIR_NEAR int32 = 3
    BRANCH_DIR_PSEUDOCOST int32 = 7
    BRANCH_DIR_ROOT_LP int32 = 5
    BRANCH_DIR_UP int32 = 1
    BRANCH_DIR_BEGIN int32 = 0
    BRANCH_DIR_END   int32 = 8
)
const ( // enum transpose
    TRANSPOSE_NO int32 = 0
    TRANSPOSE_YES int32 = 1
    TRANSPOSE_BEGIN int32 = 0
    TRANSPOSE_END   int32 = 2
)
const ( // enum rescodetype
    RESPONSE_ERR int32 = 3
    RESPONSE_OK int32 = 0
    RESPONSE_TRM int32 = 2
    RESPONSE_UNK int32 = 4
    RESPONSE_WRN int32 = 1
    RESPONSE_BEGIN int32 = 0
    RESPONSE_END   int32 = 5
)
const ( // enum sparam
    SPAR_BAS_SOL_FILE_NAME int32 = 0
    SPAR_DATA_FILE_NAME int32 = 1
    SPAR_DEBUG_FILE_NAME int32 = 2
    SPAR_INT_SOL_FILE_NAME int32 = 3
    SPAR_ITR_SOL_FILE_NAME int32 = 4
    SPAR_MIO_DEBUG_STRING int32 = 5
    SPAR_PARAM_COMMENT_SIGN int32 = 6
    SPAR_PARAM_READ_FILE_NAME int32 = 7
    SPAR_PARAM_WRITE_FILE_NAME int32 = 8
    SPAR_READ_MPS_BOU_NAME int32 = 9
    SPAR_READ_MPS_OBJ_NAME int32 = 10
    SPAR_READ_MPS_RAN_NAME int32 = 11
    SPAR_READ_MPS_RHS_NAME int32 = 12
    SPAR_REMOTE_ACCESS_TOKEN int32 = 13
    SPAR_REMOTE_TLS_CERT int32 = 14
    SPAR_REMOTE_TLS_CERT_PATH int32 = 15
    SPAR_SENSITIVITY_FILE_NAME int32 = 16
    SPAR_SENSITIVITY_RES_FILE_NAME int32 = 17
    SPAR_SOL_FILTER_XC_LOW int32 = 18
    SPAR_SOL_FILTER_XC_UPR int32 = 19
    SPAR_SOL_FILTER_XX_LOW int32 = 20
    SPAR_SOL_FILTER_XX_UPR int32 = 21
    SPAR_STAT_FILE_NAME int32 = 22
    SPAR_STAT_KEY int32 = 23
    SPAR_STAT_NAME int32 = 24
    SPAR_WRITE_LP_GEN_VAR_NAME int32 = 25
    SPAR_BEGIN int32 = 0
    SPAR_END   int32 = 26
)
const ( // enum mionodeseltype
    MIO_NODE_SELECTION_BEST int32 = 2
    MIO_NODE_SELECTION_FIRST int32 = 1
    MIO_NODE_SELECTION_FREE int32 = 0
    MIO_NODE_SELECTION_PSEUDO int32 = 3
    MIO_NODE_SELECTION_BEGIN int32 = 0
    MIO_NODE_SELECTION_END   int32 = 4
)
const ( // enum streamtype
    STREAM_ERR int32 = 2
    STREAM_LOG int32 = 0
    STREAM_MSG int32 = 1
    STREAM_WRN int32 = 3
    STREAM_BEGIN int32 = 0
    STREAM_END   int32 = 4
)
const ( // enum scopr
    OPR_ENT int32 = 0
    OPR_EXP int32 = 1
    OPR_LOG int32 = 2
    OPR_POW int32 = 3
    OPR_SQRT int32 = 4
    OPR_BEGIN int32 = 0
    OPR_END   int32 = 5
)
const ( // enum solsta
    SOL_STA_DUAL_FEAS int32 = 3
    SOL_STA_DUAL_ILLPOSED_CER int32 = 8
    SOL_STA_DUAL_INFEAS_CER int32 = 6
    SOL_STA_INTEGER_OPTIMAL int32 = 9
    SOL_STA_OPTIMAL int32 = 1
    SOL_STA_PRIM_AND_DUAL_FEAS int32 = 4
    SOL_STA_PRIM_FEAS int32 = 2
    SOL_STA_PRIM_ILLPOSED_CER int32 = 7
    SOL_STA_PRIM_INFEAS_CER int32 = 5
    SOL_STA_UNKNOWN int32 = 0
    SOL_STA_BEGIN int32 = 0
    SOL_STA_END   int32 = 10
)
const ( // enum rescode
    RES_ERR_AD_INVALID_CODELIST int32 = 3102
    RES_ERR_API_ARRAY_TOO_SMALL int32 = 3001
    RES_ERR_API_CB_CONNECT int32 = 3002
    RES_ERR_API_FATAL_ERROR int32 = 3005
    RES_ERR_API_INTERNAL int32 = 3999
    RES_ERR_APPENDING_TOO_BIG_CONE int32 = 1311
    RES_ERR_ARG_IS_TOO_LARGE int32 = 1227
    RES_ERR_ARG_IS_TOO_SMALL int32 = 1226
    RES_ERR_ARGUMENT_DIMENSION int32 = 1201
    RES_ERR_ARGUMENT_IS_TOO_LARGE int32 = 5005
    RES_ERR_ARGUMENT_LENNEQ int32 = 1197
    RES_ERR_ARGUMENT_PERM_ARRAY int32 = 1299
    RES_ERR_ARGUMENT_TYPE int32 = 1198
    RES_ERR_BAR_VAR_DIM int32 = 3920
    RES_ERR_BASIS int32 = 1266
    RES_ERR_BASIS_FACTOR int32 = 1610
    RES_ERR_BASIS_SINGULAR int32 = 1615
    RES_ERR_BLANK_NAME int32 = 1070
    RES_ERR_CBF_DUPLICATE_ACOORD int32 = 7116
    RES_ERR_CBF_DUPLICATE_BCOORD int32 = 7115
    RES_ERR_CBF_DUPLICATE_CON int32 = 7108
    RES_ERR_CBF_DUPLICATE_INT int32 = 7110
    RES_ERR_CBF_DUPLICATE_OBJ int32 = 7107
    RES_ERR_CBF_DUPLICATE_OBJACOORD int32 = 7114
    RES_ERR_CBF_DUPLICATE_POW_CONES int32 = 7130
    RES_ERR_CBF_DUPLICATE_POW_STAR_CONES int32 = 7131
    RES_ERR_CBF_DUPLICATE_PSDVAR int32 = 7123
    RES_ERR_CBF_DUPLICATE_VAR int32 = 7109
    RES_ERR_CBF_INVALID_CON_TYPE int32 = 7112
    RES_ERR_CBF_INVALID_DIMENSION_OF_CONES int32 = 7741
    RES_ERR_CBF_INVALID_DOMAIN_DIMENSION int32 = 7113
    RES_ERR_CBF_INVALID_EXP_DIMENSION int32 = 7126
    RES_ERR_CBF_INVALID_INT_INDEX int32 = 7121
    RES_ERR_CBF_INVALID_NUMBER_OF_CONES int32 = 7740
    RES_ERR_CBF_INVALID_POWER int32 = 7132
    RES_ERR_CBF_INVALID_POWER_CONE_INDEX int32 = 7134
    RES_ERR_CBF_INVALID_POWER_STAR_CONE_INDEX int32 = 7135
    RES_ERR_CBF_INVALID_PSDVAR_DIMENSION int32 = 7124
    RES_ERR_CBF_INVALID_VAR_TYPE int32 = 7111
    RES_ERR_CBF_NO_VARIABLES int32 = 7102
    RES_ERR_CBF_NO_VERSION_SPECIFIED int32 = 7105
    RES_ERR_CBF_OBJ_SENSE int32 = 7101
    RES_ERR_CBF_PARSE int32 = 7100
    RES_ERR_CBF_POWER_CONE_IS_TOO_LONG int32 = 7133
    RES_ERR_CBF_POWER_CONE_MISMATCH int32 = 7138
    RES_ERR_CBF_POWER_STAR_CONE_MISMATCH int32 = 7139
    RES_ERR_CBF_SYNTAX int32 = 7106
    RES_ERR_CBF_TOO_FEW_CONSTRAINTS int32 = 7118
    RES_ERR_CBF_TOO_FEW_INTS int32 = 7119
    RES_ERR_CBF_TOO_FEW_PSDVAR int32 = 7125
    RES_ERR_CBF_TOO_FEW_VARIABLES int32 = 7117
    RES_ERR_CBF_TOO_MANY_CONSTRAINTS int32 = 7103
    RES_ERR_CBF_TOO_MANY_INTS int32 = 7120
    RES_ERR_CBF_TOO_MANY_VARIABLES int32 = 7104
    RES_ERR_CBF_UNHANDLED_POWER_CONE_TYPE int32 = 7136
    RES_ERR_CBF_UNHANDLED_POWER_STAR_CONE_TYPE int32 = 7137
    RES_ERR_CBF_UNSUPPORTED int32 = 7122
    RES_ERR_CON_Q_NOT_NSD int32 = 1294
    RES_ERR_CON_Q_NOT_PSD int32 = 1293
    RES_ERR_CONE_INDEX int32 = 1300
    RES_ERR_CONE_OVERLAP int32 = 1302
    RES_ERR_CONE_OVERLAP_APPEND int32 = 1307
    RES_ERR_CONE_PARAMETER int32 = 1320
    RES_ERR_CONE_REP_VAR int32 = 1303
    RES_ERR_CONE_SIZE int32 = 1301
    RES_ERR_CONE_TYPE int32 = 1305
    RES_ERR_CONE_TYPE_STR int32 = 1306
    RES_ERR_DATA_FILE_EXT int32 = 1055
    RES_ERR_DUP_NAME int32 = 1071
    RES_ERR_DUPLICATE_AIJ int32 = 1385
    RES_ERR_DUPLICATE_BARVARIABLE_NAMES int32 = 4502
    RES_ERR_DUPLICATE_CONE_NAMES int32 = 4503
    RES_ERR_DUPLICATE_CONSTRAINT_NAMES int32 = 4500
    RES_ERR_DUPLICATE_VARIABLE_NAMES int32 = 4501
    RES_ERR_END_OF_FILE int32 = 1059
    RES_ERR_FACTOR int32 = 1650
    RES_ERR_FEASREPAIR_CANNOT_RELAX int32 = 1700
    RES_ERR_FEASREPAIR_INCONSISTENT_BOUND int32 = 1702
    RES_ERR_FEASREPAIR_SOLVING_RELAXED int32 = 1701
    RES_ERR_FILE_LICENSE int32 = 1007
    RES_ERR_FILE_OPEN int32 = 1052
    RES_ERR_FILE_READ int32 = 1053
    RES_ERR_FILE_WRITE int32 = 1054
    RES_ERR_FINAL_SOLUTION int32 = 1560
    RES_ERR_FIRST int32 = 1570
    RES_ERR_FIRSTI int32 = 1285
    RES_ERR_FIRSTJ int32 = 1287
    RES_ERR_FIXED_BOUND_VALUES int32 = 1420
    RES_ERR_FLEXLM int32 = 1014
    RES_ERR_FORMAT_STRING int32 = 1072
    RES_ERR_GLOBAL_INV_CONIC_PROBLEM int32 = 1503
    RES_ERR_HUGE_AIJ int32 = 1380
    RES_ERR_HUGE_C int32 = 1375
    RES_ERR_IDENTICAL_TASKS int32 = 3101
    RES_ERR_IN_ARGUMENT int32 = 1200
    RES_ERR_INDEX int32 = 1235
    RES_ERR_INDEX_ARR_IS_TOO_LARGE int32 = 1222
    RES_ERR_INDEX_ARR_IS_TOO_SMALL int32 = 1221
    RES_ERR_INDEX_IS_TOO_LARGE int32 = 1204
    RES_ERR_INDEX_IS_TOO_SMALL int32 = 1203
    RES_ERR_INF_DOU_INDEX int32 = 1219
    RES_ERR_INF_DOU_NAME int32 = 1230
    RES_ERR_INF_INT_INDEX int32 = 1220
    RES_ERR_INF_INT_NAME int32 = 1231
    RES_ERR_INF_LINT_INDEX int32 = 1225
    RES_ERR_INF_LINT_NAME int32 = 1234
    RES_ERR_INF_TYPE int32 = 1232
    RES_ERR_INFEAS_UNDEFINED int32 = 3910
    RES_ERR_INFINITE_BOUND int32 = 1400
    RES_ERR_INT64_TO_INT32_CAST int32 = 3800
    RES_ERR_INTERNAL int32 = 3000
    RES_ERR_INTERNAL_TEST_FAILED int32 = 3500
    RES_ERR_INV_APTRE int32 = 1253
    RES_ERR_INV_BK int32 = 1255
    RES_ERR_INV_BKC int32 = 1256
    RES_ERR_INV_BKX int32 = 1257
    RES_ERR_INV_CONE_TYPE int32 = 1272
    RES_ERR_INV_CONE_TYPE_STR int32 = 1271
    RES_ERR_INV_MARKI int32 = 2501
    RES_ERR_INV_MARKJ int32 = 2502
    RES_ERR_INV_NAME_ITEM int32 = 1280
    RES_ERR_INV_NUMI int32 = 2503
    RES_ERR_INV_NUMJ int32 = 2504
    RES_ERR_INV_OPTIMIZER int32 = 1550
    RES_ERR_INV_PROBLEM int32 = 1500
    RES_ERR_INV_QCON_SUBI int32 = 1405
    RES_ERR_INV_QCON_SUBJ int32 = 1406
    RES_ERR_INV_QCON_SUBK int32 = 1404
    RES_ERR_INV_QCON_VAL int32 = 1407
    RES_ERR_INV_QOBJ_SUBI int32 = 1401
    RES_ERR_INV_QOBJ_SUBJ int32 = 1402
    RES_ERR_INV_QOBJ_VAL int32 = 1403
    RES_ERR_INV_SK int32 = 1270
    RES_ERR_INV_SK_STR int32 = 1269
    RES_ERR_INV_SKC int32 = 1267
    RES_ERR_INV_SKN int32 = 1274
    RES_ERR_INV_SKX int32 = 1268
    RES_ERR_INV_VAR_TYPE int32 = 1258
    RES_ERR_INVALID_AIJ int32 = 1473
    RES_ERR_INVALID_AMPL_STUB int32 = 3700
    RES_ERR_INVALID_BARVAR_NAME int32 = 1079
    RES_ERR_INVALID_COMPRESSION int32 = 1800
    RES_ERR_INVALID_CON_NAME int32 = 1076
    RES_ERR_INVALID_CONE_NAME int32 = 1078
    RES_ERR_INVALID_FILE_FORMAT_FOR_CFIX int32 = 4001
    RES_ERR_INVALID_FILE_FORMAT_FOR_CONES int32 = 4005
    RES_ERR_INVALID_FILE_FORMAT_FOR_FREE_CONSTRAINTS int32 = 4003
    RES_ERR_INVALID_FILE_FORMAT_FOR_NONLINEAR int32 = 4010
    RES_ERR_INVALID_FILE_FORMAT_FOR_RANGED_CONSTRAINTS int32 = 4002
    RES_ERR_INVALID_FILE_FORMAT_FOR_SYM_MAT int32 = 4000
    RES_ERR_INVALID_FILE_NAME int32 = 1056
    RES_ERR_INVALID_FORMAT_TYPE int32 = 1283
    RES_ERR_INVALID_IDX int32 = 1246
    RES_ERR_INVALID_IOMODE int32 = 1801
    RES_ERR_INVALID_MAX_NUM int32 = 1247
    RES_ERR_INVALID_NAME_IN_SOL_FILE int32 = 1170
    RES_ERR_INVALID_OBJ_NAME int32 = 1075
    RES_ERR_INVALID_OBJECTIVE_SENSE int32 = 1445
    RES_ERR_INVALID_PROBLEM_TYPE int32 = 6000
    RES_ERR_INVALID_SOL_FILE_NAME int32 = 1057
    RES_ERR_INVALID_STREAM int32 = 1062
    RES_ERR_INVALID_SURPLUS int32 = 1275
    RES_ERR_INVALID_SYM_MAT_DIM int32 = 3950
    RES_ERR_INVALID_TASK int32 = 1064
    RES_ERR_INVALID_UTF8 int32 = 2900
    RES_ERR_INVALID_VAR_NAME int32 = 1077
    RES_ERR_INVALID_WCHAR int32 = 2901
    RES_ERR_INVALID_WHICHSOL int32 = 1228
    RES_ERR_JSON_DATA int32 = 1179
    RES_ERR_JSON_FORMAT int32 = 1178
    RES_ERR_JSON_MISSING_DATA int32 = 1180
    RES_ERR_JSON_NUMBER_OVERFLOW int32 = 1177
    RES_ERR_JSON_STRING int32 = 1176
    RES_ERR_JSON_SYNTAX int32 = 1175
    RES_ERR_LAST int32 = 1571
    RES_ERR_LASTI int32 = 1286
    RES_ERR_LASTJ int32 = 1288
    RES_ERR_LAU_ARG_K int32 = 7012
    RES_ERR_LAU_ARG_M int32 = 7010
    RES_ERR_LAU_ARG_N int32 = 7011
    RES_ERR_LAU_ARG_TRANS int32 = 7018
    RES_ERR_LAU_ARG_TRANSA int32 = 7015
    RES_ERR_LAU_ARG_TRANSB int32 = 7016
    RES_ERR_LAU_ARG_UPLO int32 = 7017
    RES_ERR_LAU_INVALID_LOWER_TRIANGULAR_MATRIX int32 = 7002
    RES_ERR_LAU_INVALID_SPARSE_SYMMETRIC_MATRIX int32 = 7019
    RES_ERR_LAU_NOT_POSITIVE_DEFINITE int32 = 7001
    RES_ERR_LAU_SINGULAR_MATRIX int32 = 7000
    RES_ERR_LAU_UNKNOWN int32 = 7005
    RES_ERR_LICENSE int32 = 1000
    RES_ERR_LICENSE_CANNOT_ALLOCATE int32 = 1020
    RES_ERR_LICENSE_CANNOT_CONNECT int32 = 1021
    RES_ERR_LICENSE_EXPIRED int32 = 1001
    RES_ERR_LICENSE_FEATURE int32 = 1018
    RES_ERR_LICENSE_INVALID_HOSTID int32 = 1025
    RES_ERR_LICENSE_MAX int32 = 1016
    RES_ERR_LICENSE_MOSEKLM_DAEMON int32 = 1017
    RES_ERR_LICENSE_NO_SERVER_LINE int32 = 1028
    RES_ERR_LICENSE_NO_SERVER_SUPPORT int32 = 1027
    RES_ERR_LICENSE_SERVER int32 = 1015
    RES_ERR_LICENSE_SERVER_VERSION int32 = 1026
    RES_ERR_LICENSE_VERSION int32 = 1002
    RES_ERR_LINK_FILE_DLL int32 = 1040
    RES_ERR_LIVING_TASKS int32 = 1066
    RES_ERR_LOWER_BOUND_IS_A_NAN int32 = 1390
    RES_ERR_LP_DUP_SLACK_NAME int32 = 1152
    RES_ERR_LP_EMPTY int32 = 1151
    RES_ERR_LP_FILE_FORMAT int32 = 1157
    RES_ERR_LP_FORMAT int32 = 1160
    RES_ERR_LP_FREE_CONSTRAINT int32 = 1155
    RES_ERR_LP_INCOMPATIBLE int32 = 1150
    RES_ERR_LP_INVALID_CON_NAME int32 = 1171
    RES_ERR_LP_INVALID_VAR_NAME int32 = 1154
    RES_ERR_LP_WRITE_CONIC_PROBLEM int32 = 1163
    RES_ERR_LP_WRITE_GECO_PROBLEM int32 = 1164
    RES_ERR_LU_MAX_NUM_TRIES int32 = 2800
    RES_ERR_MAX_LEN_IS_TOO_SMALL int32 = 1289
    RES_ERR_MAXNUMBARVAR int32 = 1242
    RES_ERR_MAXNUMCON int32 = 1240
    RES_ERR_MAXNUMCONE int32 = 1304
    RES_ERR_MAXNUMQNZ int32 = 1243
    RES_ERR_MAXNUMVAR int32 = 1241
    RES_ERR_MIO_INTERNAL int32 = 5010
    RES_ERR_MIO_INVALID_NODE_OPTIMIZER int32 = 7701
    RES_ERR_MIO_INVALID_ROOT_OPTIMIZER int32 = 7700
    RES_ERR_MIO_NO_OPTIMIZER int32 = 1551
    RES_ERR_MISSING_LICENSE_FILE int32 = 1008
    RES_ERR_MIXED_CONIC_AND_NL int32 = 1501
    RES_ERR_MPS_CONE_OVERLAP int32 = 1118
    RES_ERR_MPS_CONE_REPEAT int32 = 1119
    RES_ERR_MPS_CONE_TYPE int32 = 1117
    RES_ERR_MPS_DUPLICATE_Q_ELEMENT int32 = 1121
    RES_ERR_MPS_FILE int32 = 1100
    RES_ERR_MPS_INV_BOUND_KEY int32 = 1108
    RES_ERR_MPS_INV_CON_KEY int32 = 1107
    RES_ERR_MPS_INV_FIELD int32 = 1101
    RES_ERR_MPS_INV_MARKER int32 = 1102
    RES_ERR_MPS_INV_SEC_NAME int32 = 1109
    RES_ERR_MPS_INV_SEC_ORDER int32 = 1115
    RES_ERR_MPS_INVALID_OBJ_NAME int32 = 1128
    RES_ERR_MPS_INVALID_OBJSENSE int32 = 1122
    RES_ERR_MPS_MUL_CON_NAME int32 = 1112
    RES_ERR_MPS_MUL_CSEC int32 = 1116
    RES_ERR_MPS_MUL_QOBJ int32 = 1114
    RES_ERR_MPS_MUL_QSEC int32 = 1113
    RES_ERR_MPS_NO_OBJECTIVE int32 = 1110
    RES_ERR_MPS_NON_SYMMETRIC_Q int32 = 1120
    RES_ERR_MPS_NULL_CON_NAME int32 = 1103
    RES_ERR_MPS_NULL_VAR_NAME int32 = 1104
    RES_ERR_MPS_SPLITTED_VAR int32 = 1111
    RES_ERR_MPS_TAB_IN_FIELD2 int32 = 1125
    RES_ERR_MPS_TAB_IN_FIELD3 int32 = 1126
    RES_ERR_MPS_TAB_IN_FIELD5 int32 = 1127
    RES_ERR_MPS_UNDEF_CON_NAME int32 = 1105
    RES_ERR_MPS_UNDEF_VAR_NAME int32 = 1106
    RES_ERR_MUL_A_ELEMENT int32 = 1254
    RES_ERR_NAME_IS_NULL int32 = 1760
    RES_ERR_NAME_MAX_LEN int32 = 1750
    RES_ERR_NAN_IN_BLC int32 = 1461
    RES_ERR_NAN_IN_BLX int32 = 1471
    RES_ERR_NAN_IN_BUC int32 = 1462
    RES_ERR_NAN_IN_BUX int32 = 1472
    RES_ERR_NAN_IN_C int32 = 1470
    RES_ERR_NAN_IN_DOUBLE_DATA int32 = 1450
    RES_ERR_NEGATIVE_APPEND int32 = 1578
    RES_ERR_NEGATIVE_SURPLUS int32 = 1573
    RES_ERR_NEWER_DLL int32 = 1036
    RES_ERR_NO_BARS_FOR_SOLUTION int32 = 3916
    RES_ERR_NO_BARX_FOR_SOLUTION int32 = 3915
    RES_ERR_NO_BASIS_SOL int32 = 1600
    RES_ERR_NO_DUAL_FOR_ITG_SOL int32 = 2950
    RES_ERR_NO_DUAL_INFEAS_CER int32 = 2001
    RES_ERR_NO_INIT_ENV int32 = 1063
    RES_ERR_NO_OPTIMIZER_VAR_TYPE int32 = 1552
    RES_ERR_NO_PRIMAL_INFEAS_CER int32 = 2000
    RES_ERR_NO_SNX_FOR_BAS_SOL int32 = 2953
    RES_ERR_NO_SOLUTION_IN_CALLBACK int32 = 2500
    RES_ERR_NON_UNIQUE_ARRAY int32 = 5000
    RES_ERR_NONCONVEX int32 = 1291
    RES_ERR_NONLINEAR_EQUALITY int32 = 1290
    RES_ERR_NONLINEAR_RANGED int32 = 1292
    RES_ERR_NULL_ENV int32 = 1060
    RES_ERR_NULL_POINTER int32 = 1065
    RES_ERR_NULL_TASK int32 = 1061
    RES_ERR_NUM_ARGUMENTS int32 = 1199
    RES_ERR_NUMCONLIM int32 = 1250
    RES_ERR_NUMVARLIM int32 = 1251
    RES_ERR_OBJ_Q_NOT_NSD int32 = 1296
    RES_ERR_OBJ_Q_NOT_PSD int32 = 1295
    RES_ERR_OBJECTIVE_RANGE int32 = 1260
    RES_ERR_OLDER_DLL int32 = 1035
    RES_ERR_OPF_FORMAT int32 = 1168
    RES_ERR_OPF_NEW_VARIABLE int32 = 1169
    RES_ERR_OPF_PREMATURE_EOF int32 = 1172
    RES_ERR_OPTIMIZER_LICENSE int32 = 1013
    RES_ERR_OVERFLOW int32 = 1590
    RES_ERR_PARAM_INDEX int32 = 1210
    RES_ERR_PARAM_IS_TOO_LARGE int32 = 1215
    RES_ERR_PARAM_IS_TOO_SMALL int32 = 1216
    RES_ERR_PARAM_NAME int32 = 1205
    RES_ERR_PARAM_NAME_DOU int32 = 1206
    RES_ERR_PARAM_NAME_INT int32 = 1207
    RES_ERR_PARAM_NAME_STR int32 = 1208
    RES_ERR_PARAM_TYPE int32 = 1218
    RES_ERR_PARAM_VALUE_STR int32 = 1217
    RES_ERR_PLATFORM_NOT_LICENSED int32 = 1019
    RES_ERR_POSTSOLVE int32 = 1580
    RES_ERR_PRO_ITEM int32 = 1281
    RES_ERR_PROB_LICENSE int32 = 1006
    RES_ERR_PTF_FORMAT int32 = 1167
    RES_ERR_QCON_SUBI_TOO_LARGE int32 = 1409
    RES_ERR_QCON_SUBI_TOO_SMALL int32 = 1408
    RES_ERR_QCON_UPPER_TRIANGLE int32 = 1417
    RES_ERR_QOBJ_UPPER_TRIANGLE int32 = 1415
    RES_ERR_READ_FORMAT int32 = 1090
    RES_ERR_READ_LP_MISSING_END_TAG int32 = 1159
    RES_ERR_READ_LP_NONEXISTING_NAME int32 = 1162
    RES_ERR_REMOVE_CONE_VARIABLE int32 = 1310
    RES_ERR_REPAIR_INVALID_PROBLEM int32 = 1710
    RES_ERR_REPAIR_OPTIMIZATION_FAILED int32 = 1711
    RES_ERR_SEN_BOUND_INVALID_LO int32 = 3054
    RES_ERR_SEN_BOUND_INVALID_UP int32 = 3053
    RES_ERR_SEN_FORMAT int32 = 3050
    RES_ERR_SEN_INDEX_INVALID int32 = 3055
    RES_ERR_SEN_INDEX_RANGE int32 = 3052
    RES_ERR_SEN_INVALID_REGEXP int32 = 3056
    RES_ERR_SEN_NUMERICAL int32 = 3058
    RES_ERR_SEN_SOLUTION_STATUS int32 = 3057
    RES_ERR_SEN_UNDEF_NAME int32 = 3051
    RES_ERR_SEN_UNHANDLED_PROBLEM_TYPE int32 = 3080
    RES_ERR_SERVER_ACCESS_TOKEN int32 = 8007
    RES_ERR_SERVER_ADDRESS int32 = 8004
    RES_ERR_SERVER_CERTIFICATE int32 = 8005
    RES_ERR_SERVER_CONNECT int32 = 8000
    RES_ERR_SERVER_PROTOCOL int32 = 8001
    RES_ERR_SERVER_STATUS int32 = 8002
    RES_ERR_SERVER_TLS_CLIENT int32 = 8006
    RES_ERR_SERVER_TOKEN int32 = 8003
    RES_ERR_SHAPE_IS_TOO_LARGE int32 = 1202
    RES_ERR_SIZE_LICENSE int32 = 1005
    RES_ERR_SIZE_LICENSE_CON int32 = 1010
    RES_ERR_SIZE_LICENSE_INTVAR int32 = 1012
    RES_ERR_SIZE_LICENSE_NUMCORES int32 = 3900
    RES_ERR_SIZE_LICENSE_VAR int32 = 1011
    RES_ERR_SLICE_SIZE int32 = 1572
    RES_ERR_SOL_FILE_INVALID_NUMBER int32 = 1350
    RES_ERR_SOLITEM int32 = 1237
    RES_ERR_SOLVER_PROBTYPE int32 = 1259
    RES_ERR_SPACE int32 = 1051
    RES_ERR_SPACE_LEAKING int32 = 1080
    RES_ERR_SPACE_NO_INFO int32 = 1081
    RES_ERR_SYM_MAT_DUPLICATE int32 = 3944
    RES_ERR_SYM_MAT_HUGE int32 = 1482
    RES_ERR_SYM_MAT_INVALID int32 = 1480
    RES_ERR_SYM_MAT_INVALID_COL_INDEX int32 = 3941
    RES_ERR_SYM_MAT_INVALID_ROW_INDEX int32 = 3940
    RES_ERR_SYM_MAT_INVALID_VALUE int32 = 3943
    RES_ERR_SYM_MAT_NOT_LOWER_TRINGULAR int32 = 3942
    RES_ERR_TASK_INCOMPATIBLE int32 = 2560
    RES_ERR_TASK_INVALID int32 = 2561
    RES_ERR_TASK_WRITE int32 = 2562
    RES_ERR_THREAD_COND_INIT int32 = 1049
    RES_ERR_THREAD_CREATE int32 = 1048
    RES_ERR_THREAD_MUTEX_INIT int32 = 1045
    RES_ERR_THREAD_MUTEX_LOCK int32 = 1046
    RES_ERR_THREAD_MUTEX_UNLOCK int32 = 1047
    RES_ERR_TOCONIC_CONSTR_NOT_CONIC int32 = 7803
    RES_ERR_TOCONIC_CONSTR_Q_NOT_PSD int32 = 7800
    RES_ERR_TOCONIC_CONSTRAINT_FX int32 = 7801
    RES_ERR_TOCONIC_CONSTRAINT_RA int32 = 7802
    RES_ERR_TOCONIC_OBJECTIVE_NOT_PSD int32 = 7804
    RES_ERR_TOO_SMALL_A_TRUNCATION_VALUE int32 = 1421
    RES_ERR_TOO_SMALL_MAX_NUM_NZ int32 = 1245
    RES_ERR_TOO_SMALL_MAXNUMANZ int32 = 1252
    RES_ERR_UNB_STEP_SIZE int32 = 3100
    RES_ERR_UNDEF_SOLUTION int32 = 1265
    RES_ERR_UNDEFINED_OBJECTIVE_SENSE int32 = 1446
    RES_ERR_UNHANDLED_SOLUTION_STATUS int32 = 6010
    RES_ERR_UNKNOWN int32 = 1050
    RES_ERR_UPPER_BOUND_IS_A_NAN int32 = 1391
    RES_ERR_UPPER_TRIANGLE int32 = 6020
    RES_ERR_WHICHITEM_NOT_ALLOWED int32 = 1238
    RES_ERR_WHICHSOL int32 = 1236
    RES_ERR_WRITE_LP_FORMAT int32 = 1158
    RES_ERR_WRITE_LP_NON_UNIQUE_NAME int32 = 1161
    RES_ERR_WRITE_MPS_INVALID_NAME int32 = 1153
    RES_ERR_WRITE_OPF_INVALID_VAR_NAME int32 = 1156
    RES_ERR_WRITING_FILE int32 = 1166
    RES_ERR_XML_INVALID_PROBLEM_TYPE int32 = 3600
    RES_ERR_Y_IS_UNDEFINED int32 = 1449
    RES_OK int32 = 0
    RES_TRM_INTERNAL int32 = 10030
    RES_TRM_INTERNAL_STOP int32 = 10031
    RES_TRM_MAX_ITERATIONS int32 = 10000
    RES_TRM_MAX_NUM_SETBACKS int32 = 10020
    RES_TRM_MAX_TIME int32 = 10001
    RES_TRM_MIO_NUM_BRANCHES int32 = 10009
    RES_TRM_MIO_NUM_RELAXS int32 = 10008
    RES_TRM_NUM_MAX_NUM_INT_SOLUTIONS int32 = 10015
    RES_TRM_NUMERICAL_PROBLEM int32 = 10025
    RES_TRM_OBJECTIVE_RANGE int32 = 10002
    RES_TRM_STALL int32 = 10006
    RES_TRM_USER_CALLBACK int32 = 10007
    RES_WRN_ANA_ALMOST_INT_BOUNDS int32 = 904
    RES_WRN_ANA_C_ZERO int32 = 901
    RES_WRN_ANA_CLOSE_BOUNDS int32 = 903
    RES_WRN_ANA_EMPTY_COLS int32 = 902
    RES_WRN_ANA_LARGE_BOUNDS int32 = 900
    RES_WRN_DROPPED_NZ_QOBJ int32 = 201
    RES_WRN_DUPLICATE_BARVARIABLE_NAMES int32 = 852
    RES_WRN_DUPLICATE_CONE_NAMES int32 = 853
    RES_WRN_DUPLICATE_CONSTRAINT_NAMES int32 = 850
    RES_WRN_DUPLICATE_VARIABLE_NAMES int32 = 851
    RES_WRN_ELIMINATOR_SPACE int32 = 801
    RES_WRN_EMPTY_NAME int32 = 502
    RES_WRN_EXP_CONES_WITH_VARIABLES_FIXED_AT_ZERO int32 = 932
    RES_WRN_IGNORE_INTEGER int32 = 250
    RES_WRN_INCOMPLETE_LINEAR_DEPENDENCY_CHECK int32 = 800
    RES_WRN_INVALID_MPS_NAME int32 = 504
    RES_WRN_INVALID_MPS_OBJ_NAME int32 = 505
    RES_WRN_LARGE_AIJ int32 = 62
    RES_WRN_LARGE_BOUND int32 = 51
    RES_WRN_LARGE_CJ int32 = 57
    RES_WRN_LARGE_CON_FX int32 = 54
    RES_WRN_LARGE_LO_BOUND int32 = 52
    RES_WRN_LARGE_UP_BOUND int32 = 53
    RES_WRN_LICENSE_EXPIRE int32 = 500
    RES_WRN_LICENSE_FEATURE_EXPIRE int32 = 509
    RES_WRN_LICENSE_SERVER int32 = 501
    RES_WRN_LP_DROP_VARIABLE int32 = 85
    RES_WRN_LP_OLD_QUAD_FORMAT int32 = 80
    RES_WRN_MIO_INFEASIBLE_FINAL int32 = 270
    RES_WRN_MPS_SPLIT_BOU_VECTOR int32 = 72
    RES_WRN_MPS_SPLIT_RAN_VECTOR int32 = 71
    RES_WRN_MPS_SPLIT_RHS_VECTOR int32 = 70
    RES_WRN_NAME_MAX_LEN int32 = 65
    RES_WRN_NO_DUALIZER int32 = 950
    RES_WRN_NO_GLOBAL_OPTIMIZER int32 = 251
    RES_WRN_NZ_IN_UPR_TRI int32 = 200
    RES_WRN_OPEN_PARAM_FILE int32 = 50
    RES_WRN_PARAM_IGNORED_CMIO int32 = 516
    RES_WRN_PARAM_NAME_DOU int32 = 510
    RES_WRN_PARAM_NAME_INT int32 = 511
    RES_WRN_PARAM_NAME_STR int32 = 512
    RES_WRN_PARAM_STR_VALUE int32 = 515
    RES_WRN_POW_CONES_WITH_ROOT_FIXED_AT_ZERO int32 = 933
    RES_WRN_PRESOLVE_OUTOFSPACE int32 = 802
    RES_WRN_QUAD_CONES_WITH_ROOT_FIXED_AT_ZERO int32 = 930
    RES_WRN_RQUAD_CONES_WITH_ROOT_FIXED_AT_ZERO int32 = 931
    RES_WRN_SOL_FILE_IGNORED_CON int32 = 351
    RES_WRN_SOL_FILE_IGNORED_VAR int32 = 352
    RES_WRN_SOL_FILTER int32 = 300
    RES_WRN_SPAR_MAX_LEN int32 = 66
    RES_WRN_SYM_MAT_LARGE int32 = 960
    RES_WRN_TOO_FEW_BASIS_VARS int32 = 400
    RES_WRN_TOO_MANY_BASIS_VARS int32 = 405
    RES_WRN_UNDEF_SOL_FILE_NAME int32 = 350
    RES_WRN_USING_GENERIC_NAMES int32 = 503
    RES_WRN_WRITE_CHANGED_NAMES int32 = 803
    RES_WRN_WRITE_DISCARDED_CFIX int32 = 804
    RES_WRN_ZERO_AIJ int32 = 63
    RES_WRN_ZEROS_IN_SPARSE_COL int32 = 710
    RES_WRN_ZEROS_IN_SPARSE_ROW int32 = 705
)
const ( // enum parametertype
    PAR_DOU_TYPE int32 = 1
    PAR_INT_TYPE int32 = 2
    PAR_INVALID_TYPE int32 = 0
    PAR_STR_TYPE int32 = 3
    PAR_BEGIN int32 = 0
    PAR_END   int32 = 4
)
const ( // enum scalingmethod
    SCALING_METHOD_FREE int32 = 1
    SCALING_METHOD_POW2 int32 = 0
    SCALING_METHOD_BEGIN int32 = 0
    SCALING_METHOD_END   int32 = 2
)
const ( // enum simreform
    SIM_REFORMULATION_AGGRESSIVE int32 = 3
    SIM_REFORMULATION_FREE int32 = 2
    SIM_REFORMULATION_OFF int32 = 0
    SIM_REFORMULATION_ON int32 = 1
    SIM_REFORMULATION_BEGIN int32 = 0
    SIM_REFORMULATION_END   int32 = 4
)
const ( // enum boundkey
    BK_FR int32 = 3
    BK_FX int32 = 2
    BK_LO int32 = 0
    BK_RA int32 = 4
    BK_UP int32 = 1
    BK_BEGIN int32 = 0
    BK_END   int32 = 5
)
const ( // enum uplo
    UPLO_LO int32 = 0
    UPLO_UP int32 = 1
    UPLO_BEGIN int32 = 0
    UPLO_END   int32 = 2
)
const ( // enum symmattype
    SYMMAT_TYPE_SPARSE int32 = 0
    SYMMAT_TYPE_BEGIN int32 = 0
    SYMMAT_TYPE_END   int32 = 1
)
const ( // enum presolvemode
    PRESOLVE_MODE_FREE int32 = 2
    PRESOLVE_MODE_OFF int32 = 0
    PRESOLVE_MODE_ON int32 = 1
    PRESOLVE_MODE_BEGIN int32 = 0
    PRESOLVE_MODE_END   int32 = 3
)
const ( // enum objsense
    OBJECTIVE_SENSE_MAXIMIZE int32 = 1
    OBJECTIVE_SENSE_MINIMIZE int32 = 0
    OBJECTIVE_SENSE_BEGIN int32 = 0
    OBJECTIVE_SENSE_END   int32 = 2
)
const ( // enum purify
    PURIFY_AUTO int32 = 4
    PURIFY_DUAL int32 = 2
    PURIFY_NONE int32 = 0
    PURIFY_PRIMAL int32 = 1
    PURIFY_PRIMAL_DUAL int32 = 3
    PURIFY_BEGIN int32 = 0
    PURIFY_END   int32 = 5
)
const ( // enum mark
    MARK_LO int32 = 0
    MARK_UP int32 = 1
    MARK_BEGIN int32 = 0
    MARK_END   int32 = 2
)
const ( // enum value
    LICENSE_BUFFER_LENGTH int32 = 21
    MAX_STR_LEN int32 = 1024
)
const ( // enum problemitem
    PI_CON int32 = 1
    PI_CONE int32 = 2
    PI_VAR int32 = 0
    PI_BEGIN int32 = 0
    PI_END   int32 = 3
)
const ( // enum checkconvexitytype
    CHECK_CONVEXITY_FULL int32 = 2
    CHECK_CONVEXITY_NONE int32 = 0
    CHECK_CONVEXITY_SIMPLE int32 = 1
    CHECK_CONVEXITY_BEGIN int32 = 0
    CHECK_CONVEXITY_END   int32 = 3
)
const ( // enum dataformat
    DATA_FORMAT_CB int32 = 7
    DATA_FORMAT_EXTENSION int32 = 0
    DATA_FORMAT_FREE_MPS int32 = 4
    DATA_FORMAT_JSON_TASK int32 = 8
    DATA_FORMAT_LP int32 = 2
    DATA_FORMAT_MPS int32 = 1
    DATA_FORMAT_OP int32 = 3
    DATA_FORMAT_PTF int32 = 6
    DATA_FORMAT_TASK int32 = 5
    DATA_FORMAT_BEGIN int32 = 0
    DATA_FORMAT_END   int32 = 9
)
const ( // enum compresstype
    COMPRESS_FREE int32 = 1
    COMPRESS_GZIP int32 = 2
    COMPRESS_NONE int32 = 0
    COMPRESS_ZSTD int32 = 3
    COMPRESS_BEGIN int32 = 0
    COMPRESS_END   int32 = 4
)
const ( // enum inftype
    INF_DOU_TYPE int32 = 0
    INF_INT_TYPE int32 = 1
    INF_LINT_TYPE int32 = 2
    INF_BEGIN int32 = 0
    INF_END   int32 = 3
)
const ( // enum solveform
    SOLVE_DUAL int32 = 2
    SOLVE_FREE int32 = 0
    SOLVE_PRIMAL int32 = 1
    SOLVE_BEGIN int32 = 0
    SOLVE_END   int32 = 3
)
const ( // enum orderingtype
    ORDER_METHOD_APPMINLOC int32 = 1
    ORDER_METHOD_EXPERIMENTAL int32 = 2
    ORDER_METHOD_FORCE_GRAPHPAR int32 = 4
    ORDER_METHOD_FREE int32 = 0
    ORDER_METHOD_NONE int32 = 5
    ORDER_METHOD_TRY_GRAPHPAR int32 = 3
    ORDER_METHOD_BEGIN int32 = 0
    ORDER_METHOD_END   int32 = 6
)
const ( // enum nametype
    NAME_TYPE_GEN int32 = 0
    NAME_TYPE_LP int32 = 2
    NAME_TYPE_MPS int32 = 1
    NAME_TYPE_BEGIN int32 = 0
    NAME_TYPE_END   int32 = 3
)
const ( // enum liinfitem
    LIINF_BI_CLEAN_DUAL_DEG_ITER int32 = 0
    LIINF_BI_CLEAN_DUAL_ITER int32 = 1
    LIINF_BI_CLEAN_PRIMAL_DEG_ITER int32 = 2
    LIINF_BI_CLEAN_PRIMAL_ITER int32 = 3
    LIINF_BI_DUAL_ITER int32 = 4
    LIINF_BI_PRIMAL_ITER int32 = 5
    LIINF_INTPNT_FACTOR_NUM_NZ int32 = 6
    LIINF_MIO_ANZ int32 = 7
    LIINF_MIO_INTPNT_ITER int32 = 8
    LIINF_MIO_PRESOLVED_ANZ int32 = 9
    LIINF_MIO_SIMPLEX_ITER int32 = 10
    LIINF_RD_NUMANZ int32 = 11
    LIINF_RD_NUMQNZ int32 = 12
    LIINF_BEGIN int32 = 0
    LIINF_END   int32 = 13
)
const ( // enum simdegen
    SIM_DEGEN_AGGRESSIVE int32 = 2
    SIM_DEGEN_FREE int32 = 1
    SIM_DEGEN_MINIMUM int32 = 4
    SIM_DEGEN_MODERATE int32 = 3
    SIM_DEGEN_NONE int32 = 0
    SIM_DEGEN_BEGIN int32 = 0
    SIM_DEGEN_END   int32 = 5
)
const ( // enum prosta
    PRO_STA_DUAL_FEAS int32 = 3
    PRO_STA_DUAL_INFEAS int32 = 5
    PRO_STA_ILL_POSED int32 = 7
    PRO_STA_PRIM_AND_DUAL_FEAS int32 = 1
    PRO_STA_PRIM_AND_DUAL_INFEAS int32 = 6
    PRO_STA_PRIM_FEAS int32 = 2
    PRO_STA_PRIM_INFEAS int32 = 4
    PRO_STA_PRIM_INFEAS_OR_UNBOUNDED int32 = 8
    PRO_STA_UNKNOWN int32 = 0
    PRO_STA_BEGIN int32 = 0
    PRO_STA_END   int32 = 9
)
const ( // enum conetype
    CT_DEXP int32 = 3
    CT_DPOW int32 = 5
    CT_PEXP int32 = 2
    CT_PPOW int32 = 4
    CT_QUAD int32 = 0
    CT_RQUAD int32 = 1
    CT_ZERO int32 = 6
    CT_BEGIN int32 = 0
    CT_END   int32 = 7
)
const ( // enum optimizertype
    OPTIMIZER_CONIC int32 = 0
    OPTIMIZER_DUAL_SIMPLEX int32 = 1
    OPTIMIZER_FREE int32 = 2
    OPTIMIZER_FREE_SIMPLEX int32 = 3
    OPTIMIZER_INTPNT int32 = 4
    OPTIMIZER_MIXED_INT int32 = 5
    OPTIMIZER_PRIMAL_SIMPLEX int32 = 6
    OPTIMIZER_BEGIN int32 = 0
    OPTIMIZER_END   int32 = 7
)
const ( // enum solitem
    SOL_ITEM_SLC int32 = 3
    SOL_ITEM_SLX int32 = 5
    SOL_ITEM_SNX int32 = 7
    SOL_ITEM_SUC int32 = 4
    SOL_ITEM_SUX int32 = 6
    SOL_ITEM_XC int32 = 0
    SOL_ITEM_XX int32 = 1
    SOL_ITEM_Y int32 = 2
    SOL_ITEM_BEGIN int32 = 0
    SOL_ITEM_END   int32 = 8
)
const ( // enum simseltype
    SIM_SELECTION_ASE int32 = 2
    SIM_SELECTION_DEVEX int32 = 3
    SIM_SELECTION_FREE int32 = 0
    SIM_SELECTION_FULL int32 = 1
    SIM_SELECTION_PARTIAL int32 = 5
    SIM_SELECTION_SE int32 = 4
    SIM_SELECTION_BEGIN int32 = 0
    SIM_SELECTION_END   int32 = 6
)
const ( // enum iparam
    IPAR_ANA_SOL_BASIS int32 = 0
    IPAR_ANA_SOL_PRINT_VIOLATED int32 = 1
    IPAR_AUTO_SORT_A_BEFORE_OPT int32 = 2
    IPAR_AUTO_UPDATE_SOL_INFO int32 = 3
    IPAR_BASIS_SOLVE_USE_PLUS_ONE int32 = 4
    IPAR_BI_CLEAN_OPTIMIZER int32 = 5
    IPAR_BI_IGNORE_MAX_ITER int32 = 6
    IPAR_BI_IGNORE_NUM_ERROR int32 = 7
    IPAR_BI_MAX_ITERATIONS int32 = 8
    IPAR_CACHE_LICENSE int32 = 9
    IPAR_CHECK_CONVEXITY int32 = 10
    IPAR_COMPRESS_STATFILE int32 = 11
    IPAR_INFEAS_GENERIC_NAMES int32 = 12
    IPAR_INFEAS_PREFER_PRIMAL int32 = 13
    IPAR_INFEAS_REPORT_AUTO int32 = 14
    IPAR_INFEAS_REPORT_LEVEL int32 = 15
    IPAR_INTPNT_BASIS int32 = 16
    IPAR_INTPNT_DIFF_STEP int32 = 17
    IPAR_INTPNT_HOTSTART int32 = 18
    IPAR_INTPNT_MAX_ITERATIONS int32 = 19
    IPAR_INTPNT_MAX_NUM_COR int32 = 20
    IPAR_INTPNT_MAX_NUM_REFINEMENT_STEPS int32 = 21
    IPAR_INTPNT_MULTI_THREAD int32 = 22
    IPAR_INTPNT_OFF_COL_TRH int32 = 23
    IPAR_INTPNT_ORDER_GP_NUM_SEEDS int32 = 24
    IPAR_INTPNT_ORDER_METHOD int32 = 25
    IPAR_INTPNT_PURIFY int32 = 26
    IPAR_INTPNT_REGULARIZATION_USE int32 = 27
    IPAR_INTPNT_SCALING int32 = 28
    IPAR_INTPNT_SOLVE_FORM int32 = 29
    IPAR_INTPNT_STARTING_POINT int32 = 30
    IPAR_LICENSE_DEBUG int32 = 31
    IPAR_LICENSE_PAUSE_TIME int32 = 32
    IPAR_LICENSE_SUPPRESS_EXPIRE_WRNS int32 = 33
    IPAR_LICENSE_TRH_EXPIRY_WRN int32 = 34
    IPAR_LICENSE_WAIT int32 = 35
    IPAR_LOG int32 = 36
    IPAR_LOG_ANA_PRO int32 = 37
    IPAR_LOG_BI int32 = 38
    IPAR_LOG_BI_FREQ int32 = 39
    IPAR_LOG_CHECK_CONVEXITY int32 = 40
    IPAR_LOG_CUT_SECOND_OPT int32 = 41
    IPAR_LOG_EXPAND int32 = 42
    IPAR_LOG_FEAS_REPAIR int32 = 43
    IPAR_LOG_FILE int32 = 44
    IPAR_LOG_INCLUDE_SUMMARY int32 = 45
    IPAR_LOG_INFEAS_ANA int32 = 46
    IPAR_LOG_INTPNT int32 = 47
    IPAR_LOG_LOCAL_INFO int32 = 48
    IPAR_LOG_MIO int32 = 49
    IPAR_LOG_MIO_FREQ int32 = 50
    IPAR_LOG_ORDER int32 = 51
    IPAR_LOG_PRESOLVE int32 = 52
    IPAR_LOG_RESPONSE int32 = 53
    IPAR_LOG_SENSITIVITY int32 = 54
    IPAR_LOG_SENSITIVITY_OPT int32 = 55
    IPAR_LOG_SIM int32 = 56
    IPAR_LOG_SIM_FREQ int32 = 57
    IPAR_LOG_SIM_MINOR int32 = 58
    IPAR_LOG_STORAGE int32 = 59
    IPAR_MAX_NUM_WARNINGS int32 = 60
    IPAR_MIO_BRANCH_DIR int32 = 61
    IPAR_MIO_CONIC_OUTER_APPROXIMATION int32 = 62
    IPAR_MIO_CUT_CLIQUE int32 = 63
    IPAR_MIO_CUT_CMIR int32 = 64
    IPAR_MIO_CUT_GMI int32 = 65
    IPAR_MIO_CUT_IMPLIED_BOUND int32 = 66
    IPAR_MIO_CUT_KNAPSACK_COVER int32 = 67
    IPAR_MIO_CUT_SELECTION_LEVEL int32 = 68
    IPAR_MIO_FEASPUMP_LEVEL int32 = 69
    IPAR_MIO_HEURISTIC_LEVEL int32 = 70
    IPAR_MIO_MAX_NUM_BRANCHES int32 = 71
    IPAR_MIO_MAX_NUM_RELAXS int32 = 72
    IPAR_MIO_MAX_NUM_ROOT_CUT_ROUNDS int32 = 73
    IPAR_MIO_MAX_NUM_SOLUTIONS int32 = 74
    IPAR_MIO_MODE int32 = 75
    IPAR_MIO_NODE_OPTIMIZER int32 = 76
    IPAR_MIO_NODE_SELECTION int32 = 77
    IPAR_MIO_PERSPECTIVE_REFORMULATE int32 = 78
    IPAR_MIO_PROBING_LEVEL int32 = 79
    IPAR_MIO_PROPAGATE_OBJECTIVE_CONSTRAINT int32 = 80
    IPAR_MIO_RINS_MAX_NODES int32 = 81
    IPAR_MIO_ROOT_OPTIMIZER int32 = 82
    IPAR_MIO_ROOT_REPEAT_PRESOLVE_LEVEL int32 = 83
    IPAR_MIO_SEED int32 = 84
    IPAR_MIO_VB_DETECTION_LEVEL int32 = 85
    IPAR_MT_SPINCOUNT int32 = 86
    IPAR_NUM_THREADS int32 = 87
    IPAR_OPF_WRITE_HEADER int32 = 88
    IPAR_OPF_WRITE_HINTS int32 = 89
    IPAR_OPF_WRITE_LINE_LENGTH int32 = 90
    IPAR_OPF_WRITE_PARAMETERS int32 = 91
    IPAR_OPF_WRITE_PROBLEM int32 = 92
    IPAR_OPF_WRITE_SOL_BAS int32 = 93
    IPAR_OPF_WRITE_SOL_ITG int32 = 94
    IPAR_OPF_WRITE_SOL_ITR int32 = 95
    IPAR_OPF_WRITE_SOLUTIONS int32 = 96
    IPAR_OPTIMIZER int32 = 97
    IPAR_PARAM_READ_CASE_NAME int32 = 98
    IPAR_PARAM_READ_IGN_ERROR int32 = 99
    IPAR_PRESOLVE_ELIMINATOR_MAX_FILL int32 = 100
    IPAR_PRESOLVE_ELIMINATOR_MAX_NUM_TRIES int32 = 101
    IPAR_PRESOLVE_LEVEL int32 = 102
    IPAR_PRESOLVE_LINDEP_ABS_WORK_TRH int32 = 103
    IPAR_PRESOLVE_LINDEP_REL_WORK_TRH int32 = 104
    IPAR_PRESOLVE_LINDEP_USE int32 = 105
    IPAR_PRESOLVE_MAX_NUM_PASS int32 = 106
    IPAR_PRESOLVE_MAX_NUM_REDUCTIONS int32 = 107
    IPAR_PRESOLVE_USE int32 = 108
    IPAR_PRIMAL_REPAIR_OPTIMIZER int32 = 109
    IPAR_PTF_WRITE_TRANSFORM int32 = 110
    IPAR_READ_DEBUG int32 = 111
    IPAR_READ_KEEP_FREE_CON int32 = 112
    IPAR_READ_LP_DROP_NEW_VARS_IN_BOU int32 = 113
    IPAR_READ_LP_QUOTED_NAMES int32 = 114
    IPAR_READ_MPS_FORMAT int32 = 115
    IPAR_READ_MPS_WIDTH int32 = 116
    IPAR_READ_TASK_IGNORE_PARAM int32 = 117
    IPAR_REMOVE_UNUSED_SOLUTIONS int32 = 118
    IPAR_SENSITIVITY_ALL int32 = 119
    IPAR_SENSITIVITY_OPTIMIZER int32 = 120
    IPAR_SENSITIVITY_TYPE int32 = 121
    IPAR_SIM_BASIS_FACTOR_USE int32 = 122
    IPAR_SIM_DEGEN int32 = 123
    IPAR_SIM_DUAL_CRASH int32 = 124
    IPAR_SIM_DUAL_PHASEONE_METHOD int32 = 125
    IPAR_SIM_DUAL_RESTRICT_SELECTION int32 = 126
    IPAR_SIM_DUAL_SELECTION int32 = 127
    IPAR_SIM_EXPLOIT_DUPVEC int32 = 128
    IPAR_SIM_HOTSTART int32 = 129
    IPAR_SIM_HOTSTART_LU int32 = 130
    IPAR_SIM_MAX_ITERATIONS int32 = 131
    IPAR_SIM_MAX_NUM_SETBACKS int32 = 132
    IPAR_SIM_NON_SINGULAR int32 = 133
    IPAR_SIM_PRIMAL_CRASH int32 = 134
    IPAR_SIM_PRIMAL_PHASEONE_METHOD int32 = 135
    IPAR_SIM_PRIMAL_RESTRICT_SELECTION int32 = 136
    IPAR_SIM_PRIMAL_SELECTION int32 = 137
    IPAR_SIM_REFACTOR_FREQ int32 = 138
    IPAR_SIM_REFORMULATION int32 = 139
    IPAR_SIM_SAVE_LU int32 = 140
    IPAR_SIM_SCALING int32 = 141
    IPAR_SIM_SCALING_METHOD int32 = 142
    IPAR_SIM_SEED int32 = 143
    IPAR_SIM_SOLVE_FORM int32 = 144
    IPAR_SIM_STABILITY_PRIORITY int32 = 145
    IPAR_SIM_SWITCH_OPTIMIZER int32 = 146
    IPAR_SOL_FILTER_KEEP_BASIC int32 = 147
    IPAR_SOL_FILTER_KEEP_RANGED int32 = 148
    IPAR_SOL_READ_NAME_WIDTH int32 = 149
    IPAR_SOL_READ_WIDTH int32 = 150
    IPAR_SOLUTION_CALLBACK int32 = 151
    IPAR_TIMING_LEVEL int32 = 152
    IPAR_WRITE_BAS_CONSTRAINTS int32 = 153
    IPAR_WRITE_BAS_HEAD int32 = 154
    IPAR_WRITE_BAS_VARIABLES int32 = 155
    IPAR_WRITE_COMPRESSION int32 = 156
    IPAR_WRITE_DATA_PARAM int32 = 157
    IPAR_WRITE_FREE_CON int32 = 158
    IPAR_WRITE_GENERIC_NAMES int32 = 159
    IPAR_WRITE_GENERIC_NAMES_IO int32 = 160
    IPAR_WRITE_IGNORE_INCOMPATIBLE_ITEMS int32 = 161
    IPAR_WRITE_INT_CONSTRAINTS int32 = 162
    IPAR_WRITE_INT_HEAD int32 = 163
    IPAR_WRITE_INT_VARIABLES int32 = 164
    IPAR_WRITE_LP_FULL_OBJ int32 = 165
    IPAR_WRITE_LP_LINE_WIDTH int32 = 166
    IPAR_WRITE_LP_QUOTED_NAMES int32 = 167
    IPAR_WRITE_LP_STRICT_FORMAT int32 = 168
    IPAR_WRITE_LP_TERMS_PER_LINE int32 = 169
    IPAR_WRITE_MPS_FORMAT int32 = 170
    IPAR_WRITE_MPS_INT int32 = 171
    IPAR_WRITE_PRECISION int32 = 172
    IPAR_WRITE_SOL_BARVARIABLES int32 = 173
    IPAR_WRITE_SOL_CONSTRAINTS int32 = 174
    IPAR_WRITE_SOL_HEAD int32 = 175
    IPAR_WRITE_SOL_IGNORE_INVALID_NAMES int32 = 176
    IPAR_WRITE_SOL_VARIABLES int32 = 177
    IPAR_WRITE_TASK_INC_SOL int32 = 178
    IPAR_WRITE_XML_MODE int32 = 179
    IPAR_BEGIN int32 = 0
    IPAR_END   int32 = 180
)
const ( // enum dparam
    DPAR_ANA_SOL_INFEAS_TOL int32 = 0
    DPAR_BASIS_REL_TOL_S int32 = 1
    DPAR_BASIS_TOL_S int32 = 2
    DPAR_BASIS_TOL_X int32 = 3
    DPAR_CHECK_CONVEXITY_REL_TOL int32 = 4
    DPAR_DATA_SYM_MAT_TOL int32 = 5
    DPAR_DATA_SYM_MAT_TOL_HUGE int32 = 6
    DPAR_DATA_SYM_MAT_TOL_LARGE int32 = 7
    DPAR_DATA_TOL_AIJ_HUGE int32 = 8
    DPAR_DATA_TOL_AIJ_LARGE int32 = 9
    DPAR_DATA_TOL_BOUND_INF int32 = 10
    DPAR_DATA_TOL_BOUND_WRN int32 = 11
    DPAR_DATA_TOL_C_HUGE int32 = 12
    DPAR_DATA_TOL_CJ_LARGE int32 = 13
    DPAR_DATA_TOL_QIJ int32 = 14
    DPAR_DATA_TOL_X int32 = 15
    DPAR_INTPNT_CO_TOL_DFEAS int32 = 16
    DPAR_INTPNT_CO_TOL_INFEAS int32 = 17
    DPAR_INTPNT_CO_TOL_MU_RED int32 = 18
    DPAR_INTPNT_CO_TOL_NEAR_REL int32 = 19
    DPAR_INTPNT_CO_TOL_PFEAS int32 = 20
    DPAR_INTPNT_CO_TOL_REL_GAP int32 = 21
    DPAR_INTPNT_QO_TOL_DFEAS int32 = 22
    DPAR_INTPNT_QO_TOL_INFEAS int32 = 23
    DPAR_INTPNT_QO_TOL_MU_RED int32 = 24
    DPAR_INTPNT_QO_TOL_NEAR_REL int32 = 25
    DPAR_INTPNT_QO_TOL_PFEAS int32 = 26
    DPAR_INTPNT_QO_TOL_REL_GAP int32 = 27
    DPAR_INTPNT_TOL_DFEAS int32 = 28
    DPAR_INTPNT_TOL_DSAFE int32 = 29
    DPAR_INTPNT_TOL_INFEAS int32 = 30
    DPAR_INTPNT_TOL_MU_RED int32 = 31
    DPAR_INTPNT_TOL_PATH int32 = 32
    DPAR_INTPNT_TOL_PFEAS int32 = 33
    DPAR_INTPNT_TOL_PSAFE int32 = 34
    DPAR_INTPNT_TOL_REL_GAP int32 = 35
    DPAR_INTPNT_TOL_REL_STEP int32 = 36
    DPAR_INTPNT_TOL_STEP_SIZE int32 = 37
    DPAR_LOWER_OBJ_CUT int32 = 38
    DPAR_LOWER_OBJ_CUT_FINITE_TRH int32 = 39
    DPAR_MIO_MAX_TIME int32 = 40
    DPAR_MIO_REL_GAP_CONST int32 = 41
    DPAR_MIO_TOL_ABS_GAP int32 = 42
    DPAR_MIO_TOL_ABS_RELAX_INT int32 = 43
    DPAR_MIO_TOL_FEAS int32 = 44
    DPAR_MIO_TOL_REL_DUAL_BOUND_IMPROVEMENT int32 = 45
    DPAR_MIO_TOL_REL_GAP int32 = 46
    DPAR_OPTIMIZER_MAX_TIME int32 = 47
    DPAR_PRESOLVE_TOL_ABS_LINDEP int32 = 48
    DPAR_PRESOLVE_TOL_AIJ int32 = 49
    DPAR_PRESOLVE_TOL_REL_LINDEP int32 = 50
    DPAR_PRESOLVE_TOL_S int32 = 51
    DPAR_PRESOLVE_TOL_X int32 = 52
    DPAR_QCQO_REFORMULATE_REL_DROP_TOL int32 = 53
    DPAR_SEMIDEFINITE_TOL_APPROX int32 = 54
    DPAR_SIM_LU_TOL_REL_PIV int32 = 55
    DPAR_SIMPLEX_ABS_TOL_PIV int32 = 56
    DPAR_UPPER_OBJ_CUT int32 = 57
    DPAR_UPPER_OBJ_CUT_FINITE_TRH int32 = 58
    DPAR_BEGIN int32 = 0
    DPAR_END   int32 = 59
)
const ( // enum simdupvec
    SIM_EXPLOIT_DUPVEC_FREE int32 = 2
    SIM_EXPLOIT_DUPVEC_OFF int32 = 0
    SIM_EXPLOIT_DUPVEC_ON int32 = 1
    SIM_EXPLOIT_DUPVEC_BEGIN int32 = 0
    SIM_EXPLOIT_DUPVEC_END   int32 = 3
)
const ( // enum intpnthotstart
    INTPNT_HOTSTART_DUAL int32 = 2
    INTPNT_HOTSTART_NONE int32 = 0
    INTPNT_HOTSTART_PRIMAL int32 = 1
    INTPNT_HOTSTART_PRIMAL_DUAL int32 = 3
    INTPNT_HOTSTART_BEGIN int32 = 0
    INTPNT_HOTSTART_END   int32 = 4
)
const ( // enum xmlwriteroutputtype
    WRITE_XML_MODE_COL int32 = 1
    WRITE_XML_MODE_ROW int32 = 0
    WRITE_XML_MODE_BEGIN int32 = 0
    WRITE_XML_MODE_END   int32 = 2
)
const ( // enum mpsformat
    MPS_FORMAT_CPLEX int32 = 3
    MPS_FORMAT_FREE int32 = 2
    MPS_FORMAT_RELAXED int32 = 1
    MPS_FORMAT_STRICT int32 = 0
    MPS_FORMAT_BEGIN int32 = 0
    MPS_FORMAT_END   int32 = 4
)
const ( // enum soltype
    SOL_BAS int32 = 1
    SOL_ITG int32 = 2
    SOL_ITR int32 = 0
    SOL_BEGIN int32 = 0
    SOL_END   int32 = 3
)
func (task *Task) AnalyzeNames(whichstream_ int32,nametype_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_analyzenames(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKnametypee(nametype_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AnalyzeProblem(whichstream_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_analyzeproblem(task.ptr(),C.MSKstreamtypee(whichstream_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AnalyzeSolution(whichstream_ int32,whichsol_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_analyzesolution(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKsoltypee(whichsol_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendBarvars(dim_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(dim_) })
    _c_num_ := C.MSKint32t(num_)
    if dim_ == nil { panic("Argument 'dim_' is nil in call to 'AppendBarvars'") }
    var _c_dim_ *C.MSKint32t = nil
    if len(dim_) > 0 { _c_dim_ = (*C.MSKint32t)(&dim_[0]) }
    task.r = int32(C.MSK_appendbarvars(task.ptr(),_c_num_,_c_dim_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendCone(ct_ int32,conepar_ float64,submem_ []int32) () {
  if task.r == RES_OK {
    _c_conepar_ := C.MSKrealt(conepar_)
    nummem_ := minint([]int{ len(submem_) })
    _c_nummem_ := C.MSKint32t(nummem_)
    if submem_ == nil { panic("Argument 'submem_' is nil in call to 'AppendCone'") }
    var _c_submem_ *C.MSKint32t = nil
    if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
    task.r = int32(C.MSK_appendcone(task.ptr(),C.MSKconetypee(ct_),_c_conepar_,_c_nummem_,_c_submem_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendConeSeq(ct_ int32,conepar_ float64,nummem_ int32,j_ int32) () {
  if task.r == RES_OK {
    _c_conepar_ := C.MSKrealt(conepar_)
    _c_nummem_ := C.MSKint32t(nummem_)
    _c_j_ := C.MSKint32t(j_)
    task.r = int32(C.MSK_appendconeseq(task.ptr(),C.MSKconetypee(ct_),_c_conepar_,_c_nummem_,_c_j_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendConesSeq(ct_ []int32,conepar_ []float64,nummem_ []int32,j_ int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(ct_),len(conepar_),len(nummem_) })
    _c_num_ := C.MSKint32t(num_)
    if ct_ == nil { panic("Argument 'ct_' is nil in call to 'AppendConesSeq'") }
    var _c_ct_ *C.MSKconetypee = nil
    if len(ct_) > 0 { _c_ct_ = (*C.MSKconetypee)(unsafe.Pointer(&ct_[0])) }
    if conepar_ == nil { panic("Argument 'conepar_' is nil in call to 'AppendConesSeq'") }
    var _c_conepar_ *C.MSKrealt = nil
    if len(conepar_) > 0 { _c_conepar_ = (*C.MSKrealt)(&conepar_[0]) }
    if nummem_ == nil { panic("Argument 'nummem_' is nil in call to 'AppendConesSeq'") }
    var _c_nummem_ *C.MSKint32t = nil
    if len(nummem_) > 0 { _c_nummem_ = (*C.MSKint32t)(&nummem_[0]) }
    _c_j_ := C.MSKint32t(j_)
    task.r = int32(C.MSK_appendconesseq(task.ptr(),_c_num_,_c_ct_,_c_conepar_,_c_nummem_,_c_j_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendCons(num_ int32) () {
  if task.r == RES_OK {
    _c_num_ := C.MSKint32t(num_)
    task.r = int32(C.MSK_appendcons(task.ptr(),_c_num_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) AppendSparseSymMat(dim_ int32,subi_ []int32,subj_ []int32,valij_ []float64) (_r_idx_ int64) {
  if task.r == RES_OK {
    _c_dim_ := C.MSKint32t(dim_)
    nz_ := minint([]int{ len(subi_),len(subj_),len(valij_) })
    _c_nz_ := C.MSKint64t(nz_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'AppendSparseSymMat'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'AppendSparseSymMat'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if valij_ == nil { panic("Argument 'valij_' is nil in call to 'AppendSparseSymMat'") }
    var _c_valij_ *C.MSKrealt = nil
    if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
    var _c_idx_ C.MSKint64t
    task.r = int32(C.MSK_appendsparsesymmat(task.ptr(),_c_dim_,_c_nz_,_c_subi_,_c_subj_,_c_valij_,&_c_idx_))
    if task.r != 0 { return }
    _r_idx_ = int64(_c_idx_)
  }
  return
}
func (task *Task) AppendSparseSymMatList(dims_ []int32,nz_ []int64,subi_ []int32,subj_ []int32,valij_ []float64,idx_ []int64) (_r_idx_ []int64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(dims_),len(nz_) })
    _c_num_ := C.MSKint32t(num_)
    if dims_ == nil { panic("Argument 'dims_' is nil in call to 'AppendSparseSymMatList'") }
    var _c_dims_ *C.MSKint32t = nil
    if len(dims_) > 0 { _c_dims_ = (*C.MSKint32t)(&dims_[0]) }
    if nz_ == nil { panic("Argument 'nz_' is nil in call to 'AppendSparseSymMatList'") }
    var _c_nz_ *C.MSKint64t = nil
    if len(nz_) > 0 { _c_nz_ = (*C.MSKint64t)(&nz_[0]) }
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'AppendSparseSymMatList'") }
    var __tmp_var_0 int64 = 0
    for __tmp_var_2 := 0; __tmp_var_2 < len(nz_); __tmp_var_2 += 1 {
      __tmp_var_0 += nz_[__tmp_var_2]
    }
    if len(subi_) < int(__tmp_var_0) { panic("Slice argument 'subi_' is too short in call to 'AppendSparseSymMatList'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'AppendSparseSymMatList'") }
    var __tmp_var_3 int64 = 0
    for __tmp_var_5 := 0; __tmp_var_5 < len(nz_); __tmp_var_5 += 1 {
      __tmp_var_3 += nz_[__tmp_var_5]
    }
    if len(subj_) < int(__tmp_var_3) { panic("Slice argument 'subj_' is too short in call to 'AppendSparseSymMatList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if valij_ == nil { panic("Argument 'valij_' is nil in call to 'AppendSparseSymMatList'") }
    var __tmp_var_6 int64 = 0
    for __tmp_var_8 := 0; __tmp_var_8 < len(nz_); __tmp_var_8 += 1 {
      __tmp_var_6 += nz_[__tmp_var_8]
    }
    if len(valij_) < int(__tmp_var_6) { panic("Slice argument 'valij_' is too short in call to 'AppendSparseSymMatList'") }
    var _c_valij_ *C.MSKrealt = nil
    if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
    if idx_ == nil { idx_ = make([]int64,num_,num_)
    } else if len(idx_) < int(num_) { panic("Slice in 'idx_' is too short in call to 'AppendSparseSymMatList'") }
    var _c_idx_ *C.MSKint64t = nil
    if len(idx_) > 0 { _c_idx_ = (*C.MSKint64t)(&idx_[0]) }
    task.r = int32(C.MSK_appendsparsesymmatlist(task.ptr(),_c_num_,_c_dims_,_c_nz_,_c_subi_,_c_subj_,_c_valij_,_c_idx_))
    if task.r != 0 { return }
    _r_idx_ = idx_
  }
  return
}
func (task *Task) AppendVars(num_ int32) () {
  if task.r == RES_OK {
    _c_num_ := C.MSKint32t(num_)
    task.r = int32(C.MSK_appendvars(task.ptr(),_c_num_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) BasisCond() (_r_nrmbasis_ float64,_r_nrminvbasis_ float64) {
  if task.r == RES_OK {
    var _c_nrmbasis_ C.MSKrealt
    var _c_nrminvbasis_ C.MSKrealt
    task.r = int32(C.MSK_basiscond(task.ptr(),&_c_nrmbasis_,&_c_nrminvbasis_))
    if task.r != 0 { return }
    _r_nrmbasis_ = float64(_c_nrmbasis_)
    _r_nrminvbasis_ = float64(_c_nrminvbasis_)
  }
  return
}
func (task *Task) CheckMem(file_ string,line_ int32) () {
  if task.r == RES_OK {
    _c_file_ := C.CString(file_)
    defer C.free(unsafe.Pointer(_c_file_))
    _c_line_ := C.MSKint32t(line_)
    task.r = int32(C.MSK_checkmemtask(task.ptr(),C.MSKstring_t(_c_file_),_c_line_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ChgConBound(i_ int32,lower_ int32,finite_ int32,value_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_lower_ := C.MSKint32t(lower_)
    _c_finite_ := C.MSKint32t(finite_)
    _c_value_ := C.MSKrealt(value_)
    task.r = int32(C.MSK_chgconbound(task.ptr(),_c_i_,_c_lower_,_c_finite_,_c_value_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ChgVarBound(j_ int32,lower_ int32,finite_ int32,value_ float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_lower_ := C.MSKint32t(lower_)
    _c_finite_ := C.MSKint32t(finite_)
    _c_value_ := C.MSKrealt(value_)
    task.r = int32(C.MSK_chgvarbound(task.ptr(),_c_j_,_c_lower_,_c_finite_,_c_value_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) CommitChanges() () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_commitchanges(task.ptr()))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) DeleteSolution(whichsol_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_deletesolution(task.ptr(),C.MSKsoltypee(whichsol_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) DualSensitivity(subj_ []int32,leftpricej_ []float64,rightpricej_ []float64,leftrangej_ []float64,rightrangej_ []float64) (_r_leftpricej_ []float64,_r_rightpricej_ []float64,_r_leftrangej_ []float64,_r_rightrangej_ []float64) {
  if task.r == RES_OK {
    numj_ := minint([]int{ len(subj_) })
    _c_numj_ := C.MSKint32t(numj_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'DualSensitivity'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if leftpricej_ == nil { leftpricej_ = make([]float64,numj_,numj_)
    } else if len(leftpricej_) < int(numj_) { panic("Slice in 'leftpricej_' is too short in call to 'DualSensitivity'") }
    var _c_leftpricej_ *C.MSKrealt = nil
    if len(leftpricej_) > 0 { _c_leftpricej_ = (*C.MSKrealt)(&leftpricej_[0]) }
    if rightpricej_ == nil { rightpricej_ = make([]float64,numj_,numj_)
    } else if len(rightpricej_) < int(numj_) { panic("Slice in 'rightpricej_' is too short in call to 'DualSensitivity'") }
    var _c_rightpricej_ *C.MSKrealt = nil
    if len(rightpricej_) > 0 { _c_rightpricej_ = (*C.MSKrealt)(&rightpricej_[0]) }
    if leftrangej_ == nil { leftrangej_ = make([]float64,numj_,numj_)
    } else if len(leftrangej_) < int(numj_) { panic("Slice in 'leftrangej_' is too short in call to 'DualSensitivity'") }
    var _c_leftrangej_ *C.MSKrealt = nil
    if len(leftrangej_) > 0 { _c_leftrangej_ = (*C.MSKrealt)(&leftrangej_[0]) }
    if rightrangej_ == nil { rightrangej_ = make([]float64,numj_,numj_)
    } else if len(rightrangej_) < int(numj_) { panic("Slice in 'rightrangej_' is too short in call to 'DualSensitivity'") }
    var _c_rightrangej_ *C.MSKrealt = nil
    if len(rightrangej_) > 0 { _c_rightrangej_ = (*C.MSKrealt)(&rightrangej_[0]) }
    task.r = int32(C.MSK_dualsensitivity(task.ptr(),_c_numj_,_c_subj_,_c_leftpricej_,_c_rightpricej_,_c_leftrangej_,_c_rightrangej_))
    if task.r != 0 { return }
    _r_leftpricej_ = leftpricej_
    _r_rightpricej_ = rightpricej_
    _r_leftrangej_ = leftrangej_
    _r_rightrangej_ = rightrangej_
  }
  return
}
func (task *Task) GenerateConeNames(subk_ []int32,fmt_ string,dims_ []int32,sp_ []int64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subk_) })
    _c_num_ := C.MSKint32t(num_)
    if subk_ == nil { panic("Argument 'subk_' is nil in call to 'GenerateConeNames'") }
    var _c_subk_ *C.MSKint32t = nil
    if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
    _c_fmt_ := C.CString(fmt_)
    defer C.free(unsafe.Pointer(_c_fmt_))
    ndims_ := minint([]int{ len(dims_) })
    _c_ndims_ := C.MSKint32t(ndims_)
    if dims_ == nil { panic("Argument 'dims_' is nil in call to 'GenerateConeNames'") }
    var _c_dims_ *C.MSKint32t = nil
    if len(dims_) > 0 { _c_dims_ = (*C.MSKint32t)(&dims_[0]) }
    if sp_ == nil { panic("Argument 'sp_' is nil in call to 'GenerateConeNames'") }
    if len(sp_) < int(num_) { panic("Slice argument 'sp_' is too short in call to 'GenerateConeNames'") }
    var _c_sp_ *C.MSKint64t = nil
    if len(sp_) > 0 { _c_sp_ = (*C.MSKint64t)(&sp_[0]) }
    task.r = int32(C.MSK_generateconenames(task.ptr(),_c_num_,_c_subk_,C.MSKstring_t(_c_fmt_),_c_ndims_,_c_dims_,_c_sp_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) GenerateConNames(subi_ []int32,fmt_ string,dims_ []int32,sp_ []int64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subi_) })
    _c_num_ := C.MSKint32t(num_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'GenerateConNames'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    _c_fmt_ := C.CString(fmt_)
    defer C.free(unsafe.Pointer(_c_fmt_))
    ndims_ := minint([]int{ len(dims_) })
    _c_ndims_ := C.MSKint32t(ndims_)
    if dims_ == nil { panic("Argument 'dims_' is nil in call to 'GenerateConNames'") }
    var _c_dims_ *C.MSKint32t = nil
    if len(dims_) > 0 { _c_dims_ = (*C.MSKint32t)(&dims_[0]) }
    if sp_ == nil { panic("Argument 'sp_' is nil in call to 'GenerateConNames'") }
    if len(sp_) < int(num_) { panic("Slice argument 'sp_' is too short in call to 'GenerateConNames'") }
    var _c_sp_ *C.MSKint64t = nil
    if len(sp_) > 0 { _c_sp_ = (*C.MSKint64t)(&sp_[0]) }
    task.r = int32(C.MSK_generateconnames(task.ptr(),_c_num_,_c_subi_,C.MSKstring_t(_c_fmt_),_c_ndims_,_c_dims_,_c_sp_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) GenerateVarNames(subj_ []int32,fmt_ string,dims_ []int32,sp_ []int64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subj_) })
    _c_num_ := C.MSKint32t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'GenerateVarNames'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    _c_fmt_ := C.CString(fmt_)
    defer C.free(unsafe.Pointer(_c_fmt_))
    ndims_ := minint([]int{ len(dims_) })
    _c_ndims_ := C.MSKint32t(ndims_)
    if dims_ == nil { panic("Argument 'dims_' is nil in call to 'GenerateVarNames'") }
    var _c_dims_ *C.MSKint32t = nil
    if len(dims_) > 0 { _c_dims_ = (*C.MSKint32t)(&dims_[0]) }
    if sp_ == nil { panic("Argument 'sp_' is nil in call to 'GenerateVarNames'") }
    if len(sp_) < int(num_) { panic("Slice argument 'sp_' is too short in call to 'GenerateVarNames'") }
    var _c_sp_ *C.MSKint64t = nil
    if len(sp_) > 0 { _c_sp_ = (*C.MSKint64t)(&sp_[0]) }
    task.r = int32(C.MSK_generatevarnames(task.ptr(),_c_num_,_c_subj_,C.MSKstring_t(_c_fmt_),_c_ndims_,_c_dims_,_c_sp_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) GetACol(j_ int32,subj_ []int32,valj_ []float64) (_r_nzj_ int32,_r_subj_ []int32,_r_valj_ []float64) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var _c_nzj_ C.MSKint32t
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetAColNumNz(j_)
    if task.r != RES_OK { return }
    if subj_ == nil { subj_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(subj_) < int(__tmp_var_1) { panic("Slice in 'subj_' is too short in call to 'GetACol'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    var __tmp_var_4 int32
    __tmp_var_4 = task.GetAColNumNz(j_)
    if task.r != RES_OK { return }
    if valj_ == nil { valj_ = make([]float64,__tmp_var_4,__tmp_var_4)
    } else if len(valj_) < int(__tmp_var_4) { panic("Slice in 'valj_' is too short in call to 'GetACol'") }
    var _c_valj_ *C.MSKrealt = nil
    if len(valj_) > 0 { _c_valj_ = (*C.MSKrealt)(&valj_[0]) }
    task.r = int32(C.MSK_getacol(task.ptr(),_c_j_,&_c_nzj_,_c_subj_,_c_valj_))
    if task.r != 0 { return }
    _r_nzj_ = int32(_c_nzj_)
    _r_subj_ = subj_
    _r_valj_ = valj_
  }
  return
}
func (task *Task) GetAColNumNz(i_ int32) (_r_nzj_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_nzj_ C.MSKint32t
    task.r = int32(C.MSK_getacolnumnz(task.ptr(),_c_i_,&_c_nzj_))
    if task.r != 0 { return }
    _r_nzj_ = int32(_c_nzj_)
  }
  return
}
func (task *Task) GetAColSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,sub_ []int32,val_ []float64) (_r_ptrb_ []int64,_r_ptre_ []int64,_r_sub_ []int32,_r_val_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetAColSliceNumNz(first_,last_)
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_surp_ C.MSKint64t = C.MSKint64t(len(sub_))
    if ptrb_ == nil { ptrb_ = make([]int64,last_ - first_,last_ - first_)
    } else if len(ptrb_) < int(last_ - first_) { panic("Slice in 'ptrb_' is too short in call to 'GetAColSlice'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { ptre_ = make([]int64,last_ - first_,last_ - first_)
    } else if len(ptre_) < int(last_ - first_) { panic("Slice in 'ptre_' is too short in call to 'GetAColSlice'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if sub_ == nil { sub_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(sub_) < int(maxnumnz_) { panic("Slice in 'sub_' is too short in call to 'GetAColSlice'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if val_ == nil { val_ = make([]float64,maxnumnz_,maxnumnz_)
    } else if len(val_) < int(maxnumnz_) { panic("Slice in 'val_' is too short in call to 'GetAColSlice'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_getacolslice64(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_ptrb_,_c_ptre_,_c_sub_,_c_val_))
    if task.r != 0 { return }
    _r_ptrb_ = ptrb_
    _r_ptre_ = ptre_
    _r_sub_ = sub_
    _r_val_ = val_
  }
  return
}
func (task *Task) GetAColSliceNumNz(first_ int32,last_ int32) (_r_numnz_ int64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var _c_numnz_ C.MSKint64t
    task.r = int32(C.MSK_getacolslicenumnz64(task.ptr(),_c_first_,_c_last_,&_c_numnz_))
    if task.r != 0 { return }
    _r_numnz_ = int64(_c_numnz_)
  }
  return
}
func (task *Task) GetAColSliceTrip(first_ int32,last_ int32,subi_ []int32,subj_ []int32,val_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_val_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetAColSliceNumNz(first_,last_)
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_surp_ C.MSKint64t = C.MSKint64t(len(subi_))
    if subi_ == nil { subi_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(subi_) < int(maxnumnz_) { panic("Slice in 'subi_' is too short in call to 'GetAColSliceTrip'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { subj_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(subj_) < int(maxnumnz_) { panic("Slice in 'subj_' is too short in call to 'GetAColSliceTrip'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if val_ == nil { val_ = make([]float64,maxnumnz_,maxnumnz_)
    } else if len(val_) < int(maxnumnz_) { panic("Slice in 'val_' is too short in call to 'GetAColSliceTrip'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_getacolslicetrip(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_subi_,_c_subj_,_c_val_))
    if task.r != 0 { return }
    _r_subi_ = subi_
    _r_subj_ = subj_
    _r_val_ = val_
  }
  return
}
func (task *Task) GetAij(i_ int32,j_ int32) (_r_aij_ float64) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_j_ := C.MSKint32t(j_)
    var _c_aij_ C.MSKrealt
    task.r = int32(C.MSK_getaij(task.ptr(),_c_i_,_c_j_,&_c_aij_))
    if task.r != 0 { return }
    _r_aij_ = float64(_c_aij_)
  }
  return
}
func (task *Task) GetAPieceNumNz(firsti_ int32,lasti_ int32,firstj_ int32,lastj_ int32) (_r_numnz_ int32) {
  if task.r == RES_OK {
    _c_firsti_ := C.MSKint32t(firsti_)
    _c_lasti_ := C.MSKint32t(lasti_)
    _c_firstj_ := C.MSKint32t(firstj_)
    _c_lastj_ := C.MSKint32t(lastj_)
    var _c_numnz_ C.MSKint32t
    task.r = int32(C.MSK_getapiecenumnz(task.ptr(),_c_firsti_,_c_lasti_,_c_firstj_,_c_lastj_,&_c_numnz_))
    if task.r != 0 { return }
    _r_numnz_ = int32(_c_numnz_)
  }
  return
}
func (task *Task) GetARow(i_ int32,subi_ []int32,vali_ []float64) (_r_nzi_ int32,_r_subi_ []int32,_r_vali_ []float64) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_nzi_ C.MSKint32t
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetARowNumNz(i_)
    if task.r != RES_OK { return }
    if subi_ == nil { subi_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(subi_) < int(__tmp_var_1) { panic("Slice in 'subi_' is too short in call to 'GetARow'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    var __tmp_var_4 int32
    __tmp_var_4 = task.GetARowNumNz(i_)
    if task.r != RES_OK { return }
    if vali_ == nil { vali_ = make([]float64,__tmp_var_4,__tmp_var_4)
    } else if len(vali_) < int(__tmp_var_4) { panic("Slice in 'vali_' is too short in call to 'GetARow'") }
    var _c_vali_ *C.MSKrealt = nil
    if len(vali_) > 0 { _c_vali_ = (*C.MSKrealt)(&vali_[0]) }
    task.r = int32(C.MSK_getarow(task.ptr(),_c_i_,&_c_nzi_,_c_subi_,_c_vali_))
    if task.r != 0 { return }
    _r_nzi_ = int32(_c_nzi_)
    _r_subi_ = subi_
    _r_vali_ = vali_
  }
  return
}
func (task *Task) GetARowNumNz(i_ int32) (_r_nzi_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_nzi_ C.MSKint32t
    task.r = int32(C.MSK_getarownumnz(task.ptr(),_c_i_,&_c_nzi_))
    if task.r != 0 { return }
    _r_nzi_ = int32(_c_nzi_)
  }
  return
}
func (task *Task) GetARowSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,sub_ []int32,val_ []float64) (_r_ptrb_ []int64,_r_ptre_ []int64,_r_sub_ []int32,_r_val_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetARowSliceNumNz(first_,last_)
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_surp_ C.MSKint64t = C.MSKint64t(len(sub_))
    if ptrb_ == nil { ptrb_ = make([]int64,last_ - first_,last_ - first_)
    } else if len(ptrb_) < int(last_ - first_) { panic("Slice in 'ptrb_' is too short in call to 'GetARowSlice'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { ptre_ = make([]int64,last_ - first_,last_ - first_)
    } else if len(ptre_) < int(last_ - first_) { panic("Slice in 'ptre_' is too short in call to 'GetARowSlice'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if sub_ == nil { sub_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(sub_) < int(maxnumnz_) { panic("Slice in 'sub_' is too short in call to 'GetARowSlice'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if val_ == nil { val_ = make([]float64,maxnumnz_,maxnumnz_)
    } else if len(val_) < int(maxnumnz_) { panic("Slice in 'val_' is too short in call to 'GetARowSlice'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_getarowslice64(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_ptrb_,_c_ptre_,_c_sub_,_c_val_))
    if task.r != 0 { return }
    _r_ptrb_ = ptrb_
    _r_ptre_ = ptre_
    _r_sub_ = sub_
    _r_val_ = val_
  }
  return
}
func (task *Task) GetARowSliceNumNz(first_ int32,last_ int32) (_r_numnz_ int64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var _c_numnz_ C.MSKint64t
    task.r = int32(C.MSK_getarowslicenumnz64(task.ptr(),_c_first_,_c_last_,&_c_numnz_))
    if task.r != 0 { return }
    _r_numnz_ = int64(_c_numnz_)
  }
  return
}
func (task *Task) GetARowSliceTrip(first_ int32,last_ int32,subi_ []int32,subj_ []int32,val_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_val_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetARowSliceNumNz(first_,last_)
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_surp_ C.MSKint64t = C.MSKint64t(len(subi_))
    if subi_ == nil { subi_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(subi_) < int(maxnumnz_) { panic("Slice in 'subi_' is too short in call to 'GetARowSliceTrip'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { subj_ = make([]int32,maxnumnz_,maxnumnz_)
    } else if len(subj_) < int(maxnumnz_) { panic("Slice in 'subj_' is too short in call to 'GetARowSliceTrip'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if val_ == nil { val_ = make([]float64,maxnumnz_,maxnumnz_)
    } else if len(val_) < int(maxnumnz_) { panic("Slice in 'val_' is too short in call to 'GetARowSliceTrip'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_getarowslicetrip(task.ptr(),_c_first_,_c_last_,_c_maxnumnz_,&_c_surp_,_c_subi_,_c_subj_,_c_val_))
    if task.r != 0 { return }
    _r_subi_ = subi_
    _r_subj_ = subj_
    _r_val_ = val_
  }
  return
}
func (task *Task) GetATruncateTol(tolzero_ []float64) (_r_tolzero_ []float64) {
  if task.r == RES_OK {
    if tolzero_ == nil { tolzero_ = make([]float64,1,1)
    } else if len(tolzero_) < int(1) { panic("Slice in 'tolzero_' is too short in call to 'GetATruncateTol'") }
    var _c_tolzero_ *C.MSKrealt = nil
    if len(tolzero_) > 0 { _c_tolzero_ = (*C.MSKrealt)(&tolzero_[0]) }
    task.r = int32(C.MSK_getatruncatetol(task.ptr(),_c_tolzero_))
    if task.r != 0 { return }
    _r_tolzero_ = tolzero_
  }
  return
}
func (task *Task) GetBaraBlockTriplet(subi_ []int32,subj_ []int32,subk_ []int32,subl_ []int32,valijkl_ []float64) (_r_num_ int64,_r_subi_ []int32,_r_subj_ []int32,_r_subk_ []int32,_r_subl_ []int32,_r_valijkl_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumBaraBlockTriplets()
    if task.r != RES_OK { return }
    maxnum_ := __tmp_var_1
    _c_maxnum_ := C.MSKint64t(maxnum_)
    var _c_num_ C.MSKint64t
    if subi_ == nil { subi_ = make([]int32,maxnum_,maxnum_)
    } else if len(subi_) < int(maxnum_) { panic("Slice in 'subi_' is too short in call to 'GetBaraBlockTriplet'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { subj_ = make([]int32,maxnum_,maxnum_)
    } else if len(subj_) < int(maxnum_) { panic("Slice in 'subj_' is too short in call to 'GetBaraBlockTriplet'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if subk_ == nil { subk_ = make([]int32,maxnum_,maxnum_)
    } else if len(subk_) < int(maxnum_) { panic("Slice in 'subk_' is too short in call to 'GetBaraBlockTriplet'") }
    var _c_subk_ *C.MSKint32t = nil
    if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
    if subl_ == nil { subl_ = make([]int32,maxnum_,maxnum_)
    } else if len(subl_) < int(maxnum_) { panic("Slice in 'subl_' is too short in call to 'GetBaraBlockTriplet'") }
    var _c_subl_ *C.MSKint32t = nil
    if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
    if valijkl_ == nil { valijkl_ = make([]float64,maxnum_,maxnum_)
    } else if len(valijkl_) < int(maxnum_) { panic("Slice in 'valijkl_' is too short in call to 'GetBaraBlockTriplet'") }
    var _c_valijkl_ *C.MSKrealt = nil
    if len(valijkl_) > 0 { _c_valijkl_ = (*C.MSKrealt)(&valijkl_[0]) }
    task.r = int32(C.MSK_getbarablocktriplet(task.ptr(),_c_maxnum_,&_c_num_,_c_subi_,_c_subj_,_c_subk_,_c_subl_,_c_valijkl_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
    _r_subi_ = subi_
    _r_subj_ = subj_
    _r_subk_ = subk_
    _r_subl_ = subl_
    _r_valijkl_ = valijkl_
  }
  return
}
func (task *Task) GetBaraIdx(idx_ int64,sub_ []int64,weights_ []float64) (_r_i_ int32,_r_j_ int32,_r_num_ int64,_r_sub_ []int64,_r_weights_ []float64) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetBaraIdxInfo(idx_)
    if task.r != RES_OK { return }
    maxnum_ := __tmp_var_1
    _c_maxnum_ := C.MSKint64t(maxnum_)
    var _c_i_ C.MSKint32t
    var _c_j_ C.MSKint32t
    var _c_num_ C.MSKint64t
    if sub_ == nil { sub_ = make([]int64,maxnum_,maxnum_)
    } else if len(sub_) < int(maxnum_) { panic("Slice in 'sub_' is too short in call to 'GetBaraIdx'") }
    var _c_sub_ *C.MSKint64t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
    if weights_ == nil { weights_ = make([]float64,maxnum_,maxnum_)
    } else if len(weights_) < int(maxnum_) { panic("Slice in 'weights_' is too short in call to 'GetBaraIdx'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_getbaraidx(task.ptr(),_c_idx_,_c_maxnum_,&_c_i_,&_c_j_,&_c_num_,_c_sub_,_c_weights_))
    if task.r != 0 { return }
    _r_i_ = int32(_c_i_)
    _r_j_ = int32(_c_j_)
    _r_num_ = int64(_c_num_)
    _r_sub_ = sub_
    _r_weights_ = weights_
  }
  return
}
func (task *Task) GetBaraIdxIJ(idx_ int64) (_r_i_ int32,_r_j_ int32) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var _c_i_ C.MSKint32t
    var _c_j_ C.MSKint32t
    task.r = int32(C.MSK_getbaraidxij(task.ptr(),_c_idx_,&_c_i_,&_c_j_))
    if task.r != 0 { return }
    _r_i_ = int32(_c_i_)
    _r_j_ = int32(_c_j_)
  }
  return
}
func (task *Task) GetBaraIdxInfo(idx_ int64) (_r_num_ int64) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var _c_num_ C.MSKint64t
    task.r = int32(C.MSK_getbaraidxinfo(task.ptr(),_c_idx_,&_c_num_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
  }
  return
}
func (task *Task) GetBaraSparsity(idxij_ []int64) (_r_numnz_ int64,_r_idxij_ []int64) {
  if task.r == RES_OK {
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumBaraNz()
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_numnz_ C.MSKint64t
    if idxij_ == nil { idxij_ = make([]int64,maxnumnz_,maxnumnz_)
    } else if len(idxij_) < int(maxnumnz_) { panic("Slice in 'idxij_' is too short in call to 'GetBaraSparsity'") }
    var _c_idxij_ *C.MSKint64t = nil
    if len(idxij_) > 0 { _c_idxij_ = (*C.MSKint64t)(&idxij_[0]) }
    task.r = int32(C.MSK_getbarasparsity(task.ptr(),_c_maxnumnz_,&_c_numnz_,_c_idxij_))
    if task.r != 0 { return }
    _r_numnz_ = int64(_c_numnz_)
    _r_idxij_ = idxij_
  }
  return
}
func (task *Task) GetBarcBlockTriplet(subj_ []int32,subk_ []int32,subl_ []int32,valjkl_ []float64) (_r_num_ int64,_r_subj_ []int32,_r_subk_ []int32,_r_subl_ []int32,_r_valjkl_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumBarcBlockTriplets()
    if task.r != RES_OK { return }
    maxnum_ := __tmp_var_1
    _c_maxnum_ := C.MSKint64t(maxnum_)
    var _c_num_ C.MSKint64t
    if subj_ == nil { subj_ = make([]int32,maxnum_,maxnum_)
    } else if len(subj_) < int(maxnum_) { panic("Slice in 'subj_' is too short in call to 'GetBarcBlockTriplet'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if subk_ == nil { subk_ = make([]int32,maxnum_,maxnum_)
    } else if len(subk_) < int(maxnum_) { panic("Slice in 'subk_' is too short in call to 'GetBarcBlockTriplet'") }
    var _c_subk_ *C.MSKint32t = nil
    if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
    if subl_ == nil { subl_ = make([]int32,maxnum_,maxnum_)
    } else if len(subl_) < int(maxnum_) { panic("Slice in 'subl_' is too short in call to 'GetBarcBlockTriplet'") }
    var _c_subl_ *C.MSKint32t = nil
    if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
    if valjkl_ == nil { valjkl_ = make([]float64,maxnum_,maxnum_)
    } else if len(valjkl_) < int(maxnum_) { panic("Slice in 'valjkl_' is too short in call to 'GetBarcBlockTriplet'") }
    var _c_valjkl_ *C.MSKrealt = nil
    if len(valjkl_) > 0 { _c_valjkl_ = (*C.MSKrealt)(&valjkl_[0]) }
    task.r = int32(C.MSK_getbarcblocktriplet(task.ptr(),_c_maxnum_,&_c_num_,_c_subj_,_c_subk_,_c_subl_,_c_valjkl_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
    _r_subj_ = subj_
    _r_subk_ = subk_
    _r_subl_ = subl_
    _r_valjkl_ = valjkl_
  }
  return
}
func (task *Task) GetBarcIdx(idx_ int64,sub_ []int64,weights_ []float64) (_r_j_ int32,_r_num_ int64,_r_sub_ []int64,_r_weights_ []float64) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetBarcIdxInfo(idx_)
    if task.r != RES_OK { return }
    maxnum_ := __tmp_var_1
    _c_maxnum_ := C.MSKint64t(maxnum_)
    var _c_j_ C.MSKint32t
    var _c_num_ C.MSKint64t
    if sub_ == nil { sub_ = make([]int64,maxnum_,maxnum_)
    } else if len(sub_) < int(maxnum_) { panic("Slice in 'sub_' is too short in call to 'GetBarcIdx'") }
    var _c_sub_ *C.MSKint64t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
    if weights_ == nil { weights_ = make([]float64,maxnum_,maxnum_)
    } else if len(weights_) < int(maxnum_) { panic("Slice in 'weights_' is too short in call to 'GetBarcIdx'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_getbarcidx(task.ptr(),_c_idx_,_c_maxnum_,&_c_j_,&_c_num_,_c_sub_,_c_weights_))
    if task.r != 0 { return }
    _r_j_ = int32(_c_j_)
    _r_num_ = int64(_c_num_)
    _r_sub_ = sub_
    _r_weights_ = weights_
  }
  return
}
func (task *Task) GetBarcIdxInfo(idx_ int64) (_r_num_ int64) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var _c_num_ C.MSKint64t
    task.r = int32(C.MSK_getbarcidxinfo(task.ptr(),_c_idx_,&_c_num_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
  }
  return
}
func (task *Task) GetBarcIdxJ(idx_ int64) (_r_j_ int32) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var _c_j_ C.MSKint32t
    task.r = int32(C.MSK_getbarcidxj(task.ptr(),_c_idx_,&_c_j_))
    if task.r != 0 { return }
    _r_j_ = int32(_c_j_)
  }
  return
}
func (task *Task) GetBarcSparsity(idxj_ []int64) (_r_numnz_ int64,_r_idxj_ []int64) {
  if task.r == RES_OK {
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumBarcNz()
    if task.r != RES_OK { return }
    maxnumnz_ := __tmp_var_1
    _c_maxnumnz_ := C.MSKint64t(maxnumnz_)
    var _c_numnz_ C.MSKint64t
    if idxj_ == nil { idxj_ = make([]int64,maxnumnz_,maxnumnz_)
    } else if len(idxj_) < int(maxnumnz_) { panic("Slice in 'idxj_' is too short in call to 'GetBarcSparsity'") }
    var _c_idxj_ *C.MSKint64t = nil
    if len(idxj_) > 0 { _c_idxj_ = (*C.MSKint64t)(&idxj_[0]) }
    task.r = int32(C.MSK_getbarcsparsity(task.ptr(),_c_maxnumnz_,&_c_numnz_,_c_idxj_))
    if task.r != 0 { return }
    _r_numnz_ = int64(_c_numnz_)
    _r_idxj_ = idxj_
  }
  return
}
func (task *Task) GetBarsJ(whichsol_ int32,j_ int32,barsj_ []float64) (_r_barsj_ []float64) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetLenBarvarJ(j_)
    if task.r != RES_OK { return }
    if barsj_ == nil { barsj_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(barsj_) < int(__tmp_var_1) { panic("Slice in 'barsj_' is too short in call to 'GetBarsJ'") }
    var _c_barsj_ *C.MSKrealt = nil
    if len(barsj_) > 0 { _c_barsj_ = (*C.MSKrealt)(&barsj_[0]) }
    task.r = int32(C.MSK_getbarsj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barsj_))
    if task.r != 0 { return }
    _r_barsj_ = barsj_
  }
  return
}
func (task *Task) GetBarsSlice(whichsol_ int32,first_ int32,last_ int32,slicesize_ int64,barsslice_ []float64) (_r_barsslice_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    _c_slicesize_ := C.MSKint64t(slicesize_)
    if barsslice_ == nil { barsslice_ = make([]float64,slicesize_,slicesize_)
    } else if len(barsslice_) < int(slicesize_) { panic("Slice in 'barsslice_' is too short in call to 'GetBarsSlice'") }
    var _c_barsslice_ *C.MSKrealt = nil
    if len(barsslice_) > 0 { _c_barsslice_ = (*C.MSKrealt)(&barsslice_[0]) }
    task.r = int32(C.MSK_getbarsslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slicesize_,_c_barsslice_))
    if task.r != 0 { return }
    _r_barsslice_ = barsslice_
  }
  return
}
func (task *Task) GetBarvarName(i_ int32) (_r_name_ string) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetBarvarNameLen(i_)
    if task.r != RES_OK { return }
    sizename_ := 1 + __tmp_var_3
    _c_sizename_ := C.MSKint32t(sizename_)
    _c_name_ := (*C.char)(C.malloc(C.size_t(sizename_+1)))
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_getbarvarname(task.ptr(),_c_i_,_c_sizename_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
    _r_name_ = C.GoStringN(_c_name_,C.int(sizename_))
  }
  return
}
func (task *Task) GetBarvarNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32) {
  if task.r == RES_OK {
    _c_somename_ := C.CString(somename_)
    defer C.free(unsafe.Pointer(_c_somename_))
    var _c_asgn_ C.MSKint32t
    var _c_index_ C.MSKint32t
    task.r = int32(C.MSK_getbarvarnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
    if task.r != 0 { return }
    _r_asgn_ = int32(_c_asgn_)
    _r_index_ = int32(_c_index_)
  }
  return
}
func (task *Task) GetBarvarNameLen(i_ int32) (_r_len_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getbarvarnamelen(task.ptr(),_c_i_,&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetBarxJ(whichsol_ int32,j_ int32,barxj_ []float64) (_r_barxj_ []float64) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetLenBarvarJ(j_)
    if task.r != RES_OK { return }
    if barxj_ == nil { barxj_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(barxj_) < int(__tmp_var_1) { panic("Slice in 'barxj_' is too short in call to 'GetBarxJ'") }
    var _c_barxj_ *C.MSKrealt = nil
    if len(barxj_) > 0 { _c_barxj_ = (*C.MSKrealt)(&barxj_[0]) }
    task.r = int32(C.MSK_getbarxj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barxj_))
    if task.r != 0 { return }
    _r_barxj_ = barxj_
  }
  return
}
func (task *Task) GetBarxSlice(whichsol_ int32,first_ int32,last_ int32,slicesize_ int64,barxslice_ []float64) (_r_barxslice_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    _c_slicesize_ := C.MSKint64t(slicesize_)
    if barxslice_ == nil { barxslice_ = make([]float64,slicesize_,slicesize_)
    } else if len(barxslice_) < int(slicesize_) { panic("Slice in 'barxslice_' is too short in call to 'GetBarxSlice'") }
    var _c_barxslice_ *C.MSKrealt = nil
    if len(barxslice_) > 0 { _c_barxslice_ = (*C.MSKrealt)(&barxslice_[0]) }
    task.r = int32(C.MSK_getbarxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slicesize_,_c_barxslice_))
    if task.r != 0 { return }
    _r_barxslice_ = barxslice_
  }
  return
}
func (task *Task) GetC(c_ []float64) (_r_c_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if c_ == nil { c_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(c_) < int(__tmp_var_1) { panic("Slice in 'c_' is too short in call to 'GetC'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    task.r = int32(C.MSK_getc(task.ptr(),_c_c_))
    if task.r != 0 { return }
    _r_c_ = c_
  }
  return
}
func (task *Task) GetCfix() (_r_cfix_ float64) {
  if task.r == RES_OK {
    var _c_cfix_ C.MSKrealt
    task.r = int32(C.MSK_getcfix(task.ptr(),&_c_cfix_))
    if task.r != 0 { return }
    _r_cfix_ = float64(_c_cfix_)
  }
  return
}
func (task *Task) GetCJ(j_ int32) (_r_cj_ float64) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var _c_cj_ C.MSKrealt
    task.r = int32(C.MSK_getcj(task.ptr(),_c_j_,&_c_cj_))
    if task.r != 0 { return }
    _r_cj_ = float64(_c_cj_)
  }
  return
}
func (task *Task) GetCList(subj_ []int32,c_ []float64) (_r_c_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subj_) })
    _c_num_ := C.MSKint32t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'GetCList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if c_ == nil { c_ = make([]float64,num_,num_)
    } else if len(c_) < int(num_) { panic("Slice in 'c_' is too short in call to 'GetCList'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    task.r = int32(C.MSK_getclist(task.ptr(),_c_num_,_c_subj_,_c_c_))
    if task.r != 0 { return }
    _r_c_ = c_
  }
  return
}
func (task *Task) GetConBound(i_ int32) (_r_bk_ int32,_r_bl_ float64,_r_bu_ float64) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_bk_ C.MSKboundkeye
    var _c_bl_ C.MSKrealt
    var _c_bu_ C.MSKrealt
    task.r = int32(C.MSK_getconbound(task.ptr(),_c_i_,&_c_bk_,&_c_bl_,&_c_bu_))
    if task.r != 0 { return }
    _r_bk_ = int32(_c_bk_)
    _r_bl_ = float64(_c_bl_)
    _r_bu_ = float64(_c_bu_)
  }
  return
}
func (task *Task) GetConBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_r_bk_ []int32,_r_bl_ []float64,_r_bu_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if bk_ == nil { bk_ = make([]int32,last_ - first_,last_ - first_)
    } else if len(bk_) < int(last_ - first_) { panic("Slice in 'bk_' is too short in call to 'GetConBoundSlice'") }
    var _c_bk_ *C.MSKboundkeye = nil
    if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
    if bl_ == nil { bl_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(bl_) < int(last_ - first_) { panic("Slice in 'bl_' is too short in call to 'GetConBoundSlice'") }
    var _c_bl_ *C.MSKrealt = nil
    if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
    if bu_ == nil { bu_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(bu_) < int(last_ - first_) { panic("Slice in 'bu_' is too short in call to 'GetConBoundSlice'") }
    var _c_bu_ *C.MSKrealt = nil
    if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
    task.r = int32(C.MSK_getconboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
    if task.r != 0 { return }
    _r_bk_ = bk_
    _r_bl_ = bl_
    _r_bu_ = bu_
  }
  return
}
func (task *Task) GetCone(k_ int32,submem_ []int32) (_r_ct_ int32,_r_conepar_ float64,_r_nummem_ int32,_r_submem_ []int32) {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    var _c_ct_ C.MSKconetypee
    var _c_conepar_ C.MSKrealt
    var _c_nummem_ C.MSKint32t
    var __tmp_var_1 int32
    _,_,__tmp_var_1 = task.GetConeInfo(k_)
    if task.r != RES_OK { return }
    if submem_ == nil { submem_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(submem_) < int(__tmp_var_1) { panic("Slice in 'submem_' is too short in call to 'GetCone'") }
    var _c_submem_ *C.MSKint32t = nil
    if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
    task.r = int32(C.MSK_getcone(task.ptr(),_c_k_,&_c_ct_,&_c_conepar_,&_c_nummem_,_c_submem_))
    if task.r != 0 { return }
    _r_ct_ = int32(_c_ct_)
    _r_conepar_ = float64(_c_conepar_)
    _r_nummem_ = int32(_c_nummem_)
    _r_submem_ = submem_
  }
  return
}
func (task *Task) GetConeInfo(k_ int32) (_r_ct_ int32,_r_conepar_ float64,_r_nummem_ int32) {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    var _c_ct_ C.MSKconetypee
    var _c_conepar_ C.MSKrealt
    var _c_nummem_ C.MSKint32t
    task.r = int32(C.MSK_getconeinfo(task.ptr(),_c_k_,&_c_ct_,&_c_conepar_,&_c_nummem_))
    if task.r != 0 { return }
    _r_ct_ = int32(_c_ct_)
    _r_conepar_ = float64(_c_conepar_)
    _r_nummem_ = int32(_c_nummem_)
  }
  return
}
func (task *Task) GetConeName(i_ int32) (_r_name_ string) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetConeNameLen(i_)
    if task.r != RES_OK { return }
    sizename_ := 1 + __tmp_var_3
    _c_sizename_ := C.MSKint32t(sizename_)
    _c_name_ := (*C.char)(C.malloc(C.size_t(sizename_+1)))
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_getconename(task.ptr(),_c_i_,_c_sizename_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
    _r_name_ = C.GoStringN(_c_name_,C.int(sizename_))
  }
  return
}
func (task *Task) GetConeNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32) {
  if task.r == RES_OK {
    _c_somename_ := C.CString(somename_)
    defer C.free(unsafe.Pointer(_c_somename_))
    var _c_asgn_ C.MSKint32t
    var _c_index_ C.MSKint32t
    task.r = int32(C.MSK_getconenameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
    if task.r != 0 { return }
    _r_asgn_ = int32(_c_asgn_)
    _r_index_ = int32(_c_index_)
  }
  return
}
func (task *Task) GetConeNameLen(i_ int32) (_r_len_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getconenamelen(task.ptr(),_c_i_,&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetConName(i_ int32) (_r_name_ string) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetConNameLen(i_)
    if task.r != RES_OK { return }
    sizename_ := 1 + __tmp_var_3
    _c_sizename_ := C.MSKint32t(sizename_)
    _c_name_ := (*C.char)(C.malloc(C.size_t(sizename_+1)))
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_getconname(task.ptr(),_c_i_,_c_sizename_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
    _r_name_ = C.GoStringN(_c_name_,C.int(sizename_))
  }
  return
}
func (task *Task) GetConNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32) {
  if task.r == RES_OK {
    _c_somename_ := C.CString(somename_)
    defer C.free(unsafe.Pointer(_c_somename_))
    var _c_asgn_ C.MSKint32t
    var _c_index_ C.MSKint32t
    task.r = int32(C.MSK_getconnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
    if task.r != 0 { return }
    _r_asgn_ = int32(_c_asgn_)
    _r_index_ = int32(_c_index_)
  }
  return
}
func (task *Task) GetConNameLen(i_ int32) (_r_len_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getconnamelen(task.ptr(),_c_i_,&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetCSlice(first_ int32,last_ int32,c_ []float64) (_r_c_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if c_ == nil { c_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(c_) < int(last_ - first_) { panic("Slice in 'c_' is too short in call to 'GetCSlice'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    task.r = int32(C.MSK_getcslice(task.ptr(),_c_first_,_c_last_,_c_c_))
    if task.r != 0 { return }
    _r_c_ = c_
  }
  return
}
func (task *Task) GetDimBarvarJ(j_ int32) (_r_dimbarvarj_ int32) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var _c_dimbarvarj_ C.MSKint32t
    task.r = int32(C.MSK_getdimbarvarj(task.ptr(),_c_j_,&_c_dimbarvarj_))
    if task.r != 0 { return }
    _r_dimbarvarj_ = int32(_c_dimbarvarj_)
  }
  return
}
func (task *Task) GetDouInf(whichdinf_ int32) (_r_dvalue_ float64) {
  if task.r == RES_OK {
    var _c_dvalue_ C.MSKrealt
    task.r = int32(C.MSK_getdouinf(task.ptr(),C.MSKdinfiteme(whichdinf_),&_c_dvalue_))
    if task.r != 0 { return }
    _r_dvalue_ = float64(_c_dvalue_)
  }
  return
}
func (task *Task) GetDouParam(param_ int32) (_r_parvalue_ float64) {
  if task.r == RES_OK {
    var _c_parvalue_ C.MSKrealt
    task.r = int32(C.MSK_getdouparam(task.ptr(),C.MSKdparame(param_),&_c_parvalue_))
    if task.r != 0 { return }
    _r_parvalue_ = float64(_c_parvalue_)
  }
  return
}
func (task *Task) GetDualObj(whichsol_ int32) (_r_dualobj_ float64) {
  if task.r == RES_OK {
    var _c_dualobj_ C.MSKrealt
    task.r = int32(C.MSK_getdualobj(task.ptr(),C.MSKsoltypee(whichsol_),&_c_dualobj_))
    if task.r != 0 { return }
    _r_dualobj_ = float64(_c_dualobj_)
  }
  return
}
func (task *Task) GetDualSolutionNorms(whichsol_ int32) (_r_nrmy_ float64,_r_nrmslc_ float64,_r_nrmsuc_ float64,_r_nrmslx_ float64,_r_nrmsux_ float64,_r_nrmsnx_ float64,_r_nrmbars_ float64) {
  if task.r == RES_OK {
    var _c_nrmy_ C.MSKrealt
    var _c_nrmslc_ C.MSKrealt
    var _c_nrmsuc_ C.MSKrealt
    var _c_nrmslx_ C.MSKrealt
    var _c_nrmsux_ C.MSKrealt
    var _c_nrmsnx_ C.MSKrealt
    var _c_nrmbars_ C.MSKrealt
    task.r = int32(C.MSK_getdualsolutionnorms(task.ptr(),C.MSKsoltypee(whichsol_),&_c_nrmy_,&_c_nrmslc_,&_c_nrmsuc_,&_c_nrmslx_,&_c_nrmsux_,&_c_nrmsnx_,&_c_nrmbars_))
    if task.r != 0 { return }
    _r_nrmy_ = float64(_c_nrmy_)
    _r_nrmslc_ = float64(_c_nrmslc_)
    _r_nrmsuc_ = float64(_c_nrmsuc_)
    _r_nrmslx_ = float64(_c_nrmslx_)
    _r_nrmsux_ = float64(_c_nrmsux_)
    _r_nrmsnx_ = float64(_c_nrmsnx_)
    _r_nrmbars_ = float64(_c_nrmbars_)
  }
  return
}
func (task *Task) GetDviolBarvar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolBarvar'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolBarvar'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getdviolbarvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetDviolCon(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolCon'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolCon'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getdviolcon(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetDviolCones(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolCones'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolCones'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getdviolcones(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetDviolVar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetDviolVar'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetDviolVar'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getdviolvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetInfeasibleSubProblem(whichsol_ int32) (_r_inftask_ Task) {
  if task.r == RES_OK {
    var _c_inftask_ C.MSKtask_t
    task.r = int32(C.MSK_getinfeasiblesubproblem(task.ptr(),C.MSKsoltypee(whichsol_),&_c_inftask_))
    if task.r != 0 { return }
    _r_inftask_.cptr = unsafe.Pointer(_c_inftask_)
  }
  return
}
func (task *Task) GetInfIndex(inftype_ int32,infname_ string) (_r_infindex_ int32) {
  if task.r == RES_OK {
    _c_infname_ := C.CString(infname_)
    defer C.free(unsafe.Pointer(_c_infname_))
    var _c_infindex_ C.MSKint32t
    task.r = int32(C.MSK_getinfindex(task.ptr(),C.MSKinftypee(inftype_),C.MSKstring_t(_c_infname_),&_c_infindex_))
    if task.r != 0 { return }
    _r_infindex_ = int32(_c_infindex_)
  }
  return
}
func (task *Task) GetInfMax(inftype_ int32,infmax_ []int32) (_r_infmax_ []int32) {
  if task.r == RES_OK {
    if infmax_ == nil { infmax_ = make([]int32,MAX_STR_LEN,MAX_STR_LEN)
    } else if len(infmax_) < int(MAX_STR_LEN) { panic("Slice in 'infmax_' is too short in call to 'GetInfMax'") }
    var _c_infmax_ *C.MSKint32t = nil
    if len(infmax_) > 0 { _c_infmax_ = (*C.MSKint32t)(&infmax_[0]) }
    task.r = int32(C.MSK_getinfmax(task.ptr(),C.MSKinftypee(inftype_),_c_infmax_))
    if task.r != 0 { return }
    _r_infmax_ = infmax_
  }
  return
}
func (task *Task) GetInfName(inftype_ int32,whichinf_ int32) (_r_infname_ string) {
  if task.r == RES_OK {
    _c_whichinf_ := C.MSKint32t(whichinf_)
    _c_infname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_infname_))
    task.r = int32(C.MSK_getinfname(task.ptr(),C.MSKinftypee(inftype_),_c_whichinf_,C.MSKstring_t(_c_infname_)))
    if task.r != 0 { return }
    _r_infname_ = C.GoStringN(_c_infname_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) GetIntInf(whichiinf_ int32) (_r_ivalue_ int32) {
  if task.r == RES_OK {
    var _c_ivalue_ C.MSKint32t
    task.r = int32(C.MSK_getintinf(task.ptr(),C.MSKiinfiteme(whichiinf_),&_c_ivalue_))
    if task.r != 0 { return }
    _r_ivalue_ = int32(_c_ivalue_)
  }
  return
}
func (task *Task) GetIntParam(param_ int32) (_r_parvalue_ int32) {
  if task.r == RES_OK {
    var _c_parvalue_ C.MSKint32t
    task.r = int32(C.MSK_getintparam(task.ptr(),C.MSKiparame(param_),&_c_parvalue_))
    if task.r != 0 { return }
    _r_parvalue_ = int32(_c_parvalue_)
  }
  return
}
func (task *Task) GetLenBarvarJ(j_ int32) (_r_lenbarvarj_ int64) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var _c_lenbarvarj_ C.MSKint64t
    task.r = int32(C.MSK_getlenbarvarj(task.ptr(),_c_j_,&_c_lenbarvarj_))
    if task.r != 0 { return }
    _r_lenbarvarj_ = int64(_c_lenbarvarj_)
  }
  return
}
func (task *Task) GetLintInf(whichliinf_ int32) (_r_ivalue_ int64) {
  if task.r == RES_OK {
    var _c_ivalue_ C.MSKint64t
    task.r = int32(C.MSK_getlintinf(task.ptr(),C.MSKliinfiteme(whichliinf_),&_c_ivalue_))
    if task.r != 0 { return }
    _r_ivalue_ = int64(_c_ivalue_)
  }
  return
}
func (task *Task) GetMaxNumANz() (_r_maxnumanz_ int64) {
  if task.r == RES_OK {
    var _c_maxnumanz_ C.MSKint64t
    task.r = int32(C.MSK_getmaxnumanz64(task.ptr(),&_c_maxnumanz_))
    if task.r != 0 { return }
    _r_maxnumanz_ = int64(_c_maxnumanz_)
  }
  return
}
func (task *Task) GetMaxNumBarvar() (_r_maxnumbarvar_ int32) {
  if task.r == RES_OK {
    var _c_maxnumbarvar_ C.MSKint32t
    task.r = int32(C.MSK_getmaxnumbarvar(task.ptr(),&_c_maxnumbarvar_))
    if task.r != 0 { return }
    _r_maxnumbarvar_ = int32(_c_maxnumbarvar_)
  }
  return
}
func (task *Task) GetMaxNumCon() (_r_maxnumcon_ int32) {
  if task.r == RES_OK {
    var _c_maxnumcon_ C.MSKint32t
    task.r = int32(C.MSK_getmaxnumcon(task.ptr(),&_c_maxnumcon_))
    if task.r != 0 { return }
    _r_maxnumcon_ = int32(_c_maxnumcon_)
  }
  return
}
func (task *Task) GetMaxNumCone() (_r_maxnumcone_ int32) {
  if task.r == RES_OK {
    var _c_maxnumcone_ C.MSKint32t
    task.r = int32(C.MSK_getmaxnumcone(task.ptr(),&_c_maxnumcone_))
    if task.r != 0 { return }
    _r_maxnumcone_ = int32(_c_maxnumcone_)
  }
  return
}
func (task *Task) GetMaxNumQNz() (_r_maxnumqnz_ int64) {
  if task.r == RES_OK {
    var _c_maxnumqnz_ C.MSKint64t
    task.r = int32(C.MSK_getmaxnumqnz64(task.ptr(),&_c_maxnumqnz_))
    if task.r != 0 { return }
    _r_maxnumqnz_ = int64(_c_maxnumqnz_)
  }
  return
}
func (task *Task) GetMaxNumVar() (_r_maxnumvar_ int32) {
  if task.r == RES_OK {
    var _c_maxnumvar_ C.MSKint32t
    task.r = int32(C.MSK_getmaxnumvar(task.ptr(),&_c_maxnumvar_))
    if task.r != 0 { return }
    _r_maxnumvar_ = int32(_c_maxnumvar_)
  }
  return
}
func (task *Task) GetMemUsage() (_r_meminuse_ int64,_r_maxmemuse_ int64) {
  if task.r == RES_OK {
    var _c_meminuse_ C.MSKint64t
    var _c_maxmemuse_ C.MSKint64t
    task.r = int32(C.MSK_getmemusagetask(task.ptr(),&_c_meminuse_,&_c_maxmemuse_))
    if task.r != 0 { return }
    _r_meminuse_ = int64(_c_meminuse_)
    _r_maxmemuse_ = int64(_c_maxmemuse_)
  }
  return
}
func (task *Task) GetNumANz() (_r_numanz_ int32) {
  if task.r == RES_OK {
    var _c_numanz_ C.MSKint32t
    task.r = int32(C.MSK_getnumanz(task.ptr(),&_c_numanz_))
    if task.r != 0 { return }
    _r_numanz_ = int32(_c_numanz_)
  }
  return
}
func (task *Task) GetNumANz64() (_r_numanz_ int64) {
  if task.r == RES_OK {
    var _c_numanz_ C.MSKint64t
    task.r = int32(C.MSK_getnumanz64(task.ptr(),&_c_numanz_))
    if task.r != 0 { return }
    _r_numanz_ = int64(_c_numanz_)
  }
  return
}
func (task *Task) GetNumBaraBlockTriplets() (_r_num_ int64) {
  if task.r == RES_OK {
    var _c_num_ C.MSKint64t
    task.r = int32(C.MSK_getnumbarablocktriplets(task.ptr(),&_c_num_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
  }
  return
}
func (task *Task) GetNumBaraNz() (_r_nz_ int64) {
  if task.r == RES_OK {
    var _c_nz_ C.MSKint64t
    task.r = int32(C.MSK_getnumbaranz(task.ptr(),&_c_nz_))
    if task.r != 0 { return }
    _r_nz_ = int64(_c_nz_)
  }
  return
}
func (task *Task) GetNumBarcBlockTriplets() (_r_num_ int64) {
  if task.r == RES_OK {
    var _c_num_ C.MSKint64t
    task.r = int32(C.MSK_getnumbarcblocktriplets(task.ptr(),&_c_num_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
  }
  return
}
func (task *Task) GetNumBarcNz() (_r_nz_ int64) {
  if task.r == RES_OK {
    var _c_nz_ C.MSKint64t
    task.r = int32(C.MSK_getnumbarcnz(task.ptr(),&_c_nz_))
    if task.r != 0 { return }
    _r_nz_ = int64(_c_nz_)
  }
  return
}
func (task *Task) GetNumBarvar() (_r_numbarvar_ int32) {
  if task.r == RES_OK {
    var _c_numbarvar_ C.MSKint32t
    task.r = int32(C.MSK_getnumbarvar(task.ptr(),&_c_numbarvar_))
    if task.r != 0 { return }
    _r_numbarvar_ = int32(_c_numbarvar_)
  }
  return
}
func (task *Task) GetNumCon() (_r_numcon_ int32) {
  if task.r == RES_OK {
    var _c_numcon_ C.MSKint32t
    task.r = int32(C.MSK_getnumcon(task.ptr(),&_c_numcon_))
    if task.r != 0 { return }
    _r_numcon_ = int32(_c_numcon_)
  }
  return
}
func (task *Task) GetNumCone() (_r_numcone_ int32) {
  if task.r == RES_OK {
    var _c_numcone_ C.MSKint32t
    task.r = int32(C.MSK_getnumcone(task.ptr(),&_c_numcone_))
    if task.r != 0 { return }
    _r_numcone_ = int32(_c_numcone_)
  }
  return
}
func (task *Task) GetNumConeMem(k_ int32) (_r_nummem_ int32) {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    var _c_nummem_ C.MSKint32t
    task.r = int32(C.MSK_getnumconemem(task.ptr(),_c_k_,&_c_nummem_))
    if task.r != 0 { return }
    _r_nummem_ = int32(_c_nummem_)
  }
  return
}
func (task *Task) GetNumIntVar() (_r_numintvar_ int32) {
  if task.r == RES_OK {
    var _c_numintvar_ C.MSKint32t
    task.r = int32(C.MSK_getnumintvar(task.ptr(),&_c_numintvar_))
    if task.r != 0 { return }
    _r_numintvar_ = int32(_c_numintvar_)
  }
  return
}
func (task *Task) GetNumParam(partype_ int32) (_r_numparam_ int32) {
  if task.r == RES_OK {
    var _c_numparam_ C.MSKint32t
    task.r = int32(C.MSK_getnumparam(task.ptr(),C.MSKparametertypee(partype_),&_c_numparam_))
    if task.r != 0 { return }
    _r_numparam_ = int32(_c_numparam_)
  }
  return
}
func (task *Task) GetNumQConKNz(k_ int32) (_r_numqcnz_ int64) {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    var _c_numqcnz_ C.MSKint64t
    task.r = int32(C.MSK_getnumqconknz64(task.ptr(),_c_k_,&_c_numqcnz_))
    if task.r != 0 { return }
    _r_numqcnz_ = int64(_c_numqcnz_)
  }
  return
}
func (task *Task) GetNumQObjNz() (_r_numqonz_ int64) {
  if task.r == RES_OK {
    var _c_numqonz_ C.MSKint64t
    task.r = int32(C.MSK_getnumqobjnz64(task.ptr(),&_c_numqonz_))
    if task.r != 0 { return }
    _r_numqonz_ = int64(_c_numqonz_)
  }
  return
}
func (task *Task) GetNumSymMat() (_r_num_ int64) {
  if task.r == RES_OK {
    var _c_num_ C.MSKint64t
    task.r = int32(C.MSK_getnumsymmat(task.ptr(),&_c_num_))
    if task.r != 0 { return }
    _r_num_ = int64(_c_num_)
  }
  return
}
func (task *Task) GetNumVar() (_r_numvar_ int32) {
  if task.r == RES_OK {
    var _c_numvar_ C.MSKint32t
    task.r = int32(C.MSK_getnumvar(task.ptr(),&_c_numvar_))
    if task.r != 0 { return }
    _r_numvar_ = int32(_c_numvar_)
  }
  return
}
func (task *Task) GetObjName() (_r_objname_ string) {
  if task.r == RES_OK {
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetObjNameLen()
    if task.r != RES_OK { return }
    sizeobjname_ := 1 + __tmp_var_3
    _c_sizeobjname_ := C.MSKint32t(sizeobjname_)
    _c_objname_ := (*C.char)(C.malloc(C.size_t(sizeobjname_+1)))
    defer C.free(unsafe.Pointer(_c_objname_))
    task.r = int32(C.MSK_getobjname(task.ptr(),_c_sizeobjname_,C.MSKstring_t(_c_objname_)))
    if task.r != 0 { return }
    _r_objname_ = C.GoStringN(_c_objname_,C.int(sizeobjname_))
  }
  return
}
func (task *Task) GetObjNameLen() (_r_len_ int32) {
  if task.r == RES_OK {
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getobjnamelen(task.ptr(),&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetObjSense() (_r_sense_ int32) {
  if task.r == RES_OK {
    var _c_sense_ C.MSKobjsensee
    task.r = int32(C.MSK_getobjsense(task.ptr(),&_c_sense_))
    if task.r != 0 { return }
    _r_sense_ = int32(_c_sense_)
  }
  return
}
func (task *Task) GetParamMax(partype_ int32) (_r_parammax_ int32) {
  if task.r == RES_OK {
    var _c_parammax_ C.MSKint32t
    task.r = int32(C.MSK_getparammax(task.ptr(),C.MSKparametertypee(partype_),&_c_parammax_))
    if task.r != 0 { return }
    _r_parammax_ = int32(_c_parammax_)
  }
  return
}
func (task *Task) GetParamName(partype_ int32,param_ int32) (_r_parname_ string) {
  if task.r == RES_OK {
    _c_param_ := C.MSKint32t(param_)
    _c_parname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_parname_))
    task.r = int32(C.MSK_getparamname(task.ptr(),C.MSKparametertypee(partype_),_c_param_,C.MSKstring_t(_c_parname_)))
    if task.r != 0 { return }
    _r_parname_ = C.GoStringN(_c_parname_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) GetPrimalObj(whichsol_ int32) (_r_primalobj_ float64) {
  if task.r == RES_OK {
    var _c_primalobj_ C.MSKrealt
    task.r = int32(C.MSK_getprimalobj(task.ptr(),C.MSKsoltypee(whichsol_),&_c_primalobj_))
    if task.r != 0 { return }
    _r_primalobj_ = float64(_c_primalobj_)
  }
  return
}
func (task *Task) GetPrimalSolutionNorms(whichsol_ int32) (_r_nrmxc_ float64,_r_nrmxx_ float64,_r_nrmbarx_ float64) {
  if task.r == RES_OK {
    var _c_nrmxc_ C.MSKrealt
    var _c_nrmxx_ C.MSKrealt
    var _c_nrmbarx_ C.MSKrealt
    task.r = int32(C.MSK_getprimalsolutionnorms(task.ptr(),C.MSKsoltypee(whichsol_),&_c_nrmxc_,&_c_nrmxx_,&_c_nrmbarx_))
    if task.r != 0 { return }
    _r_nrmxc_ = float64(_c_nrmxc_)
    _r_nrmxx_ = float64(_c_nrmxx_)
    _r_nrmbarx_ = float64(_c_nrmbarx_)
  }
  return
}
func (task *Task) GetProbType() (_r_probtype_ int32) {
  if task.r == RES_OK {
    var _c_probtype_ C.MSKproblemtypee
    task.r = int32(C.MSK_getprobtype(task.ptr(),&_c_probtype_))
    if task.r != 0 { return }
    _r_probtype_ = int32(_c_probtype_)
  }
  return
}
func (task *Task) GetProSta(whichsol_ int32) (_r_prosta_ int32) {
  if task.r == RES_OK {
    var _c_prosta_ C.MSKprostae
    task.r = int32(C.MSK_getprosta(task.ptr(),C.MSKsoltypee(whichsol_),&_c_prosta_))
    if task.r != 0 { return }
    _r_prosta_ = int32(_c_prosta_)
  }
  return
}
func (task *Task) GetPviolBarvar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolBarvar'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolBarvar'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getpviolbarvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetPviolCon(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolCon'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolCon'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getpviolcon(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetPviolCones(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolCones'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolCones'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getpviolcones(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetPviolVar(whichsol_ int32,sub_ []int32,viol_ []float64) (_r_viol_ []float64) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'GetPviolVar'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if viol_ == nil { viol_ = make([]float64,num_,num_)
    } else if len(viol_) < int(num_) { panic("Slice in 'viol_' is too short in call to 'GetPviolVar'") }
    var _c_viol_ *C.MSKrealt = nil
    if len(viol_) > 0 { _c_viol_ = (*C.MSKrealt)(&viol_[0]) }
    task.r = int32(C.MSK_getpviolvar(task.ptr(),C.MSKsoltypee(whichsol_),_c_num_,_c_sub_,_c_viol_))
    if task.r != 0 { return }
    _r_viol_ = viol_
  }
  return
}
func (task *Task) GetQConK(k_ int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) (_r_numqcnz_ int64,_r_qcsubi_ []int32,_r_qcsubj_ []int32,_r_qcval_ []float64) {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumQConKNz(k_)
    if task.r != RES_OK { return }
    maxnumqcnz_ := __tmp_var_1
    _c_maxnumqcnz_ := C.MSKint64t(maxnumqcnz_)
    var _c_qcsurp_ C.MSKint64t = C.MSKint64t(len(qcsubi_))
    var _c_numqcnz_ C.MSKint64t
    var __tmp_var_4 int64
    __tmp_var_4 = task.GetNumQConKNz(k_)
    if task.r != RES_OK { return }
    if qcsubi_ == nil { qcsubi_ = make([]int32,__tmp_var_4,__tmp_var_4)
    } else if len(qcsubi_) < int(__tmp_var_4) { panic("Slice in 'qcsubi_' is too short in call to 'GetQConK'") }
    var _c_qcsubi_ *C.MSKint32t = nil
    if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
    var __tmp_var_7 int64
    __tmp_var_7 = task.GetNumQConKNz(k_)
    if task.r != RES_OK { return }
    if qcsubj_ == nil { qcsubj_ = make([]int32,__tmp_var_7,__tmp_var_7)
    } else if len(qcsubj_) < int(__tmp_var_7) { panic("Slice in 'qcsubj_' is too short in call to 'GetQConK'") }
    var _c_qcsubj_ *C.MSKint32t = nil
    if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
    var __tmp_var_10 int64
    __tmp_var_10 = task.GetNumQConKNz(k_)
    if task.r != RES_OK { return }
    if qcval_ == nil { qcval_ = make([]float64,__tmp_var_10,__tmp_var_10)
    } else if len(qcval_) < int(__tmp_var_10) { panic("Slice in 'qcval_' is too short in call to 'GetQConK'") }
    var _c_qcval_ *C.MSKrealt = nil
    if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
    task.r = int32(C.MSK_getqconk64(task.ptr(),_c_k_,_c_maxnumqcnz_,&_c_qcsurp_,&_c_numqcnz_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
    if task.r != 0 { return }
    _r_numqcnz_ = int64(_c_numqcnz_)
    _r_qcsubi_ = qcsubi_
    _r_qcsubj_ = qcsubj_
    _r_qcval_ = qcval_
  }
  return
}
func (task *Task) GetQObj(qosubi_ []int32,qosubj_ []int32,qoval_ []float64) (_r_numqonz_ int64,_r_qosubi_ []int32,_r_qosubj_ []int32,_r_qoval_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetNumQObjNz()
    if task.r != RES_OK { return }
    maxnumqonz_ := __tmp_var_1
    _c_maxnumqonz_ := C.MSKint64t(maxnumqonz_)
    var _c_qosurp_ C.MSKint64t = C.MSKint64t(len(qosubi_))
    var _c_numqonz_ C.MSKint64t
    if qosubi_ == nil { qosubi_ = make([]int32,maxnumqonz_,maxnumqonz_)
    } else if len(qosubi_) < int(maxnumqonz_) { panic("Slice in 'qosubi_' is too short in call to 'GetQObj'") }
    var _c_qosubi_ *C.MSKint32t = nil
    if len(qosubi_) > 0 { _c_qosubi_ = (*C.MSKint32t)(&qosubi_[0]) }
    if qosubj_ == nil { qosubj_ = make([]int32,maxnumqonz_,maxnumqonz_)
    } else if len(qosubj_) < int(maxnumqonz_) { panic("Slice in 'qosubj_' is too short in call to 'GetQObj'") }
    var _c_qosubj_ *C.MSKint32t = nil
    if len(qosubj_) > 0 { _c_qosubj_ = (*C.MSKint32t)(&qosubj_[0]) }
    if qoval_ == nil { qoval_ = make([]float64,maxnumqonz_,maxnumqonz_)
    } else if len(qoval_) < int(maxnumqonz_) { panic("Slice in 'qoval_' is too short in call to 'GetQObj'") }
    var _c_qoval_ *C.MSKrealt = nil
    if len(qoval_) > 0 { _c_qoval_ = (*C.MSKrealt)(&qoval_[0]) }
    task.r = int32(C.MSK_getqobj64(task.ptr(),_c_maxnumqonz_,&_c_qosurp_,&_c_numqonz_,_c_qosubi_,_c_qosubj_,_c_qoval_))
    if task.r != 0 { return }
    _r_numqonz_ = int64(_c_numqonz_)
    _r_qosubi_ = qosubi_
    _r_qosubj_ = qosubj_
    _r_qoval_ = qoval_
  }
  return
}
func (task *Task) GetQObjIJ(i_ int32,j_ int32) (_r_qoij_ float64) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_j_ := C.MSKint32t(j_)
    var _c_qoij_ C.MSKrealt
    task.r = int32(C.MSK_getqobjij(task.ptr(),_c_i_,_c_j_,&_c_qoij_))
    if task.r != 0 { return }
    _r_qoij_ = float64(_c_qoij_)
  }
  return
}
func (task *Task) GetReducedCosts(whichsol_ int32,first_ int32,last_ int32,redcosts_ []float64) (_r_redcosts_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if redcosts_ == nil { redcosts_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(redcosts_) < int(last_ - first_) { panic("Slice in 'redcosts_' is too short in call to 'GetReducedCosts'") }
    var _c_redcosts_ *C.MSKrealt = nil
    if len(redcosts_) > 0 { _c_redcosts_ = (*C.MSKrealt)(&redcosts_[0]) }
    task.r = int32(C.MSK_getreducedcosts(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_redcosts_))
    if task.r != 0 { return }
    _r_redcosts_ = redcosts_
  }
  return
}
func (task *Task) GetSkc(whichsol_ int32,skc_ []int32) (_r_skc_ []int32) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if skc_ == nil { skc_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(skc_) < int(__tmp_var_1) { panic("Slice in 'skc_' is too short in call to 'GetSkc'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    task.r = int32(C.MSK_getskc(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_))
    if task.r != 0 { return }
    _r_skc_ = skc_
  }
  return
}
func (task *Task) GetSkcSlice(whichsol_ int32,first_ int32,last_ int32,skc_ []int32) (_r_skc_ []int32) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if skc_ == nil { skc_ = make([]int32,last_ - first_,last_ - first_)
    } else if len(skc_) < int(last_ - first_) { panic("Slice in 'skc_' is too short in call to 'GetSkcSlice'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    task.r = int32(C.MSK_getskcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skc_))
    if task.r != 0 { return }
    _r_skc_ = skc_
  }
  return
}
func (task *Task) GetSkn(whichsol_ int32,skn_ []int32) (_r_skn_ []int32) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCone()
    if task.r != RES_OK { return }
    if skn_ == nil { skn_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(skn_) < int(__tmp_var_1) { panic("Slice in 'skn_' is too short in call to 'GetSkn'") }
    var _c_skn_ *C.MSKstakeye = nil
    if len(skn_) > 0 { _c_skn_ = (*C.MSKstakeye)(unsafe.Pointer(&skn_[0])) }
    task.r = int32(C.MSK_getskn(task.ptr(),C.MSKsoltypee(whichsol_),_c_skn_))
    if task.r != 0 { return }
    _r_skn_ = skn_
  }
  return
}
func (task *Task) GetSkx(whichsol_ int32,skx_ []int32) (_r_skx_ []int32) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if skx_ == nil { skx_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(skx_) < int(__tmp_var_1) { panic("Slice in 'skx_' is too short in call to 'GetSkx'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    task.r = int32(C.MSK_getskx(task.ptr(),C.MSKsoltypee(whichsol_),_c_skx_))
    if task.r != 0 { return }
    _r_skx_ = skx_
  }
  return
}
func (task *Task) GetSkxSlice(whichsol_ int32,first_ int32,last_ int32,skx_ []int32) (_r_skx_ []int32) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if skx_ == nil { skx_ = make([]int32,last_ - first_,last_ - first_)
    } else if len(skx_) < int(last_ - first_) { panic("Slice in 'skx_' is too short in call to 'GetSkxSlice'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    task.r = int32(C.MSK_getskxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skx_))
    if task.r != 0 { return }
    _r_skx_ = skx_
  }
  return
}
func (task *Task) GetSlc(whichsol_ int32,slc_ []float64) (_r_slc_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if slc_ == nil { slc_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(slc_) < int(__tmp_var_1) { panic("Slice in 'slc_' is too short in call to 'GetSlc'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    task.r = int32(C.MSK_getslc(task.ptr(),C.MSKsoltypee(whichsol_),_c_slc_))
    if task.r != 0 { return }
    _r_slc_ = slc_
  }
  return
}
func (task *Task) GetSlcSlice(whichsol_ int32,first_ int32,last_ int32,slc_ []float64) (_r_slc_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if slc_ == nil { slc_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(slc_) < int(last_ - first_) { panic("Slice in 'slc_' is too short in call to 'GetSlcSlice'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    task.r = int32(C.MSK_getslcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slc_))
    if task.r != 0 { return }
    _r_slc_ = slc_
  }
  return
}
func (task *Task) GetSlx(whichsol_ int32,slx_ []float64) (_r_slx_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if slx_ == nil { slx_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(slx_) < int(__tmp_var_1) { panic("Slice in 'slx_' is too short in call to 'GetSlx'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    task.r = int32(C.MSK_getslx(task.ptr(),C.MSKsoltypee(whichsol_),_c_slx_))
    if task.r != 0 { return }
    _r_slx_ = slx_
  }
  return
}
func (task *Task) GetSlxSlice(whichsol_ int32,first_ int32,last_ int32,slx_ []float64) (_r_slx_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if slx_ == nil { slx_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(slx_) < int(last_ - first_) { panic("Slice in 'slx_' is too short in call to 'GetSlxSlice'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    task.r = int32(C.MSK_getslxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slx_))
    if task.r != 0 { return }
    _r_slx_ = slx_
  }
  return
}
func (task *Task) GetSnx(whichsol_ int32,snx_ []float64) (_r_snx_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if snx_ == nil { snx_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(snx_) < int(__tmp_var_1) { panic("Slice in 'snx_' is too short in call to 'GetSnx'") }
    var _c_snx_ *C.MSKrealt = nil
    if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
    task.r = int32(C.MSK_getsnx(task.ptr(),C.MSKsoltypee(whichsol_),_c_snx_))
    if task.r != 0 { return }
    _r_snx_ = snx_
  }
  return
}
func (task *Task) GetSnxSlice(whichsol_ int32,first_ int32,last_ int32,snx_ []float64) (_r_snx_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if snx_ == nil { snx_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(snx_) < int(last_ - first_) { panic("Slice in 'snx_' is too short in call to 'GetSnxSlice'") }
    var _c_snx_ *C.MSKrealt = nil
    if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
    task.r = int32(C.MSK_getsnxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_snx_))
    if task.r != 0 { return }
    _r_snx_ = snx_
  }
  return
}
func (task *Task) GetSolSta(whichsol_ int32) (_r_solsta_ int32) {
  if task.r == RES_OK {
    var _c_solsta_ C.MSKsolstae
    task.r = int32(C.MSK_getsolsta(task.ptr(),C.MSKsoltypee(whichsol_),&_c_solsta_))
    if task.r != 0 { return }
    _r_solsta_ = int32(_c_solsta_)
  }
  return
}
func (task *Task) GetSolution(whichsol_ int32,skc_ []int32,skx_ []int32,skn_ []int32,xc_ []float64,xx_ []float64,y_ []float64,slc_ []float64,suc_ []float64,slx_ []float64,sux_ []float64,snx_ []float64) (_r_prosta_ int32,_r_solsta_ int32,_r_skc_ []int32,_r_skx_ []int32,_r_skn_ []int32,_r_xc_ []float64,_r_xx_ []float64,_r_y_ []float64,_r_slc_ []float64,_r_suc_ []float64,_r_slx_ []float64,_r_sux_ []float64,_r_snx_ []float64) {
  if task.r == RES_OK {
    var _c_prosta_ C.MSKprostae
    var _c_solsta_ C.MSKsolstae
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if skc_ == nil { skc_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(skc_) < int(__tmp_var_1) { panic("Slice in 'skc_' is too short in call to 'GetSolution'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetNumVar()
    if task.r != RES_OK { return }
    if skx_ == nil { skx_ = make([]int32,__tmp_var_3,__tmp_var_3)
    } else if len(skx_) < int(__tmp_var_3) { panic("Slice in 'skx_' is too short in call to 'GetSolution'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    var __tmp_var_5 int32
    __tmp_var_5 = task.GetNumCone()
    if task.r != RES_OK { return }
    if skn_ == nil { skn_ = make([]int32,__tmp_var_5,__tmp_var_5)
    } else if len(skn_) < int(__tmp_var_5) { panic("Slice in 'skn_' is too short in call to 'GetSolution'") }
    var _c_skn_ *C.MSKstakeye = nil
    if len(skn_) > 0 { _c_skn_ = (*C.MSKstakeye)(unsafe.Pointer(&skn_[0])) }
    var __tmp_var_7 int32
    __tmp_var_7 = task.GetNumCon()
    if task.r != RES_OK { return }
    if xc_ == nil { xc_ = make([]float64,__tmp_var_7,__tmp_var_7)
    } else if len(xc_) < int(__tmp_var_7) { panic("Slice in 'xc_' is too short in call to 'GetSolution'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    var __tmp_var_9 int32
    __tmp_var_9 = task.GetNumVar()
    if task.r != RES_OK { return }
    if xx_ == nil { xx_ = make([]float64,__tmp_var_9,__tmp_var_9)
    } else if len(xx_) < int(__tmp_var_9) { panic("Slice in 'xx_' is too short in call to 'GetSolution'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    var __tmp_var_11 int32
    __tmp_var_11 = task.GetNumCon()
    if task.r != RES_OK { return }
    if y_ == nil { y_ = make([]float64,__tmp_var_11,__tmp_var_11)
    } else if len(y_) < int(__tmp_var_11) { panic("Slice in 'y_' is too short in call to 'GetSolution'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    var __tmp_var_13 int32
    __tmp_var_13 = task.GetNumCon()
    if task.r != RES_OK { return }
    if slc_ == nil { slc_ = make([]float64,__tmp_var_13,__tmp_var_13)
    } else if len(slc_) < int(__tmp_var_13) { panic("Slice in 'slc_' is too short in call to 'GetSolution'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    var __tmp_var_15 int32
    __tmp_var_15 = task.GetNumCon()
    if task.r != RES_OK { return }
    if suc_ == nil { suc_ = make([]float64,__tmp_var_15,__tmp_var_15)
    } else if len(suc_) < int(__tmp_var_15) { panic("Slice in 'suc_' is too short in call to 'GetSolution'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    var __tmp_var_17 int32
    __tmp_var_17 = task.GetNumVar()
    if task.r != RES_OK { return }
    if slx_ == nil { slx_ = make([]float64,__tmp_var_17,__tmp_var_17)
    } else if len(slx_) < int(__tmp_var_17) { panic("Slice in 'slx_' is too short in call to 'GetSolution'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    var __tmp_var_19 int32
    __tmp_var_19 = task.GetNumVar()
    if task.r != RES_OK { return }
    if sux_ == nil { sux_ = make([]float64,__tmp_var_19,__tmp_var_19)
    } else if len(sux_) < int(__tmp_var_19) { panic("Slice in 'sux_' is too short in call to 'GetSolution'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    var __tmp_var_21 int32
    __tmp_var_21 = task.GetNumVar()
    if task.r != RES_OK { return }
    if snx_ == nil { snx_ = make([]float64,__tmp_var_21,__tmp_var_21)
    } else if len(snx_) < int(__tmp_var_21) { panic("Slice in 'snx_' is too short in call to 'GetSolution'") }
    var _c_snx_ *C.MSKrealt = nil
    if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
    task.r = int32(C.MSK_getsolution(task.ptr(),C.MSKsoltypee(whichsol_),&_c_prosta_,&_c_solsta_,_c_skc_,_c_skx_,_c_skn_,_c_xc_,_c_xx_,_c_y_,_c_slc_,_c_suc_,_c_slx_,_c_sux_,_c_snx_))
    if task.r != 0 { return }
    _r_prosta_ = int32(_c_prosta_)
    _r_solsta_ = int32(_c_solsta_)
    _r_skc_ = skc_
    _r_skx_ = skx_
    _r_skn_ = skn_
    _r_xc_ = xc_
    _r_xx_ = xx_
    _r_y_ = y_
    _r_slc_ = slc_
    _r_suc_ = suc_
    _r_slx_ = slx_
    _r_sux_ = sux_
    _r_snx_ = snx_
  }
  return
}
func (task *Task) GetSolutionInfo(whichsol_ int32) (_r_pobj_ float64,_r_pviolcon_ float64,_r_pviolvar_ float64,_r_pviolbarvar_ float64,_r_pviolcone_ float64,_r_pviolitg_ float64,_r_dobj_ float64,_r_dviolcon_ float64,_r_dviolvar_ float64,_r_dviolbarvar_ float64,_r_dviolcone_ float64) {
  if task.r == RES_OK {
    var _c_pobj_ C.MSKrealt
    var _c_pviolcon_ C.MSKrealt
    var _c_pviolvar_ C.MSKrealt
    var _c_pviolbarvar_ C.MSKrealt
    var _c_pviolcone_ C.MSKrealt
    var _c_pviolitg_ C.MSKrealt
    var _c_dobj_ C.MSKrealt
    var _c_dviolcon_ C.MSKrealt
    var _c_dviolvar_ C.MSKrealt
    var _c_dviolbarvar_ C.MSKrealt
    var _c_dviolcone_ C.MSKrealt
    task.r = int32(C.MSK_getsolutioninfo(task.ptr(),C.MSKsoltypee(whichsol_),&_c_pobj_,&_c_pviolcon_,&_c_pviolvar_,&_c_pviolbarvar_,&_c_pviolcone_,&_c_pviolitg_,&_c_dobj_,&_c_dviolcon_,&_c_dviolvar_,&_c_dviolbarvar_,&_c_dviolcone_))
    if task.r != 0 { return }
    _r_pobj_ = float64(_c_pobj_)
    _r_pviolcon_ = float64(_c_pviolcon_)
    _r_pviolvar_ = float64(_c_pviolvar_)
    _r_pviolbarvar_ = float64(_c_pviolbarvar_)
    _r_pviolcone_ = float64(_c_pviolcone_)
    _r_pviolitg_ = float64(_c_pviolitg_)
    _r_dobj_ = float64(_c_dobj_)
    _r_dviolcon_ = float64(_c_dviolcon_)
    _r_dviolvar_ = float64(_c_dviolvar_)
    _r_dviolbarvar_ = float64(_c_dviolbarvar_)
    _r_dviolcone_ = float64(_c_dviolcone_)
  }
  return
}
func (task *Task) GetSolutionSlice(whichsol_ int32,solitem_ int32,first_ int32,last_ int32,values_ []float64) (_r_values_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if values_ == nil { values_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(values_) < int(last_ - first_) { panic("Slice in 'values_' is too short in call to 'GetSolutionSlice'") }
    var _c_values_ *C.MSKrealt = nil
    if len(values_) > 0 { _c_values_ = (*C.MSKrealt)(&values_[0]) }
    task.r = int32(C.MSK_getsolutionslice(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKsoliteme(solitem_),_c_first_,_c_last_,_c_values_))
    if task.r != 0 { return }
    _r_values_ = values_
  }
  return
}
func (task *Task) GetSparseSymMat(idx_ int64,subi_ []int32,subj_ []int32,valij_ []float64) (_r_subi_ []int32,_r_subj_ []int32,_r_valij_ []float64) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var __tmp_var_1 int64
    _,__tmp_var_1,_ = task.GetSymMatInfo(idx_)
    if task.r != RES_OK { return }
    maxlen_ := __tmp_var_1
    _c_maxlen_ := C.MSKint64t(maxlen_)
    if subi_ == nil { subi_ = make([]int32,maxlen_,maxlen_)
    } else if len(subi_) < int(maxlen_) { panic("Slice in 'subi_' is too short in call to 'GetSparseSymMat'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { subj_ = make([]int32,maxlen_,maxlen_)
    } else if len(subj_) < int(maxlen_) { panic("Slice in 'subj_' is too short in call to 'GetSparseSymMat'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if valij_ == nil { valij_ = make([]float64,maxlen_,maxlen_)
    } else if len(valij_) < int(maxlen_) { panic("Slice in 'valij_' is too short in call to 'GetSparseSymMat'") }
    var _c_valij_ *C.MSKrealt = nil
    if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
    task.r = int32(C.MSK_getsparsesymmat(task.ptr(),_c_idx_,_c_maxlen_,_c_subi_,_c_subj_,_c_valij_))
    if task.r != 0 { return }
    _r_subi_ = subi_
    _r_subj_ = subj_
    _r_valij_ = valij_
  }
  return
}
func (task *Task) GetStrParam(param_ int32) (_r_len_ int32,_r_parvalue_ string) {
  if task.r == RES_OK {
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetStrParamLen(param_)
    if task.r != RES_OK { return }
    maxlen_ := 1 + __tmp_var_3
    _c_maxlen_ := C.MSKint32t(maxlen_)
    var _c_len_ C.MSKint32t
    _c_parvalue_ := (*C.char)(C.malloc(C.size_t(maxlen_+1)))
    defer C.free(unsafe.Pointer(_c_parvalue_))
    task.r = int32(C.MSK_getstrparam(task.ptr(),C.MSKsparame(param_),_c_maxlen_,&_c_len_,C.MSKstring_t(_c_parvalue_)))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
    _r_parvalue_ = C.GoStringN(_c_parvalue_,C.int(maxlen_))
  }
  return
}
func (task *Task) GetStrParamLen(param_ int32) (_r_len_ int32) {
  if task.r == RES_OK {
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getstrparamlen(task.ptr(),C.MSKsparame(param_),&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetSuc(whichsol_ int32,suc_ []float64) (_r_suc_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if suc_ == nil { suc_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(suc_) < int(__tmp_var_1) { panic("Slice in 'suc_' is too short in call to 'GetSuc'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    task.r = int32(C.MSK_getsuc(task.ptr(),C.MSKsoltypee(whichsol_),_c_suc_))
    if task.r != 0 { return }
    _r_suc_ = suc_
  }
  return
}
func (task *Task) GetSucSlice(whichsol_ int32,first_ int32,last_ int32,suc_ []float64) (_r_suc_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if suc_ == nil { suc_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(suc_) < int(last_ - first_) { panic("Slice in 'suc_' is too short in call to 'GetSucSlice'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    task.r = int32(C.MSK_getsucslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_suc_))
    if task.r != 0 { return }
    _r_suc_ = suc_
  }
  return
}
func (task *Task) GetSux(whichsol_ int32,sux_ []float64) (_r_sux_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if sux_ == nil { sux_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(sux_) < int(__tmp_var_1) { panic("Slice in 'sux_' is too short in call to 'GetSux'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    task.r = int32(C.MSK_getsux(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
    if task.r != 0 { return }
    _r_sux_ = sux_
  }
  return
}
func (task *Task) GetSuxSlice(whichsol_ int32,first_ int32,last_ int32,sux_ []float64) (_r_sux_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if sux_ == nil { sux_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(sux_) < int(last_ - first_) { panic("Slice in 'sux_' is too short in call to 'GetSuxSlice'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    task.r = int32(C.MSK_getsuxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_sux_))
    if task.r != 0 { return }
    _r_sux_ = sux_
  }
  return
}
func (task *Task) GetSymMatInfo(idx_ int64) (_r_dim_ int32,_r_nz_ int64,_r_type_ int32) {
  if task.r == RES_OK {
    _c_idx_ := C.MSKint64t(idx_)
    var _c_dim_ C.MSKint32t
    var _c_nz_ C.MSKint64t
    var _c_type_ C.MSKsymmattypee
    task.r = int32(C.MSK_getsymmatinfo(task.ptr(),_c_idx_,&_c_dim_,&_c_nz_,&_c_type_))
    if task.r != 0 { return }
    _r_dim_ = int32(_c_dim_)
    _r_nz_ = int64(_c_nz_)
    _r_type_ = int32(_c_type_)
  }
  return
}
func (task *Task) GetTaskName() (_r_taskname_ string) {
  if task.r == RES_OK {
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetTaskNameLen()
    if task.r != RES_OK { return }
    sizetaskname_ := 1 + __tmp_var_3
    _c_sizetaskname_ := C.MSKint32t(sizetaskname_)
    _c_taskname_ := (*C.char)(C.malloc(C.size_t(sizetaskname_+1)))
    defer C.free(unsafe.Pointer(_c_taskname_))
    task.r = int32(C.MSK_gettaskname(task.ptr(),_c_sizetaskname_,C.MSKstring_t(_c_taskname_)))
    if task.r != 0 { return }
    _r_taskname_ = C.GoStringN(_c_taskname_,C.int(sizetaskname_))
  }
  return
}
func (task *Task) GetTaskNameLen() (_r_len_ int32) {
  if task.r == RES_OK {
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_gettasknamelen(task.ptr(),&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetVarBound(i_ int32) (_r_bk_ int32,_r_bl_ float64,_r_bu_ float64) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_bk_ C.MSKboundkeye
    var _c_bl_ C.MSKrealt
    var _c_bu_ C.MSKrealt
    task.r = int32(C.MSK_getvarbound(task.ptr(),_c_i_,&_c_bk_,&_c_bl_,&_c_bu_))
    if task.r != 0 { return }
    _r_bk_ = int32(_c_bk_)
    _r_bl_ = float64(_c_bl_)
    _r_bu_ = float64(_c_bu_)
  }
  return
}
func (task *Task) GetVarBoundSlice(first_ int32,last_ int32,bk_ []int32,bl_ []float64,bu_ []float64) (_r_bk_ []int32,_r_bl_ []float64,_r_bu_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if bk_ == nil { bk_ = make([]int32,last_ - first_,last_ - first_)
    } else if len(bk_) < int(last_ - first_) { panic("Slice in 'bk_' is too short in call to 'GetVarBoundSlice'") }
    var _c_bk_ *C.MSKboundkeye = nil
    if len(bk_) > 0 { _c_bk_ = (*C.MSKboundkeye)(unsafe.Pointer(&bk_[0])) }
    if bl_ == nil { bl_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(bl_) < int(last_ - first_) { panic("Slice in 'bl_' is too short in call to 'GetVarBoundSlice'") }
    var _c_bl_ *C.MSKrealt = nil
    if len(bl_) > 0 { _c_bl_ = (*C.MSKrealt)(&bl_[0]) }
    if bu_ == nil { bu_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(bu_) < int(last_ - first_) { panic("Slice in 'bu_' is too short in call to 'GetVarBoundSlice'") }
    var _c_bu_ *C.MSKrealt = nil
    if len(bu_) > 0 { _c_bu_ = (*C.MSKrealt)(&bu_[0]) }
    task.r = int32(C.MSK_getvarboundslice(task.ptr(),_c_first_,_c_last_,_c_bk_,_c_bl_,_c_bu_))
    if task.r != 0 { return }
    _r_bk_ = bk_
    _r_bl_ = bl_
    _r_bu_ = bu_
  }
  return
}
func (task *Task) GetVarName(j_ int32) (_r_name_ string) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetVarNameLen(j_)
    if task.r != RES_OK { return }
    sizename_ := 1 + __tmp_var_3
    _c_sizename_ := C.MSKint32t(sizename_)
    _c_name_ := (*C.char)(C.malloc(C.size_t(sizename_+1)))
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_getvarname(task.ptr(),_c_j_,_c_sizename_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
    _r_name_ = C.GoStringN(_c_name_,C.int(sizename_))
  }
  return
}
func (task *Task) GetVarNameIndex(somename_ string) (_r_asgn_ int32,_r_index_ int32) {
  if task.r == RES_OK {
    _c_somename_ := C.CString(somename_)
    defer C.free(unsafe.Pointer(_c_somename_))
    var _c_asgn_ C.MSKint32t
    var _c_index_ C.MSKint32t
    task.r = int32(C.MSK_getvarnameindex(task.ptr(),C.MSKstring_t(_c_somename_),&_c_asgn_,&_c_index_))
    if task.r != 0 { return }
    _r_asgn_ = int32(_c_asgn_)
    _r_index_ = int32(_c_index_)
  }
  return
}
func (task *Task) GetVarNameLen(i_ int32) (_r_len_ int32) {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    var _c_len_ C.MSKint32t
    task.r = int32(C.MSK_getvarnamelen(task.ptr(),_c_i_,&_c_len_))
    if task.r != 0 { return }
    _r_len_ = int32(_c_len_)
  }
  return
}
func (task *Task) GetVarType(j_ int32) (_r_vartype_ int32) {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    var _c_vartype_ C.MSKvariabletypee
    task.r = int32(C.MSK_getvartype(task.ptr(),_c_j_,&_c_vartype_))
    if task.r != 0 { return }
    _r_vartype_ = int32(_c_vartype_)
  }
  return
}
func (task *Task) GetVarTypeList(subj_ []int32,vartype_ []int32) (_r_vartype_ []int32) {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subj_) })
    _c_num_ := C.MSKint32t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'GetVarTypeList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if vartype_ == nil { vartype_ = make([]int32,num_,num_)
    } else if len(vartype_) < int(num_) { panic("Slice in 'vartype_' is too short in call to 'GetVarTypeList'") }
    var _c_vartype_ *C.MSKvariabletypee = nil
    if len(vartype_) > 0 { _c_vartype_ = (*C.MSKvariabletypee)(unsafe.Pointer(&vartype_[0])) }
    task.r = int32(C.MSK_getvartypelist(task.ptr(),_c_num_,_c_subj_,_c_vartype_))
    if task.r != 0 { return }
    _r_vartype_ = vartype_
  }
  return
}
func (task *Task) GetXc(whichsol_ int32,xc_ []float64) (_r_xc_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if xc_ == nil { xc_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(xc_) < int(__tmp_var_1) { panic("Slice in 'xc_' is too short in call to 'GetXc'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    task.r = int32(C.MSK_getxc(task.ptr(),C.MSKsoltypee(whichsol_),_c_xc_))
    if task.r != 0 { return }
    _r_xc_ = xc_
  }
  return
}
func (task *Task) GetXcSlice(whichsol_ int32,first_ int32,last_ int32,xc_ []float64) (_r_xc_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if xc_ == nil { xc_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(xc_) < int(last_ - first_) { panic("Slice in 'xc_' is too short in call to 'GetXcSlice'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    task.r = int32(C.MSK_getxcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xc_))
    if task.r != 0 { return }
    _r_xc_ = xc_
  }
  return
}
func (task *Task) GetXx(whichsol_ int32,xx_ []float64) (_r_xx_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if xx_ == nil { xx_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(xx_) < int(__tmp_var_1) { panic("Slice in 'xx_' is too short in call to 'GetXx'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    task.r = int32(C.MSK_getxx(task.ptr(),C.MSKsoltypee(whichsol_),_c_xx_))
    if task.r != 0 { return }
    _r_xx_ = xx_
  }
  return
}
func (task *Task) GetXxSlice(whichsol_ int32,first_ int32,last_ int32,xx_ []float64) (_r_xx_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if xx_ == nil { xx_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(xx_) < int(last_ - first_) { panic("Slice in 'xx_' is too short in call to 'GetXxSlice'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    task.r = int32(C.MSK_getxxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xx_))
    if task.r != 0 { return }
    _r_xx_ = xx_
  }
  return
}
func (task *Task) GetY(whichsol_ int32,y_ []float64) (_r_y_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if y_ == nil { y_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(y_) < int(__tmp_var_1) { panic("Slice in 'y_' is too short in call to 'GetY'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    task.r = int32(C.MSK_gety(task.ptr(),C.MSKsoltypee(whichsol_),_c_y_))
    if task.r != 0 { return }
    _r_y_ = y_
  }
  return
}
func (task *Task) GetYSlice(whichsol_ int32,first_ int32,last_ int32,y_ []float64) (_r_y_ []float64) {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if y_ == nil { y_ = make([]float64,last_ - first_,last_ - first_)
    } else if len(y_) < int(last_ - first_) { panic("Slice in 'y_' is too short in call to 'GetYSlice'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    task.r = int32(C.MSK_getyslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_y_))
    if task.r != 0 { return }
    _r_y_ = y_
  }
  return
}
func (task *Task) InitBasisSolve(basis_ []int32) (_r_basis_ []int32) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if basis_ == nil { basis_ = make([]int32,__tmp_var_1,__tmp_var_1)
    } else if len(basis_) < int(__tmp_var_1) { panic("Slice in 'basis_' is too short in call to 'InitBasisSolve'") }
    var _c_basis_ *C.MSKint32t = nil
    if len(basis_) > 0 { _c_basis_ = (*C.MSKint32t)(&basis_[0]) }
    task.r = int32(C.MSK_initbasissolve(task.ptr(),_c_basis_))
    if task.r != 0 { return }
    _r_basis_ = basis_
  }
  return
}
func (task *Task) InputData(maxnumcon_ int32,maxnumvar_ int32,c_ []float64,cfix_ float64,aptrb_ []int64,aptre_ []int64,asub_ []int32,aval_ []float64,bkc_ []int32,blc_ []float64,buc_ []float64,bkx_ []int32,blx_ []float64,bux_ []float64) () {
  if task.r == RES_OK {
    _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
    _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
    numcon_ := minint([]int{ len(buc_),len(blc_),len(bkc_) })
    _c_numcon_ := C.MSKint32t(numcon_)
    numvar_ := minint([]int{ len(c_),len(bux_),len(blx_),len(bkx_),len(aptrb_),len(aptre_) })
    _c_numvar_ := C.MSKint32t(numvar_)
    if c_ == nil { panic("Argument 'c_' is nil in call to 'InputData'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    _c_cfix_ := C.MSKrealt(cfix_)
    if aptrb_ == nil { panic("Argument 'aptrb_' is nil in call to 'InputData'") }
    var _c_aptrb_ *C.MSKint64t = nil
    if len(aptrb_) > 0 { _c_aptrb_ = (*C.MSKint64t)(&aptrb_[0]) }
    if aptre_ == nil { panic("Argument 'aptre_' is nil in call to 'InputData'") }
    var _c_aptre_ *C.MSKint64t = nil
    if len(aptre_) > 0 { _c_aptre_ = (*C.MSKint64t)(&aptre_[0]) }
    if asub_ == nil { panic("Argument 'asub_' is nil in call to 'InputData'") }
    var _c_asub_ *C.MSKint32t = nil
    if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
    if aval_ == nil { panic("Argument 'aval_' is nil in call to 'InputData'") }
    var _c_aval_ *C.MSKrealt = nil
    if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
    if bkc_ == nil { panic("Argument 'bkc_' is nil in call to 'InputData'") }
    var _c_bkc_ *C.MSKboundkeye = nil
    if len(bkc_) > 0 { _c_bkc_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkc_[0])) }
    if blc_ == nil { panic("Argument 'blc_' is nil in call to 'InputData'") }
    var _c_blc_ *C.MSKrealt = nil
    if len(blc_) > 0 { _c_blc_ = (*C.MSKrealt)(&blc_[0]) }
    if buc_ == nil { panic("Argument 'buc_' is nil in call to 'InputData'") }
    var _c_buc_ *C.MSKrealt = nil
    if len(buc_) > 0 { _c_buc_ = (*C.MSKrealt)(&buc_[0]) }
    if bkx_ == nil { panic("Argument 'bkx_' is nil in call to 'InputData'") }
    var _c_bkx_ *C.MSKboundkeye = nil
    if len(bkx_) > 0 { _c_bkx_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkx_[0])) }
    if blx_ == nil { panic("Argument 'blx_' is nil in call to 'InputData'") }
    var _c_blx_ *C.MSKrealt = nil
    if len(blx_) > 0 { _c_blx_ = (*C.MSKrealt)(&blx_[0]) }
    if bux_ == nil { panic("Argument 'bux_' is nil in call to 'InputData'") }
    var _c_bux_ *C.MSKrealt = nil
    if len(bux_) > 0 { _c_bux_ = (*C.MSKrealt)(&bux_[0]) }
    task.r = int32(C.MSK_inputdata64(task.ptr(),_c_maxnumcon_,_c_maxnumvar_,_c_numcon_,_c_numvar_,_c_c_,_c_cfix_,_c_aptrb_,_c_aptre_,_c_asub_,_c_aval_,_c_bkc_,_c_blc_,_c_buc_,_c_bkx_,_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) IsDouParName(parname_ string) (_r_param_ int32) {
  if task.r == RES_OK {
    _c_parname_ := C.CString(parname_)
    defer C.free(unsafe.Pointer(_c_parname_))
    var _c_param_ C.MSKdparame
    task.r = int32(C.MSK_isdouparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
    if task.r != 0 { return }
    _r_param_ = int32(_c_param_)
  }
  return
}
func (task *Task) IsIntParName(parname_ string) (_r_param_ int32) {
  if task.r == RES_OK {
    _c_parname_ := C.CString(parname_)
    defer C.free(unsafe.Pointer(_c_parname_))
    var _c_param_ C.MSKiparame
    task.r = int32(C.MSK_isintparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
    if task.r != 0 { return }
    _r_param_ = int32(_c_param_)
  }
  return
}
func (task *Task) IsStrParName(parname_ string) (_r_param_ int32) {
  if task.r == RES_OK {
    _c_parname_ := C.CString(parname_)
    defer C.free(unsafe.Pointer(_c_parname_))
    var _c_param_ C.MSKsparame
    task.r = int32(C.MSK_isstrparname(task.ptr(),C.MSKstring_t(_c_parname_),&_c_param_))
    if task.r != 0 { return }
    _r_param_ = int32(_c_param_)
  }
  return
}
func (task *Task) LinkFileToStream(whichstream_ int32,filename_ string,append_ int32) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    _c_append_ := C.MSKint32t(append_)
    task.r = int32(C.MSK_linkfiletotaskstream(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKstring_t(_c_filename_),_c_append_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) OneSolutionSummary(whichstream_ int32,whichsol_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_onesolutionsummary(task.ptr(),C.MSKstreamtypee(whichstream_),C.MSKsoltypee(whichsol_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) OptimizerSummary(whichstream_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_optimizersummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) Optimize() (_r_trmcode_ int32) {
  if task.r == RES_OK {
    var _c_trmcode_ C.MSKrescodee
    task.r = int32(C.MSK_optimizetrm(task.ptr(),&_c_trmcode_))
    if task.r != 0 { return }
    _r_trmcode_ = int32(_c_trmcode_)
  }
  return
}
func (task *Task) PrimalRepair(wlc_ []float64,wuc_ []float64,wlx_ []float64,wux_ []float64) () {
  if task.r == RES_OK {
    if wlc_ == nil { panic("Argument 'wlc_' is nil in call to 'PrimalRepair'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(wlc_) < int(__tmp_var_1) { panic("Slice argument 'wlc_' is too short in call to 'PrimalRepair'") }
    var _c_wlc_ *C.MSKrealt = nil
    if len(wlc_) > 0 { _c_wlc_ = (*C.MSKrealt)(&wlc_[0]) }
    if wuc_ == nil { panic("Argument 'wuc_' is nil in call to 'PrimalRepair'") }
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(wuc_) < int(__tmp_var_3) { panic("Slice argument 'wuc_' is too short in call to 'PrimalRepair'") }
    var _c_wuc_ *C.MSKrealt = nil
    if len(wuc_) > 0 { _c_wuc_ = (*C.MSKrealt)(&wuc_[0]) }
    if wlx_ == nil { panic("Argument 'wlx_' is nil in call to 'PrimalRepair'") }
    var __tmp_var_5 int32
    __tmp_var_5 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(wlx_) < int(__tmp_var_5) { panic("Slice argument 'wlx_' is too short in call to 'PrimalRepair'") }
    var _c_wlx_ *C.MSKrealt = nil
    if len(wlx_) > 0 { _c_wlx_ = (*C.MSKrealt)(&wlx_[0]) }
    if wux_ == nil { panic("Argument 'wux_' is nil in call to 'PrimalRepair'") }
    var __tmp_var_7 int32
    __tmp_var_7 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(wux_) < int(__tmp_var_7) { panic("Slice argument 'wux_' is too short in call to 'PrimalRepair'") }
    var _c_wux_ *C.MSKrealt = nil
    if len(wux_) > 0 { _c_wux_ = (*C.MSKrealt)(&wux_[0]) }
    task.r = int32(C.MSK_primalrepair(task.ptr(),_c_wlc_,_c_wuc_,_c_wlx_,_c_wux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PrimalSensitivity(subi_ []int32,marki_ []int32,subj_ []int32,markj_ []int32,leftpricei_ []float64,rightpricei_ []float64,leftrangei_ []float64,rightrangei_ []float64,leftpricej_ []float64,rightpricej_ []float64,leftrangej_ []float64,rightrangej_ []float64) (_r_leftpricei_ []float64,_r_rightpricei_ []float64,_r_leftrangei_ []float64,_r_rightrangei_ []float64,_r_leftpricej_ []float64,_r_rightpricej_ []float64,_r_leftrangej_ []float64,_r_rightrangej_ []float64) {
  if task.r == RES_OK {
    numi_ := minint([]int{ len(subi_),len(marki_) })
    _c_numi_ := C.MSKint32t(numi_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PrimalSensitivity'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if marki_ == nil { panic("Argument 'marki_' is nil in call to 'PrimalSensitivity'") }
    var _c_marki_ *C.MSKmarke = nil
    if len(marki_) > 0 { _c_marki_ = (*C.MSKmarke)(unsafe.Pointer(&marki_[0])) }
    numj_ := minint([]int{ len(subj_),len(markj_) })
    _c_numj_ := C.MSKint32t(numj_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PrimalSensitivity'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if markj_ == nil { panic("Argument 'markj_' is nil in call to 'PrimalSensitivity'") }
    var _c_markj_ *C.MSKmarke = nil
    if len(markj_) > 0 { _c_markj_ = (*C.MSKmarke)(unsafe.Pointer(&markj_[0])) }
    if leftpricei_ == nil { leftpricei_ = make([]float64,numi_,numi_)
    } else if len(leftpricei_) < int(numi_) { panic("Slice in 'leftpricei_' is too short in call to 'PrimalSensitivity'") }
    var _c_leftpricei_ *C.MSKrealt = nil
    if len(leftpricei_) > 0 { _c_leftpricei_ = (*C.MSKrealt)(&leftpricei_[0]) }
    if rightpricei_ == nil { rightpricei_ = make([]float64,numi_,numi_)
    } else if len(rightpricei_) < int(numi_) { panic("Slice in 'rightpricei_' is too short in call to 'PrimalSensitivity'") }
    var _c_rightpricei_ *C.MSKrealt = nil
    if len(rightpricei_) > 0 { _c_rightpricei_ = (*C.MSKrealt)(&rightpricei_[0]) }
    if leftrangei_ == nil { leftrangei_ = make([]float64,numi_,numi_)
    } else if len(leftrangei_) < int(numi_) { panic("Slice in 'leftrangei_' is too short in call to 'PrimalSensitivity'") }
    var _c_leftrangei_ *C.MSKrealt = nil
    if len(leftrangei_) > 0 { _c_leftrangei_ = (*C.MSKrealt)(&leftrangei_[0]) }
    if rightrangei_ == nil { rightrangei_ = make([]float64,numi_,numi_)
    } else if len(rightrangei_) < int(numi_) { panic("Slice in 'rightrangei_' is too short in call to 'PrimalSensitivity'") }
    var _c_rightrangei_ *C.MSKrealt = nil
    if len(rightrangei_) > 0 { _c_rightrangei_ = (*C.MSKrealt)(&rightrangei_[0]) }
    if leftpricej_ == nil { leftpricej_ = make([]float64,numj_,numj_)
    } else if len(leftpricej_) < int(numj_) { panic("Slice in 'leftpricej_' is too short in call to 'PrimalSensitivity'") }
    var _c_leftpricej_ *C.MSKrealt = nil
    if len(leftpricej_) > 0 { _c_leftpricej_ = (*C.MSKrealt)(&leftpricej_[0]) }
    if rightpricej_ == nil { rightpricej_ = make([]float64,numj_,numj_)
    } else if len(rightpricej_) < int(numj_) { panic("Slice in 'rightpricej_' is too short in call to 'PrimalSensitivity'") }
    var _c_rightpricej_ *C.MSKrealt = nil
    if len(rightpricej_) > 0 { _c_rightpricej_ = (*C.MSKrealt)(&rightpricej_[0]) }
    if leftrangej_ == nil { leftrangej_ = make([]float64,numj_,numj_)
    } else if len(leftrangej_) < int(numj_) { panic("Slice in 'leftrangej_' is too short in call to 'PrimalSensitivity'") }
    var _c_leftrangej_ *C.MSKrealt = nil
    if len(leftrangej_) > 0 { _c_leftrangej_ = (*C.MSKrealt)(&leftrangej_[0]) }
    if rightrangej_ == nil { rightrangej_ = make([]float64,numj_,numj_)
    } else if len(rightrangej_) < int(numj_) { panic("Slice in 'rightrangej_' is too short in call to 'PrimalSensitivity'") }
    var _c_rightrangej_ *C.MSKrealt = nil
    if len(rightrangej_) > 0 { _c_rightrangej_ = (*C.MSKrealt)(&rightrangej_[0]) }
    task.r = int32(C.MSK_primalsensitivity(task.ptr(),_c_numi_,_c_subi_,_c_marki_,_c_numj_,_c_subj_,_c_markj_,_c_leftpricei_,_c_rightpricei_,_c_leftrangei_,_c_rightrangei_,_c_leftpricej_,_c_rightpricej_,_c_leftrangej_,_c_rightrangej_))
    if task.r != 0 { return }
    _r_leftpricei_ = leftpricei_
    _r_rightpricei_ = rightpricei_
    _r_leftrangei_ = leftrangei_
    _r_rightrangei_ = rightrangei_
    _r_leftpricej_ = leftpricej_
    _r_rightpricej_ = rightpricej_
    _r_leftrangej_ = leftrangej_
    _r_rightrangej_ = rightrangej_
  }
  return
}
func (task *Task) ProbTypeToStr(probtype_ int32) (_r_str_ string) {
  if task.r == RES_OK {
    _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_str_))
    task.r = int32(C.MSK_probtypetostr(task.ptr(),C.MSKproblemtypee(probtype_),C.MSKstring_t(_c_str_)))
    if task.r != 0 { return }
    _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) ProStaToStr(prosta_ int32) (_r_str_ string) {
  if task.r == RES_OK {
    _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_str_))
    task.r = int32(C.MSK_prostatostr(task.ptr(),C.MSKprostae(prosta_),C.MSKstring_t(_c_str_)))
    if task.r != 0 { return }
    _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) PutACol(j_ int32,subj_ []int32,valj_ []float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    nzj_ := minint([]int{ len(subj_),len(valj_) })
    _c_nzj_ := C.MSKint32t(nzj_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutACol'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if valj_ == nil { panic("Argument 'valj_' is nil in call to 'PutACol'") }
    var _c_valj_ *C.MSKrealt = nil
    if len(valj_) > 0 { _c_valj_ = (*C.MSKrealt)(&valj_[0]) }
    task.r = int32(C.MSK_putacol(task.ptr(),_c_j_,_c_nzj_,_c_subj_,_c_valj_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutAColList(sub_ []int32,ptrb_ []int32,ptre_ []int32,asub_ []int32,aval_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_),len(ptrb_),len(ptre_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutAColList'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutAColList'") }
    var _c_ptrb_ *C.MSKint32t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint32t)(&ptrb_[0]) }
    if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutAColList'") }
    var _c_ptre_ *C.MSKint32t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint32t)(&ptre_[0]) }
    if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutAColList'") }
    var _c_asub_ *C.MSKint32t = nil
    if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
    if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutAColList'") }
    var _c_aval_ *C.MSKrealt = nil
    if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
    task.r = int32(C.MSK_putacollist(task.ptr(),_c_num_,_c_sub_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutAColSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,asub_ []int32,aval_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutAColSlice'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutAColSlice'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutAColSlice'") }
    var _c_asub_ *C.MSKint32t = nil
    if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
    if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutAColSlice'") }
    var _c_aval_ *C.MSKrealt = nil
    if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
    task.r = int32(C.MSK_putacolslice64(task.ptr(),_c_first_,_c_last_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutAij(i_ int32,j_ int32,aij_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_j_ := C.MSKint32t(j_)
    _c_aij_ := C.MSKrealt(aij_)
    task.r = int32(C.MSK_putaij(task.ptr(),_c_i_,_c_j_,_c_aij_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutAijList(subi_ []int32,subj_ []int32,valij_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subi_),len(subj_),len(valij_) })
    _c_num_ := C.MSKint64t(num_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutAijList'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutAijList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if valij_ == nil { panic("Argument 'valij_' is nil in call to 'PutAijList'") }
    var _c_valij_ *C.MSKrealt = nil
    if len(valij_) > 0 { _c_valij_ = (*C.MSKrealt)(&valij_[0]) }
    task.r = int32(C.MSK_putaijlist64(task.ptr(),_c_num_,_c_subi_,_c_subj_,_c_valij_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutARow(i_ int32,subi_ []int32,vali_ []float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    nzi_ := minint([]int{ len(subi_),len(vali_) })
    _c_nzi_ := C.MSKint32t(nzi_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutARow'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if vali_ == nil { panic("Argument 'vali_' is nil in call to 'PutARow'") }
    var _c_vali_ *C.MSKrealt = nil
    if len(vali_) > 0 { _c_vali_ = (*C.MSKrealt)(&vali_[0]) }
    task.r = int32(C.MSK_putarow(task.ptr(),_c_i_,_c_nzi_,_c_subi_,_c_vali_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutARowList(sub_ []int32,ptrb_ []int64,ptre_ []int64,asub_ []int32,aval_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_),len(ptrb_),len(ptre_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutARowList'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutARowList'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutARowList'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutARowList'") }
    var _c_asub_ *C.MSKint32t = nil
    if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
    if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutARowList'") }
    var _c_aval_ *C.MSKrealt = nil
    if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
    task.r = int32(C.MSK_putarowlist64(task.ptr(),_c_num_,_c_sub_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutARowSlice(first_ int32,last_ int32,ptrb_ []int64,ptre_ []int64,asub_ []int32,aval_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutARowSlice'") }
    if len(ptrb_) < int(last_ - first_) { panic("Slice argument 'ptrb_' is too short in call to 'PutARowSlice'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutARowSlice'") }
    if len(ptre_) < int(last_ - first_) { panic("Slice argument 'ptre_' is too short in call to 'PutARowSlice'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if asub_ == nil { panic("Argument 'asub_' is nil in call to 'PutARowSlice'") }
    var _c_asub_ *C.MSKint32t = nil
    if len(asub_) > 0 { _c_asub_ = (*C.MSKint32t)(&asub_[0]) }
    if aval_ == nil { panic("Argument 'aval_' is nil in call to 'PutARowSlice'") }
    var _c_aval_ *C.MSKrealt = nil
    if len(aval_) > 0 { _c_aval_ = (*C.MSKrealt)(&aval_[0]) }
    task.r = int32(C.MSK_putarowslice64(task.ptr(),_c_first_,_c_last_,_c_ptrb_,_c_ptre_,_c_asub_,_c_aval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutATruncateTol(tolzero_ float64) () {
  if task.r == RES_OK {
    _c_tolzero_ := C.MSKrealt(tolzero_)
    task.r = int32(C.MSK_putatruncatetol(task.ptr(),_c_tolzero_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBaraBlockTriplet(num_ int64,subi_ []int32,subj_ []int32,subk_ []int32,subl_ []int32,valijkl_ []float64) () {
  if task.r == RES_OK {
    _c_num_ := C.MSKint64t(num_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutBaraBlockTriplet'") }
    if len(subi_) < int(num_) { panic("Slice argument 'subi_' is too short in call to 'PutBaraBlockTriplet'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBaraBlockTriplet'") }
    if len(subj_) < int(num_) { panic("Slice argument 'subj_' is too short in call to 'PutBaraBlockTriplet'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if subk_ == nil { panic("Argument 'subk_' is nil in call to 'PutBaraBlockTriplet'") }
    if len(subk_) < int(num_) { panic("Slice argument 'subk_' is too short in call to 'PutBaraBlockTriplet'") }
    var _c_subk_ *C.MSKint32t = nil
    if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
    if subl_ == nil { panic("Argument 'subl_' is nil in call to 'PutBaraBlockTriplet'") }
    if len(subl_) < int(num_) { panic("Slice argument 'subl_' is too short in call to 'PutBaraBlockTriplet'") }
    var _c_subl_ *C.MSKint32t = nil
    if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
    if valijkl_ == nil { panic("Argument 'valijkl_' is nil in call to 'PutBaraBlockTriplet'") }
    if len(valijkl_) < int(num_) { panic("Slice argument 'valijkl_' is too short in call to 'PutBaraBlockTriplet'") }
    var _c_valijkl_ *C.MSKrealt = nil
    if len(valijkl_) > 0 { _c_valijkl_ = (*C.MSKrealt)(&valijkl_[0]) }
    task.r = int32(C.MSK_putbarablocktriplet(task.ptr(),_c_num_,_c_subi_,_c_subj_,_c_subk_,_c_subl_,_c_valijkl_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBaraIj(i_ int32,j_ int32,sub_ []int64,weights_ []float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_j_ := C.MSKint32t(j_)
    num_ := minint([]int{ len(sub_),len(weights_) })
    _c_num_ := C.MSKint64t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutBaraIj'") }
    var _c_sub_ *C.MSKint64t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
    if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBaraIj'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_putbaraij(task.ptr(),_c_i_,_c_j_,_c_num_,_c_sub_,_c_weights_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBaraIjList(subi_ []int32,subj_ []int32,alphaptrb_ []int64,alphaptre_ []int64,matidx_ []int64,weights_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subi_),len(subj_),len(alphaptrb_),len(alphaptre_) })
    _c_num_ := C.MSKint32t(num_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutBaraIjList'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBaraIjList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if alphaptrb_ == nil { panic("Argument 'alphaptrb_' is nil in call to 'PutBaraIjList'") }
    var _c_alphaptrb_ *C.MSKint64t = nil
    if len(alphaptrb_) > 0 { _c_alphaptrb_ = (*C.MSKint64t)(&alphaptrb_[0]) }
    if alphaptre_ == nil { panic("Argument 'alphaptre_' is nil in call to 'PutBaraIjList'") }
    var _c_alphaptre_ *C.MSKint64t = nil
    if len(alphaptre_) > 0 { _c_alphaptre_ = (*C.MSKint64t)(&alphaptre_[0]) }
    if matidx_ == nil { panic("Argument 'matidx_' is nil in call to 'PutBaraIjList'") }
    var _c_matidx_ *C.MSKint64t = nil
    if len(matidx_) > 0 { _c_matidx_ = (*C.MSKint64t)(&matidx_[0]) }
    if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBaraIjList'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_putbaraijlist(task.ptr(),_c_num_,_c_subi_,_c_subj_,_c_alphaptrb_,_c_alphaptre_,_c_matidx_,_c_weights_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBaraRowList(subi_ []int32,ptrb_ []int64,ptre_ []int64,subj_ []int32,nummat_ []int64,matidx_ []int64,weights_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subi_),len(ptrb_),len(ptre_) })
    _c_num_ := C.MSKint32t(num_)
    if subi_ == nil { panic("Argument 'subi_' is nil in call to 'PutBaraRowList'") }
    var _c_subi_ *C.MSKint32t = nil
    if len(subi_) > 0 { _c_subi_ = (*C.MSKint32t)(&subi_[0]) }
    if ptrb_ == nil { panic("Argument 'ptrb_' is nil in call to 'PutBaraRowList'") }
    var _c_ptrb_ *C.MSKint64t = nil
    if len(ptrb_) > 0 { _c_ptrb_ = (*C.MSKint64t)(&ptrb_[0]) }
    if ptre_ == nil { panic("Argument 'ptre_' is nil in call to 'PutBaraRowList'") }
    var _c_ptre_ *C.MSKint64t = nil
    if len(ptre_) > 0 { _c_ptre_ = (*C.MSKint64t)(&ptre_[0]) }
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBaraRowList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if nummat_ == nil { panic("Argument 'nummat_' is nil in call to 'PutBaraRowList'") }
    __tmp_var_0 := len(subj_)
    if len(nummat_) < int(__tmp_var_0) { panic("Slice argument 'nummat_' is too short in call to 'PutBaraRowList'") }
    var _c_nummat_ *C.MSKint64t = nil
    if len(nummat_) > 0 { _c_nummat_ = (*C.MSKint64t)(&nummat_[0]) }
    if matidx_ == nil { panic("Argument 'matidx_' is nil in call to 'PutBaraRowList'") }
    var __tmp_var_2 int64 = 0
    for __tmp_var_4 := 0; __tmp_var_4 < len(nummat_); __tmp_var_4 += 1 {
      __tmp_var_2 += nummat_[__tmp_var_4]
    }
    if len(matidx_) < int(__tmp_var_2) { panic("Slice argument 'matidx_' is too short in call to 'PutBaraRowList'") }
    var _c_matidx_ *C.MSKint64t = nil
    if len(matidx_) > 0 { _c_matidx_ = (*C.MSKint64t)(&matidx_[0]) }
    if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBaraRowList'") }
    var __tmp_var_5 int64 = 0
    for __tmp_var_7 := 0; __tmp_var_7 < len(nummat_); __tmp_var_7 += 1 {
      __tmp_var_5 += nummat_[__tmp_var_7]
    }
    if len(weights_) < int(__tmp_var_5) { panic("Slice argument 'weights_' is too short in call to 'PutBaraRowList'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_putbararowlist(task.ptr(),_c_num_,_c_subi_,_c_ptrb_,_c_ptre_,_c_subj_,_c_nummat_,_c_matidx_,_c_weights_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBarcBlockTriplet(num_ int64,subj_ []int32,subk_ []int32,subl_ []int32,valjkl_ []float64) () {
  if task.r == RES_OK {
    _c_num_ := C.MSKint64t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutBarcBlockTriplet'") }
    if len(subj_) < int(num_) { panic("Slice argument 'subj_' is too short in call to 'PutBarcBlockTriplet'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if subk_ == nil { panic("Argument 'subk_' is nil in call to 'PutBarcBlockTriplet'") }
    if len(subk_) < int(num_) { panic("Slice argument 'subk_' is too short in call to 'PutBarcBlockTriplet'") }
    var _c_subk_ *C.MSKint32t = nil
    if len(subk_) > 0 { _c_subk_ = (*C.MSKint32t)(&subk_[0]) }
    if subl_ == nil { panic("Argument 'subl_' is nil in call to 'PutBarcBlockTriplet'") }
    if len(subl_) < int(num_) { panic("Slice argument 'subl_' is too short in call to 'PutBarcBlockTriplet'") }
    var _c_subl_ *C.MSKint32t = nil
    if len(subl_) > 0 { _c_subl_ = (*C.MSKint32t)(&subl_[0]) }
    if valjkl_ == nil { panic("Argument 'valjkl_' is nil in call to 'PutBarcBlockTriplet'") }
    if len(valjkl_) < int(num_) { panic("Slice argument 'valjkl_' is too short in call to 'PutBarcBlockTriplet'") }
    var _c_valjkl_ *C.MSKrealt = nil
    if len(valjkl_) > 0 { _c_valjkl_ = (*C.MSKrealt)(&valjkl_[0]) }
    task.r = int32(C.MSK_putbarcblocktriplet(task.ptr(),_c_num_,_c_subj_,_c_subk_,_c_subl_,_c_valjkl_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBarcJ(j_ int32,sub_ []int64,weights_ []float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    num_ := minint([]int{ len(sub_),len(weights_) })
    _c_num_ := C.MSKint64t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutBarcJ'") }
    var _c_sub_ *C.MSKint64t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint64t)(&sub_[0]) }
    if weights_ == nil { panic("Argument 'weights_' is nil in call to 'PutBarcJ'") }
    var _c_weights_ *C.MSKrealt = nil
    if len(weights_) > 0 { _c_weights_ = (*C.MSKrealt)(&weights_[0]) }
    task.r = int32(C.MSK_putbarcj(task.ptr(),_c_j_,_c_num_,_c_sub_,_c_weights_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBarsJ(whichsol_ int32,j_ int32,barsj_ []float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    if barsj_ == nil { panic("Argument 'barsj_' is nil in call to 'PutBarsJ'") }
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetLenBarvarJ(j_)
    if task.r != RES_OK { return }
    if len(barsj_) < int(__tmp_var_1) { panic("Slice argument 'barsj_' is too short in call to 'PutBarsJ'") }
    var _c_barsj_ *C.MSKrealt = nil
    if len(barsj_) > 0 { _c_barsj_ = (*C.MSKrealt)(&barsj_[0]) }
    task.r = int32(C.MSK_putbarsj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barsj_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBarvarName(j_ int32,name_ string) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_name_ := C.CString(name_)
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_putbarvarname(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutBarxJ(whichsol_ int32,j_ int32,barxj_ []float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    if barxj_ == nil { panic("Argument 'barxj_' is nil in call to 'PutBarxJ'") }
    var __tmp_var_1 int64
    __tmp_var_1 = task.GetLenBarvarJ(j_)
    if task.r != RES_OK { return }
    if len(barxj_) < int(__tmp_var_1) { panic("Slice argument 'barxj_' is too short in call to 'PutBarxJ'") }
    var _c_barxj_ *C.MSKrealt = nil
    if len(barxj_) > 0 { _c_barxj_ = (*C.MSKrealt)(&barxj_[0]) }
    task.r = int32(C.MSK_putbarxj(task.ptr(),C.MSKsoltypee(whichsol_),_c_j_,_c_barxj_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutCfix(cfix_ float64) () {
  if task.r == RES_OK {
    _c_cfix_ := C.MSKrealt(cfix_)
    task.r = int32(C.MSK_putcfix(task.ptr(),_c_cfix_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutCJ(j_ int32,cj_ float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_cj_ := C.MSKrealt(cj_)
    task.r = int32(C.MSK_putcj(task.ptr(),_c_j_,_c_cj_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutCList(subj_ []int32,val_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subj_),len(val_) })
    _c_num_ := C.MSKint32t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutCList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if val_ == nil { panic("Argument 'val_' is nil in call to 'PutCList'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_putclist(task.ptr(),_c_num_,_c_subj_,_c_val_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConBound(i_ int32,bkc_ int32,blc_ float64,buc_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_blc_ := C.MSKrealt(blc_)
    _c_buc_ := C.MSKrealt(buc_)
    task.r = int32(C.MSK_putconbound(task.ptr(),_c_i_,C.MSKboundkeye(bkc_),_c_blc_,_c_buc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConBoundList(sub_ []int32,bkc_ []int32,blc_ []float64,buc_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_),len(bkc_),len(blc_),len(buc_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutConBoundList'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if bkc_ == nil { panic("Argument 'bkc_' is nil in call to 'PutConBoundList'") }
    var _c_bkc_ *C.MSKboundkeye = nil
    if len(bkc_) > 0 { _c_bkc_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkc_[0])) }
    if blc_ == nil { panic("Argument 'blc_' is nil in call to 'PutConBoundList'") }
    var _c_blc_ *C.MSKrealt = nil
    if len(blc_) > 0 { _c_blc_ = (*C.MSKrealt)(&blc_[0]) }
    if buc_ == nil { panic("Argument 'buc_' is nil in call to 'PutConBoundList'") }
    var _c_buc_ *C.MSKrealt = nil
    if len(buc_) > 0 { _c_buc_ = (*C.MSKrealt)(&buc_[0]) }
    task.r = int32(C.MSK_putconboundlist(task.ptr(),_c_num_,_c_sub_,_c_bkc_,_c_blc_,_c_buc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConBoundListConst(sub_ []int32,bkc_ int32,blc_ float64,buc_ float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutConBoundListConst'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    _c_blc_ := C.MSKrealt(blc_)
    _c_buc_ := C.MSKrealt(buc_)
    task.r = int32(C.MSK_putconboundlistconst(task.ptr(),_c_num_,_c_sub_,C.MSKboundkeye(bkc_),_c_blc_,_c_buc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConBoundSlice(first_ int32,last_ int32,bkc_ []int32,blc_ []float64,buc_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if bkc_ == nil { panic("Argument 'bkc_' is nil in call to 'PutConBoundSlice'") }
    if len(bkc_) < int(last_ - first_) { panic("Slice argument 'bkc_' is too short in call to 'PutConBoundSlice'") }
    var _c_bkc_ *C.MSKboundkeye = nil
    if len(bkc_) > 0 { _c_bkc_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkc_[0])) }
    if blc_ == nil { panic("Argument 'blc_' is nil in call to 'PutConBoundSlice'") }
    if len(blc_) < int(last_ - first_) { panic("Slice argument 'blc_' is too short in call to 'PutConBoundSlice'") }
    var _c_blc_ *C.MSKrealt = nil
    if len(blc_) > 0 { _c_blc_ = (*C.MSKrealt)(&blc_[0]) }
    if buc_ == nil { panic("Argument 'buc_' is nil in call to 'PutConBoundSlice'") }
    if len(buc_) < int(last_ - first_) { panic("Slice argument 'buc_' is too short in call to 'PutConBoundSlice'") }
    var _c_buc_ *C.MSKrealt = nil
    if len(buc_) > 0 { _c_buc_ = (*C.MSKrealt)(&buc_[0]) }
    task.r = int32(C.MSK_putconboundslice(task.ptr(),_c_first_,_c_last_,_c_bkc_,_c_blc_,_c_buc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConBoundSliceConst(first_ int32,last_ int32,bkc_ int32,blc_ float64,buc_ float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    _c_blc_ := C.MSKrealt(blc_)
    _c_buc_ := C.MSKrealt(buc_)
    task.r = int32(C.MSK_putconboundsliceconst(task.ptr(),_c_first_,_c_last_,C.MSKboundkeye(bkc_),_c_blc_,_c_buc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutCone(k_ int32,ct_ int32,conepar_ float64,submem_ []int32) () {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    _c_conepar_ := C.MSKrealt(conepar_)
    nummem_ := minint([]int{ len(submem_) })
    _c_nummem_ := C.MSKint32t(nummem_)
    if submem_ == nil { panic("Argument 'submem_' is nil in call to 'PutCone'") }
    var _c_submem_ *C.MSKint32t = nil
    if len(submem_) > 0 { _c_submem_ = (*C.MSKint32t)(&submem_[0]) }
    task.r = int32(C.MSK_putcone(task.ptr(),_c_k_,C.MSKconetypee(ct_),_c_conepar_,_c_nummem_,_c_submem_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConeName(j_ int32,name_ string) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_name_ := C.CString(name_)
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_putconename(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConName(i_ int32,name_ string) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_name_ := C.CString(name_)
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_putconname(task.ptr(),_c_i_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutConSolutionI(i_ int32,whichsol_ int32,sk_ int32,x_ float64,sl_ float64,su_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_x_ := C.MSKrealt(x_)
    _c_sl_ := C.MSKrealt(sl_)
    _c_su_ := C.MSKrealt(su_)
    task.r = int32(C.MSK_putconsolutioni(task.ptr(),_c_i_,C.MSKsoltypee(whichsol_),C.MSKstakeye(sk_),_c_x_,_c_sl_,_c_su_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutCSlice(first_ int32,last_ int32,slice_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if slice_ == nil { panic("Argument 'slice_' is nil in call to 'PutCSlice'") }
    if len(slice_) < int(last_ - first_) { panic("Slice argument 'slice_' is too short in call to 'PutCSlice'") }
    var _c_slice_ *C.MSKrealt = nil
    if len(slice_) > 0 { _c_slice_ = (*C.MSKrealt)(&slice_[0]) }
    task.r = int32(C.MSK_putcslice(task.ptr(),_c_first_,_c_last_,_c_slice_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutDouParam(param_ int32,parvalue_ float64) () {
  if task.r == RES_OK {
    _c_parvalue_ := C.MSKrealt(parvalue_)
    task.r = int32(C.MSK_putdouparam(task.ptr(),C.MSKdparame(param_),_c_parvalue_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutIntParam(param_ int32,parvalue_ int32) () {
  if task.r == RES_OK {
    _c_parvalue_ := C.MSKint32t(parvalue_)
    task.r = int32(C.MSK_putintparam(task.ptr(),C.MSKiparame(param_),_c_parvalue_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumANz(maxnumanz_ int64) () {
  if task.r == RES_OK {
    _c_maxnumanz_ := C.MSKint64t(maxnumanz_)
    task.r = int32(C.MSK_putmaxnumanz(task.ptr(),_c_maxnumanz_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumBarvar(maxnumbarvar_ int32) () {
  if task.r == RES_OK {
    _c_maxnumbarvar_ := C.MSKint32t(maxnumbarvar_)
    task.r = int32(C.MSK_putmaxnumbarvar(task.ptr(),_c_maxnumbarvar_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumCon(maxnumcon_ int32) () {
  if task.r == RES_OK {
    _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
    task.r = int32(C.MSK_putmaxnumcon(task.ptr(),_c_maxnumcon_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumCone(maxnumcone_ int32) () {
  if task.r == RES_OK {
    _c_maxnumcone_ := C.MSKint32t(maxnumcone_)
    task.r = int32(C.MSK_putmaxnumcone(task.ptr(),_c_maxnumcone_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumQNz(maxnumqnz_ int64) () {
  if task.r == RES_OK {
    _c_maxnumqnz_ := C.MSKint64t(maxnumqnz_)
    task.r = int32(C.MSK_putmaxnumqnz(task.ptr(),_c_maxnumqnz_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutMaxNumVar(maxnumvar_ int32) () {
  if task.r == RES_OK {
    _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
    task.r = int32(C.MSK_putmaxnumvar(task.ptr(),_c_maxnumvar_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutNaDouParam(paramname_ string,parvalue_ float64) () {
  if task.r == RES_OK {
    _c_paramname_ := C.CString(paramname_)
    defer C.free(unsafe.Pointer(_c_paramname_))
    _c_parvalue_ := C.MSKrealt(parvalue_)
    task.r = int32(C.MSK_putnadouparam(task.ptr(),C.MSKstring_t(_c_paramname_),_c_parvalue_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutNaIntParam(paramname_ string,parvalue_ int32) () {
  if task.r == RES_OK {
    _c_paramname_ := C.CString(paramname_)
    defer C.free(unsafe.Pointer(_c_paramname_))
    _c_parvalue_ := C.MSKint32t(parvalue_)
    task.r = int32(C.MSK_putnaintparam(task.ptr(),C.MSKstring_t(_c_paramname_),_c_parvalue_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutNaStrParam(paramname_ string,parvalue_ string) () {
  if task.r == RES_OK {
    _c_paramname_ := C.CString(paramname_)
    defer C.free(unsafe.Pointer(_c_paramname_))
    _c_parvalue_ := C.CString(parvalue_)
    defer C.free(unsafe.Pointer(_c_parvalue_))
    task.r = int32(C.MSK_putnastrparam(task.ptr(),C.MSKstring_t(_c_paramname_),C.MSKstring_t(_c_parvalue_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutObjName(objname_ string) () {
  if task.r == RES_OK {
    _c_objname_ := C.CString(objname_)
    defer C.free(unsafe.Pointer(_c_objname_))
    task.r = int32(C.MSK_putobjname(task.ptr(),C.MSKstring_t(_c_objname_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutObjSense(sense_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_putobjsense(task.ptr(),C.MSKobjsensee(sense_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutParam(parname_ string,parvalue_ string) () {
  if task.r == RES_OK {
    _c_parname_ := C.CString(parname_)
    defer C.free(unsafe.Pointer(_c_parname_))
    _c_parvalue_ := C.CString(parvalue_)
    defer C.free(unsafe.Pointer(_c_parvalue_))
    task.r = int32(C.MSK_putparam(task.ptr(),C.MSKstring_t(_c_parname_),C.MSKstring_t(_c_parvalue_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutQCon(qcsubk_ []int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) () {
  if task.r == RES_OK {
    numqcnz_ := minint([]int{ len(qcsubi_),len(qcsubj_),len(qcval_) })
    _c_numqcnz_ := C.MSKint32t(numqcnz_)
    if qcsubk_ == nil { panic("Argument 'qcsubk_' is nil in call to 'PutQCon'") }
    var _c_qcsubk_ *C.MSKint32t = nil
    if len(qcsubk_) > 0 { _c_qcsubk_ = (*C.MSKint32t)(&qcsubk_[0]) }
    if qcsubi_ == nil { panic("Argument 'qcsubi_' is nil in call to 'PutQCon'") }
    var _c_qcsubi_ *C.MSKint32t = nil
    if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
    if qcsubj_ == nil { panic("Argument 'qcsubj_' is nil in call to 'PutQCon'") }
    var _c_qcsubj_ *C.MSKint32t = nil
    if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
    if qcval_ == nil { panic("Argument 'qcval_' is nil in call to 'PutQCon'") }
    var _c_qcval_ *C.MSKrealt = nil
    if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
    task.r = int32(C.MSK_putqcon(task.ptr(),_c_numqcnz_,_c_qcsubk_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutQConK(k_ int32,qcsubi_ []int32,qcsubj_ []int32,qcval_ []float64) () {
  if task.r == RES_OK {
    _c_k_ := C.MSKint32t(k_)
    numqcnz_ := minint([]int{ len(qcsubi_),len(qcsubj_),len(qcval_) })
    _c_numqcnz_ := C.MSKint32t(numqcnz_)
    if qcsubi_ == nil { panic("Argument 'qcsubi_' is nil in call to 'PutQConK'") }
    var _c_qcsubi_ *C.MSKint32t = nil
    if len(qcsubi_) > 0 { _c_qcsubi_ = (*C.MSKint32t)(&qcsubi_[0]) }
    if qcsubj_ == nil { panic("Argument 'qcsubj_' is nil in call to 'PutQConK'") }
    var _c_qcsubj_ *C.MSKint32t = nil
    if len(qcsubj_) > 0 { _c_qcsubj_ = (*C.MSKint32t)(&qcsubj_[0]) }
    if qcval_ == nil { panic("Argument 'qcval_' is nil in call to 'PutQConK'") }
    var _c_qcval_ *C.MSKrealt = nil
    if len(qcval_) > 0 { _c_qcval_ = (*C.MSKrealt)(&qcval_[0]) }
    task.r = int32(C.MSK_putqconk(task.ptr(),_c_k_,_c_numqcnz_,_c_qcsubi_,_c_qcsubj_,_c_qcval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutQObj(qosubi_ []int32,qosubj_ []int32,qoval_ []float64) () {
  if task.r == RES_OK {
    numqonz_ := minint([]int{ len(qosubi_),len(qosubj_),len(qoval_) })
    _c_numqonz_ := C.MSKint32t(numqonz_)
    if qosubi_ == nil { panic("Argument 'qosubi_' is nil in call to 'PutQObj'") }
    var _c_qosubi_ *C.MSKint32t = nil
    if len(qosubi_) > 0 { _c_qosubi_ = (*C.MSKint32t)(&qosubi_[0]) }
    if qosubj_ == nil { panic("Argument 'qosubj_' is nil in call to 'PutQObj'") }
    var _c_qosubj_ *C.MSKint32t = nil
    if len(qosubj_) > 0 { _c_qosubj_ = (*C.MSKint32t)(&qosubj_[0]) }
    if qoval_ == nil { panic("Argument 'qoval_' is nil in call to 'PutQObj'") }
    var _c_qoval_ *C.MSKrealt = nil
    if len(qoval_) > 0 { _c_qoval_ = (*C.MSKrealt)(&qoval_[0]) }
    task.r = int32(C.MSK_putqobj(task.ptr(),_c_numqonz_,_c_qosubi_,_c_qosubj_,_c_qoval_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutQObjIJ(i_ int32,j_ int32,qoij_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_j_ := C.MSKint32t(j_)
    _c_qoij_ := C.MSKrealt(qoij_)
    task.r = int32(C.MSK_putqobjij(task.ptr(),_c_i_,_c_j_,_c_qoij_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSkc(whichsol_ int32,skc_ []int32) () {
  if task.r == RES_OK {
    if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSkc'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(skc_) < int(__tmp_var_1) { panic("Slice argument 'skc_' is too short in call to 'PutSkc'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    task.r = int32(C.MSK_putskc(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSkcSlice(whichsol_ int32,first_ int32,last_ int32,skc_ []int32) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSkcSlice'") }
    if len(skc_) < int(last_ - first_) { panic("Slice argument 'skc_' is too short in call to 'PutSkcSlice'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    task.r = int32(C.MSK_putskcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSkx(whichsol_ int32,skx_ []int32) () {
  if task.r == RES_OK {
    if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSkx'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(skx_) < int(__tmp_var_1) { panic("Slice argument 'skx_' is too short in call to 'PutSkx'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    task.r = int32(C.MSK_putskx(task.ptr(),C.MSKsoltypee(whichsol_),_c_skx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSkxSlice(whichsol_ int32,first_ int32,last_ int32,skx_ []int32) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSkxSlice'") }
    if len(skx_) < int(last_ - first_) { panic("Slice argument 'skx_' is too short in call to 'PutSkxSlice'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    task.r = int32(C.MSK_putskxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_skx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSlc(whichsol_ int32,slc_ []float64) () {
  if task.r == RES_OK {
    if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSlc'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(slc_) < int(__tmp_var_1) { panic("Slice argument 'slc_' is too short in call to 'PutSlc'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    task.r = int32(C.MSK_putslc(task.ptr(),C.MSKsoltypee(whichsol_),_c_slc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSlcSlice(whichsol_ int32,first_ int32,last_ int32,slc_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSlcSlice'") }
    if len(slc_) < int(last_ - first_) { panic("Slice argument 'slc_' is too short in call to 'PutSlcSlice'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    task.r = int32(C.MSK_putslcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSlx(whichsol_ int32,slx_ []float64) () {
  if task.r == RES_OK {
    if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSlx'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(slx_) < int(__tmp_var_1) { panic("Slice argument 'slx_' is too short in call to 'PutSlx'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    task.r = int32(C.MSK_putslx(task.ptr(),C.MSKsoltypee(whichsol_),_c_slx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSlxSlice(whichsol_ int32,first_ int32,last_ int32,slx_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSlxSlice'") }
    if len(slx_) < int(last_ - first_) { panic("Slice argument 'slx_' is too short in call to 'PutSlxSlice'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    task.r = int32(C.MSK_putslxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_slx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSnx(whichsol_ int32,sux_ []float64) () {
  if task.r == RES_OK {
    if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSnx'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(sux_) < int(__tmp_var_1) { panic("Slice argument 'sux_' is too short in call to 'PutSnx'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    task.r = int32(C.MSK_putsnx(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSnxSlice(whichsol_ int32,first_ int32,last_ int32,snx_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if snx_ == nil { panic("Argument 'snx_' is nil in call to 'PutSnxSlice'") }
    if len(snx_) < int(last_ - first_) { panic("Slice argument 'snx_' is too short in call to 'PutSnxSlice'") }
    var _c_snx_ *C.MSKrealt = nil
    if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
    task.r = int32(C.MSK_putsnxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_snx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSolution(whichsol_ int32,skc_ []int32,skx_ []int32,skn_ []int32,xc_ []float64,xx_ []float64,y_ []float64,slc_ []float64,suc_ []float64,slx_ []float64,sux_ []float64,snx_ []float64) () {
  if task.r == RES_OK {
    if skc_ == nil { panic("Argument 'skc_' is nil in call to 'PutSolution'") }
    var _c_skc_ *C.MSKstakeye = nil
    if len(skc_) > 0 { _c_skc_ = (*C.MSKstakeye)(unsafe.Pointer(&skc_[0])) }
    if skx_ == nil { panic("Argument 'skx_' is nil in call to 'PutSolution'") }
    var _c_skx_ *C.MSKstakeye = nil
    if len(skx_) > 0 { _c_skx_ = (*C.MSKstakeye)(unsafe.Pointer(&skx_[0])) }
    if skn_ == nil { panic("Argument 'skn_' is nil in call to 'PutSolution'") }
    var _c_skn_ *C.MSKstakeye = nil
    if len(skn_) > 0 { _c_skn_ = (*C.MSKstakeye)(unsafe.Pointer(&skn_[0])) }
    if xc_ == nil { panic("Argument 'xc_' is nil in call to 'PutSolution'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutSolution'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    if y_ == nil { panic("Argument 'y_' is nil in call to 'PutSolution'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    if slc_ == nil { panic("Argument 'slc_' is nil in call to 'PutSolution'") }
    var _c_slc_ *C.MSKrealt = nil
    if len(slc_) > 0 { _c_slc_ = (*C.MSKrealt)(&slc_[0]) }
    if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSolution'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    if slx_ == nil { panic("Argument 'slx_' is nil in call to 'PutSolution'") }
    var _c_slx_ *C.MSKrealt = nil
    if len(slx_) > 0 { _c_slx_ = (*C.MSKrealt)(&slx_[0]) }
    if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSolution'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    if snx_ == nil { panic("Argument 'snx_' is nil in call to 'PutSolution'") }
    var _c_snx_ *C.MSKrealt = nil
    if len(snx_) > 0 { _c_snx_ = (*C.MSKrealt)(&snx_[0]) }
    task.r = int32(C.MSK_putsolution(task.ptr(),C.MSKsoltypee(whichsol_),_c_skc_,_c_skx_,_c_skn_,_c_xc_,_c_xx_,_c_y_,_c_slc_,_c_suc_,_c_slx_,_c_sux_,_c_snx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSolutionYI(i_ int32,whichsol_ int32,y_ float64) () {
  if task.r == RES_OK {
    _c_i_ := C.MSKint32t(i_)
    _c_y_ := C.MSKrealt(y_)
    task.r = int32(C.MSK_putsolutionyi(task.ptr(),_c_i_,C.MSKsoltypee(whichsol_),_c_y_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutStrParam(param_ int32,parvalue_ string) () {
  if task.r == RES_OK {
    _c_parvalue_ := C.CString(parvalue_)
    defer C.free(unsafe.Pointer(_c_parvalue_))
    task.r = int32(C.MSK_putstrparam(task.ptr(),C.MSKsparame(param_),C.MSKstring_t(_c_parvalue_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSuc(whichsol_ int32,suc_ []float64) () {
  if task.r == RES_OK {
    if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSuc'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(suc_) < int(__tmp_var_1) { panic("Slice argument 'suc_' is too short in call to 'PutSuc'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    task.r = int32(C.MSK_putsuc(task.ptr(),C.MSKsoltypee(whichsol_),_c_suc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSucSlice(whichsol_ int32,first_ int32,last_ int32,suc_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if suc_ == nil { panic("Argument 'suc_' is nil in call to 'PutSucSlice'") }
    if len(suc_) < int(last_ - first_) { panic("Slice argument 'suc_' is too short in call to 'PutSucSlice'") }
    var _c_suc_ *C.MSKrealt = nil
    if len(suc_) > 0 { _c_suc_ = (*C.MSKrealt)(&suc_[0]) }
    task.r = int32(C.MSK_putsucslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_suc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSux(whichsol_ int32,sux_ []float64) () {
  if task.r == RES_OK {
    if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSux'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(sux_) < int(__tmp_var_1) { panic("Slice argument 'sux_' is too short in call to 'PutSux'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    task.r = int32(C.MSK_putsux(task.ptr(),C.MSKsoltypee(whichsol_),_c_sux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutSuxSlice(whichsol_ int32,first_ int32,last_ int32,sux_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if sux_ == nil { panic("Argument 'sux_' is nil in call to 'PutSuxSlice'") }
    if len(sux_) < int(last_ - first_) { panic("Slice argument 'sux_' is too short in call to 'PutSuxSlice'") }
    var _c_sux_ *C.MSKrealt = nil
    if len(sux_) > 0 { _c_sux_ = (*C.MSKrealt)(&sux_[0]) }
    task.r = int32(C.MSK_putsuxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_sux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutTaskName(taskname_ string) () {
  if task.r == RES_OK {
    _c_taskname_ := C.CString(taskname_)
    defer C.free(unsafe.Pointer(_c_taskname_))
    task.r = int32(C.MSK_puttaskname(task.ptr(),C.MSKstring_t(_c_taskname_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarBound(j_ int32,bkx_ int32,blx_ float64,bux_ float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_blx_ := C.MSKrealt(blx_)
    _c_bux_ := C.MSKrealt(bux_)
    task.r = int32(C.MSK_putvarbound(task.ptr(),_c_j_,C.MSKboundkeye(bkx_),_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarBoundList(sub_ []int32,bkx_ []int32,blx_ []float64,bux_ []float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_),len(bkx_),len(blx_),len(bux_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutVarBoundList'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if bkx_ == nil { panic("Argument 'bkx_' is nil in call to 'PutVarBoundList'") }
    var _c_bkx_ *C.MSKboundkeye = nil
    if len(bkx_) > 0 { _c_bkx_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkx_[0])) }
    if blx_ == nil { panic("Argument 'blx_' is nil in call to 'PutVarBoundList'") }
    var _c_blx_ *C.MSKrealt = nil
    if len(blx_) > 0 { _c_blx_ = (*C.MSKrealt)(&blx_[0]) }
    if bux_ == nil { panic("Argument 'bux_' is nil in call to 'PutVarBoundList'") }
    var _c_bux_ *C.MSKrealt = nil
    if len(bux_) > 0 { _c_bux_ = (*C.MSKrealt)(&bux_[0]) }
    task.r = int32(C.MSK_putvarboundlist(task.ptr(),_c_num_,_c_sub_,_c_bkx_,_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarBoundListConst(sub_ []int32,bkx_ int32,blx_ float64,bux_ float64) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(sub_) })
    _c_num_ := C.MSKint32t(num_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'PutVarBoundListConst'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    _c_blx_ := C.MSKrealt(blx_)
    _c_bux_ := C.MSKrealt(bux_)
    task.r = int32(C.MSK_putvarboundlistconst(task.ptr(),_c_num_,_c_sub_,C.MSKboundkeye(bkx_),_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarBoundSlice(first_ int32,last_ int32,bkx_ []int32,blx_ []float64,bux_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if bkx_ == nil { panic("Argument 'bkx_' is nil in call to 'PutVarBoundSlice'") }
    if len(bkx_) < int(last_ - first_) { panic("Slice argument 'bkx_' is too short in call to 'PutVarBoundSlice'") }
    var _c_bkx_ *C.MSKboundkeye = nil
    if len(bkx_) > 0 { _c_bkx_ = (*C.MSKboundkeye)(unsafe.Pointer(&bkx_[0])) }
    if blx_ == nil { panic("Argument 'blx_' is nil in call to 'PutVarBoundSlice'") }
    if len(blx_) < int(last_ - first_) { panic("Slice argument 'blx_' is too short in call to 'PutVarBoundSlice'") }
    var _c_blx_ *C.MSKrealt = nil
    if len(blx_) > 0 { _c_blx_ = (*C.MSKrealt)(&blx_[0]) }
    if bux_ == nil { panic("Argument 'bux_' is nil in call to 'PutVarBoundSlice'") }
    if len(bux_) < int(last_ - first_) { panic("Slice argument 'bux_' is too short in call to 'PutVarBoundSlice'") }
    var _c_bux_ *C.MSKrealt = nil
    if len(bux_) > 0 { _c_bux_ = (*C.MSKrealt)(&bux_[0]) }
    task.r = int32(C.MSK_putvarboundslice(task.ptr(),_c_first_,_c_last_,_c_bkx_,_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarBoundSliceConst(first_ int32,last_ int32,bkx_ int32,blx_ float64,bux_ float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    _c_blx_ := C.MSKrealt(blx_)
    _c_bux_ := C.MSKrealt(bux_)
    task.r = int32(C.MSK_putvarboundsliceconst(task.ptr(),_c_first_,_c_last_,C.MSKboundkeye(bkx_),_c_blx_,_c_bux_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarName(j_ int32,name_ string) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_name_ := C.CString(name_)
    defer C.free(unsafe.Pointer(_c_name_))
    task.r = int32(C.MSK_putvarname(task.ptr(),_c_j_,C.MSKstring_t(_c_name_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarSolutionJ(j_ int32,whichsol_ int32,sk_ int32,x_ float64,sl_ float64,su_ float64,sn_ float64) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    _c_x_ := C.MSKrealt(x_)
    _c_sl_ := C.MSKrealt(sl_)
    _c_su_ := C.MSKrealt(su_)
    _c_sn_ := C.MSKrealt(sn_)
    task.r = int32(C.MSK_putvarsolutionj(task.ptr(),_c_j_,C.MSKsoltypee(whichsol_),C.MSKstakeye(sk_),_c_x_,_c_sl_,_c_su_,_c_sn_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarType(j_ int32,vartype_ int32) () {
  if task.r == RES_OK {
    _c_j_ := C.MSKint32t(j_)
    task.r = int32(C.MSK_putvartype(task.ptr(),_c_j_,C.MSKvariabletypee(vartype_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutVarTypeList(subj_ []int32,vartype_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subj_),len(vartype_) })
    _c_num_ := C.MSKint32t(num_)
    if subj_ == nil { panic("Argument 'subj_' is nil in call to 'PutVarTypeList'") }
    var _c_subj_ *C.MSKint32t = nil
    if len(subj_) > 0 { _c_subj_ = (*C.MSKint32t)(&subj_[0]) }
    if vartype_ == nil { panic("Argument 'vartype_' is nil in call to 'PutVarTypeList'") }
    var _c_vartype_ *C.MSKvariabletypee = nil
    if len(vartype_) > 0 { _c_vartype_ = (*C.MSKvariabletypee)(unsafe.Pointer(&vartype_[0])) }
    task.r = int32(C.MSK_putvartypelist(task.ptr(),_c_num_,_c_subj_,_c_vartype_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutXc(whichsol_ int32,xc_ []float64) (_r_xc_ []float64) {
  if task.r == RES_OK {
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if xc_ == nil { xc_ = make([]float64,__tmp_var_1,__tmp_var_1)
    } else if len(xc_) < int(__tmp_var_1) { panic("Slice in 'xc_' is too short in call to 'PutXc'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    task.r = int32(C.MSK_putxc(task.ptr(),C.MSKsoltypee(whichsol_),_c_xc_))
    if task.r != 0 { return }
    _r_xc_ = xc_
  }
  return
}
func (task *Task) PutXcSlice(whichsol_ int32,first_ int32,last_ int32,xc_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if xc_ == nil { panic("Argument 'xc_' is nil in call to 'PutXcSlice'") }
    if len(xc_) < int(last_ - first_) { panic("Slice argument 'xc_' is too short in call to 'PutXcSlice'") }
    var _c_xc_ *C.MSKrealt = nil
    if len(xc_) > 0 { _c_xc_ = (*C.MSKrealt)(&xc_[0]) }
    task.r = int32(C.MSK_putxcslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xc_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutXx(whichsol_ int32,xx_ []float64) () {
  if task.r == RES_OK {
    if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutXx'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumVar()
    if task.r != RES_OK { return }
    if len(xx_) < int(__tmp_var_1) { panic("Slice argument 'xx_' is too short in call to 'PutXx'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    task.r = int32(C.MSK_putxx(task.ptr(),C.MSKsoltypee(whichsol_),_c_xx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutXxSlice(whichsol_ int32,first_ int32,last_ int32,xx_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if xx_ == nil { panic("Argument 'xx_' is nil in call to 'PutXxSlice'") }
    if len(xx_) < int(last_ - first_) { panic("Slice argument 'xx_' is too short in call to 'PutXxSlice'") }
    var _c_xx_ *C.MSKrealt = nil
    if len(xx_) > 0 { _c_xx_ = (*C.MSKrealt)(&xx_[0]) }
    task.r = int32(C.MSK_putxxslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_xx_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutY(whichsol_ int32,y_ []float64) () {
  if task.r == RES_OK {
    if y_ == nil { panic("Argument 'y_' is nil in call to 'PutY'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(y_) < int(__tmp_var_1) { panic("Slice argument 'y_' is too short in call to 'PutY'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    task.r = int32(C.MSK_puty(task.ptr(),C.MSKsoltypee(whichsol_),_c_y_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) PutYSlice(whichsol_ int32,first_ int32,last_ int32,y_ []float64) () {
  if task.r == RES_OK {
    _c_first_ := C.MSKint32t(first_)
    _c_last_ := C.MSKint32t(last_)
    if y_ == nil { panic("Argument 'y_' is nil in call to 'PutYSlice'") }
    if len(y_) < int(last_ - first_) { panic("Slice argument 'y_' is too short in call to 'PutYSlice'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    task.r = int32(C.MSK_putyslice(task.ptr(),C.MSKsoltypee(whichsol_),_c_first_,_c_last_,_c_y_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadData(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_readdataautoformat(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadDataFormat(filename_ string,format_ int32,compress_ int32) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_readdataformat(task.ptr(),C.MSKstring_t(_c_filename_),C.int(format_),C.int(compress_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadJsonString(data_ string) () {
  if task.r == RES_OK {
    _c_data_ := C.CString(data_)
    defer C.free(unsafe.Pointer(_c_data_))
    task.r = int32(C.MSK_readjsonstring(task.ptr(),C.MSKstring_t(_c_data_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadLpString(data_ string) () {
  if task.r == RES_OK {
    _c_data_ := C.CString(data_)
    defer C.free(unsafe.Pointer(_c_data_))
    task.r = int32(C.MSK_readlpstring(task.ptr(),C.MSKstring_t(_c_data_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadOpfString(data_ string) () {
  if task.r == RES_OK {
    _c_data_ := C.CString(data_)
    defer C.free(unsafe.Pointer(_c_data_))
    task.r = int32(C.MSK_readopfstring(task.ptr(),C.MSKstring_t(_c_data_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadParamFile(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_readparamfile(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadPtfString(data_ string) () {
  if task.r == RES_OK {
    _c_data_ := C.CString(data_)
    defer C.free(unsafe.Pointer(_c_data_))
    task.r = int32(C.MSK_readptfstring(task.ptr(),C.MSKstring_t(_c_data_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadSolution(whichsol_ int32,filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_readsolution(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadSummary(whichstream_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_readsummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ReadTask(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_readtask(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) RemoveBarvars(subset_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subset_) })
    _c_num_ := C.MSKint32t(num_)
    if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveBarvars'") }
    var _c_subset_ *C.MSKint32t = nil
    if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
    task.r = int32(C.MSK_removebarvars(task.ptr(),_c_num_,_c_subset_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) RemoveCones(subset_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subset_) })
    _c_num_ := C.MSKint32t(num_)
    if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveCones'") }
    var _c_subset_ *C.MSKint32t = nil
    if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
    task.r = int32(C.MSK_removecones(task.ptr(),_c_num_,_c_subset_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) RemoveCons(subset_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subset_) })
    _c_num_ := C.MSKint32t(num_)
    if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveCons'") }
    var _c_subset_ *C.MSKint32t = nil
    if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
    task.r = int32(C.MSK_removecons(task.ptr(),_c_num_,_c_subset_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) RemoveVars(subset_ []int32) () {
  if task.r == RES_OK {
    num_ := minint([]int{ len(subset_) })
    _c_num_ := C.MSKint32t(num_)
    if subset_ == nil { panic("Argument 'subset_' is nil in call to 'RemoveVars'") }
    var _c_subset_ *C.MSKint32t = nil
    if len(subset_) > 0 { _c_subset_ = (*C.MSKint32t)(&subset_[0]) }
    task.r = int32(C.MSK_removevars(task.ptr(),_c_num_,_c_subset_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) ResizeTask(maxnumcon_ int32,maxnumvar_ int32,maxnumcone_ int32,maxnumanz_ int64,maxnumqnz_ int64) () {
  if task.r == RES_OK {
    _c_maxnumcon_ := C.MSKint32t(maxnumcon_)
    _c_maxnumvar_ := C.MSKint32t(maxnumvar_)
    _c_maxnumcone_ := C.MSKint32t(maxnumcone_)
    _c_maxnumanz_ := C.MSKint64t(maxnumanz_)
    _c_maxnumqnz_ := C.MSKint64t(maxnumqnz_)
    task.r = int32(C.MSK_resizetask(task.ptr(),_c_maxnumcon_,_c_maxnumvar_,_c_maxnumcone_,_c_maxnumanz_,_c_maxnumqnz_))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) SensitivityReport(whichstream_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_sensitivityreport(task.ptr(),C.MSKstreamtypee(whichstream_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) SetDefaults() () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_setdefaults(task.ptr()))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) SkToStr(sk_ int32) (_r_str_ string) {
  if task.r == RES_OK {
    _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_str_))
    task.r = int32(C.MSK_sktostr(task.ptr(),C.MSKstakeye(sk_),C.MSKstring_t(_c_str_)))
    if task.r != 0 { return }
    _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) SolStaToStr(solsta_ int32) (_r_str_ string) {
  if task.r == RES_OK {
    _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
    defer C.free(unsafe.Pointer(_c_str_))
    task.r = int32(C.MSK_solstatostr(task.ptr(),C.MSKsolstae(solsta_),C.MSKstring_t(_c_str_)))
    if task.r != 0 { return }
    _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  }
  return
}
func (task *Task) SolutionDef(whichsol_ int32) (_r_isdef_ bool) {
  if task.r == RES_OK {
    var _c_isdef_ C.MSKbooleant
    task.r = int32(C.MSK_solutiondef(task.ptr(),C.MSKsoltypee(whichsol_),&_c_isdef_))
    if task.r != 0 { return }
    _r_isdef_ = int(_c_isdef_)!=0
  }
  return
}
func (task *Task) SolutionSummary(whichstream_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_solutionsummary(task.ptr(),C.MSKstreamtypee(whichstream_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) SolveWithBasis(transp_ int32,numnz_ int32,sub_ []int32,val_ []float64) (_r_numnz_ int32,_r_sub_ []int32,_r_val_ []float64) {
  if task.r == RES_OK {
    _c_transp_ := C.MSKint32t(transp_)
    var _c_numnz_ C.MSKint32t = C.MSKint32t(numnz_)
    if sub_ == nil { panic("Argument 'sub_' is nil in call to 'SolveWithBasis'") }
    var __tmp_var_1 int32
    __tmp_var_1 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(sub_) < int(__tmp_var_1) { panic("Slice argument 'sub_' is too short in call to 'SolveWithBasis'") }
    var _c_sub_ *C.MSKint32t = nil
    if len(sub_) > 0 { _c_sub_ = (*C.MSKint32t)(&sub_[0]) }
    if val_ == nil { panic("Argument 'val_' is nil in call to 'SolveWithBasis'") }
    var __tmp_var_3 int32
    __tmp_var_3 = task.GetNumCon()
    if task.r != RES_OK { return }
    if len(val_) < int(__tmp_var_3) { panic("Slice argument 'val_' is too short in call to 'SolveWithBasis'") }
    var _c_val_ *C.MSKrealt = nil
    if len(val_) > 0 { _c_val_ = (*C.MSKrealt)(&val_[0]) }
    task.r = int32(C.MSK_solvewithbasis(task.ptr(),_c_transp_,& _c_numnz_,_c_sub_,_c_val_))
    if task.r != 0 { return }
    _r_numnz_ = int32(_c_numnz_)
    _r_sub_ = sub_
    _r_val_ = val_
  }
  return
}
func (task *Task) StrToConeType(str_ string) (_r_conetype_ int32) {
  if task.r == RES_OK {
    _c_str_ := C.CString(str_)
    defer C.free(unsafe.Pointer(_c_str_))
    var _c_conetype_ C.MSKconetypee
    task.r = int32(C.MSK_strtoconetype(task.ptr(),C.MSKstring_t(_c_str_),&_c_conetype_))
    if task.r != 0 { return }
    _r_conetype_ = int32(_c_conetype_)
  }
  return
}
func (task *Task) StrToSk(str_ string) (_r_sk_ int32) {
  if task.r == RES_OK {
    _c_str_ := C.CString(str_)
    defer C.free(unsafe.Pointer(_c_str_))
    var _c_sk_ C.MSKstakeye
    task.r = int32(C.MSK_strtosk(task.ptr(),C.MSKstring_t(_c_str_),&_c_sk_))
    if task.r != 0 { return }
    _r_sk_ = int32(_c_sk_)
  }
  return
}
func (task *Task) Toconic() () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_toconic(task.ptr()))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) UpdateSolutionInfo(whichsol_ int32) () {
  if task.r == RES_OK {
    task.r = int32(C.MSK_updatesolutioninfo(task.ptr(),C.MSKsoltypee(whichsol_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) WriteData(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_writedata(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) WriteJsonSol(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_writejsonsol(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) WriteParamFile(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_writeparamfile(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) WriteSolution(whichsol_ int32,filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_writesolution(task.ptr(),C.MSKsoltypee(whichsol_),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (task *Task) WriteTask(filename_ string) () {
  if task.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    task.r = int32(C.MSK_writetask(task.ptr(),C.MSKstring_t(_c_filename_)))
    if task.r != 0 { return }
  }
  return
}
func (env *Env) Axpy(n_ int32,alpha_ float64,x_ []float64,y_ []float64) (_r_y_ []float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    _c_alpha_ := C.MSKrealt(alpha_)
    if x_ == nil { panic("Argument 'x_' is nil in call to 'Axpy'") }
    if len(x_) < int(n_) { panic("Slice argument 'x_' is too short in call to 'Axpy'") }
    var _c_x_ *C.MSKrealt = nil
    if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
    if y_ == nil { panic("Argument 'y_' is nil in call to 'Axpy'") }
    if len(y_) < int(n_) { panic("Slice argument 'y_' is too short in call to 'Axpy'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    env.r = int32(C.MSK_axpy(env.ptr(),_c_n_,_c_alpha_,_c_x_,_c_y_))
    if env.r != 0 { return }
    _r_y_ = y_
  }
  return
}
func (env *Env) CheckInAll() () {
  if env.r == RES_OK {
    env.r = int32(C.MSK_checkinall(env.ptr()))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) CheckInLicense(feature_ int32) () {
  if env.r == RES_OK {
    env.r = int32(C.MSK_checkinlicense(env.ptr(),C.MSKfeaturee(feature_)))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) CheckoutLicense(feature_ int32) () {
  if env.r == RES_OK {
    env.r = int32(C.MSK_checkoutlicense(env.ptr(),C.MSKfeaturee(feature_)))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) Dot(n_ int32,x_ []float64,y_ []float64) (_r_xty_ float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    if x_ == nil { panic("Argument 'x_' is nil in call to 'Dot'") }
    if len(x_) < int(n_) { panic("Slice argument 'x_' is too short in call to 'Dot'") }
    var _c_x_ *C.MSKrealt = nil
    if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
    if y_ == nil { panic("Argument 'y_' is nil in call to 'Dot'") }
    if len(y_) < int(n_) { panic("Slice argument 'y_' is too short in call to 'Dot'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    var _c_xty_ C.MSKrealt
    env.r = int32(C.MSK_dot(env.ptr(),_c_n_,_c_x_,_c_y_,&_c_xty_))
    if env.r != 0 { return }
    _r_xty_ = float64(_c_xty_)
  }
  return
}
func (env *Env) EchoIntro(longver_ int32) () {
  if env.r == RES_OK {
    _c_longver_ := C.MSKint32t(longver_)
    env.r = int32(C.MSK_echointro(env.ptr(),_c_longver_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) Gemm(transa_ int32,transb_ int32,m_ int32,n_ int32,k_ int32,alpha_ float64,a_ []float64,b_ []float64,beta_ float64,c_ []float64) (_r_c_ []float64) {
  if env.r == RES_OK {
    _c_m_ := C.MSKint32t(m_)
    _c_n_ := C.MSKint32t(n_)
    _c_k_ := C.MSKint32t(k_)
    _c_alpha_ := C.MSKrealt(alpha_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Gemm'") }
    if len(a_) < int(m_ * k_) { panic("Slice argument 'a_' is too short in call to 'Gemm'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    if b_ == nil { panic("Argument 'b_' is nil in call to 'Gemm'") }
    if len(b_) < int(k_ * n_) { panic("Slice argument 'b_' is too short in call to 'Gemm'") }
    var _c_b_ *C.MSKrealt = nil
    if len(b_) > 0 { _c_b_ = (*C.MSKrealt)(&b_[0]) }
    _c_beta_ := C.MSKrealt(beta_)
    if c_ == nil { panic("Argument 'c_' is nil in call to 'Gemm'") }
    if len(c_) < int(m_ * n_) { panic("Slice argument 'c_' is too short in call to 'Gemm'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    env.r = int32(C.MSK_gemm(env.ptr(),C.MSKtransposee(transa_),C.MSKtransposee(transb_),_c_m_,_c_n_,_c_k_,_c_alpha_,_c_a_,_c_b_,_c_beta_,_c_c_))
    if env.r != 0 { return }
    _r_c_ = c_
  }
  return
}
func (env *Env) Gemv(transa_ int32,m_ int32,n_ int32,alpha_ float64,a_ []float64,x_ []float64,beta_ float64,y_ []float64) (_r_y_ []float64) {
  if env.r == RES_OK {
    _c_m_ := C.MSKint32t(m_)
    _c_n_ := C.MSKint32t(n_)
    _c_alpha_ := C.MSKrealt(alpha_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Gemv'") }
    if len(a_) < int(n_ * m_) { panic("Slice argument 'a_' is too short in call to 'Gemv'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    if x_ == nil { panic("Argument 'x_' is nil in call to 'Gemv'") }
    var __tmp_var_3 int32
    if (transa_ == TRANSPOSE_NO) {
      __tmp_var_3 = n_
    }else {
      __tmp_var_3 = m_
    }
    if len(x_) < int(__tmp_var_3) { panic("Slice argument 'x_' is too short in call to 'Gemv'") }
    var _c_x_ *C.MSKrealt = nil
    if len(x_) > 0 { _c_x_ = (*C.MSKrealt)(&x_[0]) }
    _c_beta_ := C.MSKrealt(beta_)
    if y_ == nil { panic("Argument 'y_' is nil in call to 'Gemv'") }
    var __tmp_var_9 int32
    if (transa_ == TRANSPOSE_NO) {
      __tmp_var_9 = m_
    }else {
      __tmp_var_9 = n_
    }
    if len(y_) < int(__tmp_var_9) { panic("Slice argument 'y_' is too short in call to 'Gemv'") }
    var _c_y_ *C.MSKrealt = nil
    if len(y_) > 0 { _c_y_ = (*C.MSKrealt)(&y_[0]) }
    env.r = int32(C.MSK_gemv(env.ptr(),C.MSKtransposee(transa_),_c_m_,_c_n_,_c_alpha_,_c_a_,_c_x_,_c_beta_,_c_y_))
    if env.r != 0 { return }
    _r_y_ = y_
  }
  return
}
func GetCodeDesc(code_ int32) (_r_symname_ string,_r_str_ string,_res int32) {
  _c_symname_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_symname_))
  _c_str_ := (*C.char)(C.malloc(C.size_t(MAX_STR_LEN+1)))
  defer C.free(unsafe.Pointer(_c_str_))
  _res = int32(C.MSK_getcodedesc(C.MSKrescodee(code_),C.MSKstring_t(_c_symname_),C.MSKstring_t(_c_str_)))
  if _res != 0 { return }
  _r_symname_ = C.GoStringN(_c_symname_,C.int(MAX_STR_LEN))
  _r_str_ = C.GoStringN(_c_str_,C.int(MAX_STR_LEN))
  return
}
func GetVersion() (_r_major_ int32,_r_minor_ int32,_r_revision_ int32,_res int32) {
  var _c_major_ C.MSKint32t
  var _c_minor_ C.MSKint32t
  var _c_revision_ C.MSKint32t
  _res = int32(C.MSK_getversion(&_c_major_,&_c_minor_,&_c_revision_))
  if _res != 0 { return }
  _r_major_ = int32(_c_major_)
  _r_minor_ = int32(_c_minor_)
  _r_revision_ = int32(_c_revision_)
  return
}
func Licensecleanup() (_res int32) {
  _res = int32(C.MSK_licensecleanup())
  if _res != 0 { return }
  return
}
func (env *Env) Linkfiletostream(whichstream_ int32,filename_ string,append_ int32) () {
  if env.r == RES_OK {
    _c_filename_ := C.CString(filename_)
    defer C.free(unsafe.Pointer(_c_filename_))
    _c_append_ := C.MSKint32t(append_)
    env.r = int32(C.MSK_linkfiletoenvstream(env.ptr(),C.MSKstreamtypee(whichstream_),C.MSKstring_t(_c_filename_),_c_append_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) Potrf(uplo_ int32,n_ int32,a_ []float64) (_r_a_ []float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Potrf'") }
    if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Potrf'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    env.r = int32(C.MSK_potrf(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_))
    if env.r != 0 { return }
    _r_a_ = a_
  }
  return
}
func (env *Env) PutLicenseCode(code_ []int32) () {
  if env.r == RES_OK {
    if code_ == nil { panic("Argument 'code_' is nil in call to 'PutLicenseCode'") }
    if len(code_) < int(LICENSE_BUFFER_LENGTH) { panic("Slice argument 'code_' is too short in call to 'PutLicenseCode'") }
    var _c_code_ *C.MSKint32t = nil
    if len(code_) > 0 { _c_code_ = (*C.MSKint32t)(&code_[0]) }
    env.r = int32(C.MSK_putlicensecode(env.ptr(),_c_code_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) PutLicenseDebug(licdebug_ int32) () {
  if env.r == RES_OK {
    _c_licdebug_ := C.MSKint32t(licdebug_)
    env.r = int32(C.MSK_putlicensedebug(env.ptr(),_c_licdebug_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) PutLicensePath(licensepath_ string) () {
  if env.r == RES_OK {
    _c_licensepath_ := C.CString(licensepath_)
    defer C.free(unsafe.Pointer(_c_licensepath_))
    env.r = int32(C.MSK_putlicensepath(env.ptr(),C.MSKstring_t(_c_licensepath_)))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) PutLicenseWait(licwait_ int32) () {
  if env.r == RES_OK {
    _c_licwait_ := C.MSKint32t(licwait_)
    env.r = int32(C.MSK_putlicensewait(env.ptr(),_c_licwait_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) SetupThreads(numthreads_ int32) () {
  if env.r == RES_OK {
    _c_numthreads_ := C.MSKint32t(numthreads_)
    env.r = int32(C.MSK_setupthreads(env.ptr(),_c_numthreads_))
    if env.r != 0 { return }
  }
  return
}
func (env *Env) Syeig(uplo_ int32,n_ int32,a_ []float64,w_ []float64) (_r_w_ []float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Syeig'") }
    if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Syeig'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    if w_ == nil { w_ = make([]float64,n_,n_)
    } else if len(w_) < int(n_) { panic("Slice in 'w_' is too short in call to 'Syeig'") }
    var _c_w_ *C.MSKrealt = nil
    if len(w_) > 0 { _c_w_ = (*C.MSKrealt)(&w_[0]) }
    env.r = int32(C.MSK_syeig(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_,_c_w_))
    if env.r != 0 { return }
    _r_w_ = w_
  }
  return
}
func (env *Env) Syevd(uplo_ int32,n_ int32,a_ []float64,w_ []float64) (_r_a_ []float64,_r_w_ []float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Syevd'") }
    if len(a_) < int(n_ * n_) { panic("Slice argument 'a_' is too short in call to 'Syevd'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    if w_ == nil { w_ = make([]float64,n_,n_)
    } else if len(w_) < int(n_) { panic("Slice in 'w_' is too short in call to 'Syevd'") }
    var _c_w_ *C.MSKrealt = nil
    if len(w_) > 0 { _c_w_ = (*C.MSKrealt)(&w_[0]) }
    env.r = int32(C.MSK_syevd(env.ptr(),C.MSKuploe(uplo_),_c_n_,_c_a_,_c_w_))
    if env.r != 0 { return }
    _r_a_ = a_
    _r_w_ = w_
  }
  return
}
func (env *Env) Syrk(uplo_ int32,trans_ int32,n_ int32,k_ int32,alpha_ float64,a_ []float64,beta_ float64,c_ []float64) (_r_c_ []float64) {
  if env.r == RES_OK {
    _c_n_ := C.MSKint32t(n_)
    _c_k_ := C.MSKint32t(k_)
    _c_alpha_ := C.MSKrealt(alpha_)
    if a_ == nil { panic("Argument 'a_' is nil in call to 'Syrk'") }
    if len(a_) < int(n_ * k_) { panic("Slice argument 'a_' is too short in call to 'Syrk'") }
    var _c_a_ *C.MSKrealt = nil
    if len(a_) > 0 { _c_a_ = (*C.MSKrealt)(&a_[0]) }
    _c_beta_ := C.MSKrealt(beta_)
    if c_ == nil { panic("Argument 'c_' is nil in call to 'Syrk'") }
    if len(c_) < int(n_ * n_) { panic("Slice argument 'c_' is too short in call to 'Syrk'") }
    var _c_c_ *C.MSKrealt = nil
    if len(c_) > 0 { _c_c_ = (*C.MSKrealt)(&c_[0]) }
    env.r = int32(C.MSK_syrk(env.ptr(),C.MSKuploe(uplo_),C.MSKtransposee(trans_),_c_n_,_c_k_,_c_alpha_,_c_a_,_c_beta_,_c_c_))
    if env.r != 0 { return }
    _r_c_ = c_
  }
  return
}
